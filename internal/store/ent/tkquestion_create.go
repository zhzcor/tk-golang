// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"time"
	"tkserver/internal/store/ent/admin"
	"tkserver/internal/store/ent/collection"
	"tkserver/internal/store/ent/kcsmallcategoryquestion"
	"tkserver/internal/store/ent/tkexampartitionquestionlink"
	"tkserver/internal/store/ent/tkknowledgepoint"
	"tkserver/internal/store/ent/tkquestion"
	"tkserver/internal/store/ent/tkquestionansweroption"
	"tkserver/internal/store/ent/tkquestionbank"
	"tkserver/internal/store/ent/tkquestionerrorfeedback"
	"tkserver/internal/store/ent/tkquestionsection"
	"tkserver/internal/store/ent/tkuserquestionrecord"
	"tkserver/internal/store/ent/tkuserrandomexamrecode"
	"tkserver/internal/store/ent/tkusersimulationteachermark"
	"tkserver/internal/store/ent/tkuserwrongquestionrecode"

	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
)

// TkQuestionCreate is the builder for creating a TkQuestion entity.
type TkQuestionCreate struct {
	config
	mutation *TkQuestionMutation
	hooks    []Hook
}

// SetUUID sets the "uuid" field.
func (tqc *TkQuestionCreate) SetUUID(s string) *TkQuestionCreate {
	tqc.mutation.SetUUID(s)
	return tqc
}

// SetCreatedAt sets the "created_at" field.
func (tqc *TkQuestionCreate) SetCreatedAt(t time.Time) *TkQuestionCreate {
	tqc.mutation.SetCreatedAt(t)
	return tqc
}

// SetNillableCreatedAt sets the "created_at" field if the given value is not nil.
func (tqc *TkQuestionCreate) SetNillableCreatedAt(t *time.Time) *TkQuestionCreate {
	if t != nil {
		tqc.SetCreatedAt(*t)
	}
	return tqc
}

// SetUpdatedAt sets the "updated_at" field.
func (tqc *TkQuestionCreate) SetUpdatedAt(t time.Time) *TkQuestionCreate {
	tqc.mutation.SetUpdatedAt(t)
	return tqc
}

// SetNillableUpdatedAt sets the "updated_at" field if the given value is not nil.
func (tqc *TkQuestionCreate) SetNillableUpdatedAt(t *time.Time) *TkQuestionCreate {
	if t != nil {
		tqc.SetUpdatedAt(*t)
	}
	return tqc
}

// SetDeletedAt sets the "deleted_at" field.
func (tqc *TkQuestionCreate) SetDeletedAt(t time.Time) *TkQuestionCreate {
	tqc.mutation.SetDeletedAt(t)
	return tqc
}

// SetNillableDeletedAt sets the "deleted_at" field if the given value is not nil.
func (tqc *TkQuestionCreate) SetNillableDeletedAt(t *time.Time) *TkQuestionCreate {
	if t != nil {
		tqc.SetDeletedAt(*t)
	}
	return tqc
}

// SetName sets the "name" field.
func (tqc *TkQuestionCreate) SetName(s string) *TkQuestionCreate {
	tqc.mutation.SetName(s)
	return tqc
}

// SetNillableName sets the "name" field if the given value is not nil.
func (tqc *TkQuestionCreate) SetNillableName(s *string) *TkQuestionCreate {
	if s != nil {
		tqc.SetName(*s)
	}
	return tqc
}

// SetDifficulty sets the "difficulty" field.
func (tqc *TkQuestionCreate) SetDifficulty(u uint8) *TkQuestionCreate {
	tqc.mutation.SetDifficulty(u)
	return tqc
}

// SetNillableDifficulty sets the "difficulty" field if the given value is not nil.
func (tqc *TkQuestionCreate) SetNillableDifficulty(u *uint8) *TkQuestionCreate {
	if u != nil {
		tqc.SetDifficulty(*u)
	}
	return tqc
}

// SetType sets the "type" field.
func (tqc *TkQuestionCreate) SetType(u uint8) *TkQuestionCreate {
	tqc.mutation.SetType(u)
	return tqc
}

// SetNillableType sets the "type" field if the given value is not nil.
func (tqc *TkQuestionCreate) SetNillableType(u *uint8) *TkQuestionCreate {
	if u != nil {
		tqc.SetType(*u)
	}
	return tqc
}

// SetDesc sets the "desc" field.
func (tqc *TkQuestionCreate) SetDesc(s string) *TkQuestionCreate {
	tqc.mutation.SetDesc(s)
	return tqc
}

// SetNillableDesc sets the "desc" field if the given value is not nil.
func (tqc *TkQuestionCreate) SetNillableDesc(s *string) *TkQuestionCreate {
	if s != nil {
		tqc.SetDesc(*s)
	}
	return tqc
}

// SetCreatedAdminID sets the "created_admin_id" field.
func (tqc *TkQuestionCreate) SetCreatedAdminID(i int) *TkQuestionCreate {
	tqc.mutation.SetCreatedAdminID(i)
	return tqc
}

// SetNillableCreatedAdminID sets the "created_admin_id" field if the given value is not nil.
func (tqc *TkQuestionCreate) SetNillableCreatedAdminID(i *int) *TkQuestionCreate {
	if i != nil {
		tqc.SetCreatedAdminID(*i)
	}
	return tqc
}

// SetQuestionBankID sets the "question_bank_id" field.
func (tqc *TkQuestionCreate) SetQuestionBankID(i int) *TkQuestionCreate {
	tqc.mutation.SetQuestionBankID(i)
	return tqc
}

// SetNillableQuestionBankID sets the "question_bank_id" field if the given value is not nil.
func (tqc *TkQuestionCreate) SetNillableQuestionBankID(i *int) *TkQuestionCreate {
	if i != nil {
		tqc.SetQuestionBankID(*i)
	}
	return tqc
}

// SetAnswerCount sets the "answer_count" field.
func (tqc *TkQuestionCreate) SetAnswerCount(i int) *TkQuestionCreate {
	tqc.mutation.SetAnswerCount(i)
	return tqc
}

// SetNillableAnswerCount sets the "answer_count" field if the given value is not nil.
func (tqc *TkQuestionCreate) SetNillableAnswerCount(i *int) *TkQuestionCreate {
	if i != nil {
		tqc.SetAnswerCount(*i)
	}
	return tqc
}

// SetRightCount sets the "right_count" field.
func (tqc *TkQuestionCreate) SetRightCount(i int) *TkQuestionCreate {
	tqc.mutation.SetRightCount(i)
	return tqc
}

// SetNillableRightCount sets the "right_count" field if the given value is not nil.
func (tqc *TkQuestionCreate) SetNillableRightCount(i *int) *TkQuestionCreate {
	if i != nil {
		tqc.SetRightCount(*i)
	}
	return tqc
}

// SetPid sets the "pid" field.
func (tqc *TkQuestionCreate) SetPid(i int) *TkQuestionCreate {
	tqc.mutation.SetPid(i)
	return tqc
}

// SetNillablePid sets the "pid" field if the given value is not nil.
func (tqc *TkQuestionCreate) SetNillablePid(i *int) *TkQuestionCreate {
	if i != nil {
		tqc.SetPid(*i)
	}
	return tqc
}

// SetQuestionBank sets the "question_bank" edge to the TkQuestionBank entity.
func (tqc *TkQuestionCreate) SetQuestionBank(t *TkQuestionBank) *TkQuestionCreate {
	return tqc.SetQuestionBankID(t.ID)
}

// SetAdminID sets the "admin" edge to the Admin entity by ID.
func (tqc *TkQuestionCreate) SetAdminID(id int) *TkQuestionCreate {
	tqc.mutation.SetAdminID(id)
	return tqc
}

// SetNillableAdminID sets the "admin" edge to the Admin entity by ID if the given value is not nil.
func (tqc *TkQuestionCreate) SetNillableAdminID(id *int) *TkQuestionCreate {
	if id != nil {
		tqc = tqc.SetAdminID(*id)
	}
	return tqc
}

// SetAdmin sets the "admin" edge to the Admin entity.
func (tqc *TkQuestionCreate) SetAdmin(a *Admin) *TkQuestionCreate {
	return tqc.SetAdminID(a.ID)
}

// AddUserRandDomIDs adds the "user_rand_dom" edge to the TkUserRandomExamRecode entity by IDs.
func (tqc *TkQuestionCreate) AddUserRandDomIDs(ids ...int) *TkQuestionCreate {
	tqc.mutation.AddUserRandDomIDs(ids...)
	return tqc
}

// AddUserRandDom adds the "user_rand_dom" edges to the TkUserRandomExamRecode entity.
func (tqc *TkQuestionCreate) AddUserRandDom(t ...*TkUserRandomExamRecode) *TkQuestionCreate {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tqc.AddUserRandDomIDs(ids...)
}

// AddAnswerOptionIDs adds the "answer_options" edge to the TkQuestionAnswerOption entity by IDs.
func (tqc *TkQuestionCreate) AddAnswerOptionIDs(ids ...int) *TkQuestionCreate {
	tqc.mutation.AddAnswerOptionIDs(ids...)
	return tqc
}

// AddAnswerOptions adds the "answer_options" edges to the TkQuestionAnswerOption entity.
func (tqc *TkQuestionCreate) AddAnswerOptions(t ...*TkQuestionAnswerOption) *TkQuestionCreate {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tqc.AddAnswerOptionIDs(ids...)
}

// AddKnowledgePointIDs adds the "knowledge_points" edge to the TkKnowledgePoint entity by IDs.
func (tqc *TkQuestionCreate) AddKnowledgePointIDs(ids ...int) *TkQuestionCreate {
	tqc.mutation.AddKnowledgePointIDs(ids...)
	return tqc
}

// AddKnowledgePoints adds the "knowledge_points" edges to the TkKnowledgePoint entity.
func (tqc *TkQuestionCreate) AddKnowledgePoints(t ...*TkKnowledgePoint) *TkQuestionCreate {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tqc.AddKnowledgePointIDs(ids...)
}

// AddQuestionSectionLinkIDs adds the "question_section_links" edge to the TkQuestionSection entity by IDs.
func (tqc *TkQuestionCreate) AddQuestionSectionLinkIDs(ids ...int) *TkQuestionCreate {
	tqc.mutation.AddQuestionSectionLinkIDs(ids...)
	return tqc
}

// AddQuestionSectionLinks adds the "question_section_links" edges to the TkQuestionSection entity.
func (tqc *TkQuestionCreate) AddQuestionSectionLinks(t ...*TkQuestionSection) *TkQuestionCreate {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tqc.AddQuestionSectionLinkIDs(ids...)
}

// AddExamPartitionQuestionIDs adds the "exam_partition_questions" edge to the TkExamPartitionQuestionLink entity by IDs.
func (tqc *TkQuestionCreate) AddExamPartitionQuestionIDs(ids ...int) *TkQuestionCreate {
	tqc.mutation.AddExamPartitionQuestionIDs(ids...)
	return tqc
}

// AddExamPartitionQuestions adds the "exam_partition_questions" edges to the TkExamPartitionQuestionLink entity.
func (tqc *TkQuestionCreate) AddExamPartitionQuestions(t ...*TkExamPartitionQuestionLink) *TkQuestionCreate {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tqc.AddExamPartitionQuestionIDs(ids...)
}

// AddQuestionErrorFeedbackIDs adds the "question_error_feedbacks" edge to the TkQuestionErrorFeedback entity by IDs.
func (tqc *TkQuestionCreate) AddQuestionErrorFeedbackIDs(ids ...int) *TkQuestionCreate {
	tqc.mutation.AddQuestionErrorFeedbackIDs(ids...)
	return tqc
}

// AddQuestionErrorFeedbacks adds the "question_error_feedbacks" edges to the TkQuestionErrorFeedback entity.
func (tqc *TkQuestionCreate) AddQuestionErrorFeedbacks(t ...*TkQuestionErrorFeedback) *TkQuestionCreate {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tqc.AddQuestionErrorFeedbackIDs(ids...)
}

// AddUserRecordIDs adds the "user_records" edge to the TkUserQuestionRecord entity by IDs.
func (tqc *TkQuestionCreate) AddUserRecordIDs(ids ...int) *TkQuestionCreate {
	tqc.mutation.AddUserRecordIDs(ids...)
	return tqc
}

// AddUserRecords adds the "user_records" edges to the TkUserQuestionRecord entity.
func (tqc *TkQuestionCreate) AddUserRecords(t ...*TkUserQuestionRecord) *TkQuestionCreate {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tqc.AddUserRecordIDs(ids...)
}

// AddSmallCategoryQuestionIDs adds the "small_category_questions" edge to the KcSmallCategoryQuestion entity by IDs.
func (tqc *TkQuestionCreate) AddSmallCategoryQuestionIDs(ids ...int) *TkQuestionCreate {
	tqc.mutation.AddSmallCategoryQuestionIDs(ids...)
	return tqc
}

// AddSmallCategoryQuestions adds the "small_category_questions" edges to the KcSmallCategoryQuestion entity.
func (tqc *TkQuestionCreate) AddSmallCategoryQuestions(k ...*KcSmallCategoryQuestion) *TkQuestionCreate {
	ids := make([]int, len(k))
	for i := range k {
		ids[i] = k[i].ID
	}
	return tqc.AddSmallCategoryQuestionIDs(ids...)
}

// AddUserExamQuestionIDs adds the "user_exam_questions" edge to the TkUserSimulationTeacherMark entity by IDs.
func (tqc *TkQuestionCreate) AddUserExamQuestionIDs(ids ...int) *TkQuestionCreate {
	tqc.mutation.AddUserExamQuestionIDs(ids...)
	return tqc
}

// AddUserExamQuestions adds the "user_exam_questions" edges to the TkUserSimulationTeacherMark entity.
func (tqc *TkQuestionCreate) AddUserExamQuestions(t ...*TkUserSimulationTeacherMark) *TkQuestionCreate {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tqc.AddUserExamQuestionIDs(ids...)
}

// AddUserRecodeWrongIDs adds the "user_recode_wrong" edge to the TkUserWrongQuestionRecode entity by IDs.
func (tqc *TkQuestionCreate) AddUserRecodeWrongIDs(ids ...int) *TkQuestionCreate {
	tqc.mutation.AddUserRecodeWrongIDs(ids...)
	return tqc
}

// AddUserRecodeWrong adds the "user_recode_wrong" edges to the TkUserWrongQuestionRecode entity.
func (tqc *TkQuestionCreate) AddUserRecodeWrong(t ...*TkUserWrongQuestionRecode) *TkQuestionCreate {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tqc.AddUserRecodeWrongIDs(ids...)
}

// SetParentID sets the "parent" edge to the TkQuestion entity by ID.
func (tqc *TkQuestionCreate) SetParentID(id int) *TkQuestionCreate {
	tqc.mutation.SetParentID(id)
	return tqc
}

// SetNillableParentID sets the "parent" edge to the TkQuestion entity by ID if the given value is not nil.
func (tqc *TkQuestionCreate) SetNillableParentID(id *int) *TkQuestionCreate {
	if id != nil {
		tqc = tqc.SetParentID(*id)
	}
	return tqc
}

// SetParent sets the "parent" edge to the TkQuestion entity.
func (tqc *TkQuestionCreate) SetParent(t *TkQuestion) *TkQuestionCreate {
	return tqc.SetParentID(t.ID)
}

// AddChildIDs adds the "children" edge to the TkQuestion entity by IDs.
func (tqc *TkQuestionCreate) AddChildIDs(ids ...int) *TkQuestionCreate {
	tqc.mutation.AddChildIDs(ids...)
	return tqc
}

// AddChildren adds the "children" edges to the TkQuestion entity.
func (tqc *TkQuestionCreate) AddChildren(t ...*TkQuestion) *TkQuestionCreate {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tqc.AddChildIDs(ids...)
}

// AddCollectionQuestionIDs adds the "collection_question" edge to the Collection entity by IDs.
func (tqc *TkQuestionCreate) AddCollectionQuestionIDs(ids ...int) *TkQuestionCreate {
	tqc.mutation.AddCollectionQuestionIDs(ids...)
	return tqc
}

// AddCollectionQuestion adds the "collection_question" edges to the Collection entity.
func (tqc *TkQuestionCreate) AddCollectionQuestion(c ...*Collection) *TkQuestionCreate {
	ids := make([]int, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return tqc.AddCollectionQuestionIDs(ids...)
}

// Mutation returns the TkQuestionMutation object of the builder.
func (tqc *TkQuestionCreate) Mutation() *TkQuestionMutation {
	return tqc.mutation
}

// Save creates the TkQuestion in the database.
func (tqc *TkQuestionCreate) Save(ctx context.Context) (*TkQuestion, error) {
	var (
		err  error
		node *TkQuestion
	)
	tqc.defaults()
	if len(tqc.hooks) == 0 {
		if err = tqc.check(); err != nil {
			return nil, err
		}
		node, err = tqc.sqlSave(ctx)
	} else {
		var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
			mutation, ok := m.(*TkQuestionMutation)
			if !ok {
				return nil, fmt.Errorf("unexpected mutation type %T", m)
			}
			if err = tqc.check(); err != nil {
				return nil, err
			}
			tqc.mutation = mutation
			node, err = tqc.sqlSave(ctx)
			mutation.done = true
			return node, err
		})
		for i := len(tqc.hooks) - 1; i >= 0; i-- {
			mut = tqc.hooks[i](mut)
		}
		if _, err := mut.Mutate(ctx, tqc.mutation); err != nil {
			return nil, err
		}
	}
	return node, err
}

// SaveX calls Save and panics if Save returns an error.
func (tqc *TkQuestionCreate) SaveX(ctx context.Context) *TkQuestion {
	v, err := tqc.Save(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// defaults sets the default values of the builder before save.
func (tqc *TkQuestionCreate) defaults() {
	if _, ok := tqc.mutation.CreatedAt(); !ok {
		v := tkquestion.DefaultCreatedAt()
		tqc.mutation.SetCreatedAt(v)
	}
	if _, ok := tqc.mutation.UpdatedAt(); !ok {
		v := tkquestion.DefaultUpdatedAt()
		tqc.mutation.SetUpdatedAt(v)
	}
	if _, ok := tqc.mutation.Difficulty(); !ok {
		v := tkquestion.DefaultDifficulty
		tqc.mutation.SetDifficulty(v)
	}
	if _, ok := tqc.mutation.GetType(); !ok {
		v := tkquestion.DefaultType
		tqc.mutation.SetType(v)
	}
	if _, ok := tqc.mutation.AnswerCount(); !ok {
		v := tkquestion.DefaultAnswerCount
		tqc.mutation.SetAnswerCount(v)
	}
	if _, ok := tqc.mutation.RightCount(); !ok {
		v := tkquestion.DefaultRightCount
		tqc.mutation.SetRightCount(v)
	}
}

// check runs all checks and user-defined validators on the builder.
func (tqc *TkQuestionCreate) check() error {
	if _, ok := tqc.mutation.UUID(); !ok {
		return &ValidationError{Name: "uuid", err: errors.New("ent: missing required field \"uuid\"")}
	}
	if _, ok := tqc.mutation.Difficulty(); !ok {
		return &ValidationError{Name: "difficulty", err: errors.New("ent: missing required field \"difficulty\"")}
	}
	if _, ok := tqc.mutation.GetType(); !ok {
		return &ValidationError{Name: "type", err: errors.New("ent: missing required field \"type\"")}
	}
	if _, ok := tqc.mutation.AnswerCount(); !ok {
		return &ValidationError{Name: "answer_count", err: errors.New("ent: missing required field \"answer_count\"")}
	}
	if _, ok := tqc.mutation.RightCount(); !ok {
		return &ValidationError{Name: "right_count", err: errors.New("ent: missing required field \"right_count\"")}
	}
	return nil
}

func (tqc *TkQuestionCreate) sqlSave(ctx context.Context) (*TkQuestion, error) {
	_node, _spec := tqc.createSpec()
	if err := sqlgraph.CreateNode(ctx, tqc.driver, _spec); err != nil {
		if cerr, ok := isSQLConstraintError(err); ok {
			err = cerr
		}
		return nil, err
	}
	id := _spec.ID.Value.(int64)
	_node.ID = int(id)
	return _node, nil
}

func (tqc *TkQuestionCreate) createSpec() (*TkQuestion, *sqlgraph.CreateSpec) {
	var (
		_node = &TkQuestion{config: tqc.config}
		_spec = &sqlgraph.CreateSpec{
			Table: tkquestion.Table,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeInt,
				Column: tkquestion.FieldID,
			},
		}
	)
	if value, ok := tqc.mutation.UUID(); ok {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: tkquestion.FieldUUID,
		})
		_node.UUID = value
	}
	if value, ok := tqc.mutation.CreatedAt(); ok {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: tkquestion.FieldCreatedAt,
		})
		_node.CreatedAt = &value
	}
	if value, ok := tqc.mutation.UpdatedAt(); ok {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: tkquestion.FieldUpdatedAt,
		})
		_node.UpdatedAt = &value
	}
	if value, ok := tqc.mutation.DeletedAt(); ok {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: tkquestion.FieldDeletedAt,
		})
		_node.DeletedAt = &value
	}
	if value, ok := tqc.mutation.Name(); ok {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: tkquestion.FieldName,
		})
		_node.Name = value
	}
	if value, ok := tqc.mutation.Difficulty(); ok {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeUint8,
			Value:  value,
			Column: tkquestion.FieldDifficulty,
		})
		_node.Difficulty = value
	}
	if value, ok := tqc.mutation.GetType(); ok {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeUint8,
			Value:  value,
			Column: tkquestion.FieldType,
		})
		_node.Type = value
	}
	if value, ok := tqc.mutation.Desc(); ok {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: tkquestion.FieldDesc,
		})
		_node.Desc = value
	}
	if value, ok := tqc.mutation.AnswerCount(); ok {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Value:  value,
			Column: tkquestion.FieldAnswerCount,
		})
		_node.AnswerCount = value
	}
	if value, ok := tqc.mutation.RightCount(); ok {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Value:  value,
			Column: tkquestion.FieldRightCount,
		})
		_node.RightCount = value
	}
	if nodes := tqc.mutation.QuestionBankIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   tkquestion.QuestionBankTable,
			Columns: []string{tkquestion.QuestionBankColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkquestionbank.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_node.QuestionBankID = nodes[0]
		_spec.Edges = append(_spec.Edges, edge)
	}
	if nodes := tqc.mutation.AdminIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   tkquestion.AdminTable,
			Columns: []string{tkquestion.AdminColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: admin.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_node.CreatedAdminID = nodes[0]
		_spec.Edges = append(_spec.Edges, edge)
	}
	if nodes := tqc.mutation.UserRandDomIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   tkquestion.UserRandDomTable,
			Columns: tkquestion.UserRandDomPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkuserrandomexamrecode.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges = append(_spec.Edges, edge)
	}
	if nodes := tqc.mutation.AnswerOptionsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.AnswerOptionsTable,
			Columns: []string{tkquestion.AnswerOptionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkquestionansweroption.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges = append(_spec.Edges, edge)
	}
	if nodes := tqc.mutation.KnowledgePointsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   tkquestion.KnowledgePointsTable,
			Columns: tkquestion.KnowledgePointsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkknowledgepoint.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges = append(_spec.Edges, edge)
	}
	if nodes := tqc.mutation.QuestionSectionLinksIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.QuestionSectionLinksTable,
			Columns: []string{tkquestion.QuestionSectionLinksColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkquestionsection.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges = append(_spec.Edges, edge)
	}
	if nodes := tqc.mutation.ExamPartitionQuestionsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.ExamPartitionQuestionsTable,
			Columns: []string{tkquestion.ExamPartitionQuestionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkexampartitionquestionlink.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges = append(_spec.Edges, edge)
	}
	if nodes := tqc.mutation.QuestionErrorFeedbacksIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.QuestionErrorFeedbacksTable,
			Columns: []string{tkquestion.QuestionErrorFeedbacksColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkquestionerrorfeedback.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges = append(_spec.Edges, edge)
	}
	if nodes := tqc.mutation.UserRecordsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.UserRecordsTable,
			Columns: []string{tkquestion.UserRecordsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkuserquestionrecord.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges = append(_spec.Edges, edge)
	}
	if nodes := tqc.mutation.SmallCategoryQuestionsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.SmallCategoryQuestionsTable,
			Columns: []string{tkquestion.SmallCategoryQuestionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: kcsmallcategoryquestion.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges = append(_spec.Edges, edge)
	}
	if nodes := tqc.mutation.UserExamQuestionsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.UserExamQuestionsTable,
			Columns: []string{tkquestion.UserExamQuestionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkusersimulationteachermark.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges = append(_spec.Edges, edge)
	}
	if nodes := tqc.mutation.UserRecodeWrongIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.UserRecodeWrongTable,
			Columns: []string{tkquestion.UserRecodeWrongColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkuserwrongquestionrecode.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges = append(_spec.Edges, edge)
	}
	if nodes := tqc.mutation.ParentIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   tkquestion.ParentTable,
			Columns: []string{tkquestion.ParentColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkquestion.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_node.Pid = nodes[0]
		_spec.Edges = append(_spec.Edges, edge)
	}
	if nodes := tqc.mutation.ChildrenIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.ChildrenTable,
			Columns: []string{tkquestion.ChildrenColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkquestion.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges = append(_spec.Edges, edge)
	}
	if nodes := tqc.mutation.CollectionQuestionIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.CollectionQuestionTable,
			Columns: []string{tkquestion.CollectionQuestionColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: collection.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges = append(_spec.Edges, edge)
	}
	return _node, _spec
}

// TkQuestionCreateBulk is the builder for creating many TkQuestion entities in bulk.
type TkQuestionCreateBulk struct {
	config
	builders []*TkQuestionCreate
}

// Save creates the TkQuestion entities in the database.
func (tqcb *TkQuestionCreateBulk) Save(ctx context.Context) ([]*TkQuestion, error) {
	specs := make([]*sqlgraph.CreateSpec, len(tqcb.builders))
	nodes := make([]*TkQuestion, len(tqcb.builders))
	mutators := make([]Mutator, len(tqcb.builders))
	for i := range tqcb.builders {
		func(i int, root context.Context) {
			builder := tqcb.builders[i]
			builder.defaults()
			var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
				mutation, ok := m.(*TkQuestionMutation)
				if !ok {
					return nil, fmt.Errorf("unexpected mutation type %T", m)
				}
				if err := builder.check(); err != nil {
					return nil, err
				}
				builder.mutation = mutation
				nodes[i], specs[i] = builder.createSpec()
				var err error
				if i < len(mutators)-1 {
					_, err = mutators[i+1].Mutate(root, tqcb.builders[i+1].mutation)
				} else {
					// Invoke the actual operation on the latest mutation in the chain.
					if err = sqlgraph.BatchCreate(ctx, tqcb.driver, &sqlgraph.BatchCreateSpec{Nodes: specs}); err != nil {
						if cerr, ok := isSQLConstraintError(err); ok {
							err = cerr
						}
					}
				}
				mutation.done = true
				if err != nil {
					return nil, err
				}
				id := specs[i].ID.Value.(int64)
				nodes[i].ID = int(id)
				return nodes[i], nil
			})
			for i := len(builder.hooks) - 1; i >= 0; i-- {
				mut = builder.hooks[i](mut)
			}
			mutators[i] = mut
		}(i, ctx)
	}
	if len(mutators) > 0 {
		if _, err := mutators[0].Mutate(ctx, tqcb.builders[0].mutation); err != nil {
			return nil, err
		}
	}
	return nodes, nil
}

// SaveX is like Save, but panics if an error occurs.
func (tqcb *TkQuestionCreateBulk) SaveX(ctx context.Context) []*TkQuestion {
	v, err := tqcb.Save(ctx)
	if err != nil {
		panic(err)
	}
	return v
}
