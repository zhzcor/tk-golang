// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"time"
	"tkserver/internal/store/ent/admin"
	"tkserver/internal/store/ent/collection"
	"tkserver/internal/store/ent/kcsmallcategoryquestion"
	"tkserver/internal/store/ent/predicate"
	"tkserver/internal/store/ent/tkexampartitionquestionlink"
	"tkserver/internal/store/ent/tkknowledgepoint"
	"tkserver/internal/store/ent/tkquestion"
	"tkserver/internal/store/ent/tkquestionansweroption"
	"tkserver/internal/store/ent/tkquestionbank"
	"tkserver/internal/store/ent/tkquestionerrorfeedback"
	"tkserver/internal/store/ent/tkquestionsection"
	"tkserver/internal/store/ent/tkuserquestionrecord"
	"tkserver/internal/store/ent/tkuserrandomexamrecode"
	"tkserver/internal/store/ent/tkusersimulationteachermark"
	"tkserver/internal/store/ent/tkuserwrongquestionrecode"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
)

// TkQuestionUpdate is the builder for updating TkQuestion entities.
type TkQuestionUpdate struct {
	config
	hooks    []Hook
	mutation *TkQuestionMutation
}

// Where adds a new predicate for the TkQuestionUpdate builder.
func (tqu *TkQuestionUpdate) Where(ps ...predicate.TkQuestion) *TkQuestionUpdate {
	tqu.mutation.predicates = append(tqu.mutation.predicates, ps...)
	return tqu
}

// SetUUID sets the "uuid" field.
func (tqu *TkQuestionUpdate) SetUUID(s string) *TkQuestionUpdate {
	tqu.mutation.SetUUID(s)
	return tqu
}

// SetUpdatedAt sets the "updated_at" field.
func (tqu *TkQuestionUpdate) SetUpdatedAt(t time.Time) *TkQuestionUpdate {
	tqu.mutation.SetUpdatedAt(t)
	return tqu
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (tqu *TkQuestionUpdate) ClearUpdatedAt() *TkQuestionUpdate {
	tqu.mutation.ClearUpdatedAt()
	return tqu
}

// SetDeletedAt sets the "deleted_at" field.
func (tqu *TkQuestionUpdate) SetDeletedAt(t time.Time) *TkQuestionUpdate {
	tqu.mutation.SetDeletedAt(t)
	return tqu
}

// SetNillableDeletedAt sets the "deleted_at" field if the given value is not nil.
func (tqu *TkQuestionUpdate) SetNillableDeletedAt(t *time.Time) *TkQuestionUpdate {
	if t != nil {
		tqu.SetDeletedAt(*t)
	}
	return tqu
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (tqu *TkQuestionUpdate) ClearDeletedAt() *TkQuestionUpdate {
	tqu.mutation.ClearDeletedAt()
	return tqu
}

// SetName sets the "name" field.
func (tqu *TkQuestionUpdate) SetName(s string) *TkQuestionUpdate {
	tqu.mutation.SetName(s)
	return tqu
}

// SetNillableName sets the "name" field if the given value is not nil.
func (tqu *TkQuestionUpdate) SetNillableName(s *string) *TkQuestionUpdate {
	if s != nil {
		tqu.SetName(*s)
	}
	return tqu
}

// ClearName clears the value of the "name" field.
func (tqu *TkQuestionUpdate) ClearName() *TkQuestionUpdate {
	tqu.mutation.ClearName()
	return tqu
}

// SetDifficulty sets the "difficulty" field.
func (tqu *TkQuestionUpdate) SetDifficulty(u uint8) *TkQuestionUpdate {
	tqu.mutation.ResetDifficulty()
	tqu.mutation.SetDifficulty(u)
	return tqu
}

// SetNillableDifficulty sets the "difficulty" field if the given value is not nil.
func (tqu *TkQuestionUpdate) SetNillableDifficulty(u *uint8) *TkQuestionUpdate {
	if u != nil {
		tqu.SetDifficulty(*u)
	}
	return tqu
}

// AddDifficulty adds u to the "difficulty" field.
func (tqu *TkQuestionUpdate) AddDifficulty(u uint8) *TkQuestionUpdate {
	tqu.mutation.AddDifficulty(u)
	return tqu
}

// SetType sets the "type" field.
func (tqu *TkQuestionUpdate) SetType(u uint8) *TkQuestionUpdate {
	tqu.mutation.ResetType()
	tqu.mutation.SetType(u)
	return tqu
}

// SetNillableType sets the "type" field if the given value is not nil.
func (tqu *TkQuestionUpdate) SetNillableType(u *uint8) *TkQuestionUpdate {
	if u != nil {
		tqu.SetType(*u)
	}
	return tqu
}

// AddType adds u to the "type" field.
func (tqu *TkQuestionUpdate) AddType(u uint8) *TkQuestionUpdate {
	tqu.mutation.AddType(u)
	return tqu
}

// SetDesc sets the "desc" field.
func (tqu *TkQuestionUpdate) SetDesc(s string) *TkQuestionUpdate {
	tqu.mutation.SetDesc(s)
	return tqu
}

// SetNillableDesc sets the "desc" field if the given value is not nil.
func (tqu *TkQuestionUpdate) SetNillableDesc(s *string) *TkQuestionUpdate {
	if s != nil {
		tqu.SetDesc(*s)
	}
	return tqu
}

// ClearDesc clears the value of the "desc" field.
func (tqu *TkQuestionUpdate) ClearDesc() *TkQuestionUpdate {
	tqu.mutation.ClearDesc()
	return tqu
}

// SetCreatedAdminID sets the "created_admin_id" field.
func (tqu *TkQuestionUpdate) SetCreatedAdminID(i int) *TkQuestionUpdate {
	tqu.mutation.ResetCreatedAdminID()
	tqu.mutation.SetCreatedAdminID(i)
	return tqu
}

// SetNillableCreatedAdminID sets the "created_admin_id" field if the given value is not nil.
func (tqu *TkQuestionUpdate) SetNillableCreatedAdminID(i *int) *TkQuestionUpdate {
	if i != nil {
		tqu.SetCreatedAdminID(*i)
	}
	return tqu
}

// ClearCreatedAdminID clears the value of the "created_admin_id" field.
func (tqu *TkQuestionUpdate) ClearCreatedAdminID() *TkQuestionUpdate {
	tqu.mutation.ClearCreatedAdminID()
	return tqu
}

// SetQuestionBankID sets the "question_bank_id" field.
func (tqu *TkQuestionUpdate) SetQuestionBankID(i int) *TkQuestionUpdate {
	tqu.mutation.ResetQuestionBankID()
	tqu.mutation.SetQuestionBankID(i)
	return tqu
}

// SetNillableQuestionBankID sets the "question_bank_id" field if the given value is not nil.
func (tqu *TkQuestionUpdate) SetNillableQuestionBankID(i *int) *TkQuestionUpdate {
	if i != nil {
		tqu.SetQuestionBankID(*i)
	}
	return tqu
}

// ClearQuestionBankID clears the value of the "question_bank_id" field.
func (tqu *TkQuestionUpdate) ClearQuestionBankID() *TkQuestionUpdate {
	tqu.mutation.ClearQuestionBankID()
	return tqu
}

// SetAnswerCount sets the "answer_count" field.
func (tqu *TkQuestionUpdate) SetAnswerCount(i int) *TkQuestionUpdate {
	tqu.mutation.ResetAnswerCount()
	tqu.mutation.SetAnswerCount(i)
	return tqu
}

// SetNillableAnswerCount sets the "answer_count" field if the given value is not nil.
func (tqu *TkQuestionUpdate) SetNillableAnswerCount(i *int) *TkQuestionUpdate {
	if i != nil {
		tqu.SetAnswerCount(*i)
	}
	return tqu
}

// AddAnswerCount adds i to the "answer_count" field.
func (tqu *TkQuestionUpdate) AddAnswerCount(i int) *TkQuestionUpdate {
	tqu.mutation.AddAnswerCount(i)
	return tqu
}

// SetRightCount sets the "right_count" field.
func (tqu *TkQuestionUpdate) SetRightCount(i int) *TkQuestionUpdate {
	tqu.mutation.ResetRightCount()
	tqu.mutation.SetRightCount(i)
	return tqu
}

// SetNillableRightCount sets the "right_count" field if the given value is not nil.
func (tqu *TkQuestionUpdate) SetNillableRightCount(i *int) *TkQuestionUpdate {
	if i != nil {
		tqu.SetRightCount(*i)
	}
	return tqu
}

// AddRightCount adds i to the "right_count" field.
func (tqu *TkQuestionUpdate) AddRightCount(i int) *TkQuestionUpdate {
	tqu.mutation.AddRightCount(i)
	return tqu
}

// SetPid sets the "pid" field.
func (tqu *TkQuestionUpdate) SetPid(i int) *TkQuestionUpdate {
	tqu.mutation.ResetPid()
	tqu.mutation.SetPid(i)
	return tqu
}

// SetNillablePid sets the "pid" field if the given value is not nil.
func (tqu *TkQuestionUpdate) SetNillablePid(i *int) *TkQuestionUpdate {
	if i != nil {
		tqu.SetPid(*i)
	}
	return tqu
}

// ClearPid clears the value of the "pid" field.
func (tqu *TkQuestionUpdate) ClearPid() *TkQuestionUpdate {
	tqu.mutation.ClearPid()
	return tqu
}

// SetQuestionBank sets the "question_bank" edge to the TkQuestionBank entity.
func (tqu *TkQuestionUpdate) SetQuestionBank(t *TkQuestionBank) *TkQuestionUpdate {
	return tqu.SetQuestionBankID(t.ID)
}

// SetAdminID sets the "admin" edge to the Admin entity by ID.
func (tqu *TkQuestionUpdate) SetAdminID(id int) *TkQuestionUpdate {
	tqu.mutation.SetAdminID(id)
	return tqu
}

// SetNillableAdminID sets the "admin" edge to the Admin entity by ID if the given value is not nil.
func (tqu *TkQuestionUpdate) SetNillableAdminID(id *int) *TkQuestionUpdate {
	if id != nil {
		tqu = tqu.SetAdminID(*id)
	}
	return tqu
}

// SetAdmin sets the "admin" edge to the Admin entity.
func (tqu *TkQuestionUpdate) SetAdmin(a *Admin) *TkQuestionUpdate {
	return tqu.SetAdminID(a.ID)
}

// AddUserRandDomIDs adds the "user_rand_dom" edge to the TkUserRandomExamRecode entity by IDs.
func (tqu *TkQuestionUpdate) AddUserRandDomIDs(ids ...int) *TkQuestionUpdate {
	tqu.mutation.AddUserRandDomIDs(ids...)
	return tqu
}

// AddUserRandDom adds the "user_rand_dom" edges to the TkUserRandomExamRecode entity.
func (tqu *TkQuestionUpdate) AddUserRandDom(t ...*TkUserRandomExamRecode) *TkQuestionUpdate {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tqu.AddUserRandDomIDs(ids...)
}

// AddAnswerOptionIDs adds the "answer_options" edge to the TkQuestionAnswerOption entity by IDs.
func (tqu *TkQuestionUpdate) AddAnswerOptionIDs(ids ...int) *TkQuestionUpdate {
	tqu.mutation.AddAnswerOptionIDs(ids...)
	return tqu
}

// AddAnswerOptions adds the "answer_options" edges to the TkQuestionAnswerOption entity.
func (tqu *TkQuestionUpdate) AddAnswerOptions(t ...*TkQuestionAnswerOption) *TkQuestionUpdate {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tqu.AddAnswerOptionIDs(ids...)
}

// AddKnowledgePointIDs adds the "knowledge_points" edge to the TkKnowledgePoint entity by IDs.
func (tqu *TkQuestionUpdate) AddKnowledgePointIDs(ids ...int) *TkQuestionUpdate {
	tqu.mutation.AddKnowledgePointIDs(ids...)
	return tqu
}

// AddKnowledgePoints adds the "knowledge_points" edges to the TkKnowledgePoint entity.
func (tqu *TkQuestionUpdate) AddKnowledgePoints(t ...*TkKnowledgePoint) *TkQuestionUpdate {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tqu.AddKnowledgePointIDs(ids...)
}

// AddQuestionSectionLinkIDs adds the "question_section_links" edge to the TkQuestionSection entity by IDs.
func (tqu *TkQuestionUpdate) AddQuestionSectionLinkIDs(ids ...int) *TkQuestionUpdate {
	tqu.mutation.AddQuestionSectionLinkIDs(ids...)
	return tqu
}

// AddQuestionSectionLinks adds the "question_section_links" edges to the TkQuestionSection entity.
func (tqu *TkQuestionUpdate) AddQuestionSectionLinks(t ...*TkQuestionSection) *TkQuestionUpdate {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tqu.AddQuestionSectionLinkIDs(ids...)
}

// AddExamPartitionQuestionIDs adds the "exam_partition_questions" edge to the TkExamPartitionQuestionLink entity by IDs.
func (tqu *TkQuestionUpdate) AddExamPartitionQuestionIDs(ids ...int) *TkQuestionUpdate {
	tqu.mutation.AddExamPartitionQuestionIDs(ids...)
	return tqu
}

// AddExamPartitionQuestions adds the "exam_partition_questions" edges to the TkExamPartitionQuestionLink entity.
func (tqu *TkQuestionUpdate) AddExamPartitionQuestions(t ...*TkExamPartitionQuestionLink) *TkQuestionUpdate {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tqu.AddExamPartitionQuestionIDs(ids...)
}

// AddQuestionErrorFeedbackIDs adds the "question_error_feedbacks" edge to the TkQuestionErrorFeedback entity by IDs.
func (tqu *TkQuestionUpdate) AddQuestionErrorFeedbackIDs(ids ...int) *TkQuestionUpdate {
	tqu.mutation.AddQuestionErrorFeedbackIDs(ids...)
	return tqu
}

// AddQuestionErrorFeedbacks adds the "question_error_feedbacks" edges to the TkQuestionErrorFeedback entity.
func (tqu *TkQuestionUpdate) AddQuestionErrorFeedbacks(t ...*TkQuestionErrorFeedback) *TkQuestionUpdate {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tqu.AddQuestionErrorFeedbackIDs(ids...)
}

// AddUserRecordIDs adds the "user_records" edge to the TkUserQuestionRecord entity by IDs.
func (tqu *TkQuestionUpdate) AddUserRecordIDs(ids ...int) *TkQuestionUpdate {
	tqu.mutation.AddUserRecordIDs(ids...)
	return tqu
}

// AddUserRecords adds the "user_records" edges to the TkUserQuestionRecord entity.
func (tqu *TkQuestionUpdate) AddUserRecords(t ...*TkUserQuestionRecord) *TkQuestionUpdate {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tqu.AddUserRecordIDs(ids...)
}

// AddSmallCategoryQuestionIDs adds the "small_category_questions" edge to the KcSmallCategoryQuestion entity by IDs.
func (tqu *TkQuestionUpdate) AddSmallCategoryQuestionIDs(ids ...int) *TkQuestionUpdate {
	tqu.mutation.AddSmallCategoryQuestionIDs(ids...)
	return tqu
}

// AddSmallCategoryQuestions adds the "small_category_questions" edges to the KcSmallCategoryQuestion entity.
func (tqu *TkQuestionUpdate) AddSmallCategoryQuestions(k ...*KcSmallCategoryQuestion) *TkQuestionUpdate {
	ids := make([]int, len(k))
	for i := range k {
		ids[i] = k[i].ID
	}
	return tqu.AddSmallCategoryQuestionIDs(ids...)
}

// AddUserExamQuestionIDs adds the "user_exam_questions" edge to the TkUserSimulationTeacherMark entity by IDs.
func (tqu *TkQuestionUpdate) AddUserExamQuestionIDs(ids ...int) *TkQuestionUpdate {
	tqu.mutation.AddUserExamQuestionIDs(ids...)
	return tqu
}

// AddUserExamQuestions adds the "user_exam_questions" edges to the TkUserSimulationTeacherMark entity.
func (tqu *TkQuestionUpdate) AddUserExamQuestions(t ...*TkUserSimulationTeacherMark) *TkQuestionUpdate {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tqu.AddUserExamQuestionIDs(ids...)
}

// AddUserRecodeWrongIDs adds the "user_recode_wrong" edge to the TkUserWrongQuestionRecode entity by IDs.
func (tqu *TkQuestionUpdate) AddUserRecodeWrongIDs(ids ...int) *TkQuestionUpdate {
	tqu.mutation.AddUserRecodeWrongIDs(ids...)
	return tqu
}

// AddUserRecodeWrong adds the "user_recode_wrong" edges to the TkUserWrongQuestionRecode entity.
func (tqu *TkQuestionUpdate) AddUserRecodeWrong(t ...*TkUserWrongQuestionRecode) *TkQuestionUpdate {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tqu.AddUserRecodeWrongIDs(ids...)
}

// SetParentID sets the "parent" edge to the TkQuestion entity by ID.
func (tqu *TkQuestionUpdate) SetParentID(id int) *TkQuestionUpdate {
	tqu.mutation.SetParentID(id)
	return tqu
}

// SetNillableParentID sets the "parent" edge to the TkQuestion entity by ID if the given value is not nil.
func (tqu *TkQuestionUpdate) SetNillableParentID(id *int) *TkQuestionUpdate {
	if id != nil {
		tqu = tqu.SetParentID(*id)
	}
	return tqu
}

// SetParent sets the "parent" edge to the TkQuestion entity.
func (tqu *TkQuestionUpdate) SetParent(t *TkQuestion) *TkQuestionUpdate {
	return tqu.SetParentID(t.ID)
}

// AddChildIDs adds the "children" edge to the TkQuestion entity by IDs.
func (tqu *TkQuestionUpdate) AddChildIDs(ids ...int) *TkQuestionUpdate {
	tqu.mutation.AddChildIDs(ids...)
	return tqu
}

// AddChildren adds the "children" edges to the TkQuestion entity.
func (tqu *TkQuestionUpdate) AddChildren(t ...*TkQuestion) *TkQuestionUpdate {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tqu.AddChildIDs(ids...)
}

// AddCollectionQuestionIDs adds the "collection_question" edge to the Collection entity by IDs.
func (tqu *TkQuestionUpdate) AddCollectionQuestionIDs(ids ...int) *TkQuestionUpdate {
	tqu.mutation.AddCollectionQuestionIDs(ids...)
	return tqu
}

// AddCollectionQuestion adds the "collection_question" edges to the Collection entity.
func (tqu *TkQuestionUpdate) AddCollectionQuestion(c ...*Collection) *TkQuestionUpdate {
	ids := make([]int, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return tqu.AddCollectionQuestionIDs(ids...)
}

// Mutation returns the TkQuestionMutation object of the builder.
func (tqu *TkQuestionUpdate) Mutation() *TkQuestionMutation {
	return tqu.mutation
}

// ClearQuestionBank clears the "question_bank" edge to the TkQuestionBank entity.
func (tqu *TkQuestionUpdate) ClearQuestionBank() *TkQuestionUpdate {
	tqu.mutation.ClearQuestionBank()
	return tqu
}

// ClearAdmin clears the "admin" edge to the Admin entity.
func (tqu *TkQuestionUpdate) ClearAdmin() *TkQuestionUpdate {
	tqu.mutation.ClearAdmin()
	return tqu
}

// ClearUserRandDom clears all "user_rand_dom" edges to the TkUserRandomExamRecode entity.
func (tqu *TkQuestionUpdate) ClearUserRandDom() *TkQuestionUpdate {
	tqu.mutation.ClearUserRandDom()
	return tqu
}

// RemoveUserRandDomIDs removes the "user_rand_dom" edge to TkUserRandomExamRecode entities by IDs.
func (tqu *TkQuestionUpdate) RemoveUserRandDomIDs(ids ...int) *TkQuestionUpdate {
	tqu.mutation.RemoveUserRandDomIDs(ids...)
	return tqu
}

// RemoveUserRandDom removes "user_rand_dom" edges to TkUserRandomExamRecode entities.
func (tqu *TkQuestionUpdate) RemoveUserRandDom(t ...*TkUserRandomExamRecode) *TkQuestionUpdate {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tqu.RemoveUserRandDomIDs(ids...)
}

// ClearAnswerOptions clears all "answer_options" edges to the TkQuestionAnswerOption entity.
func (tqu *TkQuestionUpdate) ClearAnswerOptions() *TkQuestionUpdate {
	tqu.mutation.ClearAnswerOptions()
	return tqu
}

// RemoveAnswerOptionIDs removes the "answer_options" edge to TkQuestionAnswerOption entities by IDs.
func (tqu *TkQuestionUpdate) RemoveAnswerOptionIDs(ids ...int) *TkQuestionUpdate {
	tqu.mutation.RemoveAnswerOptionIDs(ids...)
	return tqu
}

// RemoveAnswerOptions removes "answer_options" edges to TkQuestionAnswerOption entities.
func (tqu *TkQuestionUpdate) RemoveAnswerOptions(t ...*TkQuestionAnswerOption) *TkQuestionUpdate {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tqu.RemoveAnswerOptionIDs(ids...)
}

// ClearKnowledgePoints clears all "knowledge_points" edges to the TkKnowledgePoint entity.
func (tqu *TkQuestionUpdate) ClearKnowledgePoints() *TkQuestionUpdate {
	tqu.mutation.ClearKnowledgePoints()
	return tqu
}

// RemoveKnowledgePointIDs removes the "knowledge_points" edge to TkKnowledgePoint entities by IDs.
func (tqu *TkQuestionUpdate) RemoveKnowledgePointIDs(ids ...int) *TkQuestionUpdate {
	tqu.mutation.RemoveKnowledgePointIDs(ids...)
	return tqu
}

// RemoveKnowledgePoints removes "knowledge_points" edges to TkKnowledgePoint entities.
func (tqu *TkQuestionUpdate) RemoveKnowledgePoints(t ...*TkKnowledgePoint) *TkQuestionUpdate {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tqu.RemoveKnowledgePointIDs(ids...)
}

// ClearQuestionSectionLinks clears all "question_section_links" edges to the TkQuestionSection entity.
func (tqu *TkQuestionUpdate) ClearQuestionSectionLinks() *TkQuestionUpdate {
	tqu.mutation.ClearQuestionSectionLinks()
	return tqu
}

// RemoveQuestionSectionLinkIDs removes the "question_section_links" edge to TkQuestionSection entities by IDs.
func (tqu *TkQuestionUpdate) RemoveQuestionSectionLinkIDs(ids ...int) *TkQuestionUpdate {
	tqu.mutation.RemoveQuestionSectionLinkIDs(ids...)
	return tqu
}

// RemoveQuestionSectionLinks removes "question_section_links" edges to TkQuestionSection entities.
func (tqu *TkQuestionUpdate) RemoveQuestionSectionLinks(t ...*TkQuestionSection) *TkQuestionUpdate {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tqu.RemoveQuestionSectionLinkIDs(ids...)
}

// ClearExamPartitionQuestions clears all "exam_partition_questions" edges to the TkExamPartitionQuestionLink entity.
func (tqu *TkQuestionUpdate) ClearExamPartitionQuestions() *TkQuestionUpdate {
	tqu.mutation.ClearExamPartitionQuestions()
	return tqu
}

// RemoveExamPartitionQuestionIDs removes the "exam_partition_questions" edge to TkExamPartitionQuestionLink entities by IDs.
func (tqu *TkQuestionUpdate) RemoveExamPartitionQuestionIDs(ids ...int) *TkQuestionUpdate {
	tqu.mutation.RemoveExamPartitionQuestionIDs(ids...)
	return tqu
}

// RemoveExamPartitionQuestions removes "exam_partition_questions" edges to TkExamPartitionQuestionLink entities.
func (tqu *TkQuestionUpdate) RemoveExamPartitionQuestions(t ...*TkExamPartitionQuestionLink) *TkQuestionUpdate {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tqu.RemoveExamPartitionQuestionIDs(ids...)
}

// ClearQuestionErrorFeedbacks clears all "question_error_feedbacks" edges to the TkQuestionErrorFeedback entity.
func (tqu *TkQuestionUpdate) ClearQuestionErrorFeedbacks() *TkQuestionUpdate {
	tqu.mutation.ClearQuestionErrorFeedbacks()
	return tqu
}

// RemoveQuestionErrorFeedbackIDs removes the "question_error_feedbacks" edge to TkQuestionErrorFeedback entities by IDs.
func (tqu *TkQuestionUpdate) RemoveQuestionErrorFeedbackIDs(ids ...int) *TkQuestionUpdate {
	tqu.mutation.RemoveQuestionErrorFeedbackIDs(ids...)
	return tqu
}

// RemoveQuestionErrorFeedbacks removes "question_error_feedbacks" edges to TkQuestionErrorFeedback entities.
func (tqu *TkQuestionUpdate) RemoveQuestionErrorFeedbacks(t ...*TkQuestionErrorFeedback) *TkQuestionUpdate {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tqu.RemoveQuestionErrorFeedbackIDs(ids...)
}

// ClearUserRecords clears all "user_records" edges to the TkUserQuestionRecord entity.
func (tqu *TkQuestionUpdate) ClearUserRecords() *TkQuestionUpdate {
	tqu.mutation.ClearUserRecords()
	return tqu
}

// RemoveUserRecordIDs removes the "user_records" edge to TkUserQuestionRecord entities by IDs.
func (tqu *TkQuestionUpdate) RemoveUserRecordIDs(ids ...int) *TkQuestionUpdate {
	tqu.mutation.RemoveUserRecordIDs(ids...)
	return tqu
}

// RemoveUserRecords removes "user_records" edges to TkUserQuestionRecord entities.
func (tqu *TkQuestionUpdate) RemoveUserRecords(t ...*TkUserQuestionRecord) *TkQuestionUpdate {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tqu.RemoveUserRecordIDs(ids...)
}

// ClearSmallCategoryQuestions clears all "small_category_questions" edges to the KcSmallCategoryQuestion entity.
func (tqu *TkQuestionUpdate) ClearSmallCategoryQuestions() *TkQuestionUpdate {
	tqu.mutation.ClearSmallCategoryQuestions()
	return tqu
}

// RemoveSmallCategoryQuestionIDs removes the "small_category_questions" edge to KcSmallCategoryQuestion entities by IDs.
func (tqu *TkQuestionUpdate) RemoveSmallCategoryQuestionIDs(ids ...int) *TkQuestionUpdate {
	tqu.mutation.RemoveSmallCategoryQuestionIDs(ids...)
	return tqu
}

// RemoveSmallCategoryQuestions removes "small_category_questions" edges to KcSmallCategoryQuestion entities.
func (tqu *TkQuestionUpdate) RemoveSmallCategoryQuestions(k ...*KcSmallCategoryQuestion) *TkQuestionUpdate {
	ids := make([]int, len(k))
	for i := range k {
		ids[i] = k[i].ID
	}
	return tqu.RemoveSmallCategoryQuestionIDs(ids...)
}

// ClearUserExamQuestions clears all "user_exam_questions" edges to the TkUserSimulationTeacherMark entity.
func (tqu *TkQuestionUpdate) ClearUserExamQuestions() *TkQuestionUpdate {
	tqu.mutation.ClearUserExamQuestions()
	return tqu
}

// RemoveUserExamQuestionIDs removes the "user_exam_questions" edge to TkUserSimulationTeacherMark entities by IDs.
func (tqu *TkQuestionUpdate) RemoveUserExamQuestionIDs(ids ...int) *TkQuestionUpdate {
	tqu.mutation.RemoveUserExamQuestionIDs(ids...)
	return tqu
}

// RemoveUserExamQuestions removes "user_exam_questions" edges to TkUserSimulationTeacherMark entities.
func (tqu *TkQuestionUpdate) RemoveUserExamQuestions(t ...*TkUserSimulationTeacherMark) *TkQuestionUpdate {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tqu.RemoveUserExamQuestionIDs(ids...)
}

// ClearUserRecodeWrong clears all "user_recode_wrong" edges to the TkUserWrongQuestionRecode entity.
func (tqu *TkQuestionUpdate) ClearUserRecodeWrong() *TkQuestionUpdate {
	tqu.mutation.ClearUserRecodeWrong()
	return tqu
}

// RemoveUserRecodeWrongIDs removes the "user_recode_wrong" edge to TkUserWrongQuestionRecode entities by IDs.
func (tqu *TkQuestionUpdate) RemoveUserRecodeWrongIDs(ids ...int) *TkQuestionUpdate {
	tqu.mutation.RemoveUserRecodeWrongIDs(ids...)
	return tqu
}

// RemoveUserRecodeWrong removes "user_recode_wrong" edges to TkUserWrongQuestionRecode entities.
func (tqu *TkQuestionUpdate) RemoveUserRecodeWrong(t ...*TkUserWrongQuestionRecode) *TkQuestionUpdate {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tqu.RemoveUserRecodeWrongIDs(ids...)
}

// ClearParent clears the "parent" edge to the TkQuestion entity.
func (tqu *TkQuestionUpdate) ClearParent() *TkQuestionUpdate {
	tqu.mutation.ClearParent()
	return tqu
}

// ClearChildren clears all "children" edges to the TkQuestion entity.
func (tqu *TkQuestionUpdate) ClearChildren() *TkQuestionUpdate {
	tqu.mutation.ClearChildren()
	return tqu
}

// RemoveChildIDs removes the "children" edge to TkQuestion entities by IDs.
func (tqu *TkQuestionUpdate) RemoveChildIDs(ids ...int) *TkQuestionUpdate {
	tqu.mutation.RemoveChildIDs(ids...)
	return tqu
}

// RemoveChildren removes "children" edges to TkQuestion entities.
func (tqu *TkQuestionUpdate) RemoveChildren(t ...*TkQuestion) *TkQuestionUpdate {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tqu.RemoveChildIDs(ids...)
}

// ClearCollectionQuestion clears all "collection_question" edges to the Collection entity.
func (tqu *TkQuestionUpdate) ClearCollectionQuestion() *TkQuestionUpdate {
	tqu.mutation.ClearCollectionQuestion()
	return tqu
}

// RemoveCollectionQuestionIDs removes the "collection_question" edge to Collection entities by IDs.
func (tqu *TkQuestionUpdate) RemoveCollectionQuestionIDs(ids ...int) *TkQuestionUpdate {
	tqu.mutation.RemoveCollectionQuestionIDs(ids...)
	return tqu
}

// RemoveCollectionQuestion removes "collection_question" edges to Collection entities.
func (tqu *TkQuestionUpdate) RemoveCollectionQuestion(c ...*Collection) *TkQuestionUpdate {
	ids := make([]int, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return tqu.RemoveCollectionQuestionIDs(ids...)
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (tqu *TkQuestionUpdate) Save(ctx context.Context) (int, error) {
	var (
		err      error
		affected int
	)
	tqu.defaults()
	if len(tqu.hooks) == 0 {
		affected, err = tqu.sqlSave(ctx)
	} else {
		var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
			mutation, ok := m.(*TkQuestionMutation)
			if !ok {
				return nil, fmt.Errorf("unexpected mutation type %T", m)
			}
			tqu.mutation = mutation
			affected, err = tqu.sqlSave(ctx)
			mutation.done = true
			return affected, err
		})
		for i := len(tqu.hooks) - 1; i >= 0; i-- {
			mut = tqu.hooks[i](mut)
		}
		if _, err := mut.Mutate(ctx, tqu.mutation); err != nil {
			return 0, err
		}
	}
	return affected, err
}

// SaveX is like Save, but panics if an error occurs.
func (tqu *TkQuestionUpdate) SaveX(ctx context.Context) int {
	affected, err := tqu.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (tqu *TkQuestionUpdate) Exec(ctx context.Context) error {
	_, err := tqu.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (tqu *TkQuestionUpdate) ExecX(ctx context.Context) {
	if err := tqu.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (tqu *TkQuestionUpdate) defaults() {
	if _, ok := tqu.mutation.UpdatedAt(); !ok && !tqu.mutation.UpdatedAtCleared() {
		v := tkquestion.UpdateDefaultUpdatedAt()
		tqu.mutation.SetUpdatedAt(v)
	}
}

func (tqu *TkQuestionUpdate) sqlSave(ctx context.Context) (n int, err error) {
	_spec := &sqlgraph.UpdateSpec{
		Node: &sqlgraph.NodeSpec{
			Table:   tkquestion.Table,
			Columns: tkquestion.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeInt,
				Column: tkquestion.FieldID,
			},
		},
	}
	if ps := tqu.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := tqu.mutation.UUID(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: tkquestion.FieldUUID,
		})
	}
	if tqu.mutation.CreatedAtCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Column: tkquestion.FieldCreatedAt,
		})
	}
	if value, ok := tqu.mutation.UpdatedAt(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: tkquestion.FieldUpdatedAt,
		})
	}
	if tqu.mutation.UpdatedAtCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Column: tkquestion.FieldUpdatedAt,
		})
	}
	if value, ok := tqu.mutation.DeletedAt(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: tkquestion.FieldDeletedAt,
		})
	}
	if tqu.mutation.DeletedAtCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Column: tkquestion.FieldDeletedAt,
		})
	}
	if value, ok := tqu.mutation.Name(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: tkquestion.FieldName,
		})
	}
	if tqu.mutation.NameCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: tkquestion.FieldName,
		})
	}
	if value, ok := tqu.mutation.Difficulty(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeUint8,
			Value:  value,
			Column: tkquestion.FieldDifficulty,
		})
	}
	if value, ok := tqu.mutation.AddedDifficulty(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeUint8,
			Value:  value,
			Column: tkquestion.FieldDifficulty,
		})
	}
	if value, ok := tqu.mutation.GetType(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeUint8,
			Value:  value,
			Column: tkquestion.FieldType,
		})
	}
	if value, ok := tqu.mutation.AddedType(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeUint8,
			Value:  value,
			Column: tkquestion.FieldType,
		})
	}
	if value, ok := tqu.mutation.Desc(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: tkquestion.FieldDesc,
		})
	}
	if tqu.mutation.DescCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: tkquestion.FieldDesc,
		})
	}
	if value, ok := tqu.mutation.AnswerCount(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Value:  value,
			Column: tkquestion.FieldAnswerCount,
		})
	}
	if value, ok := tqu.mutation.AddedAnswerCount(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Value:  value,
			Column: tkquestion.FieldAnswerCount,
		})
	}
	if value, ok := tqu.mutation.RightCount(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Value:  value,
			Column: tkquestion.FieldRightCount,
		})
	}
	if value, ok := tqu.mutation.AddedRightCount(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Value:  value,
			Column: tkquestion.FieldRightCount,
		})
	}
	if tqu.mutation.QuestionBankCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   tkquestion.QuestionBankTable,
			Columns: []string{tkquestion.QuestionBankColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkquestionbank.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tqu.mutation.QuestionBankIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   tkquestion.QuestionBankTable,
			Columns: []string{tkquestion.QuestionBankColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkquestionbank.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if tqu.mutation.AdminCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   tkquestion.AdminTable,
			Columns: []string{tkquestion.AdminColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: admin.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tqu.mutation.AdminIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   tkquestion.AdminTable,
			Columns: []string{tkquestion.AdminColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: admin.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if tqu.mutation.UserRandDomCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   tkquestion.UserRandDomTable,
			Columns: tkquestion.UserRandDomPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkuserrandomexamrecode.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tqu.mutation.RemovedUserRandDomIDs(); len(nodes) > 0 && !tqu.mutation.UserRandDomCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   tkquestion.UserRandDomTable,
			Columns: tkquestion.UserRandDomPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkuserrandomexamrecode.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tqu.mutation.UserRandDomIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   tkquestion.UserRandDomTable,
			Columns: tkquestion.UserRandDomPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkuserrandomexamrecode.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if tqu.mutation.AnswerOptionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.AnswerOptionsTable,
			Columns: []string{tkquestion.AnswerOptionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkquestionansweroption.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tqu.mutation.RemovedAnswerOptionsIDs(); len(nodes) > 0 && !tqu.mutation.AnswerOptionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.AnswerOptionsTable,
			Columns: []string{tkquestion.AnswerOptionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkquestionansweroption.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tqu.mutation.AnswerOptionsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.AnswerOptionsTable,
			Columns: []string{tkquestion.AnswerOptionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkquestionansweroption.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if tqu.mutation.KnowledgePointsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   tkquestion.KnowledgePointsTable,
			Columns: tkquestion.KnowledgePointsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkknowledgepoint.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tqu.mutation.RemovedKnowledgePointsIDs(); len(nodes) > 0 && !tqu.mutation.KnowledgePointsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   tkquestion.KnowledgePointsTable,
			Columns: tkquestion.KnowledgePointsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkknowledgepoint.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tqu.mutation.KnowledgePointsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   tkquestion.KnowledgePointsTable,
			Columns: tkquestion.KnowledgePointsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkknowledgepoint.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if tqu.mutation.QuestionSectionLinksCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.QuestionSectionLinksTable,
			Columns: []string{tkquestion.QuestionSectionLinksColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkquestionsection.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tqu.mutation.RemovedQuestionSectionLinksIDs(); len(nodes) > 0 && !tqu.mutation.QuestionSectionLinksCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.QuestionSectionLinksTable,
			Columns: []string{tkquestion.QuestionSectionLinksColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkquestionsection.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tqu.mutation.QuestionSectionLinksIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.QuestionSectionLinksTable,
			Columns: []string{tkquestion.QuestionSectionLinksColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkquestionsection.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if tqu.mutation.ExamPartitionQuestionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.ExamPartitionQuestionsTable,
			Columns: []string{tkquestion.ExamPartitionQuestionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkexampartitionquestionlink.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tqu.mutation.RemovedExamPartitionQuestionsIDs(); len(nodes) > 0 && !tqu.mutation.ExamPartitionQuestionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.ExamPartitionQuestionsTable,
			Columns: []string{tkquestion.ExamPartitionQuestionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkexampartitionquestionlink.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tqu.mutation.ExamPartitionQuestionsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.ExamPartitionQuestionsTable,
			Columns: []string{tkquestion.ExamPartitionQuestionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkexampartitionquestionlink.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if tqu.mutation.QuestionErrorFeedbacksCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.QuestionErrorFeedbacksTable,
			Columns: []string{tkquestion.QuestionErrorFeedbacksColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkquestionerrorfeedback.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tqu.mutation.RemovedQuestionErrorFeedbacksIDs(); len(nodes) > 0 && !tqu.mutation.QuestionErrorFeedbacksCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.QuestionErrorFeedbacksTable,
			Columns: []string{tkquestion.QuestionErrorFeedbacksColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkquestionerrorfeedback.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tqu.mutation.QuestionErrorFeedbacksIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.QuestionErrorFeedbacksTable,
			Columns: []string{tkquestion.QuestionErrorFeedbacksColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkquestionerrorfeedback.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if tqu.mutation.UserRecordsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.UserRecordsTable,
			Columns: []string{tkquestion.UserRecordsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkuserquestionrecord.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tqu.mutation.RemovedUserRecordsIDs(); len(nodes) > 0 && !tqu.mutation.UserRecordsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.UserRecordsTable,
			Columns: []string{tkquestion.UserRecordsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkuserquestionrecord.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tqu.mutation.UserRecordsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.UserRecordsTable,
			Columns: []string{tkquestion.UserRecordsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkuserquestionrecord.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if tqu.mutation.SmallCategoryQuestionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.SmallCategoryQuestionsTable,
			Columns: []string{tkquestion.SmallCategoryQuestionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: kcsmallcategoryquestion.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tqu.mutation.RemovedSmallCategoryQuestionsIDs(); len(nodes) > 0 && !tqu.mutation.SmallCategoryQuestionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.SmallCategoryQuestionsTable,
			Columns: []string{tkquestion.SmallCategoryQuestionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: kcsmallcategoryquestion.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tqu.mutation.SmallCategoryQuestionsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.SmallCategoryQuestionsTable,
			Columns: []string{tkquestion.SmallCategoryQuestionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: kcsmallcategoryquestion.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if tqu.mutation.UserExamQuestionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.UserExamQuestionsTable,
			Columns: []string{tkquestion.UserExamQuestionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkusersimulationteachermark.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tqu.mutation.RemovedUserExamQuestionsIDs(); len(nodes) > 0 && !tqu.mutation.UserExamQuestionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.UserExamQuestionsTable,
			Columns: []string{tkquestion.UserExamQuestionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkusersimulationteachermark.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tqu.mutation.UserExamQuestionsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.UserExamQuestionsTable,
			Columns: []string{tkquestion.UserExamQuestionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkusersimulationteachermark.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if tqu.mutation.UserRecodeWrongCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.UserRecodeWrongTable,
			Columns: []string{tkquestion.UserRecodeWrongColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkuserwrongquestionrecode.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tqu.mutation.RemovedUserRecodeWrongIDs(); len(nodes) > 0 && !tqu.mutation.UserRecodeWrongCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.UserRecodeWrongTable,
			Columns: []string{tkquestion.UserRecodeWrongColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkuserwrongquestionrecode.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tqu.mutation.UserRecodeWrongIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.UserRecodeWrongTable,
			Columns: []string{tkquestion.UserRecodeWrongColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkuserwrongquestionrecode.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if tqu.mutation.ParentCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   tkquestion.ParentTable,
			Columns: []string{tkquestion.ParentColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkquestion.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tqu.mutation.ParentIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   tkquestion.ParentTable,
			Columns: []string{tkquestion.ParentColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkquestion.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if tqu.mutation.ChildrenCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.ChildrenTable,
			Columns: []string{tkquestion.ChildrenColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkquestion.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tqu.mutation.RemovedChildrenIDs(); len(nodes) > 0 && !tqu.mutation.ChildrenCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.ChildrenTable,
			Columns: []string{tkquestion.ChildrenColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkquestion.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tqu.mutation.ChildrenIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.ChildrenTable,
			Columns: []string{tkquestion.ChildrenColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkquestion.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if tqu.mutation.CollectionQuestionCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.CollectionQuestionTable,
			Columns: []string{tkquestion.CollectionQuestionColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: collection.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tqu.mutation.RemovedCollectionQuestionIDs(); len(nodes) > 0 && !tqu.mutation.CollectionQuestionCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.CollectionQuestionTable,
			Columns: []string{tkquestion.CollectionQuestionColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: collection.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tqu.mutation.CollectionQuestionIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.CollectionQuestionTable,
			Columns: []string{tkquestion.CollectionQuestionColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: collection.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if n, err = sqlgraph.UpdateNodes(ctx, tqu.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{tkquestion.Label}
		} else if cerr, ok := isSQLConstraintError(err); ok {
			err = cerr
		}
		return 0, err
	}
	return n, nil
}

// TkQuestionUpdateOne is the builder for updating a single TkQuestion entity.
type TkQuestionUpdateOne struct {
	config
	fields   []string
	hooks    []Hook
	mutation *TkQuestionMutation
}

// SetUUID sets the "uuid" field.
func (tquo *TkQuestionUpdateOne) SetUUID(s string) *TkQuestionUpdateOne {
	tquo.mutation.SetUUID(s)
	return tquo
}

// SetUpdatedAt sets the "updated_at" field.
func (tquo *TkQuestionUpdateOne) SetUpdatedAt(t time.Time) *TkQuestionUpdateOne {
	tquo.mutation.SetUpdatedAt(t)
	return tquo
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (tquo *TkQuestionUpdateOne) ClearUpdatedAt() *TkQuestionUpdateOne {
	tquo.mutation.ClearUpdatedAt()
	return tquo
}

// SetDeletedAt sets the "deleted_at" field.
func (tquo *TkQuestionUpdateOne) SetDeletedAt(t time.Time) *TkQuestionUpdateOne {
	tquo.mutation.SetDeletedAt(t)
	return tquo
}

// SetNillableDeletedAt sets the "deleted_at" field if the given value is not nil.
func (tquo *TkQuestionUpdateOne) SetNillableDeletedAt(t *time.Time) *TkQuestionUpdateOne {
	if t != nil {
		tquo.SetDeletedAt(*t)
	}
	return tquo
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (tquo *TkQuestionUpdateOne) ClearDeletedAt() *TkQuestionUpdateOne {
	tquo.mutation.ClearDeletedAt()
	return tquo
}

// SetName sets the "name" field.
func (tquo *TkQuestionUpdateOne) SetName(s string) *TkQuestionUpdateOne {
	tquo.mutation.SetName(s)
	return tquo
}

// SetNillableName sets the "name" field if the given value is not nil.
func (tquo *TkQuestionUpdateOne) SetNillableName(s *string) *TkQuestionUpdateOne {
	if s != nil {
		tquo.SetName(*s)
	}
	return tquo
}

// ClearName clears the value of the "name" field.
func (tquo *TkQuestionUpdateOne) ClearName() *TkQuestionUpdateOne {
	tquo.mutation.ClearName()
	return tquo
}

// SetDifficulty sets the "difficulty" field.
func (tquo *TkQuestionUpdateOne) SetDifficulty(u uint8) *TkQuestionUpdateOne {
	tquo.mutation.ResetDifficulty()
	tquo.mutation.SetDifficulty(u)
	return tquo
}

// SetNillableDifficulty sets the "difficulty" field if the given value is not nil.
func (tquo *TkQuestionUpdateOne) SetNillableDifficulty(u *uint8) *TkQuestionUpdateOne {
	if u != nil {
		tquo.SetDifficulty(*u)
	}
	return tquo
}

// AddDifficulty adds u to the "difficulty" field.
func (tquo *TkQuestionUpdateOne) AddDifficulty(u uint8) *TkQuestionUpdateOne {
	tquo.mutation.AddDifficulty(u)
	return tquo
}

// SetType sets the "type" field.
func (tquo *TkQuestionUpdateOne) SetType(u uint8) *TkQuestionUpdateOne {
	tquo.mutation.ResetType()
	tquo.mutation.SetType(u)
	return tquo
}

// SetNillableType sets the "type" field if the given value is not nil.
func (tquo *TkQuestionUpdateOne) SetNillableType(u *uint8) *TkQuestionUpdateOne {
	if u != nil {
		tquo.SetType(*u)
	}
	return tquo
}

// AddType adds u to the "type" field.
func (tquo *TkQuestionUpdateOne) AddType(u uint8) *TkQuestionUpdateOne {
	tquo.mutation.AddType(u)
	return tquo
}

// SetDesc sets the "desc" field.
func (tquo *TkQuestionUpdateOne) SetDesc(s string) *TkQuestionUpdateOne {
	tquo.mutation.SetDesc(s)
	return tquo
}

// SetNillableDesc sets the "desc" field if the given value is not nil.
func (tquo *TkQuestionUpdateOne) SetNillableDesc(s *string) *TkQuestionUpdateOne {
	if s != nil {
		tquo.SetDesc(*s)
	}
	return tquo
}

// ClearDesc clears the value of the "desc" field.
func (tquo *TkQuestionUpdateOne) ClearDesc() *TkQuestionUpdateOne {
	tquo.mutation.ClearDesc()
	return tquo
}

// SetCreatedAdminID sets the "created_admin_id" field.
func (tquo *TkQuestionUpdateOne) SetCreatedAdminID(i int) *TkQuestionUpdateOne {
	tquo.mutation.ResetCreatedAdminID()
	tquo.mutation.SetCreatedAdminID(i)
	return tquo
}

// SetNillableCreatedAdminID sets the "created_admin_id" field if the given value is not nil.
func (tquo *TkQuestionUpdateOne) SetNillableCreatedAdminID(i *int) *TkQuestionUpdateOne {
	if i != nil {
		tquo.SetCreatedAdminID(*i)
	}
	return tquo
}

// ClearCreatedAdminID clears the value of the "created_admin_id" field.
func (tquo *TkQuestionUpdateOne) ClearCreatedAdminID() *TkQuestionUpdateOne {
	tquo.mutation.ClearCreatedAdminID()
	return tquo
}

// SetQuestionBankID sets the "question_bank_id" field.
func (tquo *TkQuestionUpdateOne) SetQuestionBankID(i int) *TkQuestionUpdateOne {
	tquo.mutation.ResetQuestionBankID()
	tquo.mutation.SetQuestionBankID(i)
	return tquo
}

// SetNillableQuestionBankID sets the "question_bank_id" field if the given value is not nil.
func (tquo *TkQuestionUpdateOne) SetNillableQuestionBankID(i *int) *TkQuestionUpdateOne {
	if i != nil {
		tquo.SetQuestionBankID(*i)
	}
	return tquo
}

// ClearQuestionBankID clears the value of the "question_bank_id" field.
func (tquo *TkQuestionUpdateOne) ClearQuestionBankID() *TkQuestionUpdateOne {
	tquo.mutation.ClearQuestionBankID()
	return tquo
}

// SetAnswerCount sets the "answer_count" field.
func (tquo *TkQuestionUpdateOne) SetAnswerCount(i int) *TkQuestionUpdateOne {
	tquo.mutation.ResetAnswerCount()
	tquo.mutation.SetAnswerCount(i)
	return tquo
}

// SetNillableAnswerCount sets the "answer_count" field if the given value is not nil.
func (tquo *TkQuestionUpdateOne) SetNillableAnswerCount(i *int) *TkQuestionUpdateOne {
	if i != nil {
		tquo.SetAnswerCount(*i)
	}
	return tquo
}

// AddAnswerCount adds i to the "answer_count" field.
func (tquo *TkQuestionUpdateOne) AddAnswerCount(i int) *TkQuestionUpdateOne {
	tquo.mutation.AddAnswerCount(i)
	return tquo
}

// SetRightCount sets the "right_count" field.
func (tquo *TkQuestionUpdateOne) SetRightCount(i int) *TkQuestionUpdateOne {
	tquo.mutation.ResetRightCount()
	tquo.mutation.SetRightCount(i)
	return tquo
}

// SetNillableRightCount sets the "right_count" field if the given value is not nil.
func (tquo *TkQuestionUpdateOne) SetNillableRightCount(i *int) *TkQuestionUpdateOne {
	if i != nil {
		tquo.SetRightCount(*i)
	}
	return tquo
}

// AddRightCount adds i to the "right_count" field.
func (tquo *TkQuestionUpdateOne) AddRightCount(i int) *TkQuestionUpdateOne {
	tquo.mutation.AddRightCount(i)
	return tquo
}

// SetPid sets the "pid" field.
func (tquo *TkQuestionUpdateOne) SetPid(i int) *TkQuestionUpdateOne {
	tquo.mutation.ResetPid()
	tquo.mutation.SetPid(i)
	return tquo
}

// SetNillablePid sets the "pid" field if the given value is not nil.
func (tquo *TkQuestionUpdateOne) SetNillablePid(i *int) *TkQuestionUpdateOne {
	if i != nil {
		tquo.SetPid(*i)
	}
	return tquo
}

// ClearPid clears the value of the "pid" field.
func (tquo *TkQuestionUpdateOne) ClearPid() *TkQuestionUpdateOne {
	tquo.mutation.ClearPid()
	return tquo
}

// SetQuestionBank sets the "question_bank" edge to the TkQuestionBank entity.
func (tquo *TkQuestionUpdateOne) SetQuestionBank(t *TkQuestionBank) *TkQuestionUpdateOne {
	return tquo.SetQuestionBankID(t.ID)
}

// SetAdminID sets the "admin" edge to the Admin entity by ID.
func (tquo *TkQuestionUpdateOne) SetAdminID(id int) *TkQuestionUpdateOne {
	tquo.mutation.SetAdminID(id)
	return tquo
}

// SetNillableAdminID sets the "admin" edge to the Admin entity by ID if the given value is not nil.
func (tquo *TkQuestionUpdateOne) SetNillableAdminID(id *int) *TkQuestionUpdateOne {
	if id != nil {
		tquo = tquo.SetAdminID(*id)
	}
	return tquo
}

// SetAdmin sets the "admin" edge to the Admin entity.
func (tquo *TkQuestionUpdateOne) SetAdmin(a *Admin) *TkQuestionUpdateOne {
	return tquo.SetAdminID(a.ID)
}

// AddUserRandDomIDs adds the "user_rand_dom" edge to the TkUserRandomExamRecode entity by IDs.
func (tquo *TkQuestionUpdateOne) AddUserRandDomIDs(ids ...int) *TkQuestionUpdateOne {
	tquo.mutation.AddUserRandDomIDs(ids...)
	return tquo
}

// AddUserRandDom adds the "user_rand_dom" edges to the TkUserRandomExamRecode entity.
func (tquo *TkQuestionUpdateOne) AddUserRandDom(t ...*TkUserRandomExamRecode) *TkQuestionUpdateOne {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tquo.AddUserRandDomIDs(ids...)
}

// AddAnswerOptionIDs adds the "answer_options" edge to the TkQuestionAnswerOption entity by IDs.
func (tquo *TkQuestionUpdateOne) AddAnswerOptionIDs(ids ...int) *TkQuestionUpdateOne {
	tquo.mutation.AddAnswerOptionIDs(ids...)
	return tquo
}

// AddAnswerOptions adds the "answer_options" edges to the TkQuestionAnswerOption entity.
func (tquo *TkQuestionUpdateOne) AddAnswerOptions(t ...*TkQuestionAnswerOption) *TkQuestionUpdateOne {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tquo.AddAnswerOptionIDs(ids...)
}

// AddKnowledgePointIDs adds the "knowledge_points" edge to the TkKnowledgePoint entity by IDs.
func (tquo *TkQuestionUpdateOne) AddKnowledgePointIDs(ids ...int) *TkQuestionUpdateOne {
	tquo.mutation.AddKnowledgePointIDs(ids...)
	return tquo
}

// AddKnowledgePoints adds the "knowledge_points" edges to the TkKnowledgePoint entity.
func (tquo *TkQuestionUpdateOne) AddKnowledgePoints(t ...*TkKnowledgePoint) *TkQuestionUpdateOne {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tquo.AddKnowledgePointIDs(ids...)
}

// AddQuestionSectionLinkIDs adds the "question_section_links" edge to the TkQuestionSection entity by IDs.
func (tquo *TkQuestionUpdateOne) AddQuestionSectionLinkIDs(ids ...int) *TkQuestionUpdateOne {
	tquo.mutation.AddQuestionSectionLinkIDs(ids...)
	return tquo
}

// AddQuestionSectionLinks adds the "question_section_links" edges to the TkQuestionSection entity.
func (tquo *TkQuestionUpdateOne) AddQuestionSectionLinks(t ...*TkQuestionSection) *TkQuestionUpdateOne {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tquo.AddQuestionSectionLinkIDs(ids...)
}

// AddExamPartitionQuestionIDs adds the "exam_partition_questions" edge to the TkExamPartitionQuestionLink entity by IDs.
func (tquo *TkQuestionUpdateOne) AddExamPartitionQuestionIDs(ids ...int) *TkQuestionUpdateOne {
	tquo.mutation.AddExamPartitionQuestionIDs(ids...)
	return tquo
}

// AddExamPartitionQuestions adds the "exam_partition_questions" edges to the TkExamPartitionQuestionLink entity.
func (tquo *TkQuestionUpdateOne) AddExamPartitionQuestions(t ...*TkExamPartitionQuestionLink) *TkQuestionUpdateOne {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tquo.AddExamPartitionQuestionIDs(ids...)
}

// AddQuestionErrorFeedbackIDs adds the "question_error_feedbacks" edge to the TkQuestionErrorFeedback entity by IDs.
func (tquo *TkQuestionUpdateOne) AddQuestionErrorFeedbackIDs(ids ...int) *TkQuestionUpdateOne {
	tquo.mutation.AddQuestionErrorFeedbackIDs(ids...)
	return tquo
}

// AddQuestionErrorFeedbacks adds the "question_error_feedbacks" edges to the TkQuestionErrorFeedback entity.
func (tquo *TkQuestionUpdateOne) AddQuestionErrorFeedbacks(t ...*TkQuestionErrorFeedback) *TkQuestionUpdateOne {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tquo.AddQuestionErrorFeedbackIDs(ids...)
}

// AddUserRecordIDs adds the "user_records" edge to the TkUserQuestionRecord entity by IDs.
func (tquo *TkQuestionUpdateOne) AddUserRecordIDs(ids ...int) *TkQuestionUpdateOne {
	tquo.mutation.AddUserRecordIDs(ids...)
	return tquo
}

// AddUserRecords adds the "user_records" edges to the TkUserQuestionRecord entity.
func (tquo *TkQuestionUpdateOne) AddUserRecords(t ...*TkUserQuestionRecord) *TkQuestionUpdateOne {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tquo.AddUserRecordIDs(ids...)
}

// AddSmallCategoryQuestionIDs adds the "small_category_questions" edge to the KcSmallCategoryQuestion entity by IDs.
func (tquo *TkQuestionUpdateOne) AddSmallCategoryQuestionIDs(ids ...int) *TkQuestionUpdateOne {
	tquo.mutation.AddSmallCategoryQuestionIDs(ids...)
	return tquo
}

// AddSmallCategoryQuestions adds the "small_category_questions" edges to the KcSmallCategoryQuestion entity.
func (tquo *TkQuestionUpdateOne) AddSmallCategoryQuestions(k ...*KcSmallCategoryQuestion) *TkQuestionUpdateOne {
	ids := make([]int, len(k))
	for i := range k {
		ids[i] = k[i].ID
	}
	return tquo.AddSmallCategoryQuestionIDs(ids...)
}

// AddUserExamQuestionIDs adds the "user_exam_questions" edge to the TkUserSimulationTeacherMark entity by IDs.
func (tquo *TkQuestionUpdateOne) AddUserExamQuestionIDs(ids ...int) *TkQuestionUpdateOne {
	tquo.mutation.AddUserExamQuestionIDs(ids...)
	return tquo
}

// AddUserExamQuestions adds the "user_exam_questions" edges to the TkUserSimulationTeacherMark entity.
func (tquo *TkQuestionUpdateOne) AddUserExamQuestions(t ...*TkUserSimulationTeacherMark) *TkQuestionUpdateOne {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tquo.AddUserExamQuestionIDs(ids...)
}

// AddUserRecodeWrongIDs adds the "user_recode_wrong" edge to the TkUserWrongQuestionRecode entity by IDs.
func (tquo *TkQuestionUpdateOne) AddUserRecodeWrongIDs(ids ...int) *TkQuestionUpdateOne {
	tquo.mutation.AddUserRecodeWrongIDs(ids...)
	return tquo
}

// AddUserRecodeWrong adds the "user_recode_wrong" edges to the TkUserWrongQuestionRecode entity.
func (tquo *TkQuestionUpdateOne) AddUserRecodeWrong(t ...*TkUserWrongQuestionRecode) *TkQuestionUpdateOne {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tquo.AddUserRecodeWrongIDs(ids...)
}

// SetParentID sets the "parent" edge to the TkQuestion entity by ID.
func (tquo *TkQuestionUpdateOne) SetParentID(id int) *TkQuestionUpdateOne {
	tquo.mutation.SetParentID(id)
	return tquo
}

// SetNillableParentID sets the "parent" edge to the TkQuestion entity by ID if the given value is not nil.
func (tquo *TkQuestionUpdateOne) SetNillableParentID(id *int) *TkQuestionUpdateOne {
	if id != nil {
		tquo = tquo.SetParentID(*id)
	}
	return tquo
}

// SetParent sets the "parent" edge to the TkQuestion entity.
func (tquo *TkQuestionUpdateOne) SetParent(t *TkQuestion) *TkQuestionUpdateOne {
	return tquo.SetParentID(t.ID)
}

// AddChildIDs adds the "children" edge to the TkQuestion entity by IDs.
func (tquo *TkQuestionUpdateOne) AddChildIDs(ids ...int) *TkQuestionUpdateOne {
	tquo.mutation.AddChildIDs(ids...)
	return tquo
}

// AddChildren adds the "children" edges to the TkQuestion entity.
func (tquo *TkQuestionUpdateOne) AddChildren(t ...*TkQuestion) *TkQuestionUpdateOne {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tquo.AddChildIDs(ids...)
}

// AddCollectionQuestionIDs adds the "collection_question" edge to the Collection entity by IDs.
func (tquo *TkQuestionUpdateOne) AddCollectionQuestionIDs(ids ...int) *TkQuestionUpdateOne {
	tquo.mutation.AddCollectionQuestionIDs(ids...)
	return tquo
}

// AddCollectionQuestion adds the "collection_question" edges to the Collection entity.
func (tquo *TkQuestionUpdateOne) AddCollectionQuestion(c ...*Collection) *TkQuestionUpdateOne {
	ids := make([]int, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return tquo.AddCollectionQuestionIDs(ids...)
}

// Mutation returns the TkQuestionMutation object of the builder.
func (tquo *TkQuestionUpdateOne) Mutation() *TkQuestionMutation {
	return tquo.mutation
}

// ClearQuestionBank clears the "question_bank" edge to the TkQuestionBank entity.
func (tquo *TkQuestionUpdateOne) ClearQuestionBank() *TkQuestionUpdateOne {
	tquo.mutation.ClearQuestionBank()
	return tquo
}

// ClearAdmin clears the "admin" edge to the Admin entity.
func (tquo *TkQuestionUpdateOne) ClearAdmin() *TkQuestionUpdateOne {
	tquo.mutation.ClearAdmin()
	return tquo
}

// ClearUserRandDom clears all "user_rand_dom" edges to the TkUserRandomExamRecode entity.
func (tquo *TkQuestionUpdateOne) ClearUserRandDom() *TkQuestionUpdateOne {
	tquo.mutation.ClearUserRandDom()
	return tquo
}

// RemoveUserRandDomIDs removes the "user_rand_dom" edge to TkUserRandomExamRecode entities by IDs.
func (tquo *TkQuestionUpdateOne) RemoveUserRandDomIDs(ids ...int) *TkQuestionUpdateOne {
	tquo.mutation.RemoveUserRandDomIDs(ids...)
	return tquo
}

// RemoveUserRandDom removes "user_rand_dom" edges to TkUserRandomExamRecode entities.
func (tquo *TkQuestionUpdateOne) RemoveUserRandDom(t ...*TkUserRandomExamRecode) *TkQuestionUpdateOne {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tquo.RemoveUserRandDomIDs(ids...)
}

// ClearAnswerOptions clears all "answer_options" edges to the TkQuestionAnswerOption entity.
func (tquo *TkQuestionUpdateOne) ClearAnswerOptions() *TkQuestionUpdateOne {
	tquo.mutation.ClearAnswerOptions()
	return tquo
}

// RemoveAnswerOptionIDs removes the "answer_options" edge to TkQuestionAnswerOption entities by IDs.
func (tquo *TkQuestionUpdateOne) RemoveAnswerOptionIDs(ids ...int) *TkQuestionUpdateOne {
	tquo.mutation.RemoveAnswerOptionIDs(ids...)
	return tquo
}

// RemoveAnswerOptions removes "answer_options" edges to TkQuestionAnswerOption entities.
func (tquo *TkQuestionUpdateOne) RemoveAnswerOptions(t ...*TkQuestionAnswerOption) *TkQuestionUpdateOne {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tquo.RemoveAnswerOptionIDs(ids...)
}

// ClearKnowledgePoints clears all "knowledge_points" edges to the TkKnowledgePoint entity.
func (tquo *TkQuestionUpdateOne) ClearKnowledgePoints() *TkQuestionUpdateOne {
	tquo.mutation.ClearKnowledgePoints()
	return tquo
}

// RemoveKnowledgePointIDs removes the "knowledge_points" edge to TkKnowledgePoint entities by IDs.
func (tquo *TkQuestionUpdateOne) RemoveKnowledgePointIDs(ids ...int) *TkQuestionUpdateOne {
	tquo.mutation.RemoveKnowledgePointIDs(ids...)
	return tquo
}

// RemoveKnowledgePoints removes "knowledge_points" edges to TkKnowledgePoint entities.
func (tquo *TkQuestionUpdateOne) RemoveKnowledgePoints(t ...*TkKnowledgePoint) *TkQuestionUpdateOne {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tquo.RemoveKnowledgePointIDs(ids...)
}

// ClearQuestionSectionLinks clears all "question_section_links" edges to the TkQuestionSection entity.
func (tquo *TkQuestionUpdateOne) ClearQuestionSectionLinks() *TkQuestionUpdateOne {
	tquo.mutation.ClearQuestionSectionLinks()
	return tquo
}

// RemoveQuestionSectionLinkIDs removes the "question_section_links" edge to TkQuestionSection entities by IDs.
func (tquo *TkQuestionUpdateOne) RemoveQuestionSectionLinkIDs(ids ...int) *TkQuestionUpdateOne {
	tquo.mutation.RemoveQuestionSectionLinkIDs(ids...)
	return tquo
}

// RemoveQuestionSectionLinks removes "question_section_links" edges to TkQuestionSection entities.
func (tquo *TkQuestionUpdateOne) RemoveQuestionSectionLinks(t ...*TkQuestionSection) *TkQuestionUpdateOne {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tquo.RemoveQuestionSectionLinkIDs(ids...)
}

// ClearExamPartitionQuestions clears all "exam_partition_questions" edges to the TkExamPartitionQuestionLink entity.
func (tquo *TkQuestionUpdateOne) ClearExamPartitionQuestions() *TkQuestionUpdateOne {
	tquo.mutation.ClearExamPartitionQuestions()
	return tquo
}

// RemoveExamPartitionQuestionIDs removes the "exam_partition_questions" edge to TkExamPartitionQuestionLink entities by IDs.
func (tquo *TkQuestionUpdateOne) RemoveExamPartitionQuestionIDs(ids ...int) *TkQuestionUpdateOne {
	tquo.mutation.RemoveExamPartitionQuestionIDs(ids...)
	return tquo
}

// RemoveExamPartitionQuestions removes "exam_partition_questions" edges to TkExamPartitionQuestionLink entities.
func (tquo *TkQuestionUpdateOne) RemoveExamPartitionQuestions(t ...*TkExamPartitionQuestionLink) *TkQuestionUpdateOne {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tquo.RemoveExamPartitionQuestionIDs(ids...)
}

// ClearQuestionErrorFeedbacks clears all "question_error_feedbacks" edges to the TkQuestionErrorFeedback entity.
func (tquo *TkQuestionUpdateOne) ClearQuestionErrorFeedbacks() *TkQuestionUpdateOne {
	tquo.mutation.ClearQuestionErrorFeedbacks()
	return tquo
}

// RemoveQuestionErrorFeedbackIDs removes the "question_error_feedbacks" edge to TkQuestionErrorFeedback entities by IDs.
func (tquo *TkQuestionUpdateOne) RemoveQuestionErrorFeedbackIDs(ids ...int) *TkQuestionUpdateOne {
	tquo.mutation.RemoveQuestionErrorFeedbackIDs(ids...)
	return tquo
}

// RemoveQuestionErrorFeedbacks removes "question_error_feedbacks" edges to TkQuestionErrorFeedback entities.
func (tquo *TkQuestionUpdateOne) RemoveQuestionErrorFeedbacks(t ...*TkQuestionErrorFeedback) *TkQuestionUpdateOne {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tquo.RemoveQuestionErrorFeedbackIDs(ids...)
}

// ClearUserRecords clears all "user_records" edges to the TkUserQuestionRecord entity.
func (tquo *TkQuestionUpdateOne) ClearUserRecords() *TkQuestionUpdateOne {
	tquo.mutation.ClearUserRecords()
	return tquo
}

// RemoveUserRecordIDs removes the "user_records" edge to TkUserQuestionRecord entities by IDs.
func (tquo *TkQuestionUpdateOne) RemoveUserRecordIDs(ids ...int) *TkQuestionUpdateOne {
	tquo.mutation.RemoveUserRecordIDs(ids...)
	return tquo
}

// RemoveUserRecords removes "user_records" edges to TkUserQuestionRecord entities.
func (tquo *TkQuestionUpdateOne) RemoveUserRecords(t ...*TkUserQuestionRecord) *TkQuestionUpdateOne {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tquo.RemoveUserRecordIDs(ids...)
}

// ClearSmallCategoryQuestions clears all "small_category_questions" edges to the KcSmallCategoryQuestion entity.
func (tquo *TkQuestionUpdateOne) ClearSmallCategoryQuestions() *TkQuestionUpdateOne {
	tquo.mutation.ClearSmallCategoryQuestions()
	return tquo
}

// RemoveSmallCategoryQuestionIDs removes the "small_category_questions" edge to KcSmallCategoryQuestion entities by IDs.
func (tquo *TkQuestionUpdateOne) RemoveSmallCategoryQuestionIDs(ids ...int) *TkQuestionUpdateOne {
	tquo.mutation.RemoveSmallCategoryQuestionIDs(ids...)
	return tquo
}

// RemoveSmallCategoryQuestions removes "small_category_questions" edges to KcSmallCategoryQuestion entities.
func (tquo *TkQuestionUpdateOne) RemoveSmallCategoryQuestions(k ...*KcSmallCategoryQuestion) *TkQuestionUpdateOne {
	ids := make([]int, len(k))
	for i := range k {
		ids[i] = k[i].ID
	}
	return tquo.RemoveSmallCategoryQuestionIDs(ids...)
}

// ClearUserExamQuestions clears all "user_exam_questions" edges to the TkUserSimulationTeacherMark entity.
func (tquo *TkQuestionUpdateOne) ClearUserExamQuestions() *TkQuestionUpdateOne {
	tquo.mutation.ClearUserExamQuestions()
	return tquo
}

// RemoveUserExamQuestionIDs removes the "user_exam_questions" edge to TkUserSimulationTeacherMark entities by IDs.
func (tquo *TkQuestionUpdateOne) RemoveUserExamQuestionIDs(ids ...int) *TkQuestionUpdateOne {
	tquo.mutation.RemoveUserExamQuestionIDs(ids...)
	return tquo
}

// RemoveUserExamQuestions removes "user_exam_questions" edges to TkUserSimulationTeacherMark entities.
func (tquo *TkQuestionUpdateOne) RemoveUserExamQuestions(t ...*TkUserSimulationTeacherMark) *TkQuestionUpdateOne {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tquo.RemoveUserExamQuestionIDs(ids...)
}

// ClearUserRecodeWrong clears all "user_recode_wrong" edges to the TkUserWrongQuestionRecode entity.
func (tquo *TkQuestionUpdateOne) ClearUserRecodeWrong() *TkQuestionUpdateOne {
	tquo.mutation.ClearUserRecodeWrong()
	return tquo
}

// RemoveUserRecodeWrongIDs removes the "user_recode_wrong" edge to TkUserWrongQuestionRecode entities by IDs.
func (tquo *TkQuestionUpdateOne) RemoveUserRecodeWrongIDs(ids ...int) *TkQuestionUpdateOne {
	tquo.mutation.RemoveUserRecodeWrongIDs(ids...)
	return tquo
}

// RemoveUserRecodeWrong removes "user_recode_wrong" edges to TkUserWrongQuestionRecode entities.
func (tquo *TkQuestionUpdateOne) RemoveUserRecodeWrong(t ...*TkUserWrongQuestionRecode) *TkQuestionUpdateOne {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tquo.RemoveUserRecodeWrongIDs(ids...)
}

// ClearParent clears the "parent" edge to the TkQuestion entity.
func (tquo *TkQuestionUpdateOne) ClearParent() *TkQuestionUpdateOne {
	tquo.mutation.ClearParent()
	return tquo
}

// ClearChildren clears all "children" edges to the TkQuestion entity.
func (tquo *TkQuestionUpdateOne) ClearChildren() *TkQuestionUpdateOne {
	tquo.mutation.ClearChildren()
	return tquo
}

// RemoveChildIDs removes the "children" edge to TkQuestion entities by IDs.
func (tquo *TkQuestionUpdateOne) RemoveChildIDs(ids ...int) *TkQuestionUpdateOne {
	tquo.mutation.RemoveChildIDs(ids...)
	return tquo
}

// RemoveChildren removes "children" edges to TkQuestion entities.
func (tquo *TkQuestionUpdateOne) RemoveChildren(t ...*TkQuestion) *TkQuestionUpdateOne {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tquo.RemoveChildIDs(ids...)
}

// ClearCollectionQuestion clears all "collection_question" edges to the Collection entity.
func (tquo *TkQuestionUpdateOne) ClearCollectionQuestion() *TkQuestionUpdateOne {
	tquo.mutation.ClearCollectionQuestion()
	return tquo
}

// RemoveCollectionQuestionIDs removes the "collection_question" edge to Collection entities by IDs.
func (tquo *TkQuestionUpdateOne) RemoveCollectionQuestionIDs(ids ...int) *TkQuestionUpdateOne {
	tquo.mutation.RemoveCollectionQuestionIDs(ids...)
	return tquo
}

// RemoveCollectionQuestion removes "collection_question" edges to Collection entities.
func (tquo *TkQuestionUpdateOne) RemoveCollectionQuestion(c ...*Collection) *TkQuestionUpdateOne {
	ids := make([]int, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return tquo.RemoveCollectionQuestionIDs(ids...)
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (tquo *TkQuestionUpdateOne) Select(field string, fields ...string) *TkQuestionUpdateOne {
	tquo.fields = append([]string{field}, fields...)
	return tquo
}

// Save executes the query and returns the updated TkQuestion entity.
func (tquo *TkQuestionUpdateOne) Save(ctx context.Context) (*TkQuestion, error) {
	var (
		err  error
		node *TkQuestion
	)
	tquo.defaults()
	if len(tquo.hooks) == 0 {
		node, err = tquo.sqlSave(ctx)
	} else {
		var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
			mutation, ok := m.(*TkQuestionMutation)
			if !ok {
				return nil, fmt.Errorf("unexpected mutation type %T", m)
			}
			tquo.mutation = mutation
			node, err = tquo.sqlSave(ctx)
			mutation.done = true
			return node, err
		})
		for i := len(tquo.hooks) - 1; i >= 0; i-- {
			mut = tquo.hooks[i](mut)
		}
		if _, err := mut.Mutate(ctx, tquo.mutation); err != nil {
			return nil, err
		}
	}
	return node, err
}

// SaveX is like Save, but panics if an error occurs.
func (tquo *TkQuestionUpdateOne) SaveX(ctx context.Context) *TkQuestion {
	node, err := tquo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (tquo *TkQuestionUpdateOne) Exec(ctx context.Context) error {
	_, err := tquo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (tquo *TkQuestionUpdateOne) ExecX(ctx context.Context) {
	if err := tquo.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (tquo *TkQuestionUpdateOne) defaults() {
	if _, ok := tquo.mutation.UpdatedAt(); !ok && !tquo.mutation.UpdatedAtCleared() {
		v := tkquestion.UpdateDefaultUpdatedAt()
		tquo.mutation.SetUpdatedAt(v)
	}
}

func (tquo *TkQuestionUpdateOne) sqlSave(ctx context.Context) (_node *TkQuestion, err error) {
	_spec := &sqlgraph.UpdateSpec{
		Node: &sqlgraph.NodeSpec{
			Table:   tkquestion.Table,
			Columns: tkquestion.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeInt,
				Column: tkquestion.FieldID,
			},
		},
	}
	id, ok := tquo.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "ID", err: fmt.Errorf("missing TkQuestion.ID for update")}
	}
	_spec.Node.ID.Value = id
	if fields := tquo.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, tkquestion.FieldID)
		for _, f := range fields {
			if !tkquestion.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
			}
			if f != tkquestion.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := tquo.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := tquo.mutation.UUID(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: tkquestion.FieldUUID,
		})
	}
	if tquo.mutation.CreatedAtCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Column: tkquestion.FieldCreatedAt,
		})
	}
	if value, ok := tquo.mutation.UpdatedAt(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: tkquestion.FieldUpdatedAt,
		})
	}
	if tquo.mutation.UpdatedAtCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Column: tkquestion.FieldUpdatedAt,
		})
	}
	if value, ok := tquo.mutation.DeletedAt(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: tkquestion.FieldDeletedAt,
		})
	}
	if tquo.mutation.DeletedAtCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Column: tkquestion.FieldDeletedAt,
		})
	}
	if value, ok := tquo.mutation.Name(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: tkquestion.FieldName,
		})
	}
	if tquo.mutation.NameCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: tkquestion.FieldName,
		})
	}
	if value, ok := tquo.mutation.Difficulty(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeUint8,
			Value:  value,
			Column: tkquestion.FieldDifficulty,
		})
	}
	if value, ok := tquo.mutation.AddedDifficulty(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeUint8,
			Value:  value,
			Column: tkquestion.FieldDifficulty,
		})
	}
	if value, ok := tquo.mutation.GetType(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeUint8,
			Value:  value,
			Column: tkquestion.FieldType,
		})
	}
	if value, ok := tquo.mutation.AddedType(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeUint8,
			Value:  value,
			Column: tkquestion.FieldType,
		})
	}
	if value, ok := tquo.mutation.Desc(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: tkquestion.FieldDesc,
		})
	}
	if tquo.mutation.DescCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: tkquestion.FieldDesc,
		})
	}
	if value, ok := tquo.mutation.AnswerCount(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Value:  value,
			Column: tkquestion.FieldAnswerCount,
		})
	}
	if value, ok := tquo.mutation.AddedAnswerCount(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Value:  value,
			Column: tkquestion.FieldAnswerCount,
		})
	}
	if value, ok := tquo.mutation.RightCount(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Value:  value,
			Column: tkquestion.FieldRightCount,
		})
	}
	if value, ok := tquo.mutation.AddedRightCount(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Value:  value,
			Column: tkquestion.FieldRightCount,
		})
	}
	if tquo.mutation.QuestionBankCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   tkquestion.QuestionBankTable,
			Columns: []string{tkquestion.QuestionBankColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkquestionbank.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tquo.mutation.QuestionBankIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   tkquestion.QuestionBankTable,
			Columns: []string{tkquestion.QuestionBankColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkquestionbank.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if tquo.mutation.AdminCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   tkquestion.AdminTable,
			Columns: []string{tkquestion.AdminColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: admin.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tquo.mutation.AdminIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   tkquestion.AdminTable,
			Columns: []string{tkquestion.AdminColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: admin.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if tquo.mutation.UserRandDomCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   tkquestion.UserRandDomTable,
			Columns: tkquestion.UserRandDomPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkuserrandomexamrecode.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tquo.mutation.RemovedUserRandDomIDs(); len(nodes) > 0 && !tquo.mutation.UserRandDomCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   tkquestion.UserRandDomTable,
			Columns: tkquestion.UserRandDomPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkuserrandomexamrecode.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tquo.mutation.UserRandDomIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   tkquestion.UserRandDomTable,
			Columns: tkquestion.UserRandDomPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkuserrandomexamrecode.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if tquo.mutation.AnswerOptionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.AnswerOptionsTable,
			Columns: []string{tkquestion.AnswerOptionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkquestionansweroption.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tquo.mutation.RemovedAnswerOptionsIDs(); len(nodes) > 0 && !tquo.mutation.AnswerOptionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.AnswerOptionsTable,
			Columns: []string{tkquestion.AnswerOptionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkquestionansweroption.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tquo.mutation.AnswerOptionsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.AnswerOptionsTable,
			Columns: []string{tkquestion.AnswerOptionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkquestionansweroption.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if tquo.mutation.KnowledgePointsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   tkquestion.KnowledgePointsTable,
			Columns: tkquestion.KnowledgePointsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkknowledgepoint.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tquo.mutation.RemovedKnowledgePointsIDs(); len(nodes) > 0 && !tquo.mutation.KnowledgePointsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   tkquestion.KnowledgePointsTable,
			Columns: tkquestion.KnowledgePointsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkknowledgepoint.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tquo.mutation.KnowledgePointsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   tkquestion.KnowledgePointsTable,
			Columns: tkquestion.KnowledgePointsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkknowledgepoint.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if tquo.mutation.QuestionSectionLinksCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.QuestionSectionLinksTable,
			Columns: []string{tkquestion.QuestionSectionLinksColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkquestionsection.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tquo.mutation.RemovedQuestionSectionLinksIDs(); len(nodes) > 0 && !tquo.mutation.QuestionSectionLinksCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.QuestionSectionLinksTable,
			Columns: []string{tkquestion.QuestionSectionLinksColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkquestionsection.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tquo.mutation.QuestionSectionLinksIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.QuestionSectionLinksTable,
			Columns: []string{tkquestion.QuestionSectionLinksColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkquestionsection.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if tquo.mutation.ExamPartitionQuestionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.ExamPartitionQuestionsTable,
			Columns: []string{tkquestion.ExamPartitionQuestionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkexampartitionquestionlink.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tquo.mutation.RemovedExamPartitionQuestionsIDs(); len(nodes) > 0 && !tquo.mutation.ExamPartitionQuestionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.ExamPartitionQuestionsTable,
			Columns: []string{tkquestion.ExamPartitionQuestionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkexampartitionquestionlink.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tquo.mutation.ExamPartitionQuestionsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.ExamPartitionQuestionsTable,
			Columns: []string{tkquestion.ExamPartitionQuestionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkexampartitionquestionlink.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if tquo.mutation.QuestionErrorFeedbacksCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.QuestionErrorFeedbacksTable,
			Columns: []string{tkquestion.QuestionErrorFeedbacksColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkquestionerrorfeedback.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tquo.mutation.RemovedQuestionErrorFeedbacksIDs(); len(nodes) > 0 && !tquo.mutation.QuestionErrorFeedbacksCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.QuestionErrorFeedbacksTable,
			Columns: []string{tkquestion.QuestionErrorFeedbacksColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkquestionerrorfeedback.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tquo.mutation.QuestionErrorFeedbacksIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.QuestionErrorFeedbacksTable,
			Columns: []string{tkquestion.QuestionErrorFeedbacksColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkquestionerrorfeedback.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if tquo.mutation.UserRecordsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.UserRecordsTable,
			Columns: []string{tkquestion.UserRecordsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkuserquestionrecord.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tquo.mutation.RemovedUserRecordsIDs(); len(nodes) > 0 && !tquo.mutation.UserRecordsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.UserRecordsTable,
			Columns: []string{tkquestion.UserRecordsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkuserquestionrecord.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tquo.mutation.UserRecordsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.UserRecordsTable,
			Columns: []string{tkquestion.UserRecordsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkuserquestionrecord.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if tquo.mutation.SmallCategoryQuestionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.SmallCategoryQuestionsTable,
			Columns: []string{tkquestion.SmallCategoryQuestionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: kcsmallcategoryquestion.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tquo.mutation.RemovedSmallCategoryQuestionsIDs(); len(nodes) > 0 && !tquo.mutation.SmallCategoryQuestionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.SmallCategoryQuestionsTable,
			Columns: []string{tkquestion.SmallCategoryQuestionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: kcsmallcategoryquestion.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tquo.mutation.SmallCategoryQuestionsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.SmallCategoryQuestionsTable,
			Columns: []string{tkquestion.SmallCategoryQuestionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: kcsmallcategoryquestion.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if tquo.mutation.UserExamQuestionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.UserExamQuestionsTable,
			Columns: []string{tkquestion.UserExamQuestionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkusersimulationteachermark.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tquo.mutation.RemovedUserExamQuestionsIDs(); len(nodes) > 0 && !tquo.mutation.UserExamQuestionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.UserExamQuestionsTable,
			Columns: []string{tkquestion.UserExamQuestionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkusersimulationteachermark.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tquo.mutation.UserExamQuestionsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.UserExamQuestionsTable,
			Columns: []string{tkquestion.UserExamQuestionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkusersimulationteachermark.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if tquo.mutation.UserRecodeWrongCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.UserRecodeWrongTable,
			Columns: []string{tkquestion.UserRecodeWrongColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkuserwrongquestionrecode.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tquo.mutation.RemovedUserRecodeWrongIDs(); len(nodes) > 0 && !tquo.mutation.UserRecodeWrongCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.UserRecodeWrongTable,
			Columns: []string{tkquestion.UserRecodeWrongColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkuserwrongquestionrecode.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tquo.mutation.UserRecodeWrongIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.UserRecodeWrongTable,
			Columns: []string{tkquestion.UserRecodeWrongColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkuserwrongquestionrecode.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if tquo.mutation.ParentCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   tkquestion.ParentTable,
			Columns: []string{tkquestion.ParentColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkquestion.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tquo.mutation.ParentIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   tkquestion.ParentTable,
			Columns: []string{tkquestion.ParentColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkquestion.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if tquo.mutation.ChildrenCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.ChildrenTable,
			Columns: []string{tkquestion.ChildrenColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkquestion.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tquo.mutation.RemovedChildrenIDs(); len(nodes) > 0 && !tquo.mutation.ChildrenCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.ChildrenTable,
			Columns: []string{tkquestion.ChildrenColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkquestion.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tquo.mutation.ChildrenIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.ChildrenTable,
			Columns: []string{tkquestion.ChildrenColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkquestion.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if tquo.mutation.CollectionQuestionCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.CollectionQuestionTable,
			Columns: []string{tkquestion.CollectionQuestionColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: collection.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tquo.mutation.RemovedCollectionQuestionIDs(); len(nodes) > 0 && !tquo.mutation.CollectionQuestionCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.CollectionQuestionTable,
			Columns: []string{tkquestion.CollectionQuestionColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: collection.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tquo.mutation.CollectionQuestionIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tkquestion.CollectionQuestionTable,
			Columns: []string{tkquestion.CollectionQuestionColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: collection.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_node = &TkQuestion{config: tquo.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, tquo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{tkquestion.Label}
		} else if cerr, ok := isSQLConstraintError(err); ok {
			err = cerr
		}
		return nil, err
	}
	return _node, nil
}
