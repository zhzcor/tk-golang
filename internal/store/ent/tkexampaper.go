// Code generated by entc, DO NOT EDIT.

package ent

import (
	"fmt"
	"strings"
	"time"
	"tkserver/internal/store/ent/admin"
	"tkserver/internal/store/ent/tkexampaper"
	"tkserver/internal/store/ent/tkquestionbank"

	"entgo.io/ent/dialect/sql"
)

// TkExamPaper is the model entity for the TkExamPaper schema.
type TkExamPaper struct {
	config `json:"-"`
	// ID of the ent.
	ID int `json:"id,omitempty"`
	// UUID holds the value of the "uuid" field.
	UUID string `json:"uuid"`
	// CreatedAt holds the value of the "created_at" field.
	CreatedAt *time.Time `json:"created_at"`
	// UpdatedAt holds the value of the "updated_at" field.
	UpdatedAt *time.Time `json:"updated_at"`
	// DeletedAt holds the value of the "deleted_at" field.
	DeletedAt *time.Time `json:"deleted_at"`
	// Name holds the value of the "name" field.
	// 试卷名称
	Name string `json:"name"`
	// Desc holds the value of the "desc" field.
	// 试卷描述
	Desc string `json:"desc"`
	// ExamQuestionType holds the value of the "exam_question_type" field.
	// 试卷题目分类，1：模拟考试，2：章节练习，3：历年真题，4：通关必做300题，5：考前密押卷
	ExamQuestionType uint8 `json:"exam_question_type"`
	// ExamType holds the value of the "exam_type" field.
	// 考试类型，1：固定卷，2：随机卷
	ExamType uint8 `json:"exam_type"`
	// Difficulty holds the value of the "difficulty" field.
	// 难易度，1：易，2：较易，3：较难，4：难，5：一般
	Difficulty uint8 `json:"difficulty"`
	// QuestionCount holds the value of the "question_count" field.
	// 总题数
	QuestionCount int `json:"question_count"`
	// AnsweredUserCount holds the value of the "answered_user_count" field.
	// 总答题人数
	AnsweredUserCount int `json:"answered_user_count"`
	// Score holds the value of the "score" field.
	// 总分数
	Score int `json:"score"`
	// PassScore holds the value of the "pass_score" field.
	// 通过分数
	PassScore int `json:"pass_score"`
	// Duration holds the value of the "duration" field.
	// 总时长
	Duration int `json:"duration"`
	// DurationType holds the value of the "duration_type" field.
	// 1:按照作答时间计时,2:设置试卷的答题时间
	DurationType int `json:"duration_type"`
	// StartAt holds the value of the "start_at" field.
	// 模拟考试开始时间
	StartAt time.Time `json:"start_at"`
	// EndAt holds the value of the "end_at" field.
	// 模拟考试结束时间
	EndAt time.Time `json:"end_at"`
	// EnableStatus holds the value of the "enable_status" field.
	// 启用状态 1：启用，2：未启用
	EnableStatus uint8 `json:"enable_status"`
	// CreatedAdminID holds the value of the "created_admin_id" field.
	// 创建人id
	CreatedAdminID int `json:"created_admin_id"`
	// QuestionBankID holds the value of the "question_bank_id" field.
	// 题库id
	QuestionBankID int `json:"question_bank_id"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the TkExamPaperQuery when eager-loading is set.
	Edges TkExamPaperEdges `json:"edges"`
}

// TkExamPaperEdges holds the relations/edges for other nodes in the graph.
type TkExamPaperEdges struct {
	// QuestionBank holds the value of the question_bank edge.
	QuestionBank *TkQuestionBank `json:"question_bank,omitempty"`
	// Admin holds the value of the admin edge.
	Admin *Admin `json:"admin,omitempty"`
	// ExamPartitions holds the value of the exam_partitions edge.
	ExamPartitions []*TkExamPaperPartition `json:"exam_partitions,omitempty"`
	// MakeUserQuestionExam holds the value of the make_user_question_exam edge.
	MakeUserQuestionExam []*MakeUserQuestionRecord `json:"make_user_question_exam,omitempty"`
	// UserExamPapers holds the value of the user_exam_papers edge.
	UserExamPapers []*TkUserExamScoreRecord `json:"user_exam_papers,omitempty"`
	// CourseExamPapers holds the value of the course_exam_papers edge.
	CourseExamPapers []*KcSmallCategoryExamPaper `json:"course_exam_papers,omitempty"`
	// ExamPaperRecords holds the value of the exam_paper_records edge.
	ExamPaperRecords []*TkUserQuestionRecord `json:"exam_paper_records,omitempty"`
	// UserRandomExam holds the value of the user_random_exam edge.
	UserRandomExam []*TkUserRandomExamRecode `json:"user_random_exam,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [8]bool
}

// QuestionBankOrErr returns the QuestionBank value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e TkExamPaperEdges) QuestionBankOrErr() (*TkQuestionBank, error) {
	if e.loadedTypes[0] {
		if e.QuestionBank == nil {
			// The edge question_bank was loaded in eager-loading,
			// but was not found.
			return nil, &NotFoundError{label: tkquestionbank.Label}
		}
		return e.QuestionBank, nil
	}
	return nil, &NotLoadedError{edge: "question_bank"}
}

// AdminOrErr returns the Admin value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e TkExamPaperEdges) AdminOrErr() (*Admin, error) {
	if e.loadedTypes[1] {
		if e.Admin == nil {
			// The edge admin was loaded in eager-loading,
			// but was not found.
			return nil, &NotFoundError{label: admin.Label}
		}
		return e.Admin, nil
	}
	return nil, &NotLoadedError{edge: "admin"}
}

// ExamPartitionsOrErr returns the ExamPartitions value or an error if the edge
// was not loaded in eager-loading.
func (e TkExamPaperEdges) ExamPartitionsOrErr() ([]*TkExamPaperPartition, error) {
	if e.loadedTypes[2] {
		return e.ExamPartitions, nil
	}
	return nil, &NotLoadedError{edge: "exam_partitions"}
}

// MakeUserQuestionExamOrErr returns the MakeUserQuestionExam value or an error if the edge
// was not loaded in eager-loading.
func (e TkExamPaperEdges) MakeUserQuestionExamOrErr() ([]*MakeUserQuestionRecord, error) {
	if e.loadedTypes[3] {
		return e.MakeUserQuestionExam, nil
	}
	return nil, &NotLoadedError{edge: "make_user_question_exam"}
}

// UserExamPapersOrErr returns the UserExamPapers value or an error if the edge
// was not loaded in eager-loading.
func (e TkExamPaperEdges) UserExamPapersOrErr() ([]*TkUserExamScoreRecord, error) {
	if e.loadedTypes[4] {
		return e.UserExamPapers, nil
	}
	return nil, &NotLoadedError{edge: "user_exam_papers"}
}

// CourseExamPapersOrErr returns the CourseExamPapers value or an error if the edge
// was not loaded in eager-loading.
func (e TkExamPaperEdges) CourseExamPapersOrErr() ([]*KcSmallCategoryExamPaper, error) {
	if e.loadedTypes[5] {
		return e.CourseExamPapers, nil
	}
	return nil, &NotLoadedError{edge: "course_exam_papers"}
}

// ExamPaperRecordsOrErr returns the ExamPaperRecords value or an error if the edge
// was not loaded in eager-loading.
func (e TkExamPaperEdges) ExamPaperRecordsOrErr() ([]*TkUserQuestionRecord, error) {
	if e.loadedTypes[6] {
		return e.ExamPaperRecords, nil
	}
	return nil, &NotLoadedError{edge: "exam_paper_records"}
}

// UserRandomExamOrErr returns the UserRandomExam value or an error if the edge
// was not loaded in eager-loading.
func (e TkExamPaperEdges) UserRandomExamOrErr() ([]*TkUserRandomExamRecode, error) {
	if e.loadedTypes[7] {
		return e.UserRandomExam, nil
	}
	return nil, &NotLoadedError{edge: "user_random_exam"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*TkExamPaper) scanValues(columns []string) ([]interface{}, error) {
	values := make([]interface{}, len(columns))
	for i := range columns {
		switch columns[i] {
		case tkexampaper.FieldID, tkexampaper.FieldExamQuestionType, tkexampaper.FieldExamType, tkexampaper.FieldDifficulty, tkexampaper.FieldQuestionCount, tkexampaper.FieldAnsweredUserCount, tkexampaper.FieldScore, tkexampaper.FieldPassScore, tkexampaper.FieldDuration, tkexampaper.FieldDurationType, tkexampaper.FieldEnableStatus, tkexampaper.FieldCreatedAdminID, tkexampaper.FieldQuestionBankID:
			values[i] = new(sql.NullInt64)
		case tkexampaper.FieldUUID, tkexampaper.FieldName, tkexampaper.FieldDesc:
			values[i] = new(sql.NullString)
		case tkexampaper.FieldCreatedAt, tkexampaper.FieldUpdatedAt, tkexampaper.FieldDeletedAt, tkexampaper.FieldStartAt, tkexampaper.FieldEndAt:
			values[i] = new(sql.NullTime)
		default:
			return nil, fmt.Errorf("unexpected column %q for type TkExamPaper", columns[i])
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the TkExamPaper fields.
func (tep *TkExamPaper) assignValues(columns []string, values []interface{}) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case tkexampaper.FieldID:
			value, ok := values[i].(*sql.NullInt64)
			if !ok {
				return fmt.Errorf("unexpected type %T for field id", value)
			}
			tep.ID = int(value.Int64)
		case tkexampaper.FieldUUID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field uuid", values[i])
			} else if value.Valid {
				tep.UUID = value.String
			}
		case tkexampaper.FieldCreatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field created_at", values[i])
			} else if value.Valid {
				tep.CreatedAt = new(time.Time)
				*tep.CreatedAt = value.Time
			}
		case tkexampaper.FieldUpdatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field updated_at", values[i])
			} else if value.Valid {
				tep.UpdatedAt = new(time.Time)
				*tep.UpdatedAt = value.Time
			}
		case tkexampaper.FieldDeletedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field deleted_at", values[i])
			} else if value.Valid {
				tep.DeletedAt = new(time.Time)
				*tep.DeletedAt = value.Time
			}
		case tkexampaper.FieldName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field name", values[i])
			} else if value.Valid {
				tep.Name = value.String
			}
		case tkexampaper.FieldDesc:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field desc", values[i])
			} else if value.Valid {
				tep.Desc = value.String
			}
		case tkexampaper.FieldExamQuestionType:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field exam_question_type", values[i])
			} else if value.Valid {
				tep.ExamQuestionType = uint8(value.Int64)
			}
		case tkexampaper.FieldExamType:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field exam_type", values[i])
			} else if value.Valid {
				tep.ExamType = uint8(value.Int64)
			}
		case tkexampaper.FieldDifficulty:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field difficulty", values[i])
			} else if value.Valid {
				tep.Difficulty = uint8(value.Int64)
			}
		case tkexampaper.FieldQuestionCount:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field question_count", values[i])
			} else if value.Valid {
				tep.QuestionCount = int(value.Int64)
			}
		case tkexampaper.FieldAnsweredUserCount:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field answered_user_count", values[i])
			} else if value.Valid {
				tep.AnsweredUserCount = int(value.Int64)
			}
		case tkexampaper.FieldScore:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field score", values[i])
			} else if value.Valid {
				tep.Score = int(value.Int64)
			}
		case tkexampaper.FieldPassScore:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field pass_score", values[i])
			} else if value.Valid {
				tep.PassScore = int(value.Int64)
			}
		case tkexampaper.FieldDuration:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field duration", values[i])
			} else if value.Valid {
				tep.Duration = int(value.Int64)
			}
		case tkexampaper.FieldDurationType:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field duration_type", values[i])
			} else if value.Valid {
				tep.DurationType = int(value.Int64)
			}
		case tkexampaper.FieldStartAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field start_at", values[i])
			} else if value.Valid {
				tep.StartAt = value.Time
			}
		case tkexampaper.FieldEndAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field end_at", values[i])
			} else if value.Valid {
				tep.EndAt = value.Time
			}
		case tkexampaper.FieldEnableStatus:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field enable_status", values[i])
			} else if value.Valid {
				tep.EnableStatus = uint8(value.Int64)
			}
		case tkexampaper.FieldCreatedAdminID:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field created_admin_id", values[i])
			} else if value.Valid {
				tep.CreatedAdminID = int(value.Int64)
			}
		case tkexampaper.FieldQuestionBankID:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field question_bank_id", values[i])
			} else if value.Valid {
				tep.QuestionBankID = int(value.Int64)
			}
		}
	}
	return nil
}

// QueryQuestionBank queries the "question_bank" edge of the TkExamPaper entity.
func (tep *TkExamPaper) QueryQuestionBank() *TkQuestionBankQuery {
	return (&TkExamPaperClient{config: tep.config}).QueryQuestionBank(tep)
}

// QueryAdmin queries the "admin" edge of the TkExamPaper entity.
func (tep *TkExamPaper) QueryAdmin() *AdminQuery {
	return (&TkExamPaperClient{config: tep.config}).QueryAdmin(tep)
}

// QueryExamPartitions queries the "exam_partitions" edge of the TkExamPaper entity.
func (tep *TkExamPaper) QueryExamPartitions() *TkExamPaperPartitionQuery {
	return (&TkExamPaperClient{config: tep.config}).QueryExamPartitions(tep)
}

// QueryMakeUserQuestionExam queries the "make_user_question_exam" edge of the TkExamPaper entity.
func (tep *TkExamPaper) QueryMakeUserQuestionExam() *MakeUserQuestionRecordQuery {
	return (&TkExamPaperClient{config: tep.config}).QueryMakeUserQuestionExam(tep)
}

// QueryUserExamPapers queries the "user_exam_papers" edge of the TkExamPaper entity.
func (tep *TkExamPaper) QueryUserExamPapers() *TkUserExamScoreRecordQuery {
	return (&TkExamPaperClient{config: tep.config}).QueryUserExamPapers(tep)
}

// QueryCourseExamPapers queries the "course_exam_papers" edge of the TkExamPaper entity.
func (tep *TkExamPaper) QueryCourseExamPapers() *KcSmallCategoryExamPaperQuery {
	return (&TkExamPaperClient{config: tep.config}).QueryCourseExamPapers(tep)
}

// QueryExamPaperRecords queries the "exam_paper_records" edge of the TkExamPaper entity.
func (tep *TkExamPaper) QueryExamPaperRecords() *TkUserQuestionRecordQuery {
	return (&TkExamPaperClient{config: tep.config}).QueryExamPaperRecords(tep)
}

// QueryUserRandomExam queries the "user_random_exam" edge of the TkExamPaper entity.
func (tep *TkExamPaper) QueryUserRandomExam() *TkUserRandomExamRecodeQuery {
	return (&TkExamPaperClient{config: tep.config}).QueryUserRandomExam(tep)
}

// Update returns a builder for updating this TkExamPaper.
// Note that you need to call TkExamPaper.Unwrap() before calling this method if this TkExamPaper
// was returned from a transaction, and the transaction was committed or rolled back.
func (tep *TkExamPaper) Update() *TkExamPaperUpdateOne {
	return (&TkExamPaperClient{config: tep.config}).UpdateOne(tep)
}

// Unwrap unwraps the TkExamPaper entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (tep *TkExamPaper) Unwrap() *TkExamPaper {
	tx, ok := tep.config.driver.(*txDriver)
	if !ok {
		panic("ent: TkExamPaper is not a transactional entity")
	}
	tep.config.driver = tx.drv
	return tep
}

// String implements the fmt.Stringer.
func (tep *TkExamPaper) String() string {
	var builder strings.Builder
	builder.WriteString("TkExamPaper(")
	builder.WriteString(fmt.Sprintf("id=%v", tep.ID))
	builder.WriteString(", uuid=")
	builder.WriteString(tep.UUID)
	if v := tep.CreatedAt; v != nil {
		builder.WriteString(", created_at=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	if v := tep.UpdatedAt; v != nil {
		builder.WriteString(", updated_at=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	if v := tep.DeletedAt; v != nil {
		builder.WriteString(", deleted_at=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteString(", name=")
	builder.WriteString(tep.Name)
	builder.WriteString(", desc=")
	builder.WriteString(tep.Desc)
	builder.WriteString(", exam_question_type=")
	builder.WriteString(fmt.Sprintf("%v", tep.ExamQuestionType))
	builder.WriteString(", exam_type=")
	builder.WriteString(fmt.Sprintf("%v", tep.ExamType))
	builder.WriteString(", difficulty=")
	builder.WriteString(fmt.Sprintf("%v", tep.Difficulty))
	builder.WriteString(", question_count=")
	builder.WriteString(fmt.Sprintf("%v", tep.QuestionCount))
	builder.WriteString(", answered_user_count=")
	builder.WriteString(fmt.Sprintf("%v", tep.AnsweredUserCount))
	builder.WriteString(", score=")
	builder.WriteString(fmt.Sprintf("%v", tep.Score))
	builder.WriteString(", pass_score=")
	builder.WriteString(fmt.Sprintf("%v", tep.PassScore))
	builder.WriteString(", duration=")
	builder.WriteString(fmt.Sprintf("%v", tep.Duration))
	builder.WriteString(", duration_type=")
	builder.WriteString(fmt.Sprintf("%v", tep.DurationType))
	builder.WriteString(", start_at=")
	builder.WriteString(tep.StartAt.Format(time.ANSIC))
	builder.WriteString(", end_at=")
	builder.WriteString(tep.EndAt.Format(time.ANSIC))
	builder.WriteString(", enable_status=")
	builder.WriteString(fmt.Sprintf("%v", tep.EnableStatus))
	builder.WriteString(", created_admin_id=")
	builder.WriteString(fmt.Sprintf("%v", tep.CreatedAdminID))
	builder.WriteString(", question_bank_id=")
	builder.WriteString(fmt.Sprintf("%v", tep.QuestionBankID))
	builder.WriteByte(')')
	return builder.String()
}

// TkExamPapers is a parsable slice of TkExamPaper.
type TkExamPapers []*TkExamPaper

func (tep TkExamPapers) config(cfg config) {
	for _i := range tep {
		tep[_i].config = cfg
	}
}
