// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"gserver/internal/store/ent/admin"
	"gserver/internal/store/ent/attachment"
	"gserver/internal/store/ent/city"
	"gserver/internal/store/ent/itemcategory"
	"gserver/internal/store/ent/kcclass"
	"gserver/internal/store/ent/kccourse"
	"gserver/internal/store/ent/kccoursechapter"
	"gserver/internal/store/ent/kccoursesmallcategory"
	"gserver/internal/store/ent/kccourseteacher"
	"gserver/internal/store/ent/kcusercourse"
	"gserver/internal/store/ent/major"
	"gserver/internal/store/ent/message"
	"gserver/internal/store/ent/tkquestionbank"
	"gserver/internal/store/ent/usercourseappraise"
	"time"

	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
)

// KcCourseCreate is the builder for creating a KcCourse entity.
type KcCourseCreate struct {
	config
	mutation *KcCourseMutation
	hooks    []Hook
}

// SetUUID sets the "uuid" field.
func (kcc *KcCourseCreate) SetUUID(s string) *KcCourseCreate {
	kcc.mutation.SetUUID(s)
	return kcc
}

// SetCreatedAt sets the "created_at" field.
func (kcc *KcCourseCreate) SetCreatedAt(t time.Time) *KcCourseCreate {
	kcc.mutation.SetCreatedAt(t)
	return kcc
}

// SetNillableCreatedAt sets the "created_at" field if the given value is not nil.
func (kcc *KcCourseCreate) SetNillableCreatedAt(t *time.Time) *KcCourseCreate {
	if t != nil {
		kcc.SetCreatedAt(*t)
	}
	return kcc
}

// SetUpdatedAt sets the "updated_at" field.
func (kcc *KcCourseCreate) SetUpdatedAt(t time.Time) *KcCourseCreate {
	kcc.mutation.SetUpdatedAt(t)
	return kcc
}

// SetNillableUpdatedAt sets the "updated_at" field if the given value is not nil.
func (kcc *KcCourseCreate) SetNillableUpdatedAt(t *time.Time) *KcCourseCreate {
	if t != nil {
		kcc.SetUpdatedAt(*t)
	}
	return kcc
}

// SetDeletedAt sets the "deleted_at" field.
func (kcc *KcCourseCreate) SetDeletedAt(t time.Time) *KcCourseCreate {
	kcc.mutation.SetDeletedAt(t)
	return kcc
}

// SetNillableDeletedAt sets the "deleted_at" field if the given value is not nil.
func (kcc *KcCourseCreate) SetNillableDeletedAt(t *time.Time) *KcCourseCreate {
	if t != nil {
		kcc.SetDeletedAt(*t)
	}
	return kcc
}

// SetCourseName sets the "course_name" field.
func (kcc *KcCourseCreate) SetCourseName(s string) *KcCourseCreate {
	kcc.mutation.SetCourseName(s)
	return kcc
}

// SetNillableCourseName sets the "course_name" field if the given value is not nil.
func (kcc *KcCourseCreate) SetNillableCourseName(s *string) *KcCourseCreate {
	if s != nil {
		kcc.SetCourseName(*s)
	}
	return kcc
}

// SetCourseType sets the "course_type" field.
func (kcc *KcCourseCreate) SetCourseType(u uint8) *KcCourseCreate {
	kcc.mutation.SetCourseType(u)
	return kcc
}

// SetNillableCourseType sets the "course_type" field if the given value is not nil.
func (kcc *KcCourseCreate) SetNillableCourseType(u *uint8) *KcCourseCreate {
	if u != nil {
		kcc.SetCourseType(*u)
	}
	return kcc
}

// SetPeopleNum sets the "people_num" field.
func (kcc *KcCourseCreate) SetPeopleNum(i int) *KcCourseCreate {
	kcc.mutation.SetPeopleNum(i)
	return kcc
}

// SetNillablePeopleNum sets the "people_num" field if the given value is not nil.
func (kcc *KcCourseCreate) SetNillablePeopleNum(i *int) *KcCourseCreate {
	if i != nil {
		kcc.SetPeopleNum(*i)
	}
	return kcc
}

// SetCoursePrice sets the "course_price" field.
func (kcc *KcCourseCreate) SetCoursePrice(f float64) *KcCourseCreate {
	kcc.mutation.SetCoursePrice(f)
	return kcc
}

// SetNillableCoursePrice sets the "course_price" field if the given value is not nil.
func (kcc *KcCourseCreate) SetNillableCoursePrice(f *float64) *KcCourseCreate {
	if f != nil {
		kcc.SetCoursePrice(*f)
	}
	return kcc
}

// SetCourseDesc sets the "course_desc" field.
func (kcc *KcCourseCreate) SetCourseDesc(s string) *KcCourseCreate {
	kcc.mutation.SetCourseDesc(s)
	return kcc
}

// SetNillableCourseDesc sets the "course_desc" field if the given value is not nil.
func (kcc *KcCourseCreate) SetNillableCourseDesc(s *string) *KcCourseCreate {
	if s != nil {
		kcc.SetCourseDesc(*s)
	}
	return kcc
}

// SetPushStatus sets the "push_status" field.
func (kcc *KcCourseCreate) SetPushStatus(u uint8) *KcCourseCreate {
	kcc.mutation.SetPushStatus(u)
	return kcc
}

// SetNillablePushStatus sets the "push_status" field if the given value is not nil.
func (kcc *KcCourseCreate) SetNillablePushStatus(u *uint8) *KcCourseCreate {
	if u != nil {
		kcc.SetPushStatus(*u)
	}
	return kcc
}

// SetCateID sets the "cate_id" field.
func (kcc *KcCourseCreate) SetCateID(i int) *KcCourseCreate {
	kcc.mutation.SetCateID(i)
	return kcc
}

// SetNillableCateID sets the "cate_id" field if the given value is not nil.
func (kcc *KcCourseCreate) SetNillableCateID(i *int) *KcCourseCreate {
	if i != nil {
		kcc.SetCateID(*i)
	}
	return kcc
}

// SetCityID sets the "city_id" field.
func (kcc *KcCourseCreate) SetCityID(i int) *KcCourseCreate {
	kcc.mutation.SetCityID(i)
	return kcc
}

// SetNillableCityID sets the "city_id" field if the given value is not nil.
func (kcc *KcCourseCreate) SetNillableCityID(i *int) *KcCourseCreate {
	if i != nil {
		kcc.SetCityID(*i)
	}
	return kcc
}

// SetQuestionBankID sets the "question_bank_id" field.
func (kcc *KcCourseCreate) SetQuestionBankID(i int) *KcCourseCreate {
	kcc.mutation.SetQuestionBankID(i)
	return kcc
}

// SetNillableQuestionBankID sets the "question_bank_id" field if the given value is not nil.
func (kcc *KcCourseCreate) SetNillableQuestionBankID(i *int) *KcCourseCreate {
	if i != nil {
		kcc.SetQuestionBankID(*i)
	}
	return kcc
}

// SetCourseCoverImgID sets the "course_cover_img_id" field.
func (kcc *KcCourseCreate) SetCourseCoverImgID(i int) *KcCourseCreate {
	kcc.mutation.SetCourseCoverImgID(i)
	return kcc
}

// SetNillableCourseCoverImgID sets the "course_cover_img_id" field if the given value is not nil.
func (kcc *KcCourseCreate) SetNillableCourseCoverImgID(i *int) *KcCourseCreate {
	if i != nil {
		kcc.SetCourseCoverImgID(*i)
	}
	return kcc
}

// SetCreatedAdminID sets the "created_admin_id" field.
func (kcc *KcCourseCreate) SetCreatedAdminID(i int) *KcCourseCreate {
	kcc.mutation.SetCreatedAdminID(i)
	return kcc
}

// SetNillableCreatedAdminID sets the "created_admin_id" field if the given value is not nil.
func (kcc *KcCourseCreate) SetNillableCreatedAdminID(i *int) *KcCourseCreate {
	if i != nil {
		kcc.SetCreatedAdminID(*i)
	}
	return kcc
}

// AddMajorIDs adds the "major" edge to the Major entity by IDs.
func (kcc *KcCourseCreate) AddMajorIDs(ids ...int) *KcCourseCreate {
	kcc.mutation.AddMajorIDs(ids...)
	return kcc
}

// AddMajor adds the "major" edges to the Major entity.
func (kcc *KcCourseCreate) AddMajor(m ...*Major) *KcCourseCreate {
	ids := make([]int, len(m))
	for i := range m {
		ids[i] = m[i].ID
	}
	return kcc.AddMajorIDs(ids...)
}

// SetItemID sets the "item" edge to the ItemCategory entity by ID.
func (kcc *KcCourseCreate) SetItemID(id int) *KcCourseCreate {
	kcc.mutation.SetItemID(id)
	return kcc
}

// SetNillableItemID sets the "item" edge to the ItemCategory entity by ID if the given value is not nil.
func (kcc *KcCourseCreate) SetNillableItemID(id *int) *KcCourseCreate {
	if id != nil {
		kcc = kcc.SetItemID(*id)
	}
	return kcc
}

// SetItem sets the "item" edge to the ItemCategory entity.
func (kcc *KcCourseCreate) SetItem(i *ItemCategory) *KcCourseCreate {
	return kcc.SetItemID(i.ID)
}

// SetCity sets the "city" edge to the City entity.
func (kcc *KcCourseCreate) SetCity(c *City) *KcCourseCreate {
	return kcc.SetCityID(c.ID)
}

// SetAdminID sets the "admin" edge to the Admin entity by ID.
func (kcc *KcCourseCreate) SetAdminID(id int) *KcCourseCreate {
	kcc.mutation.SetAdminID(id)
	return kcc
}

// SetNillableAdminID sets the "admin" edge to the Admin entity by ID if the given value is not nil.
func (kcc *KcCourseCreate) SetNillableAdminID(id *int) *KcCourseCreate {
	if id != nil {
		kcc = kcc.SetAdminID(*id)
	}
	return kcc
}

// SetAdmin sets the "admin" edge to the Admin entity.
func (kcc *KcCourseCreate) SetAdmin(a *Admin) *KcCourseCreate {
	return kcc.SetAdminID(a.ID)
}

// SetQuestionBank sets the "question_bank" edge to the TkQuestionBank entity.
func (kcc *KcCourseCreate) SetQuestionBank(t *TkQuestionBank) *KcCourseCreate {
	return kcc.SetQuestionBankID(t.ID)
}

// SetAttachmentID sets the "attachment" edge to the Attachment entity by ID.
func (kcc *KcCourseCreate) SetAttachmentID(id int) *KcCourseCreate {
	kcc.mutation.SetAttachmentID(id)
	return kcc
}

// SetNillableAttachmentID sets the "attachment" edge to the Attachment entity by ID if the given value is not nil.
func (kcc *KcCourseCreate) SetNillableAttachmentID(id *int) *KcCourseCreate {
	if id != nil {
		kcc = kcc.SetAttachmentID(*id)
	}
	return kcc
}

// SetAttachment sets the "attachment" edge to the Attachment entity.
func (kcc *KcCourseCreate) SetAttachment(a *Attachment) *KcCourseCreate {
	return kcc.SetAttachmentID(a.ID)
}

// AddCourseTeacherIDs adds the "course_teachers" edge to the KcCourseTeacher entity by IDs.
func (kcc *KcCourseCreate) AddCourseTeacherIDs(ids ...int) *KcCourseCreate {
	kcc.mutation.AddCourseTeacherIDs(ids...)
	return kcc
}

// AddCourseTeachers adds the "course_teachers" edges to the KcCourseTeacher entity.
func (kcc *KcCourseCreate) AddCourseTeachers(k ...*KcCourseTeacher) *KcCourseCreate {
	ids := make([]int, len(k))
	for i := range k {
		ids[i] = k[i].ID
	}
	return kcc.AddCourseTeacherIDs(ids...)
}

// AddClassIDs adds the "classes" edge to the KcClass entity by IDs.
func (kcc *KcCourseCreate) AddClassIDs(ids ...int) *KcCourseCreate {
	kcc.mutation.AddClassIDs(ids...)
	return kcc
}

// AddClasses adds the "classes" edges to the KcClass entity.
func (kcc *KcCourseCreate) AddClasses(k ...*KcClass) *KcCourseCreate {
	ids := make([]int, len(k))
	for i := range k {
		ids[i] = k[i].ID
	}
	return kcc.AddClassIDs(ids...)
}

// AddCourseSmallCategoryIDs adds the "course_small_categorys" edge to the KcCourseSmallCategory entity by IDs.
func (kcc *KcCourseCreate) AddCourseSmallCategoryIDs(ids ...int) *KcCourseCreate {
	kcc.mutation.AddCourseSmallCategoryIDs(ids...)
	return kcc
}

// AddCourseSmallCategorys adds the "course_small_categorys" edges to the KcCourseSmallCategory entity.
func (kcc *KcCourseCreate) AddCourseSmallCategorys(k ...*KcCourseSmallCategory) *KcCourseCreate {
	ids := make([]int, len(k))
	for i := range k {
		ids[i] = k[i].ID
	}
	return kcc.AddCourseSmallCategoryIDs(ids...)
}

// AddCourseAppraiseIDs adds the "course_appraise" edge to the UserCourseAppraise entity by IDs.
func (kcc *KcCourseCreate) AddCourseAppraiseIDs(ids ...int) *KcCourseCreate {
	kcc.mutation.AddCourseAppraiseIDs(ids...)
	return kcc
}

// AddCourseAppraise adds the "course_appraise" edges to the UserCourseAppraise entity.
func (kcc *KcCourseCreate) AddCourseAppraise(u ...*UserCourseAppraise) *KcCourseCreate {
	ids := make([]int, len(u))
	for i := range u {
		ids[i] = u[i].ID
	}
	return kcc.AddCourseAppraiseIDs(ids...)
}

// AddCourseChapterIDs adds the "course_chapters" edge to the KcCourseChapter entity by IDs.
func (kcc *KcCourseCreate) AddCourseChapterIDs(ids ...int) *KcCourseCreate {
	kcc.mutation.AddCourseChapterIDs(ids...)
	return kcc
}

// AddCourseChapters adds the "course_chapters" edges to the KcCourseChapter entity.
func (kcc *KcCourseCreate) AddCourseChapters(k ...*KcCourseChapter) *KcCourseCreate {
	ids := make([]int, len(k))
	for i := range k {
		ids[i] = k[i].ID
	}
	return kcc.AddCourseChapterIDs(ids...)
}

// AddKcUserCourseIDs adds the "kc_user_courses" edge to the KcUserCourse entity by IDs.
func (kcc *KcCourseCreate) AddKcUserCourseIDs(ids ...int) *KcCourseCreate {
	kcc.mutation.AddKcUserCourseIDs(ids...)
	return kcc
}

// AddKcUserCourses adds the "kc_user_courses" edges to the KcUserCourse entity.
func (kcc *KcCourseCreate) AddKcUserCourses(k ...*KcUserCourse) *KcCourseCreate {
	ids := make([]int, len(k))
	for i := range k {
		ids[i] = k[i].ID
	}
	return kcc.AddKcUserCourseIDs(ids...)
}

// AddMessageCourseIDs adds the "message_courses" edge to the Message entity by IDs.
func (kcc *KcCourseCreate) AddMessageCourseIDs(ids ...int) *KcCourseCreate {
	kcc.mutation.AddMessageCourseIDs(ids...)
	return kcc
}

// AddMessageCourses adds the "message_courses" edges to the Message entity.
func (kcc *KcCourseCreate) AddMessageCourses(m ...*Message) *KcCourseCreate {
	ids := make([]int, len(m))
	for i := range m {
		ids[i] = m[i].ID
	}
	return kcc.AddMessageCourseIDs(ids...)
}

// Mutation returns the KcCourseMutation object of the builder.
func (kcc *KcCourseCreate) Mutation() *KcCourseMutation {
	return kcc.mutation
}

// Save creates the KcCourse in the database.
func (kcc *KcCourseCreate) Save(ctx context.Context) (*KcCourse, error) {
	var (
		err  error
		node *KcCourse
	)
	kcc.defaults()
	if len(kcc.hooks) == 0 {
		if err = kcc.check(); err != nil {
			return nil, err
		}
		node, err = kcc.sqlSave(ctx)
	} else {
		var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
			mutation, ok := m.(*KcCourseMutation)
			if !ok {
				return nil, fmt.Errorf("unexpected mutation type %T", m)
			}
			if err = kcc.check(); err != nil {
				return nil, err
			}
			kcc.mutation = mutation
			node, err = kcc.sqlSave(ctx)
			mutation.done = true
			return node, err
		})
		for i := len(kcc.hooks) - 1; i >= 0; i-- {
			mut = kcc.hooks[i](mut)
		}
		if _, err := mut.Mutate(ctx, kcc.mutation); err != nil {
			return nil, err
		}
	}
	return node, err
}

// SaveX calls Save and panics if Save returns an error.
func (kcc *KcCourseCreate) SaveX(ctx context.Context) *KcCourse {
	v, err := kcc.Save(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// defaults sets the default values of the builder before save.
func (kcc *KcCourseCreate) defaults() {
	if _, ok := kcc.mutation.CreatedAt(); !ok {
		v := kccourse.DefaultCreatedAt()
		kcc.mutation.SetCreatedAt(v)
	}
	if _, ok := kcc.mutation.UpdatedAt(); !ok {
		v := kccourse.DefaultUpdatedAt()
		kcc.mutation.SetUpdatedAt(v)
	}
	if _, ok := kcc.mutation.CourseName(); !ok {
		v := kccourse.DefaultCourseName
		kcc.mutation.SetCourseName(v)
	}
	if _, ok := kcc.mutation.CourseType(); !ok {
		v := kccourse.DefaultCourseType
		kcc.mutation.SetCourseType(v)
	}
	if _, ok := kcc.mutation.PeopleNum(); !ok {
		v := kccourse.DefaultPeopleNum
		kcc.mutation.SetPeopleNum(v)
	}
	if _, ok := kcc.mutation.CoursePrice(); !ok {
		v := kccourse.DefaultCoursePrice
		kcc.mutation.SetCoursePrice(v)
	}
	if _, ok := kcc.mutation.CourseDesc(); !ok {
		v := kccourse.DefaultCourseDesc
		kcc.mutation.SetCourseDesc(v)
	}
	if _, ok := kcc.mutation.PushStatus(); !ok {
		v := kccourse.DefaultPushStatus
		kcc.mutation.SetPushStatus(v)
	}
}

// check runs all checks and user-defined validators on the builder.
func (kcc *KcCourseCreate) check() error {
	if _, ok := kcc.mutation.UUID(); !ok {
		return &ValidationError{Name: "uuid", err: errors.New("ent: missing required field \"uuid\"")}
	}
	if _, ok := kcc.mutation.CourseName(); !ok {
		return &ValidationError{Name: "course_name", err: errors.New("ent: missing required field \"course_name\"")}
	}
	if _, ok := kcc.mutation.CourseType(); !ok {
		return &ValidationError{Name: "course_type", err: errors.New("ent: missing required field \"course_type\"")}
	}
	if _, ok := kcc.mutation.PeopleNum(); !ok {
		return &ValidationError{Name: "people_num", err: errors.New("ent: missing required field \"people_num\"")}
	}
	if _, ok := kcc.mutation.CoursePrice(); !ok {
		return &ValidationError{Name: "course_price", err: errors.New("ent: missing required field \"course_price\"")}
	}
	if _, ok := kcc.mutation.CourseDesc(); !ok {
		return &ValidationError{Name: "course_desc", err: errors.New("ent: missing required field \"course_desc\"")}
	}
	if _, ok := kcc.mutation.PushStatus(); !ok {
		return &ValidationError{Name: "push_status", err: errors.New("ent: missing required field \"push_status\"")}
	}
	return nil
}

func (kcc *KcCourseCreate) sqlSave(ctx context.Context) (*KcCourse, error) {
	_node, _spec := kcc.createSpec()
	if err := sqlgraph.CreateNode(ctx, kcc.driver, _spec); err != nil {
		if cerr, ok := isSQLConstraintError(err); ok {
			err = cerr
		}
		return nil, err
	}
	id := _spec.ID.Value.(int64)
	_node.ID = int(id)
	return _node, nil
}

func (kcc *KcCourseCreate) createSpec() (*KcCourse, *sqlgraph.CreateSpec) {
	var (
		_node = &KcCourse{config: kcc.config}
		_spec = &sqlgraph.CreateSpec{
			Table: kccourse.Table,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeInt,
				Column: kccourse.FieldID,
			},
		}
	)
	if value, ok := kcc.mutation.UUID(); ok {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: kccourse.FieldUUID,
		})
		_node.UUID = value
	}
	if value, ok := kcc.mutation.CreatedAt(); ok {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: kccourse.FieldCreatedAt,
		})
		_node.CreatedAt = &value
	}
	if value, ok := kcc.mutation.UpdatedAt(); ok {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: kccourse.FieldUpdatedAt,
		})
		_node.UpdatedAt = &value
	}
	if value, ok := kcc.mutation.DeletedAt(); ok {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: kccourse.FieldDeletedAt,
		})
		_node.DeletedAt = &value
	}
	if value, ok := kcc.mutation.CourseName(); ok {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: kccourse.FieldCourseName,
		})
		_node.CourseName = value
	}
	if value, ok := kcc.mutation.CourseType(); ok {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeUint8,
			Value:  value,
			Column: kccourse.FieldCourseType,
		})
		_node.CourseType = value
	}
	if value, ok := kcc.mutation.PeopleNum(); ok {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Value:  value,
			Column: kccourse.FieldPeopleNum,
		})
		_node.PeopleNum = value
	}
	if value, ok := kcc.mutation.CoursePrice(); ok {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeFloat64,
			Value:  value,
			Column: kccourse.FieldCoursePrice,
		})
		_node.CoursePrice = value
	}
	if value, ok := kcc.mutation.CourseDesc(); ok {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: kccourse.FieldCourseDesc,
		})
		_node.CourseDesc = value
	}
	if value, ok := kcc.mutation.PushStatus(); ok {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeUint8,
			Value:  value,
			Column: kccourse.FieldPushStatus,
		})
		_node.PushStatus = value
	}
	if nodes := kcc.mutation.MajorIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   kccourse.MajorTable,
			Columns: kccourse.MajorPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: major.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges = append(_spec.Edges, edge)
	}
	if nodes := kcc.mutation.ItemIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   kccourse.ItemTable,
			Columns: []string{kccourse.ItemColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: itemcategory.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_node.CateID = nodes[0]
		_spec.Edges = append(_spec.Edges, edge)
	}
	if nodes := kcc.mutation.CityIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   kccourse.CityTable,
			Columns: []string{kccourse.CityColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: city.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_node.CityID = nodes[0]
		_spec.Edges = append(_spec.Edges, edge)
	}
	if nodes := kcc.mutation.AdminIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   kccourse.AdminTable,
			Columns: []string{kccourse.AdminColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: admin.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_node.CreatedAdminID = nodes[0]
		_spec.Edges = append(_spec.Edges, edge)
	}
	if nodes := kcc.mutation.QuestionBankIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   kccourse.QuestionBankTable,
			Columns: []string{kccourse.QuestionBankColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkquestionbank.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_node.QuestionBankID = nodes[0]
		_spec.Edges = append(_spec.Edges, edge)
	}
	if nodes := kcc.mutation.AttachmentIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   kccourse.AttachmentTable,
			Columns: []string{kccourse.AttachmentColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: attachment.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_node.CourseCoverImgID = nodes[0]
		_spec.Edges = append(_spec.Edges, edge)
	}
	if nodes := kcc.mutation.CourseTeachersIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   kccourse.CourseTeachersTable,
			Columns: []string{kccourse.CourseTeachersColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: kccourseteacher.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges = append(_spec.Edges, edge)
	}
	if nodes := kcc.mutation.ClassesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   kccourse.ClassesTable,
			Columns: kccourse.ClassesPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: kcclass.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges = append(_spec.Edges, edge)
	}
	if nodes := kcc.mutation.CourseSmallCategorysIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   kccourse.CourseSmallCategorysTable,
			Columns: []string{kccourse.CourseSmallCategorysColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: kccoursesmallcategory.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges = append(_spec.Edges, edge)
	}
	if nodes := kcc.mutation.CourseAppraiseIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   kccourse.CourseAppraiseTable,
			Columns: []string{kccourse.CourseAppraiseColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: usercourseappraise.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges = append(_spec.Edges, edge)
	}
	if nodes := kcc.mutation.CourseChaptersIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   kccourse.CourseChaptersTable,
			Columns: []string{kccourse.CourseChaptersColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: kccoursechapter.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges = append(_spec.Edges, edge)
	}
	if nodes := kcc.mutation.KcUserCoursesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   kccourse.KcUserCoursesTable,
			Columns: []string{kccourse.KcUserCoursesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: kcusercourse.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges = append(_spec.Edges, edge)
	}
	if nodes := kcc.mutation.MessageCoursesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   kccourse.MessageCoursesTable,
			Columns: []string{kccourse.MessageCoursesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: message.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges = append(_spec.Edges, edge)
	}
	return _node, _spec
}

// KcCourseCreateBulk is the builder for creating many KcCourse entities in bulk.
type KcCourseCreateBulk struct {
	config
	builders []*KcCourseCreate
}

// Save creates the KcCourse entities in the database.
func (kccb *KcCourseCreateBulk) Save(ctx context.Context) ([]*KcCourse, error) {
	specs := make([]*sqlgraph.CreateSpec, len(kccb.builders))
	nodes := make([]*KcCourse, len(kccb.builders))
	mutators := make([]Mutator, len(kccb.builders))
	for i := range kccb.builders {
		func(i int, root context.Context) {
			builder := kccb.builders[i]
			builder.defaults()
			var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
				mutation, ok := m.(*KcCourseMutation)
				if !ok {
					return nil, fmt.Errorf("unexpected mutation type %T", m)
				}
				if err := builder.check(); err != nil {
					return nil, err
				}
				builder.mutation = mutation
				nodes[i], specs[i] = builder.createSpec()
				var err error
				if i < len(mutators)-1 {
					_, err = mutators[i+1].Mutate(root, kccb.builders[i+1].mutation)
				} else {
					// Invoke the actual operation on the latest mutation in the chain.
					if err = sqlgraph.BatchCreate(ctx, kccb.driver, &sqlgraph.BatchCreateSpec{Nodes: specs}); err != nil {
						if cerr, ok := isSQLConstraintError(err); ok {
							err = cerr
						}
					}
				}
				mutation.done = true
				if err != nil {
					return nil, err
				}
				id := specs[i].ID.Value.(int64)
				nodes[i].ID = int(id)
				return nodes[i], nil
			})
			for i := len(builder.hooks) - 1; i >= 0; i-- {
				mut = builder.hooks[i](mut)
			}
			mutators[i] = mut
		}(i, ctx)
	}
	if len(mutators) > 0 {
		if _, err := mutators[0].Mutate(ctx, kccb.builders[0].mutation); err != nil {
			return nil, err
		}
	}
	return nodes, nil
}

// SaveX is like Save, but panics if an error occurs.
func (kccb *KcCourseCreateBulk) SaveX(ctx context.Context) []*KcCourse {
	v, err := kccb.Save(ctx)
	if err != nil {
		panic(err)
	}
	return v
}
