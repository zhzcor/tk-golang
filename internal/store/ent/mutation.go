// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"gserver/internal/store/ent/activity"
	"gserver/internal/store/ent/activityapplyinfo"
	"gserver/internal/store/ent/activitytype"
	"gserver/internal/store/ent/admin"
	"gserver/internal/store/ent/adminloginlog"
	"gserver/internal/store/ent/adminoperationlog"
	"gserver/internal/store/ent/advertise"
	"gserver/internal/store/ent/appagreement"
	"gserver/internal/store/ent/appversion"
	"gserver/internal/store/ent/attachment"
	"gserver/internal/store/ent/city"
	"gserver/internal/store/ent/collection"
	"gserver/internal/store/ent/hotsearch"
	"gserver/internal/store/ent/importtask"
	"gserver/internal/store/ent/informationclassify"
	"gserver/internal/store/ent/itemcategory"
	"gserver/internal/store/ent/kcclass"
	"gserver/internal/store/ent/kcclassteacher"
	"gserver/internal/store/ent/kccourse"
	"gserver/internal/store/ent/kccoursechapter"
	"gserver/internal/store/ent/kccoursesection"
	"gserver/internal/store/ent/kccoursesmallcategory"
	"gserver/internal/store/ent/kccourseteacher"
	"gserver/internal/store/ent/kccoursevideo"
	"gserver/internal/store/ent/kcsmallcategoryattachment"
	"gserver/internal/store/ent/kcsmallcategoryexampaper"
	"gserver/internal/store/ent/kcsmallcategoryquestion"
	"gserver/internal/store/ent/kcuserclass"
	"gserver/internal/store/ent/kcusercourse"
	"gserver/internal/store/ent/kcvideouploadtask"
	"gserver/internal/store/ent/major"
	"gserver/internal/store/ent/majordetail"
	"gserver/internal/store/ent/majordetailtag"
	"gserver/internal/store/ent/makeuserquestionrecord"
	"gserver/internal/store/ent/message"
	"gserver/internal/store/ent/messagetype"
	"gserver/internal/store/ent/permission"
	"gserver/internal/store/ent/predicate"
	"gserver/internal/store/ent/role"
	"gserver/internal/store/ent/rolepermission"
	"gserver/internal/store/ent/shareposter"
	"gserver/internal/store/ent/teacher"
	"gserver/internal/store/ent/teachertag"
	"gserver/internal/store/ent/tkchapter"
	"gserver/internal/store/ent/tkexampaper"
	"gserver/internal/store/ent/tkexampaperpartition"
	"gserver/internal/store/ent/tkexampaperpartitionscore"
	"gserver/internal/store/ent/tkexampapersimulation"
	"gserver/internal/store/ent/tkexampartitionquestionlink"
	"gserver/internal/store/ent/tkexamquestiontype"
	"gserver/internal/store/ent/tkknowledgepoint"
	"gserver/internal/store/ent/tkquestion"
	"gserver/internal/store/ent/tkquestionansweroption"
	"gserver/internal/store/ent/tkquestionbank"
	"gserver/internal/store/ent/tkquestionerrorfeedback"
	"gserver/internal/store/ent/tkquestionsection"
	"gserver/internal/store/ent/tksection"
	"gserver/internal/store/ent/tkuserexamscorerecord"
	"gserver/internal/store/ent/tkuserquestionbankrecord"
	"gserver/internal/store/ent/tkuserquestionrecord"
	"gserver/internal/store/ent/tkuserrandomexamrecode"
	"gserver/internal/store/ent/tkusersimulationteachermark"
	"gserver/internal/store/ent/tkuserwrongquestionrecode"
	"gserver/internal/store/ent/user"
	"gserver/internal/store/ent/useraskanswer"
	"gserver/internal/store/ent/useraskanswerattachment"
	"gserver/internal/store/ent/usercourseappraise"
	"gserver/internal/store/ent/userloginlog"
	"gserver/internal/store/ent/videorecord"
	"sync"
	"time"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeActivity                    = "Activity"
	TypeActivityApplyInfo           = "ActivityApplyInfo"
	TypeActivityType                = "ActivityType"
	TypeAdmin                       = "Admin"
	TypeAdminLoginLog               = "AdminLoginLog"
	TypeAdminOperationLog           = "AdminOperationLog"
	TypeAdvertise                   = "Advertise"
	TypeAppAgreement                = "AppAgreement"
	TypeAppVersion                  = "AppVersion"
	TypeAttachment                  = "Attachment"
	TypeCity                        = "City"
	TypeCollection                  = "Collection"
	TypeHotSearch                   = "HotSearch"
	TypeImportTask                  = "ImportTask"
	TypeInformationClassify         = "InformationClassify"
	TypeItemCategory                = "ItemCategory"
	TypeKcClass                     = "KcClass"
	TypeKcClassTeacher              = "KcClassTeacher"
	TypeKcCourse                    = "KcCourse"
	TypeKcCourseChapter             = "KcCourseChapter"
	TypeKcCourseSection             = "KcCourseSection"
	TypeKcCourseSmallCategory       = "KcCourseSmallCategory"
	TypeKcCourseTeacher             = "KcCourseTeacher"
	TypeKcCourseVideo               = "KcCourseVideo"
	TypeKcSmallCategoryAttachment   = "KcSmallCategoryAttachment"
	TypeKcSmallCategoryExamPaper    = "KcSmallCategoryExamPaper"
	TypeKcSmallCategoryQuestion     = "KcSmallCategoryQuestion"
	TypeKcUserClass                 = "KcUserClass"
	TypeKcUserCourse                = "KcUserCourse"
	TypeKcVideoUploadTask           = "KcVideoUploadTask"
	TypeMajor                       = "Major"
	TypeMajorDetail                 = "MajorDetail"
	TypeMajorDetailTag              = "MajorDetailTag"
	TypeMakeUserQuestionRecord      = "MakeUserQuestionRecord"
	TypeMessage                     = "Message"
	TypeMessageType                 = "MessageType"
	TypePermission                  = "Permission"
	TypeRole                        = "Role"
	TypeRolePermission              = "RolePermission"
	TypeSharePoster                 = "SharePoster"
	TypeTeacher                     = "Teacher"
	TypeTeacherTag                  = "TeacherTag"
	TypeTkChapter                   = "TkChapter"
	TypeTkExamPaper                 = "TkExamPaper"
	TypeTkExamPaperPartition        = "TkExamPaperPartition"
	TypeTkExamPaperPartitionScore   = "TkExamPaperPartitionScore"
	TypeTkExamPaperSimulation       = "TkExamPaperSimulation"
	TypeTkExamPartitionQuestionLink = "TkExamPartitionQuestionLink"
	TypeTkExamQuestionType          = "TkExamQuestionType"
	TypeTkKnowledgePoint            = "TkKnowledgePoint"
	TypeTkQuestion                  = "TkQuestion"
	TypeTkQuestionAnswerOption      = "TkQuestionAnswerOption"
	TypeTkQuestionBank              = "TkQuestionBank"
	TypeTkQuestionErrorFeedback     = "TkQuestionErrorFeedback"
	TypeTkQuestionSection           = "TkQuestionSection"
	TypeTkSection                   = "TkSection"
	TypeTkUserExamScoreRecord       = "TkUserExamScoreRecord"
	TypeTkUserQuestionBankRecord    = "TkUserQuestionBankRecord"
	TypeTkUserQuestionRecord        = "TkUserQuestionRecord"
	TypeTkUserRandomExamRecode      = "TkUserRandomExamRecode"
	TypeTkUserSimulationTeacherMark = "TkUserSimulationTeacherMark"
	TypeTkUserWrongQuestionRecode   = "TkUserWrongQuestionRecode"
	TypeUser                        = "User"
	TypeUserAskAnswer               = "UserAskAnswer"
	TypeUserAskAnswerAttachment     = "UserAskAnswerAttachment"
	TypeUserCourseAppraise          = "UserCourseAppraise"
	TypeUserLoginLog                = "UserLoginLog"
	TypeVideoRecord                 = "VideoRecord"
)

// ActivityMutation represents an operation that mutates the Activity nodes in the graph.
type ActivityMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	uuid                    *string
	created_at              *time.Time
	updated_at              *time.Time
	deleted_at              *time.Time
	title                   *string
	sub_title               *string
	cover_img_id            *int
	addcover_img_id         *int
	notice                  *string
	detail                  *string
	place                   *string
	is_free                 *uint8
	addis_free              *uint8
	is_publish              *uint8
	addis_publish           *uint8
	amount                  *int
	addamount               *int
	start_at                *time.Time
	end_at                  *time.Time
	apply_start_at          *time.Time
	apply_end_at            *time.Time
	is_hot                  *uint8
	addis_hot               *uint8
	is_auto_publish         *uint8
	addis_auto_publish      *uint8
	apply_count             *int
	addapply_count          *int
	join_count              *int
	addjoin_count           *int
	is_limit_join_count     *uint8
	addis_limit_join_count  *uint8
	birthday                *time.Time
	sign_remark             *string
	clearedFields           map[string]struct{}
	activity_type           *int
	clearedactivity_type    bool
	apply_activities        map[int]struct{}
	removedapply_activities map[int]struct{}
	clearedapply_activities bool
	admin                   *int
	clearedadmin            bool
	done                    bool
	oldValue                func(context.Context) (*Activity, error)
	predicates              []predicate.Activity
}

var _ ent.Mutation = (*ActivityMutation)(nil)

// activityOption allows management of the mutation configuration using functional options.
type activityOption func(*ActivityMutation)

// newActivityMutation creates new mutation for the Activity entity.
func newActivityMutation(c config, op Op, opts ...activityOption) *ActivityMutation {
	m := &ActivityMutation{
		config:        c,
		op:            op,
		typ:           TypeActivity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withActivityID sets the ID field of the mutation.
func withActivityID(id int) activityOption {
	return func(m *ActivityMutation) {
		var (
			err   error
			once  sync.Once
			value *Activity
		)
		m.oldValue = func(ctx context.Context) (*Activity, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Activity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withActivity sets the old Activity of the mutation.
func withActivity(node *Activity) activityOption {
	return func(m *ActivityMutation) {
		m.oldValue = func(context.Context) (*Activity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ActivityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ActivityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *ActivityMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *ActivityMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *ActivityMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *ActivityMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ActivityMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ActivityMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *ActivityMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[activity.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *ActivityMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[activity.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ActivityMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, activity.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ActivityMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ActivityMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *ActivityMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[activity.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *ActivityMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[activity.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ActivityMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, activity.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ActivityMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ActivityMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ActivityMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[activity.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ActivityMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[activity.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ActivityMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, activity.FieldDeletedAt)
}

// SetTitle sets the "title" field.
func (m *ActivityMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ActivityMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *ActivityMutation) ResetTitle() {
	m.title = nil
}

// SetSubTitle sets the "sub_title" field.
func (m *ActivityMutation) SetSubTitle(s string) {
	m.sub_title = &s
}

// SubTitle returns the value of the "sub_title" field in the mutation.
func (m *ActivityMutation) SubTitle() (r string, exists bool) {
	v := m.sub_title
	if v == nil {
		return
	}
	return *v, true
}

// OldSubTitle returns the old "sub_title" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldSubTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSubTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSubTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubTitle: %w", err)
	}
	return oldValue.SubTitle, nil
}

// ResetSubTitle resets all changes to the "sub_title" field.
func (m *ActivityMutation) ResetSubTitle() {
	m.sub_title = nil
}

// SetCoverImgID sets the "cover_img_id" field.
func (m *ActivityMutation) SetCoverImgID(i int) {
	m.cover_img_id = &i
	m.addcover_img_id = nil
}

// CoverImgID returns the value of the "cover_img_id" field in the mutation.
func (m *ActivityMutation) CoverImgID() (r int, exists bool) {
	v := m.cover_img_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCoverImgID returns the old "cover_img_id" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldCoverImgID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCoverImgID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCoverImgID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoverImgID: %w", err)
	}
	return oldValue.CoverImgID, nil
}

// AddCoverImgID adds i to the "cover_img_id" field.
func (m *ActivityMutation) AddCoverImgID(i int) {
	if m.addcover_img_id != nil {
		*m.addcover_img_id += i
	} else {
		m.addcover_img_id = &i
	}
}

// AddedCoverImgID returns the value that was added to the "cover_img_id" field in this mutation.
func (m *ActivityMutation) AddedCoverImgID() (r int, exists bool) {
	v := m.addcover_img_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCoverImgID resets all changes to the "cover_img_id" field.
func (m *ActivityMutation) ResetCoverImgID() {
	m.cover_img_id = nil
	m.addcover_img_id = nil
}

// SetNotice sets the "notice" field.
func (m *ActivityMutation) SetNotice(s string) {
	m.notice = &s
}

// Notice returns the value of the "notice" field in the mutation.
func (m *ActivityMutation) Notice() (r string, exists bool) {
	v := m.notice
	if v == nil {
		return
	}
	return *v, true
}

// OldNotice returns the old "notice" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldNotice(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNotice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNotice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotice: %w", err)
	}
	return oldValue.Notice, nil
}

// ClearNotice clears the value of the "notice" field.
func (m *ActivityMutation) ClearNotice() {
	m.notice = nil
	m.clearedFields[activity.FieldNotice] = struct{}{}
}

// NoticeCleared returns if the "notice" field was cleared in this mutation.
func (m *ActivityMutation) NoticeCleared() bool {
	_, ok := m.clearedFields[activity.FieldNotice]
	return ok
}

// ResetNotice resets all changes to the "notice" field.
func (m *ActivityMutation) ResetNotice() {
	m.notice = nil
	delete(m.clearedFields, activity.FieldNotice)
}

// SetDetail sets the "detail" field.
func (m *ActivityMutation) SetDetail(s string) {
	m.detail = &s
}

// Detail returns the value of the "detail" field in the mutation.
func (m *ActivityMutation) Detail() (r string, exists bool) {
	v := m.detail
	if v == nil {
		return
	}
	return *v, true
}

// OldDetail returns the old "detail" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldDetail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDetail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDetail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetail: %w", err)
	}
	return oldValue.Detail, nil
}

// ClearDetail clears the value of the "detail" field.
func (m *ActivityMutation) ClearDetail() {
	m.detail = nil
	m.clearedFields[activity.FieldDetail] = struct{}{}
}

// DetailCleared returns if the "detail" field was cleared in this mutation.
func (m *ActivityMutation) DetailCleared() bool {
	_, ok := m.clearedFields[activity.FieldDetail]
	return ok
}

// ResetDetail resets all changes to the "detail" field.
func (m *ActivityMutation) ResetDetail() {
	m.detail = nil
	delete(m.clearedFields, activity.FieldDetail)
}

// SetPlace sets the "place" field.
func (m *ActivityMutation) SetPlace(s string) {
	m.place = &s
}

// Place returns the value of the "place" field in the mutation.
func (m *ActivityMutation) Place() (r string, exists bool) {
	v := m.place
	if v == nil {
		return
	}
	return *v, true
}

// OldPlace returns the old "place" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldPlace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPlace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPlace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlace: %w", err)
	}
	return oldValue.Place, nil
}

// ResetPlace resets all changes to the "place" field.
func (m *ActivityMutation) ResetPlace() {
	m.place = nil
}

// SetIsFree sets the "is_free" field.
func (m *ActivityMutation) SetIsFree(u uint8) {
	m.is_free = &u
	m.addis_free = nil
}

// IsFree returns the value of the "is_free" field in the mutation.
func (m *ActivityMutation) IsFree() (r uint8, exists bool) {
	v := m.is_free
	if v == nil {
		return
	}
	return *v, true
}

// OldIsFree returns the old "is_free" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldIsFree(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsFree is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsFree requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsFree: %w", err)
	}
	return oldValue.IsFree, nil
}

// AddIsFree adds u to the "is_free" field.
func (m *ActivityMutation) AddIsFree(u uint8) {
	if m.addis_free != nil {
		*m.addis_free += u
	} else {
		m.addis_free = &u
	}
}

// AddedIsFree returns the value that was added to the "is_free" field in this mutation.
func (m *ActivityMutation) AddedIsFree() (r uint8, exists bool) {
	v := m.addis_free
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsFree resets all changes to the "is_free" field.
func (m *ActivityMutation) ResetIsFree() {
	m.is_free = nil
	m.addis_free = nil
}

// SetIsPublish sets the "is_publish" field.
func (m *ActivityMutation) SetIsPublish(u uint8) {
	m.is_publish = &u
	m.addis_publish = nil
}

// IsPublish returns the value of the "is_publish" field in the mutation.
func (m *ActivityMutation) IsPublish() (r uint8, exists bool) {
	v := m.is_publish
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPublish returns the old "is_publish" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldIsPublish(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsPublish is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsPublish requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPublish: %w", err)
	}
	return oldValue.IsPublish, nil
}

// AddIsPublish adds u to the "is_publish" field.
func (m *ActivityMutation) AddIsPublish(u uint8) {
	if m.addis_publish != nil {
		*m.addis_publish += u
	} else {
		m.addis_publish = &u
	}
}

// AddedIsPublish returns the value that was added to the "is_publish" field in this mutation.
func (m *ActivityMutation) AddedIsPublish() (r uint8, exists bool) {
	v := m.addis_publish
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsPublish resets all changes to the "is_publish" field.
func (m *ActivityMutation) ResetIsPublish() {
	m.is_publish = nil
	m.addis_publish = nil
}

// SetAmount sets the "amount" field.
func (m *ActivityMutation) SetAmount(i int) {
	m.amount = &i
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *ActivityMutation) Amount() (r int, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldAmount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds i to the "amount" field.
func (m *ActivityMutation) AddAmount(i int) {
	if m.addamount != nil {
		*m.addamount += i
	} else {
		m.addamount = &i
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *ActivityMutation) AddedAmount() (r int, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *ActivityMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetStartAt sets the "start_at" field.
func (m *ActivityMutation) SetStartAt(t time.Time) {
	m.start_at = &t
}

// StartAt returns the value of the "start_at" field in the mutation.
func (m *ActivityMutation) StartAt() (r time.Time, exists bool) {
	v := m.start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAt returns the old "start_at" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldStartAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAt: %w", err)
	}
	return oldValue.StartAt, nil
}

// ClearStartAt clears the value of the "start_at" field.
func (m *ActivityMutation) ClearStartAt() {
	m.start_at = nil
	m.clearedFields[activity.FieldStartAt] = struct{}{}
}

// StartAtCleared returns if the "start_at" field was cleared in this mutation.
func (m *ActivityMutation) StartAtCleared() bool {
	_, ok := m.clearedFields[activity.FieldStartAt]
	return ok
}

// ResetStartAt resets all changes to the "start_at" field.
func (m *ActivityMutation) ResetStartAt() {
	m.start_at = nil
	delete(m.clearedFields, activity.FieldStartAt)
}

// SetEndAt sets the "end_at" field.
func (m *ActivityMutation) SetEndAt(t time.Time) {
	m.end_at = &t
}

// EndAt returns the value of the "end_at" field in the mutation.
func (m *ActivityMutation) EndAt() (r time.Time, exists bool) {
	v := m.end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndAt returns the old "end_at" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldEndAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndAt: %w", err)
	}
	return oldValue.EndAt, nil
}

// ClearEndAt clears the value of the "end_at" field.
func (m *ActivityMutation) ClearEndAt() {
	m.end_at = nil
	m.clearedFields[activity.FieldEndAt] = struct{}{}
}

// EndAtCleared returns if the "end_at" field was cleared in this mutation.
func (m *ActivityMutation) EndAtCleared() bool {
	_, ok := m.clearedFields[activity.FieldEndAt]
	return ok
}

// ResetEndAt resets all changes to the "end_at" field.
func (m *ActivityMutation) ResetEndAt() {
	m.end_at = nil
	delete(m.clearedFields, activity.FieldEndAt)
}

// SetApplyStartAt sets the "apply_start_at" field.
func (m *ActivityMutation) SetApplyStartAt(t time.Time) {
	m.apply_start_at = &t
}

// ApplyStartAt returns the value of the "apply_start_at" field in the mutation.
func (m *ActivityMutation) ApplyStartAt() (r time.Time, exists bool) {
	v := m.apply_start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldApplyStartAt returns the old "apply_start_at" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldApplyStartAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldApplyStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldApplyStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplyStartAt: %w", err)
	}
	return oldValue.ApplyStartAt, nil
}

// ClearApplyStartAt clears the value of the "apply_start_at" field.
func (m *ActivityMutation) ClearApplyStartAt() {
	m.apply_start_at = nil
	m.clearedFields[activity.FieldApplyStartAt] = struct{}{}
}

// ApplyStartAtCleared returns if the "apply_start_at" field was cleared in this mutation.
func (m *ActivityMutation) ApplyStartAtCleared() bool {
	_, ok := m.clearedFields[activity.FieldApplyStartAt]
	return ok
}

// ResetApplyStartAt resets all changes to the "apply_start_at" field.
func (m *ActivityMutation) ResetApplyStartAt() {
	m.apply_start_at = nil
	delete(m.clearedFields, activity.FieldApplyStartAt)
}

// SetApplyEndAt sets the "apply_end_at" field.
func (m *ActivityMutation) SetApplyEndAt(t time.Time) {
	m.apply_end_at = &t
}

// ApplyEndAt returns the value of the "apply_end_at" field in the mutation.
func (m *ActivityMutation) ApplyEndAt() (r time.Time, exists bool) {
	v := m.apply_end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldApplyEndAt returns the old "apply_end_at" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldApplyEndAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldApplyEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldApplyEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplyEndAt: %w", err)
	}
	return oldValue.ApplyEndAt, nil
}

// ClearApplyEndAt clears the value of the "apply_end_at" field.
func (m *ActivityMutation) ClearApplyEndAt() {
	m.apply_end_at = nil
	m.clearedFields[activity.FieldApplyEndAt] = struct{}{}
}

// ApplyEndAtCleared returns if the "apply_end_at" field was cleared in this mutation.
func (m *ActivityMutation) ApplyEndAtCleared() bool {
	_, ok := m.clearedFields[activity.FieldApplyEndAt]
	return ok
}

// ResetApplyEndAt resets all changes to the "apply_end_at" field.
func (m *ActivityMutation) ResetApplyEndAt() {
	m.apply_end_at = nil
	delete(m.clearedFields, activity.FieldApplyEndAt)
}

// SetIsHot sets the "is_hot" field.
func (m *ActivityMutation) SetIsHot(u uint8) {
	m.is_hot = &u
	m.addis_hot = nil
}

// IsHot returns the value of the "is_hot" field in the mutation.
func (m *ActivityMutation) IsHot() (r uint8, exists bool) {
	v := m.is_hot
	if v == nil {
		return
	}
	return *v, true
}

// OldIsHot returns the old "is_hot" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldIsHot(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsHot is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsHot requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsHot: %w", err)
	}
	return oldValue.IsHot, nil
}

// AddIsHot adds u to the "is_hot" field.
func (m *ActivityMutation) AddIsHot(u uint8) {
	if m.addis_hot != nil {
		*m.addis_hot += u
	} else {
		m.addis_hot = &u
	}
}

// AddedIsHot returns the value that was added to the "is_hot" field in this mutation.
func (m *ActivityMutation) AddedIsHot() (r uint8, exists bool) {
	v := m.addis_hot
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsHot resets all changes to the "is_hot" field.
func (m *ActivityMutation) ResetIsHot() {
	m.is_hot = nil
	m.addis_hot = nil
}

// SetIsAutoPublish sets the "is_auto_publish" field.
func (m *ActivityMutation) SetIsAutoPublish(u uint8) {
	m.is_auto_publish = &u
	m.addis_auto_publish = nil
}

// IsAutoPublish returns the value of the "is_auto_publish" field in the mutation.
func (m *ActivityMutation) IsAutoPublish() (r uint8, exists bool) {
	v := m.is_auto_publish
	if v == nil {
		return
	}
	return *v, true
}

// OldIsAutoPublish returns the old "is_auto_publish" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldIsAutoPublish(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsAutoPublish is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsAutoPublish requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsAutoPublish: %w", err)
	}
	return oldValue.IsAutoPublish, nil
}

// AddIsAutoPublish adds u to the "is_auto_publish" field.
func (m *ActivityMutation) AddIsAutoPublish(u uint8) {
	if m.addis_auto_publish != nil {
		*m.addis_auto_publish += u
	} else {
		m.addis_auto_publish = &u
	}
}

// AddedIsAutoPublish returns the value that was added to the "is_auto_publish" field in this mutation.
func (m *ActivityMutation) AddedIsAutoPublish() (r uint8, exists bool) {
	v := m.addis_auto_publish
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsAutoPublish resets all changes to the "is_auto_publish" field.
func (m *ActivityMutation) ResetIsAutoPublish() {
	m.is_auto_publish = nil
	m.addis_auto_publish = nil
}

// SetApplyCount sets the "apply_count" field.
func (m *ActivityMutation) SetApplyCount(i int) {
	m.apply_count = &i
	m.addapply_count = nil
}

// ApplyCount returns the value of the "apply_count" field in the mutation.
func (m *ActivityMutation) ApplyCount() (r int, exists bool) {
	v := m.apply_count
	if v == nil {
		return
	}
	return *v, true
}

// OldApplyCount returns the old "apply_count" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldApplyCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldApplyCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldApplyCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplyCount: %w", err)
	}
	return oldValue.ApplyCount, nil
}

// AddApplyCount adds i to the "apply_count" field.
func (m *ActivityMutation) AddApplyCount(i int) {
	if m.addapply_count != nil {
		*m.addapply_count += i
	} else {
		m.addapply_count = &i
	}
}

// AddedApplyCount returns the value that was added to the "apply_count" field in this mutation.
func (m *ActivityMutation) AddedApplyCount() (r int, exists bool) {
	v := m.addapply_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetApplyCount resets all changes to the "apply_count" field.
func (m *ActivityMutation) ResetApplyCount() {
	m.apply_count = nil
	m.addapply_count = nil
}

// SetJoinCount sets the "join_count" field.
func (m *ActivityMutation) SetJoinCount(i int) {
	m.join_count = &i
	m.addjoin_count = nil
}

// JoinCount returns the value of the "join_count" field in the mutation.
func (m *ActivityMutation) JoinCount() (r int, exists bool) {
	v := m.join_count
	if v == nil {
		return
	}
	return *v, true
}

// OldJoinCount returns the old "join_count" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldJoinCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldJoinCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldJoinCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJoinCount: %w", err)
	}
	return oldValue.JoinCount, nil
}

// AddJoinCount adds i to the "join_count" field.
func (m *ActivityMutation) AddJoinCount(i int) {
	if m.addjoin_count != nil {
		*m.addjoin_count += i
	} else {
		m.addjoin_count = &i
	}
}

// AddedJoinCount returns the value that was added to the "join_count" field in this mutation.
func (m *ActivityMutation) AddedJoinCount() (r int, exists bool) {
	v := m.addjoin_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetJoinCount resets all changes to the "join_count" field.
func (m *ActivityMutation) ResetJoinCount() {
	m.join_count = nil
	m.addjoin_count = nil
}

// SetIsLimitJoinCount sets the "is_limit_join_count" field.
func (m *ActivityMutation) SetIsLimitJoinCount(u uint8) {
	m.is_limit_join_count = &u
	m.addis_limit_join_count = nil
}

// IsLimitJoinCount returns the value of the "is_limit_join_count" field in the mutation.
func (m *ActivityMutation) IsLimitJoinCount() (r uint8, exists bool) {
	v := m.is_limit_join_count
	if v == nil {
		return
	}
	return *v, true
}

// OldIsLimitJoinCount returns the old "is_limit_join_count" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldIsLimitJoinCount(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsLimitJoinCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsLimitJoinCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsLimitJoinCount: %w", err)
	}
	return oldValue.IsLimitJoinCount, nil
}

// AddIsLimitJoinCount adds u to the "is_limit_join_count" field.
func (m *ActivityMutation) AddIsLimitJoinCount(u uint8) {
	if m.addis_limit_join_count != nil {
		*m.addis_limit_join_count += u
	} else {
		m.addis_limit_join_count = &u
	}
}

// AddedIsLimitJoinCount returns the value that was added to the "is_limit_join_count" field in this mutation.
func (m *ActivityMutation) AddedIsLimitJoinCount() (r uint8, exists bool) {
	v := m.addis_limit_join_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsLimitJoinCount resets all changes to the "is_limit_join_count" field.
func (m *ActivityMutation) ResetIsLimitJoinCount() {
	m.is_limit_join_count = nil
	m.addis_limit_join_count = nil
}

// SetBirthday sets the "birthday" field.
func (m *ActivityMutation) SetBirthday(t time.Time) {
	m.birthday = &t
}

// Birthday returns the value of the "birthday" field in the mutation.
func (m *ActivityMutation) Birthday() (r time.Time, exists bool) {
	v := m.birthday
	if v == nil {
		return
	}
	return *v, true
}

// OldBirthday returns the old "birthday" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldBirthday(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBirthday is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBirthday requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirthday: %w", err)
	}
	return oldValue.Birthday, nil
}

// ClearBirthday clears the value of the "birthday" field.
func (m *ActivityMutation) ClearBirthday() {
	m.birthday = nil
	m.clearedFields[activity.FieldBirthday] = struct{}{}
}

// BirthdayCleared returns if the "birthday" field was cleared in this mutation.
func (m *ActivityMutation) BirthdayCleared() bool {
	_, ok := m.clearedFields[activity.FieldBirthday]
	return ok
}

// ResetBirthday resets all changes to the "birthday" field.
func (m *ActivityMutation) ResetBirthday() {
	m.birthday = nil
	delete(m.clearedFields, activity.FieldBirthday)
}

// SetSignRemark sets the "sign_remark" field.
func (m *ActivityMutation) SetSignRemark(s string) {
	m.sign_remark = &s
}

// SignRemark returns the value of the "sign_remark" field in the mutation.
func (m *ActivityMutation) SignRemark() (r string, exists bool) {
	v := m.sign_remark
	if v == nil {
		return
	}
	return *v, true
}

// OldSignRemark returns the old "sign_remark" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldSignRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSignRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSignRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignRemark: %w", err)
	}
	return oldValue.SignRemark, nil
}

// ClearSignRemark clears the value of the "sign_remark" field.
func (m *ActivityMutation) ClearSignRemark() {
	m.sign_remark = nil
	m.clearedFields[activity.FieldSignRemark] = struct{}{}
}

// SignRemarkCleared returns if the "sign_remark" field was cleared in this mutation.
func (m *ActivityMutation) SignRemarkCleared() bool {
	_, ok := m.clearedFields[activity.FieldSignRemark]
	return ok
}

// ResetSignRemark resets all changes to the "sign_remark" field.
func (m *ActivityMutation) ResetSignRemark() {
	m.sign_remark = nil
	delete(m.clearedFields, activity.FieldSignRemark)
}

// SetActivityTypeID sets the "activity_type_id" field.
func (m *ActivityMutation) SetActivityTypeID(i int) {
	m.activity_type = &i
}

// ActivityTypeID returns the value of the "activity_type_id" field in the mutation.
func (m *ActivityMutation) ActivityTypeID() (r int, exists bool) {
	v := m.activity_type
	if v == nil {
		return
	}
	return *v, true
}

// OldActivityTypeID returns the old "activity_type_id" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldActivityTypeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldActivityTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldActivityTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActivityTypeID: %w", err)
	}
	return oldValue.ActivityTypeID, nil
}

// ClearActivityTypeID clears the value of the "activity_type_id" field.
func (m *ActivityMutation) ClearActivityTypeID() {
	m.activity_type = nil
	m.clearedFields[activity.FieldActivityTypeID] = struct{}{}
}

// ActivityTypeIDCleared returns if the "activity_type_id" field was cleared in this mutation.
func (m *ActivityMutation) ActivityTypeIDCleared() bool {
	_, ok := m.clearedFields[activity.FieldActivityTypeID]
	return ok
}

// ResetActivityTypeID resets all changes to the "activity_type_id" field.
func (m *ActivityMutation) ResetActivityTypeID() {
	m.activity_type = nil
	delete(m.clearedFields, activity.FieldActivityTypeID)
}

// SetCreatedAdminID sets the "created_admin_id" field.
func (m *ActivityMutation) SetCreatedAdminID(i int) {
	m.admin = &i
}

// CreatedAdminID returns the value of the "created_admin_id" field in the mutation.
func (m *ActivityMutation) CreatedAdminID() (r int, exists bool) {
	v := m.admin
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAdminID returns the old "created_admin_id" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldCreatedAdminID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAdminID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAdminID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAdminID: %w", err)
	}
	return oldValue.CreatedAdminID, nil
}

// ClearCreatedAdminID clears the value of the "created_admin_id" field.
func (m *ActivityMutation) ClearCreatedAdminID() {
	m.admin = nil
	m.clearedFields[activity.FieldCreatedAdminID] = struct{}{}
}

// CreatedAdminIDCleared returns if the "created_admin_id" field was cleared in this mutation.
func (m *ActivityMutation) CreatedAdminIDCleared() bool {
	_, ok := m.clearedFields[activity.FieldCreatedAdminID]
	return ok
}

// ResetCreatedAdminID resets all changes to the "created_admin_id" field.
func (m *ActivityMutation) ResetCreatedAdminID() {
	m.admin = nil
	delete(m.clearedFields, activity.FieldCreatedAdminID)
}

// ClearActivityType clears the "activity_type" edge to the ActivityType entity.
func (m *ActivityMutation) ClearActivityType() {
	m.clearedactivity_type = true
}

// ActivityTypeCleared reports if the "activity_type" edge to the ActivityType entity was cleared.
func (m *ActivityMutation) ActivityTypeCleared() bool {
	return m.ActivityTypeIDCleared() || m.clearedactivity_type
}

// ActivityTypeIDs returns the "activity_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ActivityTypeID instead. It exists only for internal usage by the builders.
func (m *ActivityMutation) ActivityTypeIDs() (ids []int) {
	if id := m.activity_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetActivityType resets all changes to the "activity_type" edge.
func (m *ActivityMutation) ResetActivityType() {
	m.activity_type = nil
	m.clearedactivity_type = false
}

// AddApplyActivityIDs adds the "apply_activities" edge to the ActivityApplyInfo entity by ids.
func (m *ActivityMutation) AddApplyActivityIDs(ids ...int) {
	if m.apply_activities == nil {
		m.apply_activities = make(map[int]struct{})
	}
	for i := range ids {
		m.apply_activities[ids[i]] = struct{}{}
	}
}

// ClearApplyActivities clears the "apply_activities" edge to the ActivityApplyInfo entity.
func (m *ActivityMutation) ClearApplyActivities() {
	m.clearedapply_activities = true
}

// ApplyActivitiesCleared reports if the "apply_activities" edge to the ActivityApplyInfo entity was cleared.
func (m *ActivityMutation) ApplyActivitiesCleared() bool {
	return m.clearedapply_activities
}

// RemoveApplyActivityIDs removes the "apply_activities" edge to the ActivityApplyInfo entity by IDs.
func (m *ActivityMutation) RemoveApplyActivityIDs(ids ...int) {
	if m.removedapply_activities == nil {
		m.removedapply_activities = make(map[int]struct{})
	}
	for i := range ids {
		m.removedapply_activities[ids[i]] = struct{}{}
	}
}

// RemovedApplyActivities returns the removed IDs of the "apply_activities" edge to the ActivityApplyInfo entity.
func (m *ActivityMutation) RemovedApplyActivitiesIDs() (ids []int) {
	for id := range m.removedapply_activities {
		ids = append(ids, id)
	}
	return
}

// ApplyActivitiesIDs returns the "apply_activities" edge IDs in the mutation.
func (m *ActivityMutation) ApplyActivitiesIDs() (ids []int) {
	for id := range m.apply_activities {
		ids = append(ids, id)
	}
	return
}

// ResetApplyActivities resets all changes to the "apply_activities" edge.
func (m *ActivityMutation) ResetApplyActivities() {
	m.apply_activities = nil
	m.clearedapply_activities = false
	m.removedapply_activities = nil
}

// SetAdminID sets the "admin" edge to the Admin entity by id.
func (m *ActivityMutation) SetAdminID(id int) {
	m.admin = &id
}

// ClearAdmin clears the "admin" edge to the Admin entity.
func (m *ActivityMutation) ClearAdmin() {
	m.clearedadmin = true
}

// AdminCleared reports if the "admin" edge to the Admin entity was cleared.
func (m *ActivityMutation) AdminCleared() bool {
	return m.CreatedAdminIDCleared() || m.clearedadmin
}

// AdminID returns the "admin" edge ID in the mutation.
func (m *ActivityMutation) AdminID() (id int, exists bool) {
	if m.admin != nil {
		return *m.admin, true
	}
	return
}

// AdminIDs returns the "admin" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AdminID instead. It exists only for internal usage by the builders.
func (m *ActivityMutation) AdminIDs() (ids []int) {
	if id := m.admin; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAdmin resets all changes to the "admin" edge.
func (m *ActivityMutation) ResetAdmin() {
	m.admin = nil
	m.clearedadmin = false
}

// Op returns the operation name.
func (m *ActivityMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Activity).
func (m *ActivityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ActivityMutation) Fields() []string {
	fields := make([]string, 0, 26)
	if m.uuid != nil {
		fields = append(fields, activity.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, activity.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, activity.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, activity.FieldDeletedAt)
	}
	if m.title != nil {
		fields = append(fields, activity.FieldTitle)
	}
	if m.sub_title != nil {
		fields = append(fields, activity.FieldSubTitle)
	}
	if m.cover_img_id != nil {
		fields = append(fields, activity.FieldCoverImgID)
	}
	if m.notice != nil {
		fields = append(fields, activity.FieldNotice)
	}
	if m.detail != nil {
		fields = append(fields, activity.FieldDetail)
	}
	if m.place != nil {
		fields = append(fields, activity.FieldPlace)
	}
	if m.is_free != nil {
		fields = append(fields, activity.FieldIsFree)
	}
	if m.is_publish != nil {
		fields = append(fields, activity.FieldIsPublish)
	}
	if m.amount != nil {
		fields = append(fields, activity.FieldAmount)
	}
	if m.start_at != nil {
		fields = append(fields, activity.FieldStartAt)
	}
	if m.end_at != nil {
		fields = append(fields, activity.FieldEndAt)
	}
	if m.apply_start_at != nil {
		fields = append(fields, activity.FieldApplyStartAt)
	}
	if m.apply_end_at != nil {
		fields = append(fields, activity.FieldApplyEndAt)
	}
	if m.is_hot != nil {
		fields = append(fields, activity.FieldIsHot)
	}
	if m.is_auto_publish != nil {
		fields = append(fields, activity.FieldIsAutoPublish)
	}
	if m.apply_count != nil {
		fields = append(fields, activity.FieldApplyCount)
	}
	if m.join_count != nil {
		fields = append(fields, activity.FieldJoinCount)
	}
	if m.is_limit_join_count != nil {
		fields = append(fields, activity.FieldIsLimitJoinCount)
	}
	if m.birthday != nil {
		fields = append(fields, activity.FieldBirthday)
	}
	if m.sign_remark != nil {
		fields = append(fields, activity.FieldSignRemark)
	}
	if m.activity_type != nil {
		fields = append(fields, activity.FieldActivityTypeID)
	}
	if m.admin != nil {
		fields = append(fields, activity.FieldCreatedAdminID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ActivityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case activity.FieldUUID:
		return m.UUID()
	case activity.FieldCreatedAt:
		return m.CreatedAt()
	case activity.FieldUpdatedAt:
		return m.UpdatedAt()
	case activity.FieldDeletedAt:
		return m.DeletedAt()
	case activity.FieldTitle:
		return m.Title()
	case activity.FieldSubTitle:
		return m.SubTitle()
	case activity.FieldCoverImgID:
		return m.CoverImgID()
	case activity.FieldNotice:
		return m.Notice()
	case activity.FieldDetail:
		return m.Detail()
	case activity.FieldPlace:
		return m.Place()
	case activity.FieldIsFree:
		return m.IsFree()
	case activity.FieldIsPublish:
		return m.IsPublish()
	case activity.FieldAmount:
		return m.Amount()
	case activity.FieldStartAt:
		return m.StartAt()
	case activity.FieldEndAt:
		return m.EndAt()
	case activity.FieldApplyStartAt:
		return m.ApplyStartAt()
	case activity.FieldApplyEndAt:
		return m.ApplyEndAt()
	case activity.FieldIsHot:
		return m.IsHot()
	case activity.FieldIsAutoPublish:
		return m.IsAutoPublish()
	case activity.FieldApplyCount:
		return m.ApplyCount()
	case activity.FieldJoinCount:
		return m.JoinCount()
	case activity.FieldIsLimitJoinCount:
		return m.IsLimitJoinCount()
	case activity.FieldBirthday:
		return m.Birthday()
	case activity.FieldSignRemark:
		return m.SignRemark()
	case activity.FieldActivityTypeID:
		return m.ActivityTypeID()
	case activity.FieldCreatedAdminID:
		return m.CreatedAdminID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ActivityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case activity.FieldUUID:
		return m.OldUUID(ctx)
	case activity.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case activity.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case activity.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case activity.FieldTitle:
		return m.OldTitle(ctx)
	case activity.FieldSubTitle:
		return m.OldSubTitle(ctx)
	case activity.FieldCoverImgID:
		return m.OldCoverImgID(ctx)
	case activity.FieldNotice:
		return m.OldNotice(ctx)
	case activity.FieldDetail:
		return m.OldDetail(ctx)
	case activity.FieldPlace:
		return m.OldPlace(ctx)
	case activity.FieldIsFree:
		return m.OldIsFree(ctx)
	case activity.FieldIsPublish:
		return m.OldIsPublish(ctx)
	case activity.FieldAmount:
		return m.OldAmount(ctx)
	case activity.FieldStartAt:
		return m.OldStartAt(ctx)
	case activity.FieldEndAt:
		return m.OldEndAt(ctx)
	case activity.FieldApplyStartAt:
		return m.OldApplyStartAt(ctx)
	case activity.FieldApplyEndAt:
		return m.OldApplyEndAt(ctx)
	case activity.FieldIsHot:
		return m.OldIsHot(ctx)
	case activity.FieldIsAutoPublish:
		return m.OldIsAutoPublish(ctx)
	case activity.FieldApplyCount:
		return m.OldApplyCount(ctx)
	case activity.FieldJoinCount:
		return m.OldJoinCount(ctx)
	case activity.FieldIsLimitJoinCount:
		return m.OldIsLimitJoinCount(ctx)
	case activity.FieldBirthday:
		return m.OldBirthday(ctx)
	case activity.FieldSignRemark:
		return m.OldSignRemark(ctx)
	case activity.FieldActivityTypeID:
		return m.OldActivityTypeID(ctx)
	case activity.FieldCreatedAdminID:
		return m.OldCreatedAdminID(ctx)
	}
	return nil, fmt.Errorf("unknown Activity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActivityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case activity.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case activity.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case activity.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case activity.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case activity.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case activity.FieldSubTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubTitle(v)
		return nil
	case activity.FieldCoverImgID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoverImgID(v)
		return nil
	case activity.FieldNotice:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotice(v)
		return nil
	case activity.FieldDetail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetail(v)
		return nil
	case activity.FieldPlace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlace(v)
		return nil
	case activity.FieldIsFree:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsFree(v)
		return nil
	case activity.FieldIsPublish:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPublish(v)
		return nil
	case activity.FieldAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case activity.FieldStartAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAt(v)
		return nil
	case activity.FieldEndAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndAt(v)
		return nil
	case activity.FieldApplyStartAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplyStartAt(v)
		return nil
	case activity.FieldApplyEndAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplyEndAt(v)
		return nil
	case activity.FieldIsHot:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsHot(v)
		return nil
	case activity.FieldIsAutoPublish:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsAutoPublish(v)
		return nil
	case activity.FieldApplyCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplyCount(v)
		return nil
	case activity.FieldJoinCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJoinCount(v)
		return nil
	case activity.FieldIsLimitJoinCount:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsLimitJoinCount(v)
		return nil
	case activity.FieldBirthday:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirthday(v)
		return nil
	case activity.FieldSignRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignRemark(v)
		return nil
	case activity.FieldActivityTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActivityTypeID(v)
		return nil
	case activity.FieldCreatedAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAdminID(v)
		return nil
	}
	return fmt.Errorf("unknown Activity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ActivityMutation) AddedFields() []string {
	var fields []string
	if m.addcover_img_id != nil {
		fields = append(fields, activity.FieldCoverImgID)
	}
	if m.addis_free != nil {
		fields = append(fields, activity.FieldIsFree)
	}
	if m.addis_publish != nil {
		fields = append(fields, activity.FieldIsPublish)
	}
	if m.addamount != nil {
		fields = append(fields, activity.FieldAmount)
	}
	if m.addis_hot != nil {
		fields = append(fields, activity.FieldIsHot)
	}
	if m.addis_auto_publish != nil {
		fields = append(fields, activity.FieldIsAutoPublish)
	}
	if m.addapply_count != nil {
		fields = append(fields, activity.FieldApplyCount)
	}
	if m.addjoin_count != nil {
		fields = append(fields, activity.FieldJoinCount)
	}
	if m.addis_limit_join_count != nil {
		fields = append(fields, activity.FieldIsLimitJoinCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ActivityMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case activity.FieldCoverImgID:
		return m.AddedCoverImgID()
	case activity.FieldIsFree:
		return m.AddedIsFree()
	case activity.FieldIsPublish:
		return m.AddedIsPublish()
	case activity.FieldAmount:
		return m.AddedAmount()
	case activity.FieldIsHot:
		return m.AddedIsHot()
	case activity.FieldIsAutoPublish:
		return m.AddedIsAutoPublish()
	case activity.FieldApplyCount:
		return m.AddedApplyCount()
	case activity.FieldJoinCount:
		return m.AddedJoinCount()
	case activity.FieldIsLimitJoinCount:
		return m.AddedIsLimitJoinCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActivityMutation) AddField(name string, value ent.Value) error {
	switch name {
	case activity.FieldCoverImgID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCoverImgID(v)
		return nil
	case activity.FieldIsFree:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsFree(v)
		return nil
	case activity.FieldIsPublish:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsPublish(v)
		return nil
	case activity.FieldAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case activity.FieldIsHot:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsHot(v)
		return nil
	case activity.FieldIsAutoPublish:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsAutoPublish(v)
		return nil
	case activity.FieldApplyCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddApplyCount(v)
		return nil
	case activity.FieldJoinCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddJoinCount(v)
		return nil
	case activity.FieldIsLimitJoinCount:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsLimitJoinCount(v)
		return nil
	}
	return fmt.Errorf("unknown Activity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ActivityMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(activity.FieldCreatedAt) {
		fields = append(fields, activity.FieldCreatedAt)
	}
	if m.FieldCleared(activity.FieldUpdatedAt) {
		fields = append(fields, activity.FieldUpdatedAt)
	}
	if m.FieldCleared(activity.FieldDeletedAt) {
		fields = append(fields, activity.FieldDeletedAt)
	}
	if m.FieldCleared(activity.FieldNotice) {
		fields = append(fields, activity.FieldNotice)
	}
	if m.FieldCleared(activity.FieldDetail) {
		fields = append(fields, activity.FieldDetail)
	}
	if m.FieldCleared(activity.FieldStartAt) {
		fields = append(fields, activity.FieldStartAt)
	}
	if m.FieldCleared(activity.FieldEndAt) {
		fields = append(fields, activity.FieldEndAt)
	}
	if m.FieldCleared(activity.FieldApplyStartAt) {
		fields = append(fields, activity.FieldApplyStartAt)
	}
	if m.FieldCleared(activity.FieldApplyEndAt) {
		fields = append(fields, activity.FieldApplyEndAt)
	}
	if m.FieldCleared(activity.FieldBirthday) {
		fields = append(fields, activity.FieldBirthday)
	}
	if m.FieldCleared(activity.FieldSignRemark) {
		fields = append(fields, activity.FieldSignRemark)
	}
	if m.FieldCleared(activity.FieldActivityTypeID) {
		fields = append(fields, activity.FieldActivityTypeID)
	}
	if m.FieldCleared(activity.FieldCreatedAdminID) {
		fields = append(fields, activity.FieldCreatedAdminID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ActivityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ActivityMutation) ClearField(name string) error {
	switch name {
	case activity.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case activity.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case activity.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case activity.FieldNotice:
		m.ClearNotice()
		return nil
	case activity.FieldDetail:
		m.ClearDetail()
		return nil
	case activity.FieldStartAt:
		m.ClearStartAt()
		return nil
	case activity.FieldEndAt:
		m.ClearEndAt()
		return nil
	case activity.FieldApplyStartAt:
		m.ClearApplyStartAt()
		return nil
	case activity.FieldApplyEndAt:
		m.ClearApplyEndAt()
		return nil
	case activity.FieldBirthday:
		m.ClearBirthday()
		return nil
	case activity.FieldSignRemark:
		m.ClearSignRemark()
		return nil
	case activity.FieldActivityTypeID:
		m.ClearActivityTypeID()
		return nil
	case activity.FieldCreatedAdminID:
		m.ClearCreatedAdminID()
		return nil
	}
	return fmt.Errorf("unknown Activity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ActivityMutation) ResetField(name string) error {
	switch name {
	case activity.FieldUUID:
		m.ResetUUID()
		return nil
	case activity.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case activity.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case activity.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case activity.FieldTitle:
		m.ResetTitle()
		return nil
	case activity.FieldSubTitle:
		m.ResetSubTitle()
		return nil
	case activity.FieldCoverImgID:
		m.ResetCoverImgID()
		return nil
	case activity.FieldNotice:
		m.ResetNotice()
		return nil
	case activity.FieldDetail:
		m.ResetDetail()
		return nil
	case activity.FieldPlace:
		m.ResetPlace()
		return nil
	case activity.FieldIsFree:
		m.ResetIsFree()
		return nil
	case activity.FieldIsPublish:
		m.ResetIsPublish()
		return nil
	case activity.FieldAmount:
		m.ResetAmount()
		return nil
	case activity.FieldStartAt:
		m.ResetStartAt()
		return nil
	case activity.FieldEndAt:
		m.ResetEndAt()
		return nil
	case activity.FieldApplyStartAt:
		m.ResetApplyStartAt()
		return nil
	case activity.FieldApplyEndAt:
		m.ResetApplyEndAt()
		return nil
	case activity.FieldIsHot:
		m.ResetIsHot()
		return nil
	case activity.FieldIsAutoPublish:
		m.ResetIsAutoPublish()
		return nil
	case activity.FieldApplyCount:
		m.ResetApplyCount()
		return nil
	case activity.FieldJoinCount:
		m.ResetJoinCount()
		return nil
	case activity.FieldIsLimitJoinCount:
		m.ResetIsLimitJoinCount()
		return nil
	case activity.FieldBirthday:
		m.ResetBirthday()
		return nil
	case activity.FieldSignRemark:
		m.ResetSignRemark()
		return nil
	case activity.FieldActivityTypeID:
		m.ResetActivityTypeID()
		return nil
	case activity.FieldCreatedAdminID:
		m.ResetCreatedAdminID()
		return nil
	}
	return fmt.Errorf("unknown Activity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ActivityMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.activity_type != nil {
		edges = append(edges, activity.EdgeActivityType)
	}
	if m.apply_activities != nil {
		edges = append(edges, activity.EdgeApplyActivities)
	}
	if m.admin != nil {
		edges = append(edges, activity.EdgeAdmin)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ActivityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case activity.EdgeActivityType:
		if id := m.activity_type; id != nil {
			return []ent.Value{*id}
		}
	case activity.EdgeApplyActivities:
		ids := make([]ent.Value, 0, len(m.apply_activities))
		for id := range m.apply_activities {
			ids = append(ids, id)
		}
		return ids
	case activity.EdgeAdmin:
		if id := m.admin; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ActivityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedapply_activities != nil {
		edges = append(edges, activity.EdgeApplyActivities)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ActivityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case activity.EdgeApplyActivities:
		ids := make([]ent.Value, 0, len(m.removedapply_activities))
		for id := range m.removedapply_activities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ActivityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedactivity_type {
		edges = append(edges, activity.EdgeActivityType)
	}
	if m.clearedapply_activities {
		edges = append(edges, activity.EdgeApplyActivities)
	}
	if m.clearedadmin {
		edges = append(edges, activity.EdgeAdmin)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ActivityMutation) EdgeCleared(name string) bool {
	switch name {
	case activity.EdgeActivityType:
		return m.clearedactivity_type
	case activity.EdgeApplyActivities:
		return m.clearedapply_activities
	case activity.EdgeAdmin:
		return m.clearedadmin
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ActivityMutation) ClearEdge(name string) error {
	switch name {
	case activity.EdgeActivityType:
		m.ClearActivityType()
		return nil
	case activity.EdgeAdmin:
		m.ClearAdmin()
		return nil
	}
	return fmt.Errorf("unknown Activity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ActivityMutation) ResetEdge(name string) error {
	switch name {
	case activity.EdgeActivityType:
		m.ResetActivityType()
		return nil
	case activity.EdgeApplyActivities:
		m.ResetApplyActivities()
		return nil
	case activity.EdgeAdmin:
		m.ResetAdmin()
		return nil
	}
	return fmt.Errorf("unknown Activity edge %s", name)
}

// ActivityApplyInfoMutation represents an operation that mutates the ActivityApplyInfo nodes in the graph.
type ActivityApplyInfoMutation struct {
	config
	op                Op
	typ               string
	id                *int
	uuid              *string
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	name              *string
	phone             *string
	remark            *string
	is_our_student    *uint8
	addis_our_student *uint8
	clearedFields     map[string]struct{}
	activity          *int
	clearedactivity   bool
	done              bool
	oldValue          func(context.Context) (*ActivityApplyInfo, error)
	predicates        []predicate.ActivityApplyInfo
}

var _ ent.Mutation = (*ActivityApplyInfoMutation)(nil)

// activityapplyinfoOption allows management of the mutation configuration using functional options.
type activityapplyinfoOption func(*ActivityApplyInfoMutation)

// newActivityApplyInfoMutation creates new mutation for the ActivityApplyInfo entity.
func newActivityApplyInfoMutation(c config, op Op, opts ...activityapplyinfoOption) *ActivityApplyInfoMutation {
	m := &ActivityApplyInfoMutation{
		config:        c,
		op:            op,
		typ:           TypeActivityApplyInfo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withActivityApplyInfoID sets the ID field of the mutation.
func withActivityApplyInfoID(id int) activityapplyinfoOption {
	return func(m *ActivityApplyInfoMutation) {
		var (
			err   error
			once  sync.Once
			value *ActivityApplyInfo
		)
		m.oldValue = func(ctx context.Context) (*ActivityApplyInfo, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ActivityApplyInfo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withActivityApplyInfo sets the old ActivityApplyInfo of the mutation.
func withActivityApplyInfo(node *ActivityApplyInfo) activityapplyinfoOption {
	return func(m *ActivityApplyInfoMutation) {
		m.oldValue = func(context.Context) (*ActivityApplyInfo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ActivityApplyInfoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ActivityApplyInfoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *ActivityApplyInfoMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *ActivityApplyInfoMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *ActivityApplyInfoMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the ActivityApplyInfo entity.
// If the ActivityApplyInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityApplyInfoMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *ActivityApplyInfoMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ActivityApplyInfoMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ActivityApplyInfoMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ActivityApplyInfo entity.
// If the ActivityApplyInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityApplyInfoMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *ActivityApplyInfoMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[activityapplyinfo.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *ActivityApplyInfoMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[activityapplyinfo.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ActivityApplyInfoMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, activityapplyinfo.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ActivityApplyInfoMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ActivityApplyInfoMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ActivityApplyInfo entity.
// If the ActivityApplyInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityApplyInfoMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *ActivityApplyInfoMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[activityapplyinfo.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *ActivityApplyInfoMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[activityapplyinfo.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ActivityApplyInfoMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, activityapplyinfo.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ActivityApplyInfoMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ActivityApplyInfoMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ActivityApplyInfo entity.
// If the ActivityApplyInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityApplyInfoMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ActivityApplyInfoMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[activityapplyinfo.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ActivityApplyInfoMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[activityapplyinfo.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ActivityApplyInfoMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, activityapplyinfo.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *ActivityApplyInfoMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ActivityApplyInfoMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ActivityApplyInfo entity.
// If the ActivityApplyInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityApplyInfoMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ActivityApplyInfoMutation) ResetName() {
	m.name = nil
}

// SetPhone sets the "phone" field.
func (m *ActivityApplyInfoMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *ActivityApplyInfoMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the ActivityApplyInfo entity.
// If the ActivityApplyInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityApplyInfoMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *ActivityApplyInfoMutation) ResetPhone() {
	m.phone = nil
}

// SetRemark sets the "remark" field.
func (m *ActivityApplyInfoMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *ActivityApplyInfoMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the ActivityApplyInfo entity.
// If the ActivityApplyInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityApplyInfoMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ResetRemark resets all changes to the "remark" field.
func (m *ActivityApplyInfoMutation) ResetRemark() {
	m.remark = nil
}

// SetIsOurStudent sets the "is_our_student" field.
func (m *ActivityApplyInfoMutation) SetIsOurStudent(u uint8) {
	m.is_our_student = &u
	m.addis_our_student = nil
}

// IsOurStudent returns the value of the "is_our_student" field in the mutation.
func (m *ActivityApplyInfoMutation) IsOurStudent() (r uint8, exists bool) {
	v := m.is_our_student
	if v == nil {
		return
	}
	return *v, true
}

// OldIsOurStudent returns the old "is_our_student" field's value of the ActivityApplyInfo entity.
// If the ActivityApplyInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityApplyInfoMutation) OldIsOurStudent(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsOurStudent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsOurStudent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsOurStudent: %w", err)
	}
	return oldValue.IsOurStudent, nil
}

// AddIsOurStudent adds u to the "is_our_student" field.
func (m *ActivityApplyInfoMutation) AddIsOurStudent(u uint8) {
	if m.addis_our_student != nil {
		*m.addis_our_student += u
	} else {
		m.addis_our_student = &u
	}
}

// AddedIsOurStudent returns the value that was added to the "is_our_student" field in this mutation.
func (m *ActivityApplyInfoMutation) AddedIsOurStudent() (r uint8, exists bool) {
	v := m.addis_our_student
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsOurStudent resets all changes to the "is_our_student" field.
func (m *ActivityApplyInfoMutation) ResetIsOurStudent() {
	m.is_our_student = nil
	m.addis_our_student = nil
}

// SetActivityID sets the "activity_id" field.
func (m *ActivityApplyInfoMutation) SetActivityID(i int) {
	m.activity = &i
}

// ActivityID returns the value of the "activity_id" field in the mutation.
func (m *ActivityApplyInfoMutation) ActivityID() (r int, exists bool) {
	v := m.activity
	if v == nil {
		return
	}
	return *v, true
}

// OldActivityID returns the old "activity_id" field's value of the ActivityApplyInfo entity.
// If the ActivityApplyInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityApplyInfoMutation) OldActivityID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldActivityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldActivityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActivityID: %w", err)
	}
	return oldValue.ActivityID, nil
}

// ClearActivityID clears the value of the "activity_id" field.
func (m *ActivityApplyInfoMutation) ClearActivityID() {
	m.activity = nil
	m.clearedFields[activityapplyinfo.FieldActivityID] = struct{}{}
}

// ActivityIDCleared returns if the "activity_id" field was cleared in this mutation.
func (m *ActivityApplyInfoMutation) ActivityIDCleared() bool {
	_, ok := m.clearedFields[activityapplyinfo.FieldActivityID]
	return ok
}

// ResetActivityID resets all changes to the "activity_id" field.
func (m *ActivityApplyInfoMutation) ResetActivityID() {
	m.activity = nil
	delete(m.clearedFields, activityapplyinfo.FieldActivityID)
}

// ClearActivity clears the "activity" edge to the Activity entity.
func (m *ActivityApplyInfoMutation) ClearActivity() {
	m.clearedactivity = true
}

// ActivityCleared reports if the "activity" edge to the Activity entity was cleared.
func (m *ActivityApplyInfoMutation) ActivityCleared() bool {
	return m.ActivityIDCleared() || m.clearedactivity
}

// ActivityIDs returns the "activity" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ActivityID instead. It exists only for internal usage by the builders.
func (m *ActivityApplyInfoMutation) ActivityIDs() (ids []int) {
	if id := m.activity; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetActivity resets all changes to the "activity" edge.
func (m *ActivityApplyInfoMutation) ResetActivity() {
	m.activity = nil
	m.clearedactivity = false
}

// Op returns the operation name.
func (m *ActivityApplyInfoMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ActivityApplyInfo).
func (m *ActivityApplyInfoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ActivityApplyInfoMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.uuid != nil {
		fields = append(fields, activityapplyinfo.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, activityapplyinfo.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, activityapplyinfo.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, activityapplyinfo.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, activityapplyinfo.FieldName)
	}
	if m.phone != nil {
		fields = append(fields, activityapplyinfo.FieldPhone)
	}
	if m.remark != nil {
		fields = append(fields, activityapplyinfo.FieldRemark)
	}
	if m.is_our_student != nil {
		fields = append(fields, activityapplyinfo.FieldIsOurStudent)
	}
	if m.activity != nil {
		fields = append(fields, activityapplyinfo.FieldActivityID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ActivityApplyInfoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case activityapplyinfo.FieldUUID:
		return m.UUID()
	case activityapplyinfo.FieldCreatedAt:
		return m.CreatedAt()
	case activityapplyinfo.FieldUpdatedAt:
		return m.UpdatedAt()
	case activityapplyinfo.FieldDeletedAt:
		return m.DeletedAt()
	case activityapplyinfo.FieldName:
		return m.Name()
	case activityapplyinfo.FieldPhone:
		return m.Phone()
	case activityapplyinfo.FieldRemark:
		return m.Remark()
	case activityapplyinfo.FieldIsOurStudent:
		return m.IsOurStudent()
	case activityapplyinfo.FieldActivityID:
		return m.ActivityID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ActivityApplyInfoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case activityapplyinfo.FieldUUID:
		return m.OldUUID(ctx)
	case activityapplyinfo.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case activityapplyinfo.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case activityapplyinfo.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case activityapplyinfo.FieldName:
		return m.OldName(ctx)
	case activityapplyinfo.FieldPhone:
		return m.OldPhone(ctx)
	case activityapplyinfo.FieldRemark:
		return m.OldRemark(ctx)
	case activityapplyinfo.FieldIsOurStudent:
		return m.OldIsOurStudent(ctx)
	case activityapplyinfo.FieldActivityID:
		return m.OldActivityID(ctx)
	}
	return nil, fmt.Errorf("unknown ActivityApplyInfo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActivityApplyInfoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case activityapplyinfo.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case activityapplyinfo.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case activityapplyinfo.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case activityapplyinfo.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case activityapplyinfo.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case activityapplyinfo.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case activityapplyinfo.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case activityapplyinfo.FieldIsOurStudent:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsOurStudent(v)
		return nil
	case activityapplyinfo.FieldActivityID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActivityID(v)
		return nil
	}
	return fmt.Errorf("unknown ActivityApplyInfo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ActivityApplyInfoMutation) AddedFields() []string {
	var fields []string
	if m.addis_our_student != nil {
		fields = append(fields, activityapplyinfo.FieldIsOurStudent)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ActivityApplyInfoMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case activityapplyinfo.FieldIsOurStudent:
		return m.AddedIsOurStudent()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActivityApplyInfoMutation) AddField(name string, value ent.Value) error {
	switch name {
	case activityapplyinfo.FieldIsOurStudent:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsOurStudent(v)
		return nil
	}
	return fmt.Errorf("unknown ActivityApplyInfo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ActivityApplyInfoMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(activityapplyinfo.FieldCreatedAt) {
		fields = append(fields, activityapplyinfo.FieldCreatedAt)
	}
	if m.FieldCleared(activityapplyinfo.FieldUpdatedAt) {
		fields = append(fields, activityapplyinfo.FieldUpdatedAt)
	}
	if m.FieldCleared(activityapplyinfo.FieldDeletedAt) {
		fields = append(fields, activityapplyinfo.FieldDeletedAt)
	}
	if m.FieldCleared(activityapplyinfo.FieldActivityID) {
		fields = append(fields, activityapplyinfo.FieldActivityID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ActivityApplyInfoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ActivityApplyInfoMutation) ClearField(name string) error {
	switch name {
	case activityapplyinfo.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case activityapplyinfo.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case activityapplyinfo.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case activityapplyinfo.FieldActivityID:
		m.ClearActivityID()
		return nil
	}
	return fmt.Errorf("unknown ActivityApplyInfo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ActivityApplyInfoMutation) ResetField(name string) error {
	switch name {
	case activityapplyinfo.FieldUUID:
		m.ResetUUID()
		return nil
	case activityapplyinfo.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case activityapplyinfo.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case activityapplyinfo.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case activityapplyinfo.FieldName:
		m.ResetName()
		return nil
	case activityapplyinfo.FieldPhone:
		m.ResetPhone()
		return nil
	case activityapplyinfo.FieldRemark:
		m.ResetRemark()
		return nil
	case activityapplyinfo.FieldIsOurStudent:
		m.ResetIsOurStudent()
		return nil
	case activityapplyinfo.FieldActivityID:
		m.ResetActivityID()
		return nil
	}
	return fmt.Errorf("unknown ActivityApplyInfo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ActivityApplyInfoMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.activity != nil {
		edges = append(edges, activityapplyinfo.EdgeActivity)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ActivityApplyInfoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case activityapplyinfo.EdgeActivity:
		if id := m.activity; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ActivityApplyInfoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ActivityApplyInfoMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ActivityApplyInfoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedactivity {
		edges = append(edges, activityapplyinfo.EdgeActivity)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ActivityApplyInfoMutation) EdgeCleared(name string) bool {
	switch name {
	case activityapplyinfo.EdgeActivity:
		return m.clearedactivity
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ActivityApplyInfoMutation) ClearEdge(name string) error {
	switch name {
	case activityapplyinfo.EdgeActivity:
		m.ClearActivity()
		return nil
	}
	return fmt.Errorf("unknown ActivityApplyInfo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ActivityApplyInfoMutation) ResetEdge(name string) error {
	switch name {
	case activityapplyinfo.EdgeActivity:
		m.ResetActivity()
		return nil
	}
	return fmt.Errorf("unknown ActivityApplyInfo edge %s", name)
}

// ActivityTypeMutation represents an operation that mutates the ActivityType nodes in the graph.
type ActivityTypeMutation struct {
	config
	op                Op
	typ               string
	id                *int
	uuid              *string
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	name              *string
	status            *uint8
	addstatus         *uint8
	clearedFields     map[string]struct{}
	activities        map[int]struct{}
	removedactivities map[int]struct{}
	clearedactivities bool
	done              bool
	oldValue          func(context.Context) (*ActivityType, error)
	predicates        []predicate.ActivityType
}

var _ ent.Mutation = (*ActivityTypeMutation)(nil)

// activitytypeOption allows management of the mutation configuration using functional options.
type activitytypeOption func(*ActivityTypeMutation)

// newActivityTypeMutation creates new mutation for the ActivityType entity.
func newActivityTypeMutation(c config, op Op, opts ...activitytypeOption) *ActivityTypeMutation {
	m := &ActivityTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeActivityType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withActivityTypeID sets the ID field of the mutation.
func withActivityTypeID(id int) activitytypeOption {
	return func(m *ActivityTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *ActivityType
		)
		m.oldValue = func(ctx context.Context) (*ActivityType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ActivityType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withActivityType sets the old ActivityType of the mutation.
func withActivityType(node *ActivityType) activitytypeOption {
	return func(m *ActivityTypeMutation) {
		m.oldValue = func(context.Context) (*ActivityType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ActivityTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ActivityTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *ActivityTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *ActivityTypeMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *ActivityTypeMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the ActivityType entity.
// If the ActivityType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityTypeMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *ActivityTypeMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ActivityTypeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ActivityTypeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ActivityType entity.
// If the ActivityType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityTypeMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *ActivityTypeMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[activitytype.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *ActivityTypeMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[activitytype.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ActivityTypeMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, activitytype.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ActivityTypeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ActivityTypeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ActivityType entity.
// If the ActivityType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityTypeMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *ActivityTypeMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[activitytype.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *ActivityTypeMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[activitytype.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ActivityTypeMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, activitytype.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ActivityTypeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ActivityTypeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ActivityType entity.
// If the ActivityType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityTypeMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ActivityTypeMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[activitytype.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ActivityTypeMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[activitytype.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ActivityTypeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, activitytype.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *ActivityTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ActivityTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ActivityType entity.
// If the ActivityType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ActivityTypeMutation) ResetName() {
	m.name = nil
}

// SetStatus sets the "status" field.
func (m *ActivityTypeMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *ActivityTypeMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ActivityType entity.
// If the ActivityType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityTypeMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *ActivityTypeMutation) AddStatus(u uint8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *ActivityTypeMutation) AddedStatus() (r uint8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *ActivityTypeMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// AddActivityIDs adds the "activities" edge to the Activity entity by ids.
func (m *ActivityTypeMutation) AddActivityIDs(ids ...int) {
	if m.activities == nil {
		m.activities = make(map[int]struct{})
	}
	for i := range ids {
		m.activities[ids[i]] = struct{}{}
	}
}

// ClearActivities clears the "activities" edge to the Activity entity.
func (m *ActivityTypeMutation) ClearActivities() {
	m.clearedactivities = true
}

// ActivitiesCleared reports if the "activities" edge to the Activity entity was cleared.
func (m *ActivityTypeMutation) ActivitiesCleared() bool {
	return m.clearedactivities
}

// RemoveActivityIDs removes the "activities" edge to the Activity entity by IDs.
func (m *ActivityTypeMutation) RemoveActivityIDs(ids ...int) {
	if m.removedactivities == nil {
		m.removedactivities = make(map[int]struct{})
	}
	for i := range ids {
		m.removedactivities[ids[i]] = struct{}{}
	}
}

// RemovedActivities returns the removed IDs of the "activities" edge to the Activity entity.
func (m *ActivityTypeMutation) RemovedActivitiesIDs() (ids []int) {
	for id := range m.removedactivities {
		ids = append(ids, id)
	}
	return
}

// ActivitiesIDs returns the "activities" edge IDs in the mutation.
func (m *ActivityTypeMutation) ActivitiesIDs() (ids []int) {
	for id := range m.activities {
		ids = append(ids, id)
	}
	return
}

// ResetActivities resets all changes to the "activities" edge.
func (m *ActivityTypeMutation) ResetActivities() {
	m.activities = nil
	m.clearedactivities = false
	m.removedactivities = nil
}

// Op returns the operation name.
func (m *ActivityTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ActivityType).
func (m *ActivityTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ActivityTypeMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.uuid != nil {
		fields = append(fields, activitytype.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, activitytype.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, activitytype.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, activitytype.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, activitytype.FieldName)
	}
	if m.status != nil {
		fields = append(fields, activitytype.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ActivityTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case activitytype.FieldUUID:
		return m.UUID()
	case activitytype.FieldCreatedAt:
		return m.CreatedAt()
	case activitytype.FieldUpdatedAt:
		return m.UpdatedAt()
	case activitytype.FieldDeletedAt:
		return m.DeletedAt()
	case activitytype.FieldName:
		return m.Name()
	case activitytype.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ActivityTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case activitytype.FieldUUID:
		return m.OldUUID(ctx)
	case activitytype.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case activitytype.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case activitytype.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case activitytype.FieldName:
		return m.OldName(ctx)
	case activitytype.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown ActivityType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActivityTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case activitytype.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case activitytype.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case activitytype.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case activitytype.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case activitytype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case activitytype.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown ActivityType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ActivityTypeMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, activitytype.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ActivityTypeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case activitytype.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActivityTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case activitytype.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown ActivityType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ActivityTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(activitytype.FieldCreatedAt) {
		fields = append(fields, activitytype.FieldCreatedAt)
	}
	if m.FieldCleared(activitytype.FieldUpdatedAt) {
		fields = append(fields, activitytype.FieldUpdatedAt)
	}
	if m.FieldCleared(activitytype.FieldDeletedAt) {
		fields = append(fields, activitytype.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ActivityTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ActivityTypeMutation) ClearField(name string) error {
	switch name {
	case activitytype.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case activitytype.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case activitytype.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown ActivityType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ActivityTypeMutation) ResetField(name string) error {
	switch name {
	case activitytype.FieldUUID:
		m.ResetUUID()
		return nil
	case activitytype.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case activitytype.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case activitytype.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case activitytype.FieldName:
		m.ResetName()
		return nil
	case activitytype.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown ActivityType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ActivityTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.activities != nil {
		edges = append(edges, activitytype.EdgeActivities)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ActivityTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case activitytype.EdgeActivities:
		ids := make([]ent.Value, 0, len(m.activities))
		for id := range m.activities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ActivityTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedactivities != nil {
		edges = append(edges, activitytype.EdgeActivities)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ActivityTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case activitytype.EdgeActivities:
		ids := make([]ent.Value, 0, len(m.removedactivities))
		for id := range m.removedactivities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ActivityTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedactivities {
		edges = append(edges, activitytype.EdgeActivities)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ActivityTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case activitytype.EdgeActivities:
		return m.clearedactivities
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ActivityTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ActivityType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ActivityTypeMutation) ResetEdge(name string) error {
	switch name {
	case activitytype.EdgeActivities:
		m.ResetActivities()
		return nil
	}
	return fmt.Errorf("unknown ActivityType edge %s", name)
}

// AdminMutation represents an operation that mutates the Admin nodes in the graph.
type AdminMutation struct {
	config
	op                              Op
	typ                             string
	id                              *int
	uuid                            *string
	created_at                      *time.Time
	updated_at                      *time.Time
	deleted_at                      *time.Time
	password                        *string
	salt                            *string
	boss_admin_id                   *int
	addboss_admin_id                *int
	real_name                       *string
	email                           *string
	phone                           *string
	third_openid                    *string
	platform                        *uint8
	addplatform                     *uint8
	is_active                       *uint8
	addis_active                    *uint8
	status                          *uint8
	addstatus                       *uint8
	_Remark                         *string
	clearedFields                   map[string]struct{}
	admin_login_logs                map[int]struct{}
	removedadmin_login_logs         map[int]struct{}
	clearedadmin_login_logs         bool
	operation_admin_logs            map[int]struct{}
	removedoperation_admin_logs     map[int]struct{}
	clearedoperation_admin_logs     bool
	roles                           map[int]struct{}
	removedroles                    map[int]struct{}
	clearedroles                    bool
	activities                      map[int]struct{}
	removedactivities               map[int]struct{}
	clearedactivities               bool
	message_created_admin_id        map[int]struct{}
	removedmessage_created_admin_id map[int]struct{}
	clearedmessage_created_admin_id bool
	admin_question_banks            map[int]struct{}
	removedadmin_question_banks     map[int]struct{}
	clearedadmin_question_banks     bool
	admin_Questions                 map[int]struct{}
	removedadmin_Questions          map[int]struct{}
	clearedadmin_Questions          bool
	admin_exam_papers               map[int]struct{}
	removedadmin_exam_papers        map[int]struct{}
	clearedadmin_exam_papers        bool
	admin_error_feedbacks           map[int]struct{}
	removedadmin_error_feedbacks    map[int]struct{}
	clearedadmin_error_feedbacks    bool
	course                          map[int]struct{}
	removedcourse                   map[int]struct{}
	clearedcourse                   bool
	class_admin                     map[int]struct{}
	removedclass_admin              map[int]struct{}
	clearedclass_admin              bool
	admin_attachments               *int
	clearedadmin_attachments        bool
	done                            bool
	oldValue                        func(context.Context) (*Admin, error)
	predicates                      []predicate.Admin
}

var _ ent.Mutation = (*AdminMutation)(nil)

// adminOption allows management of the mutation configuration using functional options.
type adminOption func(*AdminMutation)

// newAdminMutation creates new mutation for the Admin entity.
func newAdminMutation(c config, op Op, opts ...adminOption) *AdminMutation {
	m := &AdminMutation{
		config:        c,
		op:            op,
		typ:           TypeAdmin,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAdminID sets the ID field of the mutation.
func withAdminID(id int) adminOption {
	return func(m *AdminMutation) {
		var (
			err   error
			once  sync.Once
			value *Admin
		)
		m.oldValue = func(ctx context.Context) (*Admin, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Admin.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAdmin sets the old Admin of the mutation.
func withAdmin(node *Admin) adminOption {
	return func(m *AdminMutation) {
		m.oldValue = func(context.Context) (*Admin, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AdminMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AdminMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *AdminMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *AdminMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *AdminMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *AdminMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AdminMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AdminMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *AdminMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[admin.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *AdminMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[admin.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AdminMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, admin.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AdminMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AdminMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *AdminMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[admin.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *AdminMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[admin.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AdminMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, admin.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AdminMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AdminMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AdminMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[admin.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AdminMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[admin.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AdminMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, admin.FieldDeletedAt)
}

// SetPassword sets the "password" field.
func (m *AdminMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *AdminMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *AdminMutation) ResetPassword() {
	m.password = nil
}

// SetSalt sets the "salt" field.
func (m *AdminMutation) SetSalt(s string) {
	m.salt = &s
}

// Salt returns the value of the "salt" field in the mutation.
func (m *AdminMutation) Salt() (r string, exists bool) {
	v := m.salt
	if v == nil {
		return
	}
	return *v, true
}

// OldSalt returns the old "salt" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldSalt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSalt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSalt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSalt: %w", err)
	}
	return oldValue.Salt, nil
}

// ResetSalt resets all changes to the "salt" field.
func (m *AdminMutation) ResetSalt() {
	m.salt = nil
}

// SetBossAdminID sets the "boss_admin_id" field.
func (m *AdminMutation) SetBossAdminID(i int) {
	m.boss_admin_id = &i
	m.addboss_admin_id = nil
}

// BossAdminID returns the value of the "boss_admin_id" field in the mutation.
func (m *AdminMutation) BossAdminID() (r int, exists bool) {
	v := m.boss_admin_id
	if v == nil {
		return
	}
	return *v, true
}

// OldBossAdminID returns the old "boss_admin_id" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldBossAdminID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBossAdminID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBossAdminID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBossAdminID: %w", err)
	}
	return oldValue.BossAdminID, nil
}

// AddBossAdminID adds i to the "boss_admin_id" field.
func (m *AdminMutation) AddBossAdminID(i int) {
	if m.addboss_admin_id != nil {
		*m.addboss_admin_id += i
	} else {
		m.addboss_admin_id = &i
	}
}

// AddedBossAdminID returns the value that was added to the "boss_admin_id" field in this mutation.
func (m *AdminMutation) AddedBossAdminID() (r int, exists bool) {
	v := m.addboss_admin_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetBossAdminID resets all changes to the "boss_admin_id" field.
func (m *AdminMutation) ResetBossAdminID() {
	m.boss_admin_id = nil
	m.addboss_admin_id = nil
}

// SetRealName sets the "real_name" field.
func (m *AdminMutation) SetRealName(s string) {
	m.real_name = &s
}

// RealName returns the value of the "real_name" field in the mutation.
func (m *AdminMutation) RealName() (r string, exists bool) {
	v := m.real_name
	if v == nil {
		return
	}
	return *v, true
}

// OldRealName returns the old "real_name" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldRealName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRealName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRealName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRealName: %w", err)
	}
	return oldValue.RealName, nil
}

// ResetRealName resets all changes to the "real_name" field.
func (m *AdminMutation) ResetRealName() {
	m.real_name = nil
}

// SetEmail sets the "email" field.
func (m *AdminMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *AdminMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *AdminMutation) ResetEmail() {
	m.email = nil
}

// SetPhone sets the "phone" field.
func (m *AdminMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *AdminMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *AdminMutation) ResetPhone() {
	m.phone = nil
}

// SetThirdOpenid sets the "third_openid" field.
func (m *AdminMutation) SetThirdOpenid(s string) {
	m.third_openid = &s
}

// ThirdOpenid returns the value of the "third_openid" field in the mutation.
func (m *AdminMutation) ThirdOpenid() (r string, exists bool) {
	v := m.third_openid
	if v == nil {
		return
	}
	return *v, true
}

// OldThirdOpenid returns the old "third_openid" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldThirdOpenid(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldThirdOpenid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldThirdOpenid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThirdOpenid: %w", err)
	}
	return oldValue.ThirdOpenid, nil
}

// ResetThirdOpenid resets all changes to the "third_openid" field.
func (m *AdminMutation) ResetThirdOpenid() {
	m.third_openid = nil
}

// SetPlatform sets the "platform" field.
func (m *AdminMutation) SetPlatform(u uint8) {
	m.platform = &u
	m.addplatform = nil
}

// Platform returns the value of the "platform" field in the mutation.
func (m *AdminMutation) Platform() (r uint8, exists bool) {
	v := m.platform
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatform returns the old "platform" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldPlatform(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPlatform is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatform: %w", err)
	}
	return oldValue.Platform, nil
}

// AddPlatform adds u to the "platform" field.
func (m *AdminMutation) AddPlatform(u uint8) {
	if m.addplatform != nil {
		*m.addplatform += u
	} else {
		m.addplatform = &u
	}
}

// AddedPlatform returns the value that was added to the "platform" field in this mutation.
func (m *AdminMutation) AddedPlatform() (r uint8, exists bool) {
	v := m.addplatform
	if v == nil {
		return
	}
	return *v, true
}

// ResetPlatform resets all changes to the "platform" field.
func (m *AdminMutation) ResetPlatform() {
	m.platform = nil
	m.addplatform = nil
}

// SetIsActive sets the "is_active" field.
func (m *AdminMutation) SetIsActive(u uint8) {
	m.is_active = &u
	m.addis_active = nil
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *AdminMutation) IsActive() (r uint8, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldIsActive(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// AddIsActive adds u to the "is_active" field.
func (m *AdminMutation) AddIsActive(u uint8) {
	if m.addis_active != nil {
		*m.addis_active += u
	} else {
		m.addis_active = &u
	}
}

// AddedIsActive returns the value that was added to the "is_active" field in this mutation.
func (m *AdminMutation) AddedIsActive() (r uint8, exists bool) {
	v := m.addis_active
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *AdminMutation) ResetIsActive() {
	m.is_active = nil
	m.addis_active = nil
}

// SetStatus sets the "status" field.
func (m *AdminMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *AdminMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *AdminMutation) AddStatus(u uint8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *AdminMutation) AddedStatus() (r uint8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *AdminMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetAdminAvatarID sets the "admin_avatar_id" field.
func (m *AdminMutation) SetAdminAvatarID(i int) {
	m.admin_attachments = &i
}

// AdminAvatarID returns the value of the "admin_avatar_id" field in the mutation.
func (m *AdminMutation) AdminAvatarID() (r int, exists bool) {
	v := m.admin_attachments
	if v == nil {
		return
	}
	return *v, true
}

// OldAdminAvatarID returns the old "admin_avatar_id" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldAdminAvatarID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAdminAvatarID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAdminAvatarID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdminAvatarID: %w", err)
	}
	return oldValue.AdminAvatarID, nil
}

// ClearAdminAvatarID clears the value of the "admin_avatar_id" field.
func (m *AdminMutation) ClearAdminAvatarID() {
	m.admin_attachments = nil
	m.clearedFields[admin.FieldAdminAvatarID] = struct{}{}
}

// AdminAvatarIDCleared returns if the "admin_avatar_id" field was cleared in this mutation.
func (m *AdminMutation) AdminAvatarIDCleared() bool {
	_, ok := m.clearedFields[admin.FieldAdminAvatarID]
	return ok
}

// ResetAdminAvatarID resets all changes to the "admin_avatar_id" field.
func (m *AdminMutation) ResetAdminAvatarID() {
	m.admin_attachments = nil
	delete(m.clearedFields, admin.FieldAdminAvatarID)
}

// SetRemark sets the "Remark" field.
func (m *AdminMutation) SetRemark(s string) {
	m._Remark = &s
}

// Remark returns the value of the "Remark" field in the mutation.
func (m *AdminMutation) Remark() (r string, exists bool) {
	v := m._Remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "Remark" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ResetRemark resets all changes to the "Remark" field.
func (m *AdminMutation) ResetRemark() {
	m._Remark = nil
}

// AddAdminLoginLogIDs adds the "admin_login_logs" edge to the AdminLoginLog entity by ids.
func (m *AdminMutation) AddAdminLoginLogIDs(ids ...int) {
	if m.admin_login_logs == nil {
		m.admin_login_logs = make(map[int]struct{})
	}
	for i := range ids {
		m.admin_login_logs[ids[i]] = struct{}{}
	}
}

// ClearAdminLoginLogs clears the "admin_login_logs" edge to the AdminLoginLog entity.
func (m *AdminMutation) ClearAdminLoginLogs() {
	m.clearedadmin_login_logs = true
}

// AdminLoginLogsCleared reports if the "admin_login_logs" edge to the AdminLoginLog entity was cleared.
func (m *AdminMutation) AdminLoginLogsCleared() bool {
	return m.clearedadmin_login_logs
}

// RemoveAdminLoginLogIDs removes the "admin_login_logs" edge to the AdminLoginLog entity by IDs.
func (m *AdminMutation) RemoveAdminLoginLogIDs(ids ...int) {
	if m.removedadmin_login_logs == nil {
		m.removedadmin_login_logs = make(map[int]struct{})
	}
	for i := range ids {
		m.removedadmin_login_logs[ids[i]] = struct{}{}
	}
}

// RemovedAdminLoginLogs returns the removed IDs of the "admin_login_logs" edge to the AdminLoginLog entity.
func (m *AdminMutation) RemovedAdminLoginLogsIDs() (ids []int) {
	for id := range m.removedadmin_login_logs {
		ids = append(ids, id)
	}
	return
}

// AdminLoginLogsIDs returns the "admin_login_logs" edge IDs in the mutation.
func (m *AdminMutation) AdminLoginLogsIDs() (ids []int) {
	for id := range m.admin_login_logs {
		ids = append(ids, id)
	}
	return
}

// ResetAdminLoginLogs resets all changes to the "admin_login_logs" edge.
func (m *AdminMutation) ResetAdminLoginLogs() {
	m.admin_login_logs = nil
	m.clearedadmin_login_logs = false
	m.removedadmin_login_logs = nil
}

// AddOperationAdminLogIDs adds the "operation_admin_logs" edge to the AdminOperationLog entity by ids.
func (m *AdminMutation) AddOperationAdminLogIDs(ids ...int) {
	if m.operation_admin_logs == nil {
		m.operation_admin_logs = make(map[int]struct{})
	}
	for i := range ids {
		m.operation_admin_logs[ids[i]] = struct{}{}
	}
}

// ClearOperationAdminLogs clears the "operation_admin_logs" edge to the AdminOperationLog entity.
func (m *AdminMutation) ClearOperationAdminLogs() {
	m.clearedoperation_admin_logs = true
}

// OperationAdminLogsCleared reports if the "operation_admin_logs" edge to the AdminOperationLog entity was cleared.
func (m *AdminMutation) OperationAdminLogsCleared() bool {
	return m.clearedoperation_admin_logs
}

// RemoveOperationAdminLogIDs removes the "operation_admin_logs" edge to the AdminOperationLog entity by IDs.
func (m *AdminMutation) RemoveOperationAdminLogIDs(ids ...int) {
	if m.removedoperation_admin_logs == nil {
		m.removedoperation_admin_logs = make(map[int]struct{})
	}
	for i := range ids {
		m.removedoperation_admin_logs[ids[i]] = struct{}{}
	}
}

// RemovedOperationAdminLogs returns the removed IDs of the "operation_admin_logs" edge to the AdminOperationLog entity.
func (m *AdminMutation) RemovedOperationAdminLogsIDs() (ids []int) {
	for id := range m.removedoperation_admin_logs {
		ids = append(ids, id)
	}
	return
}

// OperationAdminLogsIDs returns the "operation_admin_logs" edge IDs in the mutation.
func (m *AdminMutation) OperationAdminLogsIDs() (ids []int) {
	for id := range m.operation_admin_logs {
		ids = append(ids, id)
	}
	return
}

// ResetOperationAdminLogs resets all changes to the "operation_admin_logs" edge.
func (m *AdminMutation) ResetOperationAdminLogs() {
	m.operation_admin_logs = nil
	m.clearedoperation_admin_logs = false
	m.removedoperation_admin_logs = nil
}

// AddRoleIDs adds the "roles" edge to the Role entity by ids.
func (m *AdminMutation) AddRoleIDs(ids ...int) {
	if m.roles == nil {
		m.roles = make(map[int]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the Role entity.
func (m *AdminMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the Role entity was cleared.
func (m *AdminMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the Role entity by IDs.
func (m *AdminMutation) RemoveRoleIDs(ids ...int) {
	if m.removedroles == nil {
		m.removedroles = make(map[int]struct{})
	}
	for i := range ids {
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the Role entity.
func (m *AdminMutation) RemovedRolesIDs() (ids []int) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *AdminMutation) RolesIDs() (ids []int) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *AdminMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// AddActivityIDs adds the "activities" edge to the Activity entity by ids.
func (m *AdminMutation) AddActivityIDs(ids ...int) {
	if m.activities == nil {
		m.activities = make(map[int]struct{})
	}
	for i := range ids {
		m.activities[ids[i]] = struct{}{}
	}
}

// ClearActivities clears the "activities" edge to the Activity entity.
func (m *AdminMutation) ClearActivities() {
	m.clearedactivities = true
}

// ActivitiesCleared reports if the "activities" edge to the Activity entity was cleared.
func (m *AdminMutation) ActivitiesCleared() bool {
	return m.clearedactivities
}

// RemoveActivityIDs removes the "activities" edge to the Activity entity by IDs.
func (m *AdminMutation) RemoveActivityIDs(ids ...int) {
	if m.removedactivities == nil {
		m.removedactivities = make(map[int]struct{})
	}
	for i := range ids {
		m.removedactivities[ids[i]] = struct{}{}
	}
}

// RemovedActivities returns the removed IDs of the "activities" edge to the Activity entity.
func (m *AdminMutation) RemovedActivitiesIDs() (ids []int) {
	for id := range m.removedactivities {
		ids = append(ids, id)
	}
	return
}

// ActivitiesIDs returns the "activities" edge IDs in the mutation.
func (m *AdminMutation) ActivitiesIDs() (ids []int) {
	for id := range m.activities {
		ids = append(ids, id)
	}
	return
}

// ResetActivities resets all changes to the "activities" edge.
func (m *AdminMutation) ResetActivities() {
	m.activities = nil
	m.clearedactivities = false
	m.removedactivities = nil
}

// AddMessageCreatedAdminIDIDs adds the "message_created_admin_id" edge to the Message entity by ids.
func (m *AdminMutation) AddMessageCreatedAdminIDIDs(ids ...int) {
	if m.message_created_admin_id == nil {
		m.message_created_admin_id = make(map[int]struct{})
	}
	for i := range ids {
		m.message_created_admin_id[ids[i]] = struct{}{}
	}
}

// ClearMessageCreatedAdminID clears the "message_created_admin_id" edge to the Message entity.
func (m *AdminMutation) ClearMessageCreatedAdminID() {
	m.clearedmessage_created_admin_id = true
}

// MessageCreatedAdminIDCleared reports if the "message_created_admin_id" edge to the Message entity was cleared.
func (m *AdminMutation) MessageCreatedAdminIDCleared() bool {
	return m.clearedmessage_created_admin_id
}

// RemoveMessageCreatedAdminIDIDs removes the "message_created_admin_id" edge to the Message entity by IDs.
func (m *AdminMutation) RemoveMessageCreatedAdminIDIDs(ids ...int) {
	if m.removedmessage_created_admin_id == nil {
		m.removedmessage_created_admin_id = make(map[int]struct{})
	}
	for i := range ids {
		m.removedmessage_created_admin_id[ids[i]] = struct{}{}
	}
}

// RemovedMessageCreatedAdminID returns the removed IDs of the "message_created_admin_id" edge to the Message entity.
func (m *AdminMutation) RemovedMessageCreatedAdminIDIDs() (ids []int) {
	for id := range m.removedmessage_created_admin_id {
		ids = append(ids, id)
	}
	return
}

// MessageCreatedAdminIDIDs returns the "message_created_admin_id" edge IDs in the mutation.
func (m *AdminMutation) MessageCreatedAdminIDIDs() (ids []int) {
	for id := range m.message_created_admin_id {
		ids = append(ids, id)
	}
	return
}

// ResetMessageCreatedAdminID resets all changes to the "message_created_admin_id" edge.
func (m *AdminMutation) ResetMessageCreatedAdminID() {
	m.message_created_admin_id = nil
	m.clearedmessage_created_admin_id = false
	m.removedmessage_created_admin_id = nil
}

// AddAdminQuestionBankIDs adds the "admin_question_banks" edge to the TkQuestionBank entity by ids.
func (m *AdminMutation) AddAdminQuestionBankIDs(ids ...int) {
	if m.admin_question_banks == nil {
		m.admin_question_banks = make(map[int]struct{})
	}
	for i := range ids {
		m.admin_question_banks[ids[i]] = struct{}{}
	}
}

// ClearAdminQuestionBanks clears the "admin_question_banks" edge to the TkQuestionBank entity.
func (m *AdminMutation) ClearAdminQuestionBanks() {
	m.clearedadmin_question_banks = true
}

// AdminQuestionBanksCleared reports if the "admin_question_banks" edge to the TkQuestionBank entity was cleared.
func (m *AdminMutation) AdminQuestionBanksCleared() bool {
	return m.clearedadmin_question_banks
}

// RemoveAdminQuestionBankIDs removes the "admin_question_banks" edge to the TkQuestionBank entity by IDs.
func (m *AdminMutation) RemoveAdminQuestionBankIDs(ids ...int) {
	if m.removedadmin_question_banks == nil {
		m.removedadmin_question_banks = make(map[int]struct{})
	}
	for i := range ids {
		m.removedadmin_question_banks[ids[i]] = struct{}{}
	}
}

// RemovedAdminQuestionBanks returns the removed IDs of the "admin_question_banks" edge to the TkQuestionBank entity.
func (m *AdminMutation) RemovedAdminQuestionBanksIDs() (ids []int) {
	for id := range m.removedadmin_question_banks {
		ids = append(ids, id)
	}
	return
}

// AdminQuestionBanksIDs returns the "admin_question_banks" edge IDs in the mutation.
func (m *AdminMutation) AdminQuestionBanksIDs() (ids []int) {
	for id := range m.admin_question_banks {
		ids = append(ids, id)
	}
	return
}

// ResetAdminQuestionBanks resets all changes to the "admin_question_banks" edge.
func (m *AdminMutation) ResetAdminQuestionBanks() {
	m.admin_question_banks = nil
	m.clearedadmin_question_banks = false
	m.removedadmin_question_banks = nil
}

// AddAdminQuestionIDs adds the "admin_Questions" edge to the TkQuestion entity by ids.
func (m *AdminMutation) AddAdminQuestionIDs(ids ...int) {
	if m.admin_Questions == nil {
		m.admin_Questions = make(map[int]struct{})
	}
	for i := range ids {
		m.admin_Questions[ids[i]] = struct{}{}
	}
}

// ClearAdminQuestions clears the "admin_Questions" edge to the TkQuestion entity.
func (m *AdminMutation) ClearAdminQuestions() {
	m.clearedadmin_Questions = true
}

// AdminQuestionsCleared reports if the "admin_Questions" edge to the TkQuestion entity was cleared.
func (m *AdminMutation) AdminQuestionsCleared() bool {
	return m.clearedadmin_Questions
}

// RemoveAdminQuestionIDs removes the "admin_Questions" edge to the TkQuestion entity by IDs.
func (m *AdminMutation) RemoveAdminQuestionIDs(ids ...int) {
	if m.removedadmin_Questions == nil {
		m.removedadmin_Questions = make(map[int]struct{})
	}
	for i := range ids {
		m.removedadmin_Questions[ids[i]] = struct{}{}
	}
}

// RemovedAdminQuestions returns the removed IDs of the "admin_Questions" edge to the TkQuestion entity.
func (m *AdminMutation) RemovedAdminQuestionsIDs() (ids []int) {
	for id := range m.removedadmin_Questions {
		ids = append(ids, id)
	}
	return
}

// AdminQuestionsIDs returns the "admin_Questions" edge IDs in the mutation.
func (m *AdminMutation) AdminQuestionsIDs() (ids []int) {
	for id := range m.admin_Questions {
		ids = append(ids, id)
	}
	return
}

// ResetAdminQuestions resets all changes to the "admin_Questions" edge.
func (m *AdminMutation) ResetAdminQuestions() {
	m.admin_Questions = nil
	m.clearedadmin_Questions = false
	m.removedadmin_Questions = nil
}

// AddAdminExamPaperIDs adds the "admin_exam_papers" edge to the TkExamPaper entity by ids.
func (m *AdminMutation) AddAdminExamPaperIDs(ids ...int) {
	if m.admin_exam_papers == nil {
		m.admin_exam_papers = make(map[int]struct{})
	}
	for i := range ids {
		m.admin_exam_papers[ids[i]] = struct{}{}
	}
}

// ClearAdminExamPapers clears the "admin_exam_papers" edge to the TkExamPaper entity.
func (m *AdminMutation) ClearAdminExamPapers() {
	m.clearedadmin_exam_papers = true
}

// AdminExamPapersCleared reports if the "admin_exam_papers" edge to the TkExamPaper entity was cleared.
func (m *AdminMutation) AdminExamPapersCleared() bool {
	return m.clearedadmin_exam_papers
}

// RemoveAdminExamPaperIDs removes the "admin_exam_papers" edge to the TkExamPaper entity by IDs.
func (m *AdminMutation) RemoveAdminExamPaperIDs(ids ...int) {
	if m.removedadmin_exam_papers == nil {
		m.removedadmin_exam_papers = make(map[int]struct{})
	}
	for i := range ids {
		m.removedadmin_exam_papers[ids[i]] = struct{}{}
	}
}

// RemovedAdminExamPapers returns the removed IDs of the "admin_exam_papers" edge to the TkExamPaper entity.
func (m *AdminMutation) RemovedAdminExamPapersIDs() (ids []int) {
	for id := range m.removedadmin_exam_papers {
		ids = append(ids, id)
	}
	return
}

// AdminExamPapersIDs returns the "admin_exam_papers" edge IDs in the mutation.
func (m *AdminMutation) AdminExamPapersIDs() (ids []int) {
	for id := range m.admin_exam_papers {
		ids = append(ids, id)
	}
	return
}

// ResetAdminExamPapers resets all changes to the "admin_exam_papers" edge.
func (m *AdminMutation) ResetAdminExamPapers() {
	m.admin_exam_papers = nil
	m.clearedadmin_exam_papers = false
	m.removedadmin_exam_papers = nil
}

// AddAdminErrorFeedbackIDs adds the "admin_error_feedbacks" edge to the TkQuestionErrorFeedback entity by ids.
func (m *AdminMutation) AddAdminErrorFeedbackIDs(ids ...int) {
	if m.admin_error_feedbacks == nil {
		m.admin_error_feedbacks = make(map[int]struct{})
	}
	for i := range ids {
		m.admin_error_feedbacks[ids[i]] = struct{}{}
	}
}

// ClearAdminErrorFeedbacks clears the "admin_error_feedbacks" edge to the TkQuestionErrorFeedback entity.
func (m *AdminMutation) ClearAdminErrorFeedbacks() {
	m.clearedadmin_error_feedbacks = true
}

// AdminErrorFeedbacksCleared reports if the "admin_error_feedbacks" edge to the TkQuestionErrorFeedback entity was cleared.
func (m *AdminMutation) AdminErrorFeedbacksCleared() bool {
	return m.clearedadmin_error_feedbacks
}

// RemoveAdminErrorFeedbackIDs removes the "admin_error_feedbacks" edge to the TkQuestionErrorFeedback entity by IDs.
func (m *AdminMutation) RemoveAdminErrorFeedbackIDs(ids ...int) {
	if m.removedadmin_error_feedbacks == nil {
		m.removedadmin_error_feedbacks = make(map[int]struct{})
	}
	for i := range ids {
		m.removedadmin_error_feedbacks[ids[i]] = struct{}{}
	}
}

// RemovedAdminErrorFeedbacks returns the removed IDs of the "admin_error_feedbacks" edge to the TkQuestionErrorFeedback entity.
func (m *AdminMutation) RemovedAdminErrorFeedbacksIDs() (ids []int) {
	for id := range m.removedadmin_error_feedbacks {
		ids = append(ids, id)
	}
	return
}

// AdminErrorFeedbacksIDs returns the "admin_error_feedbacks" edge IDs in the mutation.
func (m *AdminMutation) AdminErrorFeedbacksIDs() (ids []int) {
	for id := range m.admin_error_feedbacks {
		ids = append(ids, id)
	}
	return
}

// ResetAdminErrorFeedbacks resets all changes to the "admin_error_feedbacks" edge.
func (m *AdminMutation) ResetAdminErrorFeedbacks() {
	m.admin_error_feedbacks = nil
	m.clearedadmin_error_feedbacks = false
	m.removedadmin_error_feedbacks = nil
}

// AddCourseIDs adds the "course" edge to the KcCourse entity by ids.
func (m *AdminMutation) AddCourseIDs(ids ...int) {
	if m.course == nil {
		m.course = make(map[int]struct{})
	}
	for i := range ids {
		m.course[ids[i]] = struct{}{}
	}
}

// ClearCourse clears the "course" edge to the KcCourse entity.
func (m *AdminMutation) ClearCourse() {
	m.clearedcourse = true
}

// CourseCleared reports if the "course" edge to the KcCourse entity was cleared.
func (m *AdminMutation) CourseCleared() bool {
	return m.clearedcourse
}

// RemoveCourseIDs removes the "course" edge to the KcCourse entity by IDs.
func (m *AdminMutation) RemoveCourseIDs(ids ...int) {
	if m.removedcourse == nil {
		m.removedcourse = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcourse[ids[i]] = struct{}{}
	}
}

// RemovedCourse returns the removed IDs of the "course" edge to the KcCourse entity.
func (m *AdminMutation) RemovedCourseIDs() (ids []int) {
	for id := range m.removedcourse {
		ids = append(ids, id)
	}
	return
}

// CourseIDs returns the "course" edge IDs in the mutation.
func (m *AdminMutation) CourseIDs() (ids []int) {
	for id := range m.course {
		ids = append(ids, id)
	}
	return
}

// ResetCourse resets all changes to the "course" edge.
func (m *AdminMutation) ResetCourse() {
	m.course = nil
	m.clearedcourse = false
	m.removedcourse = nil
}

// AddClassAdminIDs adds the "class_admin" edge to the KcClass entity by ids.
func (m *AdminMutation) AddClassAdminIDs(ids ...int) {
	if m.class_admin == nil {
		m.class_admin = make(map[int]struct{})
	}
	for i := range ids {
		m.class_admin[ids[i]] = struct{}{}
	}
}

// ClearClassAdmin clears the "class_admin" edge to the KcClass entity.
func (m *AdminMutation) ClearClassAdmin() {
	m.clearedclass_admin = true
}

// ClassAdminCleared reports if the "class_admin" edge to the KcClass entity was cleared.
func (m *AdminMutation) ClassAdminCleared() bool {
	return m.clearedclass_admin
}

// RemoveClassAdminIDs removes the "class_admin" edge to the KcClass entity by IDs.
func (m *AdminMutation) RemoveClassAdminIDs(ids ...int) {
	if m.removedclass_admin == nil {
		m.removedclass_admin = make(map[int]struct{})
	}
	for i := range ids {
		m.removedclass_admin[ids[i]] = struct{}{}
	}
}

// RemovedClassAdmin returns the removed IDs of the "class_admin" edge to the KcClass entity.
func (m *AdminMutation) RemovedClassAdminIDs() (ids []int) {
	for id := range m.removedclass_admin {
		ids = append(ids, id)
	}
	return
}

// ClassAdminIDs returns the "class_admin" edge IDs in the mutation.
func (m *AdminMutation) ClassAdminIDs() (ids []int) {
	for id := range m.class_admin {
		ids = append(ids, id)
	}
	return
}

// ResetClassAdmin resets all changes to the "class_admin" edge.
func (m *AdminMutation) ResetClassAdmin() {
	m.class_admin = nil
	m.clearedclass_admin = false
	m.removedclass_admin = nil
}

// SetAdminAttachmentsID sets the "admin_attachments" edge to the Attachment entity by id.
func (m *AdminMutation) SetAdminAttachmentsID(id int) {
	m.admin_attachments = &id
}

// ClearAdminAttachments clears the "admin_attachments" edge to the Attachment entity.
func (m *AdminMutation) ClearAdminAttachments() {
	m.clearedadmin_attachments = true
}

// AdminAttachmentsCleared reports if the "admin_attachments" edge to the Attachment entity was cleared.
func (m *AdminMutation) AdminAttachmentsCleared() bool {
	return m.AdminAvatarIDCleared() || m.clearedadmin_attachments
}

// AdminAttachmentsID returns the "admin_attachments" edge ID in the mutation.
func (m *AdminMutation) AdminAttachmentsID() (id int, exists bool) {
	if m.admin_attachments != nil {
		return *m.admin_attachments, true
	}
	return
}

// AdminAttachmentsIDs returns the "admin_attachments" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AdminAttachmentsID instead. It exists only for internal usage by the builders.
func (m *AdminMutation) AdminAttachmentsIDs() (ids []int) {
	if id := m.admin_attachments; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAdminAttachments resets all changes to the "admin_attachments" edge.
func (m *AdminMutation) ResetAdminAttachments() {
	m.admin_attachments = nil
	m.clearedadmin_attachments = false
}

// Op returns the operation name.
func (m *AdminMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Admin).
func (m *AdminMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AdminMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.uuid != nil {
		fields = append(fields, admin.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, admin.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, admin.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, admin.FieldDeletedAt)
	}
	if m.password != nil {
		fields = append(fields, admin.FieldPassword)
	}
	if m.salt != nil {
		fields = append(fields, admin.FieldSalt)
	}
	if m.boss_admin_id != nil {
		fields = append(fields, admin.FieldBossAdminID)
	}
	if m.real_name != nil {
		fields = append(fields, admin.FieldRealName)
	}
	if m.email != nil {
		fields = append(fields, admin.FieldEmail)
	}
	if m.phone != nil {
		fields = append(fields, admin.FieldPhone)
	}
	if m.third_openid != nil {
		fields = append(fields, admin.FieldThirdOpenid)
	}
	if m.platform != nil {
		fields = append(fields, admin.FieldPlatform)
	}
	if m.is_active != nil {
		fields = append(fields, admin.FieldIsActive)
	}
	if m.status != nil {
		fields = append(fields, admin.FieldStatus)
	}
	if m.admin_attachments != nil {
		fields = append(fields, admin.FieldAdminAvatarID)
	}
	if m._Remark != nil {
		fields = append(fields, admin.FieldRemark)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AdminMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case admin.FieldUUID:
		return m.UUID()
	case admin.FieldCreatedAt:
		return m.CreatedAt()
	case admin.FieldUpdatedAt:
		return m.UpdatedAt()
	case admin.FieldDeletedAt:
		return m.DeletedAt()
	case admin.FieldPassword:
		return m.Password()
	case admin.FieldSalt:
		return m.Salt()
	case admin.FieldBossAdminID:
		return m.BossAdminID()
	case admin.FieldRealName:
		return m.RealName()
	case admin.FieldEmail:
		return m.Email()
	case admin.FieldPhone:
		return m.Phone()
	case admin.FieldThirdOpenid:
		return m.ThirdOpenid()
	case admin.FieldPlatform:
		return m.Platform()
	case admin.FieldIsActive:
		return m.IsActive()
	case admin.FieldStatus:
		return m.Status()
	case admin.FieldAdminAvatarID:
		return m.AdminAvatarID()
	case admin.FieldRemark:
		return m.Remark()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AdminMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case admin.FieldUUID:
		return m.OldUUID(ctx)
	case admin.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case admin.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case admin.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case admin.FieldPassword:
		return m.OldPassword(ctx)
	case admin.FieldSalt:
		return m.OldSalt(ctx)
	case admin.FieldBossAdminID:
		return m.OldBossAdminID(ctx)
	case admin.FieldRealName:
		return m.OldRealName(ctx)
	case admin.FieldEmail:
		return m.OldEmail(ctx)
	case admin.FieldPhone:
		return m.OldPhone(ctx)
	case admin.FieldThirdOpenid:
		return m.OldThirdOpenid(ctx)
	case admin.FieldPlatform:
		return m.OldPlatform(ctx)
	case admin.FieldIsActive:
		return m.OldIsActive(ctx)
	case admin.FieldStatus:
		return m.OldStatus(ctx)
	case admin.FieldAdminAvatarID:
		return m.OldAdminAvatarID(ctx)
	case admin.FieldRemark:
		return m.OldRemark(ctx)
	}
	return nil, fmt.Errorf("unknown Admin field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdminMutation) SetField(name string, value ent.Value) error {
	switch name {
	case admin.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case admin.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case admin.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case admin.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case admin.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case admin.FieldSalt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSalt(v)
		return nil
	case admin.FieldBossAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBossAdminID(v)
		return nil
	case admin.FieldRealName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRealName(v)
		return nil
	case admin.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case admin.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case admin.FieldThirdOpenid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThirdOpenid(v)
		return nil
	case admin.FieldPlatform:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatform(v)
		return nil
	case admin.FieldIsActive:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case admin.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case admin.FieldAdminAvatarID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdminAvatarID(v)
		return nil
	case admin.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	}
	return fmt.Errorf("unknown Admin field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AdminMutation) AddedFields() []string {
	var fields []string
	if m.addboss_admin_id != nil {
		fields = append(fields, admin.FieldBossAdminID)
	}
	if m.addplatform != nil {
		fields = append(fields, admin.FieldPlatform)
	}
	if m.addis_active != nil {
		fields = append(fields, admin.FieldIsActive)
	}
	if m.addstatus != nil {
		fields = append(fields, admin.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AdminMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case admin.FieldBossAdminID:
		return m.AddedBossAdminID()
	case admin.FieldPlatform:
		return m.AddedPlatform()
	case admin.FieldIsActive:
		return m.AddedIsActive()
	case admin.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdminMutation) AddField(name string, value ent.Value) error {
	switch name {
	case admin.FieldBossAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBossAdminID(v)
		return nil
	case admin.FieldPlatform:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPlatform(v)
		return nil
	case admin.FieldIsActive:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsActive(v)
		return nil
	case admin.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Admin numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AdminMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(admin.FieldCreatedAt) {
		fields = append(fields, admin.FieldCreatedAt)
	}
	if m.FieldCleared(admin.FieldUpdatedAt) {
		fields = append(fields, admin.FieldUpdatedAt)
	}
	if m.FieldCleared(admin.FieldDeletedAt) {
		fields = append(fields, admin.FieldDeletedAt)
	}
	if m.FieldCleared(admin.FieldAdminAvatarID) {
		fields = append(fields, admin.FieldAdminAvatarID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AdminMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AdminMutation) ClearField(name string) error {
	switch name {
	case admin.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case admin.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case admin.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case admin.FieldAdminAvatarID:
		m.ClearAdminAvatarID()
		return nil
	}
	return fmt.Errorf("unknown Admin nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AdminMutation) ResetField(name string) error {
	switch name {
	case admin.FieldUUID:
		m.ResetUUID()
		return nil
	case admin.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case admin.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case admin.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case admin.FieldPassword:
		m.ResetPassword()
		return nil
	case admin.FieldSalt:
		m.ResetSalt()
		return nil
	case admin.FieldBossAdminID:
		m.ResetBossAdminID()
		return nil
	case admin.FieldRealName:
		m.ResetRealName()
		return nil
	case admin.FieldEmail:
		m.ResetEmail()
		return nil
	case admin.FieldPhone:
		m.ResetPhone()
		return nil
	case admin.FieldThirdOpenid:
		m.ResetThirdOpenid()
		return nil
	case admin.FieldPlatform:
		m.ResetPlatform()
		return nil
	case admin.FieldIsActive:
		m.ResetIsActive()
		return nil
	case admin.FieldStatus:
		m.ResetStatus()
		return nil
	case admin.FieldAdminAvatarID:
		m.ResetAdminAvatarID()
		return nil
	case admin.FieldRemark:
		m.ResetRemark()
		return nil
	}
	return fmt.Errorf("unknown Admin field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AdminMutation) AddedEdges() []string {
	edges := make([]string, 0, 12)
	if m.admin_login_logs != nil {
		edges = append(edges, admin.EdgeAdminLoginLogs)
	}
	if m.operation_admin_logs != nil {
		edges = append(edges, admin.EdgeOperationAdminLogs)
	}
	if m.roles != nil {
		edges = append(edges, admin.EdgeRoles)
	}
	if m.activities != nil {
		edges = append(edges, admin.EdgeActivities)
	}
	if m.message_created_admin_id != nil {
		edges = append(edges, admin.EdgeMessageCreatedAdminID)
	}
	if m.admin_question_banks != nil {
		edges = append(edges, admin.EdgeAdminQuestionBanks)
	}
	if m.admin_Questions != nil {
		edges = append(edges, admin.EdgeAdminQuestions)
	}
	if m.admin_exam_papers != nil {
		edges = append(edges, admin.EdgeAdminExamPapers)
	}
	if m.admin_error_feedbacks != nil {
		edges = append(edges, admin.EdgeAdminErrorFeedbacks)
	}
	if m.course != nil {
		edges = append(edges, admin.EdgeCourse)
	}
	if m.class_admin != nil {
		edges = append(edges, admin.EdgeClassAdmin)
	}
	if m.admin_attachments != nil {
		edges = append(edges, admin.EdgeAdminAttachments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AdminMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case admin.EdgeAdminLoginLogs:
		ids := make([]ent.Value, 0, len(m.admin_login_logs))
		for id := range m.admin_login_logs {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeOperationAdminLogs:
		ids := make([]ent.Value, 0, len(m.operation_admin_logs))
		for id := range m.operation_admin_logs {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeActivities:
		ids := make([]ent.Value, 0, len(m.activities))
		for id := range m.activities {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeMessageCreatedAdminID:
		ids := make([]ent.Value, 0, len(m.message_created_admin_id))
		for id := range m.message_created_admin_id {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeAdminQuestionBanks:
		ids := make([]ent.Value, 0, len(m.admin_question_banks))
		for id := range m.admin_question_banks {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeAdminQuestions:
		ids := make([]ent.Value, 0, len(m.admin_Questions))
		for id := range m.admin_Questions {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeAdminExamPapers:
		ids := make([]ent.Value, 0, len(m.admin_exam_papers))
		for id := range m.admin_exam_papers {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeAdminErrorFeedbacks:
		ids := make([]ent.Value, 0, len(m.admin_error_feedbacks))
		for id := range m.admin_error_feedbacks {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeCourse:
		ids := make([]ent.Value, 0, len(m.course))
		for id := range m.course {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeClassAdmin:
		ids := make([]ent.Value, 0, len(m.class_admin))
		for id := range m.class_admin {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeAdminAttachments:
		if id := m.admin_attachments; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AdminMutation) RemovedEdges() []string {
	edges := make([]string, 0, 12)
	if m.removedadmin_login_logs != nil {
		edges = append(edges, admin.EdgeAdminLoginLogs)
	}
	if m.removedoperation_admin_logs != nil {
		edges = append(edges, admin.EdgeOperationAdminLogs)
	}
	if m.removedroles != nil {
		edges = append(edges, admin.EdgeRoles)
	}
	if m.removedactivities != nil {
		edges = append(edges, admin.EdgeActivities)
	}
	if m.removedmessage_created_admin_id != nil {
		edges = append(edges, admin.EdgeMessageCreatedAdminID)
	}
	if m.removedadmin_question_banks != nil {
		edges = append(edges, admin.EdgeAdminQuestionBanks)
	}
	if m.removedadmin_Questions != nil {
		edges = append(edges, admin.EdgeAdminQuestions)
	}
	if m.removedadmin_exam_papers != nil {
		edges = append(edges, admin.EdgeAdminExamPapers)
	}
	if m.removedadmin_error_feedbacks != nil {
		edges = append(edges, admin.EdgeAdminErrorFeedbacks)
	}
	if m.removedcourse != nil {
		edges = append(edges, admin.EdgeCourse)
	}
	if m.removedclass_admin != nil {
		edges = append(edges, admin.EdgeClassAdmin)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AdminMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case admin.EdgeAdminLoginLogs:
		ids := make([]ent.Value, 0, len(m.removedadmin_login_logs))
		for id := range m.removedadmin_login_logs {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeOperationAdminLogs:
		ids := make([]ent.Value, 0, len(m.removedoperation_admin_logs))
		for id := range m.removedoperation_admin_logs {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeActivities:
		ids := make([]ent.Value, 0, len(m.removedactivities))
		for id := range m.removedactivities {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeMessageCreatedAdminID:
		ids := make([]ent.Value, 0, len(m.removedmessage_created_admin_id))
		for id := range m.removedmessage_created_admin_id {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeAdminQuestionBanks:
		ids := make([]ent.Value, 0, len(m.removedadmin_question_banks))
		for id := range m.removedadmin_question_banks {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeAdminQuestions:
		ids := make([]ent.Value, 0, len(m.removedadmin_Questions))
		for id := range m.removedadmin_Questions {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeAdminExamPapers:
		ids := make([]ent.Value, 0, len(m.removedadmin_exam_papers))
		for id := range m.removedadmin_exam_papers {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeAdminErrorFeedbacks:
		ids := make([]ent.Value, 0, len(m.removedadmin_error_feedbacks))
		for id := range m.removedadmin_error_feedbacks {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeCourse:
		ids := make([]ent.Value, 0, len(m.removedcourse))
		for id := range m.removedcourse {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeClassAdmin:
		ids := make([]ent.Value, 0, len(m.removedclass_admin))
		for id := range m.removedclass_admin {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AdminMutation) ClearedEdges() []string {
	edges := make([]string, 0, 12)
	if m.clearedadmin_login_logs {
		edges = append(edges, admin.EdgeAdminLoginLogs)
	}
	if m.clearedoperation_admin_logs {
		edges = append(edges, admin.EdgeOperationAdminLogs)
	}
	if m.clearedroles {
		edges = append(edges, admin.EdgeRoles)
	}
	if m.clearedactivities {
		edges = append(edges, admin.EdgeActivities)
	}
	if m.clearedmessage_created_admin_id {
		edges = append(edges, admin.EdgeMessageCreatedAdminID)
	}
	if m.clearedadmin_question_banks {
		edges = append(edges, admin.EdgeAdminQuestionBanks)
	}
	if m.clearedadmin_Questions {
		edges = append(edges, admin.EdgeAdminQuestions)
	}
	if m.clearedadmin_exam_papers {
		edges = append(edges, admin.EdgeAdminExamPapers)
	}
	if m.clearedadmin_error_feedbacks {
		edges = append(edges, admin.EdgeAdminErrorFeedbacks)
	}
	if m.clearedcourse {
		edges = append(edges, admin.EdgeCourse)
	}
	if m.clearedclass_admin {
		edges = append(edges, admin.EdgeClassAdmin)
	}
	if m.clearedadmin_attachments {
		edges = append(edges, admin.EdgeAdminAttachments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AdminMutation) EdgeCleared(name string) bool {
	switch name {
	case admin.EdgeAdminLoginLogs:
		return m.clearedadmin_login_logs
	case admin.EdgeOperationAdminLogs:
		return m.clearedoperation_admin_logs
	case admin.EdgeRoles:
		return m.clearedroles
	case admin.EdgeActivities:
		return m.clearedactivities
	case admin.EdgeMessageCreatedAdminID:
		return m.clearedmessage_created_admin_id
	case admin.EdgeAdminQuestionBanks:
		return m.clearedadmin_question_banks
	case admin.EdgeAdminQuestions:
		return m.clearedadmin_Questions
	case admin.EdgeAdminExamPapers:
		return m.clearedadmin_exam_papers
	case admin.EdgeAdminErrorFeedbacks:
		return m.clearedadmin_error_feedbacks
	case admin.EdgeCourse:
		return m.clearedcourse
	case admin.EdgeClassAdmin:
		return m.clearedclass_admin
	case admin.EdgeAdminAttachments:
		return m.clearedadmin_attachments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AdminMutation) ClearEdge(name string) error {
	switch name {
	case admin.EdgeAdminAttachments:
		m.ClearAdminAttachments()
		return nil
	}
	return fmt.Errorf("unknown Admin unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AdminMutation) ResetEdge(name string) error {
	switch name {
	case admin.EdgeAdminLoginLogs:
		m.ResetAdminLoginLogs()
		return nil
	case admin.EdgeOperationAdminLogs:
		m.ResetOperationAdminLogs()
		return nil
	case admin.EdgeRoles:
		m.ResetRoles()
		return nil
	case admin.EdgeActivities:
		m.ResetActivities()
		return nil
	case admin.EdgeMessageCreatedAdminID:
		m.ResetMessageCreatedAdminID()
		return nil
	case admin.EdgeAdminQuestionBanks:
		m.ResetAdminQuestionBanks()
		return nil
	case admin.EdgeAdminQuestions:
		m.ResetAdminQuestions()
		return nil
	case admin.EdgeAdminExamPapers:
		m.ResetAdminExamPapers()
		return nil
	case admin.EdgeAdminErrorFeedbacks:
		m.ResetAdminErrorFeedbacks()
		return nil
	case admin.EdgeCourse:
		m.ResetCourse()
		return nil
	case admin.EdgeClassAdmin:
		m.ResetClassAdmin()
		return nil
	case admin.EdgeAdminAttachments:
		m.ResetAdminAttachments()
		return nil
	}
	return fmt.Errorf("unknown Admin edge %s", name)
}

// AdminLoginLogMutation represents an operation that mutates the AdminLoginLog nodes in the graph.
type AdminLoginLogMutation struct {
	config
	op            Op
	typ           string
	id            *int
	uuid          *string
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	ip            *string
	city          *string
	browser       *string
	clearedFields map[string]struct{}
	admin         *int
	clearedadmin  bool
	done          bool
	oldValue      func(context.Context) (*AdminLoginLog, error)
	predicates    []predicate.AdminLoginLog
}

var _ ent.Mutation = (*AdminLoginLogMutation)(nil)

// adminloginlogOption allows management of the mutation configuration using functional options.
type adminloginlogOption func(*AdminLoginLogMutation)

// newAdminLoginLogMutation creates new mutation for the AdminLoginLog entity.
func newAdminLoginLogMutation(c config, op Op, opts ...adminloginlogOption) *AdminLoginLogMutation {
	m := &AdminLoginLogMutation{
		config:        c,
		op:            op,
		typ:           TypeAdminLoginLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAdminLoginLogID sets the ID field of the mutation.
func withAdminLoginLogID(id int) adminloginlogOption {
	return func(m *AdminLoginLogMutation) {
		var (
			err   error
			once  sync.Once
			value *AdminLoginLog
		)
		m.oldValue = func(ctx context.Context) (*AdminLoginLog, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AdminLoginLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAdminLoginLog sets the old AdminLoginLog of the mutation.
func withAdminLoginLog(node *AdminLoginLog) adminloginlogOption {
	return func(m *AdminLoginLogMutation) {
		m.oldValue = func(context.Context) (*AdminLoginLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AdminLoginLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AdminLoginLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *AdminLoginLogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *AdminLoginLogMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *AdminLoginLogMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the AdminLoginLog entity.
// If the AdminLoginLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminLoginLogMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *AdminLoginLogMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AdminLoginLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AdminLoginLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AdminLoginLog entity.
// If the AdminLoginLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminLoginLogMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *AdminLoginLogMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[adminloginlog.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *AdminLoginLogMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[adminloginlog.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AdminLoginLogMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, adminloginlog.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AdminLoginLogMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AdminLoginLogMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AdminLoginLog entity.
// If the AdminLoginLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminLoginLogMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *AdminLoginLogMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[adminloginlog.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *AdminLoginLogMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[adminloginlog.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AdminLoginLogMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, adminloginlog.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AdminLoginLogMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AdminLoginLogMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AdminLoginLog entity.
// If the AdminLoginLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminLoginLogMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AdminLoginLogMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[adminloginlog.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AdminLoginLogMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[adminloginlog.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AdminLoginLogMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, adminloginlog.FieldDeletedAt)
}

// SetIP sets the "ip" field.
func (m *AdminLoginLogMutation) SetIP(s string) {
	m.ip = &s
}

// IP returns the value of the "ip" field in the mutation.
func (m *AdminLoginLogMutation) IP() (r string, exists bool) {
	v := m.ip
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old "ip" field's value of the AdminLoginLog entity.
// If the AdminLoginLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminLoginLogMutation) OldIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// ResetIP resets all changes to the "ip" field.
func (m *AdminLoginLogMutation) ResetIP() {
	m.ip = nil
}

// SetCity sets the "city" field.
func (m *AdminLoginLogMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *AdminLoginLogMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the AdminLoginLog entity.
// If the AdminLoginLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminLoginLogMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ResetCity resets all changes to the "city" field.
func (m *AdminLoginLogMutation) ResetCity() {
	m.city = nil
}

// SetBrowser sets the "browser" field.
func (m *AdminLoginLogMutation) SetBrowser(s string) {
	m.browser = &s
}

// Browser returns the value of the "browser" field in the mutation.
func (m *AdminLoginLogMutation) Browser() (r string, exists bool) {
	v := m.browser
	if v == nil {
		return
	}
	return *v, true
}

// OldBrowser returns the old "browser" field's value of the AdminLoginLog entity.
// If the AdminLoginLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminLoginLogMutation) OldBrowser(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBrowser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBrowser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBrowser: %w", err)
	}
	return oldValue.Browser, nil
}

// ResetBrowser resets all changes to the "browser" field.
func (m *AdminLoginLogMutation) ResetBrowser() {
	m.browser = nil
}

// SetAdminID sets the "admin_id" field.
func (m *AdminLoginLogMutation) SetAdminID(i int) {
	m.admin = &i
}

// AdminID returns the value of the "admin_id" field in the mutation.
func (m *AdminLoginLogMutation) AdminID() (r int, exists bool) {
	v := m.admin
	if v == nil {
		return
	}
	return *v, true
}

// OldAdminID returns the old "admin_id" field's value of the AdminLoginLog entity.
// If the AdminLoginLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminLoginLogMutation) OldAdminID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAdminID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAdminID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdminID: %w", err)
	}
	return oldValue.AdminID, nil
}

// ClearAdminID clears the value of the "admin_id" field.
func (m *AdminLoginLogMutation) ClearAdminID() {
	m.admin = nil
	m.clearedFields[adminloginlog.FieldAdminID] = struct{}{}
}

// AdminIDCleared returns if the "admin_id" field was cleared in this mutation.
func (m *AdminLoginLogMutation) AdminIDCleared() bool {
	_, ok := m.clearedFields[adminloginlog.FieldAdminID]
	return ok
}

// ResetAdminID resets all changes to the "admin_id" field.
func (m *AdminLoginLogMutation) ResetAdminID() {
	m.admin = nil
	delete(m.clearedFields, adminloginlog.FieldAdminID)
}

// ClearAdmin clears the "admin" edge to the Admin entity.
func (m *AdminLoginLogMutation) ClearAdmin() {
	m.clearedadmin = true
}

// AdminCleared reports if the "admin" edge to the Admin entity was cleared.
func (m *AdminLoginLogMutation) AdminCleared() bool {
	return m.AdminIDCleared() || m.clearedadmin
}

// AdminIDs returns the "admin" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AdminID instead. It exists only for internal usage by the builders.
func (m *AdminLoginLogMutation) AdminIDs() (ids []int) {
	if id := m.admin; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAdmin resets all changes to the "admin" edge.
func (m *AdminLoginLogMutation) ResetAdmin() {
	m.admin = nil
	m.clearedadmin = false
}

// Op returns the operation name.
func (m *AdminLoginLogMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AdminLoginLog).
func (m *AdminLoginLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AdminLoginLogMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.uuid != nil {
		fields = append(fields, adminloginlog.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, adminloginlog.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, adminloginlog.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, adminloginlog.FieldDeletedAt)
	}
	if m.ip != nil {
		fields = append(fields, adminloginlog.FieldIP)
	}
	if m.city != nil {
		fields = append(fields, adminloginlog.FieldCity)
	}
	if m.browser != nil {
		fields = append(fields, adminloginlog.FieldBrowser)
	}
	if m.admin != nil {
		fields = append(fields, adminloginlog.FieldAdminID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AdminLoginLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case adminloginlog.FieldUUID:
		return m.UUID()
	case adminloginlog.FieldCreatedAt:
		return m.CreatedAt()
	case adminloginlog.FieldUpdatedAt:
		return m.UpdatedAt()
	case adminloginlog.FieldDeletedAt:
		return m.DeletedAt()
	case adminloginlog.FieldIP:
		return m.IP()
	case adminloginlog.FieldCity:
		return m.City()
	case adminloginlog.FieldBrowser:
		return m.Browser()
	case adminloginlog.FieldAdminID:
		return m.AdminID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AdminLoginLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case adminloginlog.FieldUUID:
		return m.OldUUID(ctx)
	case adminloginlog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case adminloginlog.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case adminloginlog.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case adminloginlog.FieldIP:
		return m.OldIP(ctx)
	case adminloginlog.FieldCity:
		return m.OldCity(ctx)
	case adminloginlog.FieldBrowser:
		return m.OldBrowser(ctx)
	case adminloginlog.FieldAdminID:
		return m.OldAdminID(ctx)
	}
	return nil, fmt.Errorf("unknown AdminLoginLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdminLoginLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case adminloginlog.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case adminloginlog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case adminloginlog.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case adminloginlog.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case adminloginlog.FieldIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	case adminloginlog.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case adminloginlog.FieldBrowser:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBrowser(v)
		return nil
	case adminloginlog.FieldAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdminID(v)
		return nil
	}
	return fmt.Errorf("unknown AdminLoginLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AdminLoginLogMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AdminLoginLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdminLoginLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AdminLoginLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AdminLoginLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(adminloginlog.FieldCreatedAt) {
		fields = append(fields, adminloginlog.FieldCreatedAt)
	}
	if m.FieldCleared(adminloginlog.FieldUpdatedAt) {
		fields = append(fields, adminloginlog.FieldUpdatedAt)
	}
	if m.FieldCleared(adminloginlog.FieldDeletedAt) {
		fields = append(fields, adminloginlog.FieldDeletedAt)
	}
	if m.FieldCleared(adminloginlog.FieldAdminID) {
		fields = append(fields, adminloginlog.FieldAdminID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AdminLoginLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AdminLoginLogMutation) ClearField(name string) error {
	switch name {
	case adminloginlog.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case adminloginlog.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case adminloginlog.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case adminloginlog.FieldAdminID:
		m.ClearAdminID()
		return nil
	}
	return fmt.Errorf("unknown AdminLoginLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AdminLoginLogMutation) ResetField(name string) error {
	switch name {
	case adminloginlog.FieldUUID:
		m.ResetUUID()
		return nil
	case adminloginlog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case adminloginlog.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case adminloginlog.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case adminloginlog.FieldIP:
		m.ResetIP()
		return nil
	case adminloginlog.FieldCity:
		m.ResetCity()
		return nil
	case adminloginlog.FieldBrowser:
		m.ResetBrowser()
		return nil
	case adminloginlog.FieldAdminID:
		m.ResetAdminID()
		return nil
	}
	return fmt.Errorf("unknown AdminLoginLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AdminLoginLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.admin != nil {
		edges = append(edges, adminloginlog.EdgeAdmin)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AdminLoginLogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case adminloginlog.EdgeAdmin:
		if id := m.admin; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AdminLoginLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AdminLoginLogMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AdminLoginLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedadmin {
		edges = append(edges, adminloginlog.EdgeAdmin)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AdminLoginLogMutation) EdgeCleared(name string) bool {
	switch name {
	case adminloginlog.EdgeAdmin:
		return m.clearedadmin
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AdminLoginLogMutation) ClearEdge(name string) error {
	switch name {
	case adminloginlog.EdgeAdmin:
		m.ClearAdmin()
		return nil
	}
	return fmt.Errorf("unknown AdminLoginLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AdminLoginLogMutation) ResetEdge(name string) error {
	switch name {
	case adminloginlog.EdgeAdmin:
		m.ResetAdmin()
		return nil
	}
	return fmt.Errorf("unknown AdminLoginLog edge %s", name)
}

// AdminOperationLogMutation represents an operation that mutates the AdminOperationLog nodes in the graph.
type AdminOperationLogMutation struct {
	config
	op            Op
	typ           string
	id            *int
	uuid          *string
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	ip            *string
	record        *string
	remark        *string
	clearedFields map[string]struct{}
	admin         *int
	clearedadmin  bool
	done          bool
	oldValue      func(context.Context) (*AdminOperationLog, error)
	predicates    []predicate.AdminOperationLog
}

var _ ent.Mutation = (*AdminOperationLogMutation)(nil)

// adminoperationlogOption allows management of the mutation configuration using functional options.
type adminoperationlogOption func(*AdminOperationLogMutation)

// newAdminOperationLogMutation creates new mutation for the AdminOperationLog entity.
func newAdminOperationLogMutation(c config, op Op, opts ...adminoperationlogOption) *AdminOperationLogMutation {
	m := &AdminOperationLogMutation{
		config:        c,
		op:            op,
		typ:           TypeAdminOperationLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAdminOperationLogID sets the ID field of the mutation.
func withAdminOperationLogID(id int) adminoperationlogOption {
	return func(m *AdminOperationLogMutation) {
		var (
			err   error
			once  sync.Once
			value *AdminOperationLog
		)
		m.oldValue = func(ctx context.Context) (*AdminOperationLog, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AdminOperationLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAdminOperationLog sets the old AdminOperationLog of the mutation.
func withAdminOperationLog(node *AdminOperationLog) adminoperationlogOption {
	return func(m *AdminOperationLogMutation) {
		m.oldValue = func(context.Context) (*AdminOperationLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AdminOperationLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AdminOperationLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *AdminOperationLogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *AdminOperationLogMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *AdminOperationLogMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the AdminOperationLog entity.
// If the AdminOperationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminOperationLogMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *AdminOperationLogMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AdminOperationLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AdminOperationLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AdminOperationLog entity.
// If the AdminOperationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminOperationLogMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *AdminOperationLogMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[adminoperationlog.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *AdminOperationLogMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[adminoperationlog.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AdminOperationLogMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, adminoperationlog.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AdminOperationLogMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AdminOperationLogMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AdminOperationLog entity.
// If the AdminOperationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminOperationLogMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *AdminOperationLogMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[adminoperationlog.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *AdminOperationLogMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[adminoperationlog.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AdminOperationLogMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, adminoperationlog.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AdminOperationLogMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AdminOperationLogMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AdminOperationLog entity.
// If the AdminOperationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminOperationLogMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AdminOperationLogMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[adminoperationlog.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AdminOperationLogMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[adminoperationlog.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AdminOperationLogMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, adminoperationlog.FieldDeletedAt)
}

// SetIP sets the "ip" field.
func (m *AdminOperationLogMutation) SetIP(s string) {
	m.ip = &s
}

// IP returns the value of the "ip" field in the mutation.
func (m *AdminOperationLogMutation) IP() (r string, exists bool) {
	v := m.ip
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old "ip" field's value of the AdminOperationLog entity.
// If the AdminOperationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminOperationLogMutation) OldIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// ResetIP resets all changes to the "ip" field.
func (m *AdminOperationLogMutation) ResetIP() {
	m.ip = nil
}

// SetRecord sets the "record" field.
func (m *AdminOperationLogMutation) SetRecord(s string) {
	m.record = &s
}

// Record returns the value of the "record" field in the mutation.
func (m *AdminOperationLogMutation) Record() (r string, exists bool) {
	v := m.record
	if v == nil {
		return
	}
	return *v, true
}

// OldRecord returns the old "record" field's value of the AdminOperationLog entity.
// If the AdminOperationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminOperationLogMutation) OldRecord(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRecord is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRecord requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecord: %w", err)
	}
	return oldValue.Record, nil
}

// ResetRecord resets all changes to the "record" field.
func (m *AdminOperationLogMutation) ResetRecord() {
	m.record = nil
}

// SetRemark sets the "remark" field.
func (m *AdminOperationLogMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *AdminOperationLogMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the AdminOperationLog entity.
// If the AdminOperationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminOperationLogMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ResetRemark resets all changes to the "remark" field.
func (m *AdminOperationLogMutation) ResetRemark() {
	m.remark = nil
}

// SetAdminID sets the "admin_id" field.
func (m *AdminOperationLogMutation) SetAdminID(i int) {
	m.admin = &i
}

// AdminID returns the value of the "admin_id" field in the mutation.
func (m *AdminOperationLogMutation) AdminID() (r int, exists bool) {
	v := m.admin
	if v == nil {
		return
	}
	return *v, true
}

// OldAdminID returns the old "admin_id" field's value of the AdminOperationLog entity.
// If the AdminOperationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminOperationLogMutation) OldAdminID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAdminID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAdminID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdminID: %w", err)
	}
	return oldValue.AdminID, nil
}

// ClearAdminID clears the value of the "admin_id" field.
func (m *AdminOperationLogMutation) ClearAdminID() {
	m.admin = nil
	m.clearedFields[adminoperationlog.FieldAdminID] = struct{}{}
}

// AdminIDCleared returns if the "admin_id" field was cleared in this mutation.
func (m *AdminOperationLogMutation) AdminIDCleared() bool {
	_, ok := m.clearedFields[adminoperationlog.FieldAdminID]
	return ok
}

// ResetAdminID resets all changes to the "admin_id" field.
func (m *AdminOperationLogMutation) ResetAdminID() {
	m.admin = nil
	delete(m.clearedFields, adminoperationlog.FieldAdminID)
}

// ClearAdmin clears the "admin" edge to the Admin entity.
func (m *AdminOperationLogMutation) ClearAdmin() {
	m.clearedadmin = true
}

// AdminCleared reports if the "admin" edge to the Admin entity was cleared.
func (m *AdminOperationLogMutation) AdminCleared() bool {
	return m.AdminIDCleared() || m.clearedadmin
}

// AdminIDs returns the "admin" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AdminID instead. It exists only for internal usage by the builders.
func (m *AdminOperationLogMutation) AdminIDs() (ids []int) {
	if id := m.admin; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAdmin resets all changes to the "admin" edge.
func (m *AdminOperationLogMutation) ResetAdmin() {
	m.admin = nil
	m.clearedadmin = false
}

// Op returns the operation name.
func (m *AdminOperationLogMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AdminOperationLog).
func (m *AdminOperationLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AdminOperationLogMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.uuid != nil {
		fields = append(fields, adminoperationlog.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, adminoperationlog.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, adminoperationlog.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, adminoperationlog.FieldDeletedAt)
	}
	if m.ip != nil {
		fields = append(fields, adminoperationlog.FieldIP)
	}
	if m.record != nil {
		fields = append(fields, adminoperationlog.FieldRecord)
	}
	if m.remark != nil {
		fields = append(fields, adminoperationlog.FieldRemark)
	}
	if m.admin != nil {
		fields = append(fields, adminoperationlog.FieldAdminID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AdminOperationLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case adminoperationlog.FieldUUID:
		return m.UUID()
	case adminoperationlog.FieldCreatedAt:
		return m.CreatedAt()
	case adminoperationlog.FieldUpdatedAt:
		return m.UpdatedAt()
	case adminoperationlog.FieldDeletedAt:
		return m.DeletedAt()
	case adminoperationlog.FieldIP:
		return m.IP()
	case adminoperationlog.FieldRecord:
		return m.Record()
	case adminoperationlog.FieldRemark:
		return m.Remark()
	case adminoperationlog.FieldAdminID:
		return m.AdminID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AdminOperationLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case adminoperationlog.FieldUUID:
		return m.OldUUID(ctx)
	case adminoperationlog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case adminoperationlog.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case adminoperationlog.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case adminoperationlog.FieldIP:
		return m.OldIP(ctx)
	case adminoperationlog.FieldRecord:
		return m.OldRecord(ctx)
	case adminoperationlog.FieldRemark:
		return m.OldRemark(ctx)
	case adminoperationlog.FieldAdminID:
		return m.OldAdminID(ctx)
	}
	return nil, fmt.Errorf("unknown AdminOperationLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdminOperationLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case adminoperationlog.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case adminoperationlog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case adminoperationlog.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case adminoperationlog.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case adminoperationlog.FieldIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	case adminoperationlog.FieldRecord:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecord(v)
		return nil
	case adminoperationlog.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case adminoperationlog.FieldAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdminID(v)
		return nil
	}
	return fmt.Errorf("unknown AdminOperationLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AdminOperationLogMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AdminOperationLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdminOperationLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AdminOperationLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AdminOperationLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(adminoperationlog.FieldCreatedAt) {
		fields = append(fields, adminoperationlog.FieldCreatedAt)
	}
	if m.FieldCleared(adminoperationlog.FieldUpdatedAt) {
		fields = append(fields, adminoperationlog.FieldUpdatedAt)
	}
	if m.FieldCleared(adminoperationlog.FieldDeletedAt) {
		fields = append(fields, adminoperationlog.FieldDeletedAt)
	}
	if m.FieldCleared(adminoperationlog.FieldAdminID) {
		fields = append(fields, adminoperationlog.FieldAdminID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AdminOperationLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AdminOperationLogMutation) ClearField(name string) error {
	switch name {
	case adminoperationlog.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case adminoperationlog.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case adminoperationlog.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case adminoperationlog.FieldAdminID:
		m.ClearAdminID()
		return nil
	}
	return fmt.Errorf("unknown AdminOperationLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AdminOperationLogMutation) ResetField(name string) error {
	switch name {
	case adminoperationlog.FieldUUID:
		m.ResetUUID()
		return nil
	case adminoperationlog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case adminoperationlog.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case adminoperationlog.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case adminoperationlog.FieldIP:
		m.ResetIP()
		return nil
	case adminoperationlog.FieldRecord:
		m.ResetRecord()
		return nil
	case adminoperationlog.FieldRemark:
		m.ResetRemark()
		return nil
	case adminoperationlog.FieldAdminID:
		m.ResetAdminID()
		return nil
	}
	return fmt.Errorf("unknown AdminOperationLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AdminOperationLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.admin != nil {
		edges = append(edges, adminoperationlog.EdgeAdmin)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AdminOperationLogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case adminoperationlog.EdgeAdmin:
		if id := m.admin; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AdminOperationLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AdminOperationLogMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AdminOperationLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedadmin {
		edges = append(edges, adminoperationlog.EdgeAdmin)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AdminOperationLogMutation) EdgeCleared(name string) bool {
	switch name {
	case adminoperationlog.EdgeAdmin:
		return m.clearedadmin
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AdminOperationLogMutation) ClearEdge(name string) error {
	switch name {
	case adminoperationlog.EdgeAdmin:
		m.ClearAdmin()
		return nil
	}
	return fmt.Errorf("unknown AdminOperationLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AdminOperationLogMutation) ResetEdge(name string) error {
	switch name {
	case adminoperationlog.EdgeAdmin:
		m.ResetAdmin()
		return nil
	}
	return fmt.Errorf("unknown AdminOperationLog edge %s", name)
}

// AdvertiseMutation represents an operation that mutates the Advertise nodes in the graph.
type AdvertiseMutation struct {
	config
	op                Op
	typ               string
	id                *int
	uuid              *string
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	name              *string
	status            *uint8
	addstatus         *uint8
	position          *uint8
	addposition       *uint8
	start_at          *time.Time
	end_at            *time.Time
	click_count       *int
	addclick_count    *int
	ad_url            *string
	remark            *string
	sort_order        *int
	addsort_order     *int
	clearedFields     map[string]struct{}
	attachment        *int
	clearedattachment bool
	done              bool
	oldValue          func(context.Context) (*Advertise, error)
	predicates        []predicate.Advertise
}

var _ ent.Mutation = (*AdvertiseMutation)(nil)

// advertiseOption allows management of the mutation configuration using functional options.
type advertiseOption func(*AdvertiseMutation)

// newAdvertiseMutation creates new mutation for the Advertise entity.
func newAdvertiseMutation(c config, op Op, opts ...advertiseOption) *AdvertiseMutation {
	m := &AdvertiseMutation{
		config:        c,
		op:            op,
		typ:           TypeAdvertise,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAdvertiseID sets the ID field of the mutation.
func withAdvertiseID(id int) advertiseOption {
	return func(m *AdvertiseMutation) {
		var (
			err   error
			once  sync.Once
			value *Advertise
		)
		m.oldValue = func(ctx context.Context) (*Advertise, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Advertise.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAdvertise sets the old Advertise of the mutation.
func withAdvertise(node *Advertise) advertiseOption {
	return func(m *AdvertiseMutation) {
		m.oldValue = func(context.Context) (*Advertise, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AdvertiseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AdvertiseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *AdvertiseMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *AdvertiseMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *AdvertiseMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the Advertise entity.
// If the Advertise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdvertiseMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *AdvertiseMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AdvertiseMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AdvertiseMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Advertise entity.
// If the Advertise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdvertiseMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *AdvertiseMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[advertise.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *AdvertiseMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[advertise.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AdvertiseMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, advertise.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AdvertiseMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AdvertiseMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Advertise entity.
// If the Advertise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdvertiseMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *AdvertiseMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[advertise.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *AdvertiseMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[advertise.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AdvertiseMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, advertise.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AdvertiseMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AdvertiseMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Advertise entity.
// If the Advertise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdvertiseMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AdvertiseMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[advertise.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AdvertiseMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[advertise.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AdvertiseMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, advertise.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *AdvertiseMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AdvertiseMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Advertise entity.
// If the Advertise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdvertiseMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AdvertiseMutation) ResetName() {
	m.name = nil
}

// SetStatus sets the "status" field.
func (m *AdvertiseMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *AdvertiseMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Advertise entity.
// If the Advertise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdvertiseMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *AdvertiseMutation) AddStatus(u uint8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *AdvertiseMutation) AddedStatus() (r uint8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *AdvertiseMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetPosition sets the "position" field.
func (m *AdvertiseMutation) SetPosition(u uint8) {
	m.position = &u
	m.addposition = nil
}

// Position returns the value of the "position" field in the mutation.
func (m *AdvertiseMutation) Position() (r uint8, exists bool) {
	v := m.position
	if v == nil {
		return
	}
	return *v, true
}

// OldPosition returns the old "position" field's value of the Advertise entity.
// If the Advertise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdvertiseMutation) OldPosition(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPosition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPosition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPosition: %w", err)
	}
	return oldValue.Position, nil
}

// AddPosition adds u to the "position" field.
func (m *AdvertiseMutation) AddPosition(u uint8) {
	if m.addposition != nil {
		*m.addposition += u
	} else {
		m.addposition = &u
	}
}

// AddedPosition returns the value that was added to the "position" field in this mutation.
func (m *AdvertiseMutation) AddedPosition() (r uint8, exists bool) {
	v := m.addposition
	if v == nil {
		return
	}
	return *v, true
}

// ResetPosition resets all changes to the "position" field.
func (m *AdvertiseMutation) ResetPosition() {
	m.position = nil
	m.addposition = nil
}

// SetStartAt sets the "start_at" field.
func (m *AdvertiseMutation) SetStartAt(t time.Time) {
	m.start_at = &t
}

// StartAt returns the value of the "start_at" field in the mutation.
func (m *AdvertiseMutation) StartAt() (r time.Time, exists bool) {
	v := m.start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAt returns the old "start_at" field's value of the Advertise entity.
// If the Advertise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdvertiseMutation) OldStartAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAt: %w", err)
	}
	return oldValue.StartAt, nil
}

// ClearStartAt clears the value of the "start_at" field.
func (m *AdvertiseMutation) ClearStartAt() {
	m.start_at = nil
	m.clearedFields[advertise.FieldStartAt] = struct{}{}
}

// StartAtCleared returns if the "start_at" field was cleared in this mutation.
func (m *AdvertiseMutation) StartAtCleared() bool {
	_, ok := m.clearedFields[advertise.FieldStartAt]
	return ok
}

// ResetStartAt resets all changes to the "start_at" field.
func (m *AdvertiseMutation) ResetStartAt() {
	m.start_at = nil
	delete(m.clearedFields, advertise.FieldStartAt)
}

// SetEndAt sets the "end_at" field.
func (m *AdvertiseMutation) SetEndAt(t time.Time) {
	m.end_at = &t
}

// EndAt returns the value of the "end_at" field in the mutation.
func (m *AdvertiseMutation) EndAt() (r time.Time, exists bool) {
	v := m.end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndAt returns the old "end_at" field's value of the Advertise entity.
// If the Advertise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdvertiseMutation) OldEndAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndAt: %w", err)
	}
	return oldValue.EndAt, nil
}

// ClearEndAt clears the value of the "end_at" field.
func (m *AdvertiseMutation) ClearEndAt() {
	m.end_at = nil
	m.clearedFields[advertise.FieldEndAt] = struct{}{}
}

// EndAtCleared returns if the "end_at" field was cleared in this mutation.
func (m *AdvertiseMutation) EndAtCleared() bool {
	_, ok := m.clearedFields[advertise.FieldEndAt]
	return ok
}

// ResetEndAt resets all changes to the "end_at" field.
func (m *AdvertiseMutation) ResetEndAt() {
	m.end_at = nil
	delete(m.clearedFields, advertise.FieldEndAt)
}

// SetClickCount sets the "click_count" field.
func (m *AdvertiseMutation) SetClickCount(i int) {
	m.click_count = &i
	m.addclick_count = nil
}

// ClickCount returns the value of the "click_count" field in the mutation.
func (m *AdvertiseMutation) ClickCount() (r int, exists bool) {
	v := m.click_count
	if v == nil {
		return
	}
	return *v, true
}

// OldClickCount returns the old "click_count" field's value of the Advertise entity.
// If the Advertise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdvertiseMutation) OldClickCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldClickCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldClickCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClickCount: %w", err)
	}
	return oldValue.ClickCount, nil
}

// AddClickCount adds i to the "click_count" field.
func (m *AdvertiseMutation) AddClickCount(i int) {
	if m.addclick_count != nil {
		*m.addclick_count += i
	} else {
		m.addclick_count = &i
	}
}

// AddedClickCount returns the value that was added to the "click_count" field in this mutation.
func (m *AdvertiseMutation) AddedClickCount() (r int, exists bool) {
	v := m.addclick_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetClickCount resets all changes to the "click_count" field.
func (m *AdvertiseMutation) ResetClickCount() {
	m.click_count = nil
	m.addclick_count = nil
}

// SetAdURL sets the "ad_url" field.
func (m *AdvertiseMutation) SetAdURL(s string) {
	m.ad_url = &s
}

// AdURL returns the value of the "ad_url" field in the mutation.
func (m *AdvertiseMutation) AdURL() (r string, exists bool) {
	v := m.ad_url
	if v == nil {
		return
	}
	return *v, true
}

// OldAdURL returns the old "ad_url" field's value of the Advertise entity.
// If the Advertise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdvertiseMutation) OldAdURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAdURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAdURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdURL: %w", err)
	}
	return oldValue.AdURL, nil
}

// ResetAdURL resets all changes to the "ad_url" field.
func (m *AdvertiseMutation) ResetAdURL() {
	m.ad_url = nil
}

// SetRemark sets the "remark" field.
func (m *AdvertiseMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *AdvertiseMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Advertise entity.
// If the Advertise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdvertiseMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ResetRemark resets all changes to the "remark" field.
func (m *AdvertiseMutation) ResetRemark() {
	m.remark = nil
}

// SetAttachmentID sets the "attachment_id" field.
func (m *AdvertiseMutation) SetAttachmentID(i int) {
	m.attachment = &i
}

// AttachmentID returns the value of the "attachment_id" field in the mutation.
func (m *AdvertiseMutation) AttachmentID() (r int, exists bool) {
	v := m.attachment
	if v == nil {
		return
	}
	return *v, true
}

// OldAttachmentID returns the old "attachment_id" field's value of the Advertise entity.
// If the Advertise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdvertiseMutation) OldAttachmentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAttachmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAttachmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttachmentID: %w", err)
	}
	return oldValue.AttachmentID, nil
}

// ClearAttachmentID clears the value of the "attachment_id" field.
func (m *AdvertiseMutation) ClearAttachmentID() {
	m.attachment = nil
	m.clearedFields[advertise.FieldAttachmentID] = struct{}{}
}

// AttachmentIDCleared returns if the "attachment_id" field was cleared in this mutation.
func (m *AdvertiseMutation) AttachmentIDCleared() bool {
	_, ok := m.clearedFields[advertise.FieldAttachmentID]
	return ok
}

// ResetAttachmentID resets all changes to the "attachment_id" field.
func (m *AdvertiseMutation) ResetAttachmentID() {
	m.attachment = nil
	delete(m.clearedFields, advertise.FieldAttachmentID)
}

// SetSortOrder sets the "sort_order" field.
func (m *AdvertiseMutation) SetSortOrder(i int) {
	m.sort_order = &i
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *AdvertiseMutation) SortOrder() (r int, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the Advertise entity.
// If the Advertise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdvertiseMutation) OldSortOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds i to the "sort_order" field.
func (m *AdvertiseMutation) AddSortOrder(i int) {
	if m.addsort_order != nil {
		*m.addsort_order += i
	} else {
		m.addsort_order = &i
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *AdvertiseMutation) AddedSortOrder() (r int, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *AdvertiseMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
}

// ClearAttachment clears the "attachment" edge to the Attachment entity.
func (m *AdvertiseMutation) ClearAttachment() {
	m.clearedattachment = true
}

// AttachmentCleared reports if the "attachment" edge to the Attachment entity was cleared.
func (m *AdvertiseMutation) AttachmentCleared() bool {
	return m.AttachmentIDCleared() || m.clearedattachment
}

// AttachmentIDs returns the "attachment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AttachmentID instead. It exists only for internal usage by the builders.
func (m *AdvertiseMutation) AttachmentIDs() (ids []int) {
	if id := m.attachment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAttachment resets all changes to the "attachment" edge.
func (m *AdvertiseMutation) ResetAttachment() {
	m.attachment = nil
	m.clearedattachment = false
}

// Op returns the operation name.
func (m *AdvertiseMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Advertise).
func (m *AdvertiseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AdvertiseMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.uuid != nil {
		fields = append(fields, advertise.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, advertise.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, advertise.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, advertise.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, advertise.FieldName)
	}
	if m.status != nil {
		fields = append(fields, advertise.FieldStatus)
	}
	if m.position != nil {
		fields = append(fields, advertise.FieldPosition)
	}
	if m.start_at != nil {
		fields = append(fields, advertise.FieldStartAt)
	}
	if m.end_at != nil {
		fields = append(fields, advertise.FieldEndAt)
	}
	if m.click_count != nil {
		fields = append(fields, advertise.FieldClickCount)
	}
	if m.ad_url != nil {
		fields = append(fields, advertise.FieldAdURL)
	}
	if m.remark != nil {
		fields = append(fields, advertise.FieldRemark)
	}
	if m.attachment != nil {
		fields = append(fields, advertise.FieldAttachmentID)
	}
	if m.sort_order != nil {
		fields = append(fields, advertise.FieldSortOrder)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AdvertiseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case advertise.FieldUUID:
		return m.UUID()
	case advertise.FieldCreatedAt:
		return m.CreatedAt()
	case advertise.FieldUpdatedAt:
		return m.UpdatedAt()
	case advertise.FieldDeletedAt:
		return m.DeletedAt()
	case advertise.FieldName:
		return m.Name()
	case advertise.FieldStatus:
		return m.Status()
	case advertise.FieldPosition:
		return m.Position()
	case advertise.FieldStartAt:
		return m.StartAt()
	case advertise.FieldEndAt:
		return m.EndAt()
	case advertise.FieldClickCount:
		return m.ClickCount()
	case advertise.FieldAdURL:
		return m.AdURL()
	case advertise.FieldRemark:
		return m.Remark()
	case advertise.FieldAttachmentID:
		return m.AttachmentID()
	case advertise.FieldSortOrder:
		return m.SortOrder()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AdvertiseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case advertise.FieldUUID:
		return m.OldUUID(ctx)
	case advertise.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case advertise.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case advertise.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case advertise.FieldName:
		return m.OldName(ctx)
	case advertise.FieldStatus:
		return m.OldStatus(ctx)
	case advertise.FieldPosition:
		return m.OldPosition(ctx)
	case advertise.FieldStartAt:
		return m.OldStartAt(ctx)
	case advertise.FieldEndAt:
		return m.OldEndAt(ctx)
	case advertise.FieldClickCount:
		return m.OldClickCount(ctx)
	case advertise.FieldAdURL:
		return m.OldAdURL(ctx)
	case advertise.FieldRemark:
		return m.OldRemark(ctx)
	case advertise.FieldAttachmentID:
		return m.OldAttachmentID(ctx)
	case advertise.FieldSortOrder:
		return m.OldSortOrder(ctx)
	}
	return nil, fmt.Errorf("unknown Advertise field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdvertiseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case advertise.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case advertise.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case advertise.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case advertise.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case advertise.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case advertise.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case advertise.FieldPosition:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPosition(v)
		return nil
	case advertise.FieldStartAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAt(v)
		return nil
	case advertise.FieldEndAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndAt(v)
		return nil
	case advertise.FieldClickCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClickCount(v)
		return nil
	case advertise.FieldAdURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdURL(v)
		return nil
	case advertise.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case advertise.FieldAttachmentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttachmentID(v)
		return nil
	case advertise.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Advertise field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AdvertiseMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, advertise.FieldStatus)
	}
	if m.addposition != nil {
		fields = append(fields, advertise.FieldPosition)
	}
	if m.addclick_count != nil {
		fields = append(fields, advertise.FieldClickCount)
	}
	if m.addsort_order != nil {
		fields = append(fields, advertise.FieldSortOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AdvertiseMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case advertise.FieldStatus:
		return m.AddedStatus()
	case advertise.FieldPosition:
		return m.AddedPosition()
	case advertise.FieldClickCount:
		return m.AddedClickCount()
	case advertise.FieldSortOrder:
		return m.AddedSortOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdvertiseMutation) AddField(name string, value ent.Value) error {
	switch name {
	case advertise.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case advertise.FieldPosition:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPosition(v)
		return nil
	case advertise.FieldClickCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddClickCount(v)
		return nil
	case advertise.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Advertise numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AdvertiseMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(advertise.FieldCreatedAt) {
		fields = append(fields, advertise.FieldCreatedAt)
	}
	if m.FieldCleared(advertise.FieldUpdatedAt) {
		fields = append(fields, advertise.FieldUpdatedAt)
	}
	if m.FieldCleared(advertise.FieldDeletedAt) {
		fields = append(fields, advertise.FieldDeletedAt)
	}
	if m.FieldCleared(advertise.FieldStartAt) {
		fields = append(fields, advertise.FieldStartAt)
	}
	if m.FieldCleared(advertise.FieldEndAt) {
		fields = append(fields, advertise.FieldEndAt)
	}
	if m.FieldCleared(advertise.FieldAttachmentID) {
		fields = append(fields, advertise.FieldAttachmentID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AdvertiseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AdvertiseMutation) ClearField(name string) error {
	switch name {
	case advertise.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case advertise.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case advertise.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case advertise.FieldStartAt:
		m.ClearStartAt()
		return nil
	case advertise.FieldEndAt:
		m.ClearEndAt()
		return nil
	case advertise.FieldAttachmentID:
		m.ClearAttachmentID()
		return nil
	}
	return fmt.Errorf("unknown Advertise nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AdvertiseMutation) ResetField(name string) error {
	switch name {
	case advertise.FieldUUID:
		m.ResetUUID()
		return nil
	case advertise.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case advertise.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case advertise.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case advertise.FieldName:
		m.ResetName()
		return nil
	case advertise.FieldStatus:
		m.ResetStatus()
		return nil
	case advertise.FieldPosition:
		m.ResetPosition()
		return nil
	case advertise.FieldStartAt:
		m.ResetStartAt()
		return nil
	case advertise.FieldEndAt:
		m.ResetEndAt()
		return nil
	case advertise.FieldClickCount:
		m.ResetClickCount()
		return nil
	case advertise.FieldAdURL:
		m.ResetAdURL()
		return nil
	case advertise.FieldRemark:
		m.ResetRemark()
		return nil
	case advertise.FieldAttachmentID:
		m.ResetAttachmentID()
		return nil
	case advertise.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	}
	return fmt.Errorf("unknown Advertise field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AdvertiseMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.attachment != nil {
		edges = append(edges, advertise.EdgeAttachment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AdvertiseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case advertise.EdgeAttachment:
		if id := m.attachment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AdvertiseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AdvertiseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AdvertiseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedattachment {
		edges = append(edges, advertise.EdgeAttachment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AdvertiseMutation) EdgeCleared(name string) bool {
	switch name {
	case advertise.EdgeAttachment:
		return m.clearedattachment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AdvertiseMutation) ClearEdge(name string) error {
	switch name {
	case advertise.EdgeAttachment:
		m.ClearAttachment()
		return nil
	}
	return fmt.Errorf("unknown Advertise unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AdvertiseMutation) ResetEdge(name string) error {
	switch name {
	case advertise.EdgeAttachment:
		m.ResetAttachment()
		return nil
	}
	return fmt.Errorf("unknown Advertise edge %s", name)
}

// AppAgreementMutation represents an operation that mutates the AppAgreement nodes in the graph.
type AppAgreementMutation struct {
	config
	op            Op
	typ           string
	id            *int
	uuid          *string
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	name          *string
	_type         *uint8
	add_type      *uint8
	detail        *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AppAgreement, error)
	predicates    []predicate.AppAgreement
}

var _ ent.Mutation = (*AppAgreementMutation)(nil)

// appagreementOption allows management of the mutation configuration using functional options.
type appagreementOption func(*AppAgreementMutation)

// newAppAgreementMutation creates new mutation for the AppAgreement entity.
func newAppAgreementMutation(c config, op Op, opts ...appagreementOption) *AppAgreementMutation {
	m := &AppAgreementMutation{
		config:        c,
		op:            op,
		typ:           TypeAppAgreement,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppAgreementID sets the ID field of the mutation.
func withAppAgreementID(id int) appagreementOption {
	return func(m *AppAgreementMutation) {
		var (
			err   error
			once  sync.Once
			value *AppAgreement
		)
		m.oldValue = func(ctx context.Context) (*AppAgreement, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppAgreement.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppAgreement sets the old AppAgreement of the mutation.
func withAppAgreement(node *AppAgreement) appagreementOption {
	return func(m *AppAgreementMutation) {
		m.oldValue = func(context.Context) (*AppAgreement, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppAgreementMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppAgreementMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *AppAgreementMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *AppAgreementMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *AppAgreementMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the AppAgreement entity.
// If the AppAgreement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppAgreementMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *AppAgreementMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AppAgreementMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppAgreementMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppAgreement entity.
// If the AppAgreement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppAgreementMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *AppAgreementMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[appagreement.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *AppAgreementMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[appagreement.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppAgreementMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, appagreement.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppAgreementMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppAgreementMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppAgreement entity.
// If the AppAgreement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppAgreementMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *AppAgreementMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[appagreement.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *AppAgreementMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[appagreement.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppAgreementMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, appagreement.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppAgreementMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppAgreementMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AppAgreement entity.
// If the AppAgreement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppAgreementMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AppAgreementMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[appagreement.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AppAgreementMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[appagreement.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppAgreementMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, appagreement.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *AppAgreementMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AppAgreementMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AppAgreement entity.
// If the AppAgreement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppAgreementMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AppAgreementMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *AppAgreementMutation) SetType(u uint8) {
	m._type = &u
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *AppAgreementMutation) GetType() (r uint8, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the AppAgreement entity.
// If the AppAgreement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppAgreementMutation) OldType(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds u to the "type" field.
func (m *AppAgreementMutation) AddType(u uint8) {
	if m.add_type != nil {
		*m.add_type += u
	} else {
		m.add_type = &u
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *AppAgreementMutation) AddedType() (r uint8, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *AppAgreementMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetDetail sets the "detail" field.
func (m *AppAgreementMutation) SetDetail(s string) {
	m.detail = &s
}

// Detail returns the value of the "detail" field in the mutation.
func (m *AppAgreementMutation) Detail() (r string, exists bool) {
	v := m.detail
	if v == nil {
		return
	}
	return *v, true
}

// OldDetail returns the old "detail" field's value of the AppAgreement entity.
// If the AppAgreement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppAgreementMutation) OldDetail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDetail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDetail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetail: %w", err)
	}
	return oldValue.Detail, nil
}

// ClearDetail clears the value of the "detail" field.
func (m *AppAgreementMutation) ClearDetail() {
	m.detail = nil
	m.clearedFields[appagreement.FieldDetail] = struct{}{}
}

// DetailCleared returns if the "detail" field was cleared in this mutation.
func (m *AppAgreementMutation) DetailCleared() bool {
	_, ok := m.clearedFields[appagreement.FieldDetail]
	return ok
}

// ResetDetail resets all changes to the "detail" field.
func (m *AppAgreementMutation) ResetDetail() {
	m.detail = nil
	delete(m.clearedFields, appagreement.FieldDetail)
}

// Op returns the operation name.
func (m *AppAgreementMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AppAgreement).
func (m *AppAgreementMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppAgreementMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.uuid != nil {
		fields = append(fields, appagreement.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, appagreement.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, appagreement.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, appagreement.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, appagreement.FieldName)
	}
	if m._type != nil {
		fields = append(fields, appagreement.FieldType)
	}
	if m.detail != nil {
		fields = append(fields, appagreement.FieldDetail)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppAgreementMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appagreement.FieldUUID:
		return m.UUID()
	case appagreement.FieldCreatedAt:
		return m.CreatedAt()
	case appagreement.FieldUpdatedAt:
		return m.UpdatedAt()
	case appagreement.FieldDeletedAt:
		return m.DeletedAt()
	case appagreement.FieldName:
		return m.Name()
	case appagreement.FieldType:
		return m.GetType()
	case appagreement.FieldDetail:
		return m.Detail()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppAgreementMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appagreement.FieldUUID:
		return m.OldUUID(ctx)
	case appagreement.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appagreement.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appagreement.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case appagreement.FieldName:
		return m.OldName(ctx)
	case appagreement.FieldType:
		return m.OldType(ctx)
	case appagreement.FieldDetail:
		return m.OldDetail(ctx)
	}
	return nil, fmt.Errorf("unknown AppAgreement field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppAgreementMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appagreement.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case appagreement.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appagreement.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appagreement.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case appagreement.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case appagreement.FieldType:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case appagreement.FieldDetail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetail(v)
		return nil
	}
	return fmt.Errorf("unknown AppAgreement field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppAgreementMutation) AddedFields() []string {
	var fields []string
	if m.add_type != nil {
		fields = append(fields, appagreement.FieldType)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppAgreementMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appagreement.FieldType:
		return m.AddedType()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppAgreementMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appagreement.FieldType:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	}
	return fmt.Errorf("unknown AppAgreement numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppAgreementMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(appagreement.FieldCreatedAt) {
		fields = append(fields, appagreement.FieldCreatedAt)
	}
	if m.FieldCleared(appagreement.FieldUpdatedAt) {
		fields = append(fields, appagreement.FieldUpdatedAt)
	}
	if m.FieldCleared(appagreement.FieldDeletedAt) {
		fields = append(fields, appagreement.FieldDeletedAt)
	}
	if m.FieldCleared(appagreement.FieldDetail) {
		fields = append(fields, appagreement.FieldDetail)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppAgreementMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppAgreementMutation) ClearField(name string) error {
	switch name {
	case appagreement.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case appagreement.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case appagreement.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case appagreement.FieldDetail:
		m.ClearDetail()
		return nil
	}
	return fmt.Errorf("unknown AppAgreement nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppAgreementMutation) ResetField(name string) error {
	switch name {
	case appagreement.FieldUUID:
		m.ResetUUID()
		return nil
	case appagreement.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appagreement.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appagreement.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case appagreement.FieldName:
		m.ResetName()
		return nil
	case appagreement.FieldType:
		m.ResetType()
		return nil
	case appagreement.FieldDetail:
		m.ResetDetail()
		return nil
	}
	return fmt.Errorf("unknown AppAgreement field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppAgreementMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppAgreementMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppAgreementMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppAgreementMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppAgreementMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppAgreementMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppAgreementMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppAgreement unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppAgreementMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppAgreement edge %s", name)
}

// AppVersionMutation represents an operation that mutates the AppVersion nodes in the graph.
type AppVersionMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	uuid               *string
	created_at         *time.Time
	updated_at         *time.Time
	deleted_at         *time.Time
	ip                 *uint16
	addip              *uint16
	name               *string
	sn                 *string
	remark             *string
	url                *string
	phone_type         *uint8
	addphone_type      *uint8
	is_force_update    *uint8
	addis_force_update *uint8
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*AppVersion, error)
	predicates         []predicate.AppVersion
}

var _ ent.Mutation = (*AppVersionMutation)(nil)

// appversionOption allows management of the mutation configuration using functional options.
type appversionOption func(*AppVersionMutation)

// newAppVersionMutation creates new mutation for the AppVersion entity.
func newAppVersionMutation(c config, op Op, opts ...appversionOption) *AppVersionMutation {
	m := &AppVersionMutation{
		config:        c,
		op:            op,
		typ:           TypeAppVersion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppVersionID sets the ID field of the mutation.
func withAppVersionID(id int) appversionOption {
	return func(m *AppVersionMutation) {
		var (
			err   error
			once  sync.Once
			value *AppVersion
		)
		m.oldValue = func(ctx context.Context) (*AppVersion, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppVersion.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppVersion sets the old AppVersion of the mutation.
func withAppVersion(node *AppVersion) appversionOption {
	return func(m *AppVersionMutation) {
		m.oldValue = func(context.Context) (*AppVersion, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppVersionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppVersionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *AppVersionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *AppVersionMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *AppVersionMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the AppVersion entity.
// If the AppVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppVersionMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *AppVersionMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AppVersionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppVersionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppVersion entity.
// If the AppVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppVersionMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *AppVersionMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[appversion.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *AppVersionMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[appversion.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppVersionMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, appversion.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppVersionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppVersionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppVersion entity.
// If the AppVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppVersionMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *AppVersionMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[appversion.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *AppVersionMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[appversion.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppVersionMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, appversion.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppVersionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppVersionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AppVersion entity.
// If the AppVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppVersionMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AppVersionMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[appversion.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AppVersionMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[appversion.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppVersionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, appversion.FieldDeletedAt)
}

// SetIP sets the "ip" field.
func (m *AppVersionMutation) SetIP(u uint16) {
	m.ip = &u
	m.addip = nil
}

// IP returns the value of the "ip" field in the mutation.
func (m *AppVersionMutation) IP() (r uint16, exists bool) {
	v := m.ip
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old "ip" field's value of the AppVersion entity.
// If the AppVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppVersionMutation) OldIP(ctx context.Context) (v uint16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// AddIP adds u to the "ip" field.
func (m *AppVersionMutation) AddIP(u uint16) {
	if m.addip != nil {
		*m.addip += u
	} else {
		m.addip = &u
	}
}

// AddedIP returns the value that was added to the "ip" field in this mutation.
func (m *AppVersionMutation) AddedIP() (r uint16, exists bool) {
	v := m.addip
	if v == nil {
		return
	}
	return *v, true
}

// ResetIP resets all changes to the "ip" field.
func (m *AppVersionMutation) ResetIP() {
	m.ip = nil
	m.addip = nil
}

// SetName sets the "name" field.
func (m *AppVersionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AppVersionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AppVersion entity.
// If the AppVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppVersionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AppVersionMutation) ResetName() {
	m.name = nil
}

// SetSn sets the "sn" field.
func (m *AppVersionMutation) SetSn(s string) {
	m.sn = &s
}

// Sn returns the value of the "sn" field in the mutation.
func (m *AppVersionMutation) Sn() (r string, exists bool) {
	v := m.sn
	if v == nil {
		return
	}
	return *v, true
}

// OldSn returns the old "sn" field's value of the AppVersion entity.
// If the AppVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppVersionMutation) OldSn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSn: %w", err)
	}
	return oldValue.Sn, nil
}

// ResetSn resets all changes to the "sn" field.
func (m *AppVersionMutation) ResetSn() {
	m.sn = nil
}

// SetRemark sets the "remark" field.
func (m *AppVersionMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *AppVersionMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the AppVersion entity.
// If the AppVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppVersionMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *AppVersionMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[appversion.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *AppVersionMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[appversion.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *AppVersionMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, appversion.FieldRemark)
}

// SetURL sets the "url" field.
func (m *AppVersionMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *AppVersionMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the AppVersion entity.
// If the AppVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppVersionMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *AppVersionMutation) ResetURL() {
	m.url = nil
}

// SetPhoneType sets the "phone_type" field.
func (m *AppVersionMutation) SetPhoneType(u uint8) {
	m.phone_type = &u
	m.addphone_type = nil
}

// PhoneType returns the value of the "phone_type" field in the mutation.
func (m *AppVersionMutation) PhoneType() (r uint8, exists bool) {
	v := m.phone_type
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneType returns the old "phone_type" field's value of the AppVersion entity.
// If the AppVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppVersionMutation) OldPhoneType(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPhoneType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPhoneType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneType: %w", err)
	}
	return oldValue.PhoneType, nil
}

// AddPhoneType adds u to the "phone_type" field.
func (m *AppVersionMutation) AddPhoneType(u uint8) {
	if m.addphone_type != nil {
		*m.addphone_type += u
	} else {
		m.addphone_type = &u
	}
}

// AddedPhoneType returns the value that was added to the "phone_type" field in this mutation.
func (m *AppVersionMutation) AddedPhoneType() (r uint8, exists bool) {
	v := m.addphone_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetPhoneType resets all changes to the "phone_type" field.
func (m *AppVersionMutation) ResetPhoneType() {
	m.phone_type = nil
	m.addphone_type = nil
}

// SetIsForceUpdate sets the "is_force_update" field.
func (m *AppVersionMutation) SetIsForceUpdate(u uint8) {
	m.is_force_update = &u
	m.addis_force_update = nil
}

// IsForceUpdate returns the value of the "is_force_update" field in the mutation.
func (m *AppVersionMutation) IsForceUpdate() (r uint8, exists bool) {
	v := m.is_force_update
	if v == nil {
		return
	}
	return *v, true
}

// OldIsForceUpdate returns the old "is_force_update" field's value of the AppVersion entity.
// If the AppVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppVersionMutation) OldIsForceUpdate(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsForceUpdate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsForceUpdate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsForceUpdate: %w", err)
	}
	return oldValue.IsForceUpdate, nil
}

// AddIsForceUpdate adds u to the "is_force_update" field.
func (m *AppVersionMutation) AddIsForceUpdate(u uint8) {
	if m.addis_force_update != nil {
		*m.addis_force_update += u
	} else {
		m.addis_force_update = &u
	}
}

// AddedIsForceUpdate returns the value that was added to the "is_force_update" field in this mutation.
func (m *AppVersionMutation) AddedIsForceUpdate() (r uint8, exists bool) {
	v := m.addis_force_update
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsForceUpdate resets all changes to the "is_force_update" field.
func (m *AppVersionMutation) ResetIsForceUpdate() {
	m.is_force_update = nil
	m.addis_force_update = nil
}

// Op returns the operation name.
func (m *AppVersionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AppVersion).
func (m *AppVersionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppVersionMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.uuid != nil {
		fields = append(fields, appversion.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, appversion.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, appversion.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, appversion.FieldDeletedAt)
	}
	if m.ip != nil {
		fields = append(fields, appversion.FieldIP)
	}
	if m.name != nil {
		fields = append(fields, appversion.FieldName)
	}
	if m.sn != nil {
		fields = append(fields, appversion.FieldSn)
	}
	if m.remark != nil {
		fields = append(fields, appversion.FieldRemark)
	}
	if m.url != nil {
		fields = append(fields, appversion.FieldURL)
	}
	if m.phone_type != nil {
		fields = append(fields, appversion.FieldPhoneType)
	}
	if m.is_force_update != nil {
		fields = append(fields, appversion.FieldIsForceUpdate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppVersionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appversion.FieldUUID:
		return m.UUID()
	case appversion.FieldCreatedAt:
		return m.CreatedAt()
	case appversion.FieldUpdatedAt:
		return m.UpdatedAt()
	case appversion.FieldDeletedAt:
		return m.DeletedAt()
	case appversion.FieldIP:
		return m.IP()
	case appversion.FieldName:
		return m.Name()
	case appversion.FieldSn:
		return m.Sn()
	case appversion.FieldRemark:
		return m.Remark()
	case appversion.FieldURL:
		return m.URL()
	case appversion.FieldPhoneType:
		return m.PhoneType()
	case appversion.FieldIsForceUpdate:
		return m.IsForceUpdate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppVersionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appversion.FieldUUID:
		return m.OldUUID(ctx)
	case appversion.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appversion.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appversion.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case appversion.FieldIP:
		return m.OldIP(ctx)
	case appversion.FieldName:
		return m.OldName(ctx)
	case appversion.FieldSn:
		return m.OldSn(ctx)
	case appversion.FieldRemark:
		return m.OldRemark(ctx)
	case appversion.FieldURL:
		return m.OldURL(ctx)
	case appversion.FieldPhoneType:
		return m.OldPhoneType(ctx)
	case appversion.FieldIsForceUpdate:
		return m.OldIsForceUpdate(ctx)
	}
	return nil, fmt.Errorf("unknown AppVersion field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppVersionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appversion.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case appversion.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appversion.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appversion.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case appversion.FieldIP:
		v, ok := value.(uint16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	case appversion.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case appversion.FieldSn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSn(v)
		return nil
	case appversion.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case appversion.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case appversion.FieldPhoneType:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneType(v)
		return nil
	case appversion.FieldIsForceUpdate:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsForceUpdate(v)
		return nil
	}
	return fmt.Errorf("unknown AppVersion field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppVersionMutation) AddedFields() []string {
	var fields []string
	if m.addip != nil {
		fields = append(fields, appversion.FieldIP)
	}
	if m.addphone_type != nil {
		fields = append(fields, appversion.FieldPhoneType)
	}
	if m.addis_force_update != nil {
		fields = append(fields, appversion.FieldIsForceUpdate)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppVersionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appversion.FieldIP:
		return m.AddedIP()
	case appversion.FieldPhoneType:
		return m.AddedPhoneType()
	case appversion.FieldIsForceUpdate:
		return m.AddedIsForceUpdate()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppVersionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appversion.FieldIP:
		v, ok := value.(uint16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIP(v)
		return nil
	case appversion.FieldPhoneType:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPhoneType(v)
		return nil
	case appversion.FieldIsForceUpdate:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsForceUpdate(v)
		return nil
	}
	return fmt.Errorf("unknown AppVersion numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppVersionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(appversion.FieldCreatedAt) {
		fields = append(fields, appversion.FieldCreatedAt)
	}
	if m.FieldCleared(appversion.FieldUpdatedAt) {
		fields = append(fields, appversion.FieldUpdatedAt)
	}
	if m.FieldCleared(appversion.FieldDeletedAt) {
		fields = append(fields, appversion.FieldDeletedAt)
	}
	if m.FieldCleared(appversion.FieldRemark) {
		fields = append(fields, appversion.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppVersionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppVersionMutation) ClearField(name string) error {
	switch name {
	case appversion.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case appversion.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case appversion.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case appversion.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown AppVersion nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppVersionMutation) ResetField(name string) error {
	switch name {
	case appversion.FieldUUID:
		m.ResetUUID()
		return nil
	case appversion.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appversion.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appversion.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case appversion.FieldIP:
		m.ResetIP()
		return nil
	case appversion.FieldName:
		m.ResetName()
		return nil
	case appversion.FieldSn:
		m.ResetSn()
		return nil
	case appversion.FieldRemark:
		m.ResetRemark()
		return nil
	case appversion.FieldURL:
		m.ResetURL()
		return nil
	case appversion.FieldPhoneType:
		m.ResetPhoneType()
		return nil
	case appversion.FieldIsForceUpdate:
		m.ResetIsForceUpdate()
		return nil
	}
	return fmt.Errorf("unknown AppVersion field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppVersionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppVersionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppVersionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppVersionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppVersionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppVersionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppVersionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppVersion unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppVersionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppVersion edge %s", name)
}

// AttachmentMutation represents an operation that mutates the Attachment nodes in the graph.
type AttachmentMutation struct {
	config
	op                                Op
	typ                               string
	id                                *int
	uuid                              *string
	created_at                        *time.Time
	updated_at                        *time.Time
	deleted_at                        *time.Time
	filename                          *string
	file_size                         *uint32
	addfile_size                      *uint32
	mime_type                         *string
	user_id                           *int
	adduser_id                        *int
	admin_id                          *int
	addadmin_id                       *int
	clearedFields                     map[string]struct{}
	major_detail_cover_img            map[int]struct{}
	removedmajor_detail_cover_img     map[int]struct{}
	clearedmajor_detail_cover_img     bool
	major_detail_subject_img          map[int]struct{}
	removedmajor_detail_subject_img   map[int]struct{}
	clearedmajor_detail_subject_img   bool
	major_teacher_attachment          map[int]struct{}
	removedmajor_teacher_attachment   map[int]struct{}
	clearedmajor_teacher_attachment   bool
	major_service_attachment          map[int]struct{}
	removedmajor_service_attachment   map[int]struct{}
	clearedmajor_service_attachment   bool
	advertise                         map[int]struct{}
	removedadvertise                  map[int]struct{}
	clearedadvertise                  bool
	message_attachment                map[int]struct{}
	removedmessage_attachment         map[int]struct{}
	clearedmessage_attachment         bool
	share_poster_attachments          map[int]struct{}
	removedshare_poster_attachments   map[int]struct{}
	clearedshare_poster_attachments   bool
	teacher_attachments               map[int]struct{}
	removedteacher_attachments        map[int]struct{}
	clearedteacher_attachments        bool
	admin_img_id                      *int
	clearedadmin_img_id               bool
	small_category_attachments        map[int]struct{}
	removedsmall_category_attachments map[int]struct{}
	clearedsmall_category_attachments bool
	course_attachments                map[int]struct{}
	removedcourse_attachments         map[int]struct{}
	clearedcourse_attachments         bool
	class_cover_attachments           map[int]struct{}
	removedclass_cover_attachments    map[int]struct{}
	clearedclass_cover_attachments    bool
	courseware_attachment             *int
	clearedcourseware_attachment      bool
	order_attachment                  *int
	clearedorder_attachment           bool
	video_task_attachment             map[int]struct{}
	removedvideo_task_attachment      map[int]struct{}
	clearedvideo_task_attachment      bool
	ask_attachments                   map[int]struct{}
	removedask_attachments            map[int]struct{}
	clearedask_attachments            bool
	done                              bool
	oldValue                          func(context.Context) (*Attachment, error)
	predicates                        []predicate.Attachment
}

var _ ent.Mutation = (*AttachmentMutation)(nil)

// attachmentOption allows management of the mutation configuration using functional options.
type attachmentOption func(*AttachmentMutation)

// newAttachmentMutation creates new mutation for the Attachment entity.
func newAttachmentMutation(c config, op Op, opts ...attachmentOption) *AttachmentMutation {
	m := &AttachmentMutation{
		config:        c,
		op:            op,
		typ:           TypeAttachment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAttachmentID sets the ID field of the mutation.
func withAttachmentID(id int) attachmentOption {
	return func(m *AttachmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Attachment
		)
		m.oldValue = func(ctx context.Context) (*Attachment, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Attachment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAttachment sets the old Attachment of the mutation.
func withAttachment(node *Attachment) attachmentOption {
	return func(m *AttachmentMutation) {
		m.oldValue = func(context.Context) (*Attachment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AttachmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AttachmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *AttachmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *AttachmentMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *AttachmentMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *AttachmentMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AttachmentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AttachmentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *AttachmentMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[attachment.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *AttachmentMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[attachment.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AttachmentMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, attachment.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AttachmentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AttachmentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *AttachmentMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[attachment.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *AttachmentMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[attachment.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AttachmentMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, attachment.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AttachmentMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AttachmentMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AttachmentMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[attachment.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AttachmentMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[attachment.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AttachmentMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, attachment.FieldDeletedAt)
}

// SetFilename sets the "filename" field.
func (m *AttachmentMutation) SetFilename(s string) {
	m.filename = &s
}

// Filename returns the value of the "filename" field in the mutation.
func (m *AttachmentMutation) Filename() (r string, exists bool) {
	v := m.filename
	if v == nil {
		return
	}
	return *v, true
}

// OldFilename returns the old "filename" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldFilename(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFilename is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFilename requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilename: %w", err)
	}
	return oldValue.Filename, nil
}

// ResetFilename resets all changes to the "filename" field.
func (m *AttachmentMutation) ResetFilename() {
	m.filename = nil
}

// SetFileSize sets the "file_size" field.
func (m *AttachmentMutation) SetFileSize(u uint32) {
	m.file_size = &u
	m.addfile_size = nil
}

// FileSize returns the value of the "file_size" field in the mutation.
func (m *AttachmentMutation) FileSize() (r uint32, exists bool) {
	v := m.file_size
	if v == nil {
		return
	}
	return *v, true
}

// OldFileSize returns the old "file_size" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldFileSize(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFileSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFileSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileSize: %w", err)
	}
	return oldValue.FileSize, nil
}

// AddFileSize adds u to the "file_size" field.
func (m *AttachmentMutation) AddFileSize(u uint32) {
	if m.addfile_size != nil {
		*m.addfile_size += u
	} else {
		m.addfile_size = &u
	}
}

// AddedFileSize returns the value that was added to the "file_size" field in this mutation.
func (m *AttachmentMutation) AddedFileSize() (r uint32, exists bool) {
	v := m.addfile_size
	if v == nil {
		return
	}
	return *v, true
}

// ResetFileSize resets all changes to the "file_size" field.
func (m *AttachmentMutation) ResetFileSize() {
	m.file_size = nil
	m.addfile_size = nil
}

// SetMimeType sets the "mime_type" field.
func (m *AttachmentMutation) SetMimeType(s string) {
	m.mime_type = &s
}

// MimeType returns the value of the "mime_type" field in the mutation.
func (m *AttachmentMutation) MimeType() (r string, exists bool) {
	v := m.mime_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMimeType returns the old "mime_type" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldMimeType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMimeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMimeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMimeType: %w", err)
	}
	return oldValue.MimeType, nil
}

// ResetMimeType resets all changes to the "mime_type" field.
func (m *AttachmentMutation) ResetMimeType() {
	m.mime_type = nil
}

// SetUserID sets the "user_id" field.
func (m *AttachmentMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AttachmentMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *AttachmentMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *AttachmentMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearUserID clears the value of the "user_id" field.
func (m *AttachmentMutation) ClearUserID() {
	m.user_id = nil
	m.adduser_id = nil
	m.clearedFields[attachment.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *AttachmentMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[attachment.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AttachmentMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
	delete(m.clearedFields, attachment.FieldUserID)
}

// SetAdminID sets the "admin_id" field.
func (m *AttachmentMutation) SetAdminID(i int) {
	m.admin_id = &i
	m.addadmin_id = nil
}

// AdminID returns the value of the "admin_id" field in the mutation.
func (m *AttachmentMutation) AdminID() (r int, exists bool) {
	v := m.admin_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAdminID returns the old "admin_id" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldAdminID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAdminID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAdminID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdminID: %w", err)
	}
	return oldValue.AdminID, nil
}

// AddAdminID adds i to the "admin_id" field.
func (m *AttachmentMutation) AddAdminID(i int) {
	if m.addadmin_id != nil {
		*m.addadmin_id += i
	} else {
		m.addadmin_id = &i
	}
}

// AddedAdminID returns the value that was added to the "admin_id" field in this mutation.
func (m *AttachmentMutation) AddedAdminID() (r int, exists bool) {
	v := m.addadmin_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearAdminID clears the value of the "admin_id" field.
func (m *AttachmentMutation) ClearAdminID() {
	m.admin_id = nil
	m.addadmin_id = nil
	m.clearedFields[attachment.FieldAdminID] = struct{}{}
}

// AdminIDCleared returns if the "admin_id" field was cleared in this mutation.
func (m *AttachmentMutation) AdminIDCleared() bool {
	_, ok := m.clearedFields[attachment.FieldAdminID]
	return ok
}

// ResetAdminID resets all changes to the "admin_id" field.
func (m *AttachmentMutation) ResetAdminID() {
	m.admin_id = nil
	m.addadmin_id = nil
	delete(m.clearedFields, attachment.FieldAdminID)
}

// AddMajorDetailCoverImgIDs adds the "major_detail_cover_img" edge to the MajorDetail entity by ids.
func (m *AttachmentMutation) AddMajorDetailCoverImgIDs(ids ...int) {
	if m.major_detail_cover_img == nil {
		m.major_detail_cover_img = make(map[int]struct{})
	}
	for i := range ids {
		m.major_detail_cover_img[ids[i]] = struct{}{}
	}
}

// ClearMajorDetailCoverImg clears the "major_detail_cover_img" edge to the MajorDetail entity.
func (m *AttachmentMutation) ClearMajorDetailCoverImg() {
	m.clearedmajor_detail_cover_img = true
}

// MajorDetailCoverImgCleared reports if the "major_detail_cover_img" edge to the MajorDetail entity was cleared.
func (m *AttachmentMutation) MajorDetailCoverImgCleared() bool {
	return m.clearedmajor_detail_cover_img
}

// RemoveMajorDetailCoverImgIDs removes the "major_detail_cover_img" edge to the MajorDetail entity by IDs.
func (m *AttachmentMutation) RemoveMajorDetailCoverImgIDs(ids ...int) {
	if m.removedmajor_detail_cover_img == nil {
		m.removedmajor_detail_cover_img = make(map[int]struct{})
	}
	for i := range ids {
		m.removedmajor_detail_cover_img[ids[i]] = struct{}{}
	}
}

// RemovedMajorDetailCoverImg returns the removed IDs of the "major_detail_cover_img" edge to the MajorDetail entity.
func (m *AttachmentMutation) RemovedMajorDetailCoverImgIDs() (ids []int) {
	for id := range m.removedmajor_detail_cover_img {
		ids = append(ids, id)
	}
	return
}

// MajorDetailCoverImgIDs returns the "major_detail_cover_img" edge IDs in the mutation.
func (m *AttachmentMutation) MajorDetailCoverImgIDs() (ids []int) {
	for id := range m.major_detail_cover_img {
		ids = append(ids, id)
	}
	return
}

// ResetMajorDetailCoverImg resets all changes to the "major_detail_cover_img" edge.
func (m *AttachmentMutation) ResetMajorDetailCoverImg() {
	m.major_detail_cover_img = nil
	m.clearedmajor_detail_cover_img = false
	m.removedmajor_detail_cover_img = nil
}

// AddMajorDetailSubjectImgIDs adds the "major_detail_subject_img" edge to the MajorDetail entity by ids.
func (m *AttachmentMutation) AddMajorDetailSubjectImgIDs(ids ...int) {
	if m.major_detail_subject_img == nil {
		m.major_detail_subject_img = make(map[int]struct{})
	}
	for i := range ids {
		m.major_detail_subject_img[ids[i]] = struct{}{}
	}
}

// ClearMajorDetailSubjectImg clears the "major_detail_subject_img" edge to the MajorDetail entity.
func (m *AttachmentMutation) ClearMajorDetailSubjectImg() {
	m.clearedmajor_detail_subject_img = true
}

// MajorDetailSubjectImgCleared reports if the "major_detail_subject_img" edge to the MajorDetail entity was cleared.
func (m *AttachmentMutation) MajorDetailSubjectImgCleared() bool {
	return m.clearedmajor_detail_subject_img
}

// RemoveMajorDetailSubjectImgIDs removes the "major_detail_subject_img" edge to the MajorDetail entity by IDs.
func (m *AttachmentMutation) RemoveMajorDetailSubjectImgIDs(ids ...int) {
	if m.removedmajor_detail_subject_img == nil {
		m.removedmajor_detail_subject_img = make(map[int]struct{})
	}
	for i := range ids {
		m.removedmajor_detail_subject_img[ids[i]] = struct{}{}
	}
}

// RemovedMajorDetailSubjectImg returns the removed IDs of the "major_detail_subject_img" edge to the MajorDetail entity.
func (m *AttachmentMutation) RemovedMajorDetailSubjectImgIDs() (ids []int) {
	for id := range m.removedmajor_detail_subject_img {
		ids = append(ids, id)
	}
	return
}

// MajorDetailSubjectImgIDs returns the "major_detail_subject_img" edge IDs in the mutation.
func (m *AttachmentMutation) MajorDetailSubjectImgIDs() (ids []int) {
	for id := range m.major_detail_subject_img {
		ids = append(ids, id)
	}
	return
}

// ResetMajorDetailSubjectImg resets all changes to the "major_detail_subject_img" edge.
func (m *AttachmentMutation) ResetMajorDetailSubjectImg() {
	m.major_detail_subject_img = nil
	m.clearedmajor_detail_subject_img = false
	m.removedmajor_detail_subject_img = nil
}

// AddMajorTeacherAttachmentIDs adds the "major_teacher_attachment" edge to the MajorDetail entity by ids.
func (m *AttachmentMutation) AddMajorTeacherAttachmentIDs(ids ...int) {
	if m.major_teacher_attachment == nil {
		m.major_teacher_attachment = make(map[int]struct{})
	}
	for i := range ids {
		m.major_teacher_attachment[ids[i]] = struct{}{}
	}
}

// ClearMajorTeacherAttachment clears the "major_teacher_attachment" edge to the MajorDetail entity.
func (m *AttachmentMutation) ClearMajorTeacherAttachment() {
	m.clearedmajor_teacher_attachment = true
}

// MajorTeacherAttachmentCleared reports if the "major_teacher_attachment" edge to the MajorDetail entity was cleared.
func (m *AttachmentMutation) MajorTeacherAttachmentCleared() bool {
	return m.clearedmajor_teacher_attachment
}

// RemoveMajorTeacherAttachmentIDs removes the "major_teacher_attachment" edge to the MajorDetail entity by IDs.
func (m *AttachmentMutation) RemoveMajorTeacherAttachmentIDs(ids ...int) {
	if m.removedmajor_teacher_attachment == nil {
		m.removedmajor_teacher_attachment = make(map[int]struct{})
	}
	for i := range ids {
		m.removedmajor_teacher_attachment[ids[i]] = struct{}{}
	}
}

// RemovedMajorTeacherAttachment returns the removed IDs of the "major_teacher_attachment" edge to the MajorDetail entity.
func (m *AttachmentMutation) RemovedMajorTeacherAttachmentIDs() (ids []int) {
	for id := range m.removedmajor_teacher_attachment {
		ids = append(ids, id)
	}
	return
}

// MajorTeacherAttachmentIDs returns the "major_teacher_attachment" edge IDs in the mutation.
func (m *AttachmentMutation) MajorTeacherAttachmentIDs() (ids []int) {
	for id := range m.major_teacher_attachment {
		ids = append(ids, id)
	}
	return
}

// ResetMajorTeacherAttachment resets all changes to the "major_teacher_attachment" edge.
func (m *AttachmentMutation) ResetMajorTeacherAttachment() {
	m.major_teacher_attachment = nil
	m.clearedmajor_teacher_attachment = false
	m.removedmajor_teacher_attachment = nil
}

// AddMajorServiceAttachmentIDs adds the "major_service_attachment" edge to the MajorDetail entity by ids.
func (m *AttachmentMutation) AddMajorServiceAttachmentIDs(ids ...int) {
	if m.major_service_attachment == nil {
		m.major_service_attachment = make(map[int]struct{})
	}
	for i := range ids {
		m.major_service_attachment[ids[i]] = struct{}{}
	}
}

// ClearMajorServiceAttachment clears the "major_service_attachment" edge to the MajorDetail entity.
func (m *AttachmentMutation) ClearMajorServiceAttachment() {
	m.clearedmajor_service_attachment = true
}

// MajorServiceAttachmentCleared reports if the "major_service_attachment" edge to the MajorDetail entity was cleared.
func (m *AttachmentMutation) MajorServiceAttachmentCleared() bool {
	return m.clearedmajor_service_attachment
}

// RemoveMajorServiceAttachmentIDs removes the "major_service_attachment" edge to the MajorDetail entity by IDs.
func (m *AttachmentMutation) RemoveMajorServiceAttachmentIDs(ids ...int) {
	if m.removedmajor_service_attachment == nil {
		m.removedmajor_service_attachment = make(map[int]struct{})
	}
	for i := range ids {
		m.removedmajor_service_attachment[ids[i]] = struct{}{}
	}
}

// RemovedMajorServiceAttachment returns the removed IDs of the "major_service_attachment" edge to the MajorDetail entity.
func (m *AttachmentMutation) RemovedMajorServiceAttachmentIDs() (ids []int) {
	for id := range m.removedmajor_service_attachment {
		ids = append(ids, id)
	}
	return
}

// MajorServiceAttachmentIDs returns the "major_service_attachment" edge IDs in the mutation.
func (m *AttachmentMutation) MajorServiceAttachmentIDs() (ids []int) {
	for id := range m.major_service_attachment {
		ids = append(ids, id)
	}
	return
}

// ResetMajorServiceAttachment resets all changes to the "major_service_attachment" edge.
func (m *AttachmentMutation) ResetMajorServiceAttachment() {
	m.major_service_attachment = nil
	m.clearedmajor_service_attachment = false
	m.removedmajor_service_attachment = nil
}

// AddAdvertiseIDs adds the "advertise" edge to the Advertise entity by ids.
func (m *AttachmentMutation) AddAdvertiseIDs(ids ...int) {
	if m.advertise == nil {
		m.advertise = make(map[int]struct{})
	}
	for i := range ids {
		m.advertise[ids[i]] = struct{}{}
	}
}

// ClearAdvertise clears the "advertise" edge to the Advertise entity.
func (m *AttachmentMutation) ClearAdvertise() {
	m.clearedadvertise = true
}

// AdvertiseCleared reports if the "advertise" edge to the Advertise entity was cleared.
func (m *AttachmentMutation) AdvertiseCleared() bool {
	return m.clearedadvertise
}

// RemoveAdvertiseIDs removes the "advertise" edge to the Advertise entity by IDs.
func (m *AttachmentMutation) RemoveAdvertiseIDs(ids ...int) {
	if m.removedadvertise == nil {
		m.removedadvertise = make(map[int]struct{})
	}
	for i := range ids {
		m.removedadvertise[ids[i]] = struct{}{}
	}
}

// RemovedAdvertise returns the removed IDs of the "advertise" edge to the Advertise entity.
func (m *AttachmentMutation) RemovedAdvertiseIDs() (ids []int) {
	for id := range m.removedadvertise {
		ids = append(ids, id)
	}
	return
}

// AdvertiseIDs returns the "advertise" edge IDs in the mutation.
func (m *AttachmentMutation) AdvertiseIDs() (ids []int) {
	for id := range m.advertise {
		ids = append(ids, id)
	}
	return
}

// ResetAdvertise resets all changes to the "advertise" edge.
func (m *AttachmentMutation) ResetAdvertise() {
	m.advertise = nil
	m.clearedadvertise = false
	m.removedadvertise = nil
}

// AddMessageAttachmentIDs adds the "message_attachment" edge to the Message entity by ids.
func (m *AttachmentMutation) AddMessageAttachmentIDs(ids ...int) {
	if m.message_attachment == nil {
		m.message_attachment = make(map[int]struct{})
	}
	for i := range ids {
		m.message_attachment[ids[i]] = struct{}{}
	}
}

// ClearMessageAttachment clears the "message_attachment" edge to the Message entity.
func (m *AttachmentMutation) ClearMessageAttachment() {
	m.clearedmessage_attachment = true
}

// MessageAttachmentCleared reports if the "message_attachment" edge to the Message entity was cleared.
func (m *AttachmentMutation) MessageAttachmentCleared() bool {
	return m.clearedmessage_attachment
}

// RemoveMessageAttachmentIDs removes the "message_attachment" edge to the Message entity by IDs.
func (m *AttachmentMutation) RemoveMessageAttachmentIDs(ids ...int) {
	if m.removedmessage_attachment == nil {
		m.removedmessage_attachment = make(map[int]struct{})
	}
	for i := range ids {
		m.removedmessage_attachment[ids[i]] = struct{}{}
	}
}

// RemovedMessageAttachment returns the removed IDs of the "message_attachment" edge to the Message entity.
func (m *AttachmentMutation) RemovedMessageAttachmentIDs() (ids []int) {
	for id := range m.removedmessage_attachment {
		ids = append(ids, id)
	}
	return
}

// MessageAttachmentIDs returns the "message_attachment" edge IDs in the mutation.
func (m *AttachmentMutation) MessageAttachmentIDs() (ids []int) {
	for id := range m.message_attachment {
		ids = append(ids, id)
	}
	return
}

// ResetMessageAttachment resets all changes to the "message_attachment" edge.
func (m *AttachmentMutation) ResetMessageAttachment() {
	m.message_attachment = nil
	m.clearedmessage_attachment = false
	m.removedmessage_attachment = nil
}

// AddSharePosterAttachmentIDs adds the "share_poster_attachments" edge to the SharePoster entity by ids.
func (m *AttachmentMutation) AddSharePosterAttachmentIDs(ids ...int) {
	if m.share_poster_attachments == nil {
		m.share_poster_attachments = make(map[int]struct{})
	}
	for i := range ids {
		m.share_poster_attachments[ids[i]] = struct{}{}
	}
}

// ClearSharePosterAttachments clears the "share_poster_attachments" edge to the SharePoster entity.
func (m *AttachmentMutation) ClearSharePosterAttachments() {
	m.clearedshare_poster_attachments = true
}

// SharePosterAttachmentsCleared reports if the "share_poster_attachments" edge to the SharePoster entity was cleared.
func (m *AttachmentMutation) SharePosterAttachmentsCleared() bool {
	return m.clearedshare_poster_attachments
}

// RemoveSharePosterAttachmentIDs removes the "share_poster_attachments" edge to the SharePoster entity by IDs.
func (m *AttachmentMutation) RemoveSharePosterAttachmentIDs(ids ...int) {
	if m.removedshare_poster_attachments == nil {
		m.removedshare_poster_attachments = make(map[int]struct{})
	}
	for i := range ids {
		m.removedshare_poster_attachments[ids[i]] = struct{}{}
	}
}

// RemovedSharePosterAttachments returns the removed IDs of the "share_poster_attachments" edge to the SharePoster entity.
func (m *AttachmentMutation) RemovedSharePosterAttachmentsIDs() (ids []int) {
	for id := range m.removedshare_poster_attachments {
		ids = append(ids, id)
	}
	return
}

// SharePosterAttachmentsIDs returns the "share_poster_attachments" edge IDs in the mutation.
func (m *AttachmentMutation) SharePosterAttachmentsIDs() (ids []int) {
	for id := range m.share_poster_attachments {
		ids = append(ids, id)
	}
	return
}

// ResetSharePosterAttachments resets all changes to the "share_poster_attachments" edge.
func (m *AttachmentMutation) ResetSharePosterAttachments() {
	m.share_poster_attachments = nil
	m.clearedshare_poster_attachments = false
	m.removedshare_poster_attachments = nil
}

// AddTeacherAttachmentIDs adds the "teacher_attachments" edge to the Teacher entity by ids.
func (m *AttachmentMutation) AddTeacherAttachmentIDs(ids ...int) {
	if m.teacher_attachments == nil {
		m.teacher_attachments = make(map[int]struct{})
	}
	for i := range ids {
		m.teacher_attachments[ids[i]] = struct{}{}
	}
}

// ClearTeacherAttachments clears the "teacher_attachments" edge to the Teacher entity.
func (m *AttachmentMutation) ClearTeacherAttachments() {
	m.clearedteacher_attachments = true
}

// TeacherAttachmentsCleared reports if the "teacher_attachments" edge to the Teacher entity was cleared.
func (m *AttachmentMutation) TeacherAttachmentsCleared() bool {
	return m.clearedteacher_attachments
}

// RemoveTeacherAttachmentIDs removes the "teacher_attachments" edge to the Teacher entity by IDs.
func (m *AttachmentMutation) RemoveTeacherAttachmentIDs(ids ...int) {
	if m.removedteacher_attachments == nil {
		m.removedteacher_attachments = make(map[int]struct{})
	}
	for i := range ids {
		m.removedteacher_attachments[ids[i]] = struct{}{}
	}
}

// RemovedTeacherAttachments returns the removed IDs of the "teacher_attachments" edge to the Teacher entity.
func (m *AttachmentMutation) RemovedTeacherAttachmentsIDs() (ids []int) {
	for id := range m.removedteacher_attachments {
		ids = append(ids, id)
	}
	return
}

// TeacherAttachmentsIDs returns the "teacher_attachments" edge IDs in the mutation.
func (m *AttachmentMutation) TeacherAttachmentsIDs() (ids []int) {
	for id := range m.teacher_attachments {
		ids = append(ids, id)
	}
	return
}

// ResetTeacherAttachments resets all changes to the "teacher_attachments" edge.
func (m *AttachmentMutation) ResetTeacherAttachments() {
	m.teacher_attachments = nil
	m.clearedteacher_attachments = false
	m.removedteacher_attachments = nil
}

// SetAdminImgIDID sets the "admin_img_id" edge to the Admin entity by id.
func (m *AttachmentMutation) SetAdminImgIDID(id int) {
	m.admin_img_id = &id
}

// ClearAdminImgID clears the "admin_img_id" edge to the Admin entity.
func (m *AttachmentMutation) ClearAdminImgID() {
	m.clearedadmin_img_id = true
}

// AdminImgIDCleared reports if the "admin_img_id" edge to the Admin entity was cleared.
func (m *AttachmentMutation) AdminImgIDCleared() bool {
	return m.clearedadmin_img_id
}

// AdminImgIDID returns the "admin_img_id" edge ID in the mutation.
func (m *AttachmentMutation) AdminImgIDID() (id int, exists bool) {
	if m.admin_img_id != nil {
		return *m.admin_img_id, true
	}
	return
}

// AdminImgIDIDs returns the "admin_img_id" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AdminImgIDID instead. It exists only for internal usage by the builders.
func (m *AttachmentMutation) AdminImgIDIDs() (ids []int) {
	if id := m.admin_img_id; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAdminImgID resets all changes to the "admin_img_id" edge.
func (m *AttachmentMutation) ResetAdminImgID() {
	m.admin_img_id = nil
	m.clearedadmin_img_id = false
}

// AddSmallCategoryAttachmentIDs adds the "small_category_attachments" edge to the KcSmallCategoryAttachment entity by ids.
func (m *AttachmentMutation) AddSmallCategoryAttachmentIDs(ids ...int) {
	if m.small_category_attachments == nil {
		m.small_category_attachments = make(map[int]struct{})
	}
	for i := range ids {
		m.small_category_attachments[ids[i]] = struct{}{}
	}
}

// ClearSmallCategoryAttachments clears the "small_category_attachments" edge to the KcSmallCategoryAttachment entity.
func (m *AttachmentMutation) ClearSmallCategoryAttachments() {
	m.clearedsmall_category_attachments = true
}

// SmallCategoryAttachmentsCleared reports if the "small_category_attachments" edge to the KcSmallCategoryAttachment entity was cleared.
func (m *AttachmentMutation) SmallCategoryAttachmentsCleared() bool {
	return m.clearedsmall_category_attachments
}

// RemoveSmallCategoryAttachmentIDs removes the "small_category_attachments" edge to the KcSmallCategoryAttachment entity by IDs.
func (m *AttachmentMutation) RemoveSmallCategoryAttachmentIDs(ids ...int) {
	if m.removedsmall_category_attachments == nil {
		m.removedsmall_category_attachments = make(map[int]struct{})
	}
	for i := range ids {
		m.removedsmall_category_attachments[ids[i]] = struct{}{}
	}
}

// RemovedSmallCategoryAttachments returns the removed IDs of the "small_category_attachments" edge to the KcSmallCategoryAttachment entity.
func (m *AttachmentMutation) RemovedSmallCategoryAttachmentsIDs() (ids []int) {
	for id := range m.removedsmall_category_attachments {
		ids = append(ids, id)
	}
	return
}

// SmallCategoryAttachmentsIDs returns the "small_category_attachments" edge IDs in the mutation.
func (m *AttachmentMutation) SmallCategoryAttachmentsIDs() (ids []int) {
	for id := range m.small_category_attachments {
		ids = append(ids, id)
	}
	return
}

// ResetSmallCategoryAttachments resets all changes to the "small_category_attachments" edge.
func (m *AttachmentMutation) ResetSmallCategoryAttachments() {
	m.small_category_attachments = nil
	m.clearedsmall_category_attachments = false
	m.removedsmall_category_attachments = nil
}

// AddCourseAttachmentIDs adds the "course_attachments" edge to the KcCourse entity by ids.
func (m *AttachmentMutation) AddCourseAttachmentIDs(ids ...int) {
	if m.course_attachments == nil {
		m.course_attachments = make(map[int]struct{})
	}
	for i := range ids {
		m.course_attachments[ids[i]] = struct{}{}
	}
}

// ClearCourseAttachments clears the "course_attachments" edge to the KcCourse entity.
func (m *AttachmentMutation) ClearCourseAttachments() {
	m.clearedcourse_attachments = true
}

// CourseAttachmentsCleared reports if the "course_attachments" edge to the KcCourse entity was cleared.
func (m *AttachmentMutation) CourseAttachmentsCleared() bool {
	return m.clearedcourse_attachments
}

// RemoveCourseAttachmentIDs removes the "course_attachments" edge to the KcCourse entity by IDs.
func (m *AttachmentMutation) RemoveCourseAttachmentIDs(ids ...int) {
	if m.removedcourse_attachments == nil {
		m.removedcourse_attachments = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcourse_attachments[ids[i]] = struct{}{}
	}
}

// RemovedCourseAttachments returns the removed IDs of the "course_attachments" edge to the KcCourse entity.
func (m *AttachmentMutation) RemovedCourseAttachmentsIDs() (ids []int) {
	for id := range m.removedcourse_attachments {
		ids = append(ids, id)
	}
	return
}

// CourseAttachmentsIDs returns the "course_attachments" edge IDs in the mutation.
func (m *AttachmentMutation) CourseAttachmentsIDs() (ids []int) {
	for id := range m.course_attachments {
		ids = append(ids, id)
	}
	return
}

// ResetCourseAttachments resets all changes to the "course_attachments" edge.
func (m *AttachmentMutation) ResetCourseAttachments() {
	m.course_attachments = nil
	m.clearedcourse_attachments = false
	m.removedcourse_attachments = nil
}

// AddClassCoverAttachmentIDs adds the "class_cover_attachments" edge to the KcClass entity by ids.
func (m *AttachmentMutation) AddClassCoverAttachmentIDs(ids ...int) {
	if m.class_cover_attachments == nil {
		m.class_cover_attachments = make(map[int]struct{})
	}
	for i := range ids {
		m.class_cover_attachments[ids[i]] = struct{}{}
	}
}

// ClearClassCoverAttachments clears the "class_cover_attachments" edge to the KcClass entity.
func (m *AttachmentMutation) ClearClassCoverAttachments() {
	m.clearedclass_cover_attachments = true
}

// ClassCoverAttachmentsCleared reports if the "class_cover_attachments" edge to the KcClass entity was cleared.
func (m *AttachmentMutation) ClassCoverAttachmentsCleared() bool {
	return m.clearedclass_cover_attachments
}

// RemoveClassCoverAttachmentIDs removes the "class_cover_attachments" edge to the KcClass entity by IDs.
func (m *AttachmentMutation) RemoveClassCoverAttachmentIDs(ids ...int) {
	if m.removedclass_cover_attachments == nil {
		m.removedclass_cover_attachments = make(map[int]struct{})
	}
	for i := range ids {
		m.removedclass_cover_attachments[ids[i]] = struct{}{}
	}
}

// RemovedClassCoverAttachments returns the removed IDs of the "class_cover_attachments" edge to the KcClass entity.
func (m *AttachmentMutation) RemovedClassCoverAttachmentsIDs() (ids []int) {
	for id := range m.removedclass_cover_attachments {
		ids = append(ids, id)
	}
	return
}

// ClassCoverAttachmentsIDs returns the "class_cover_attachments" edge IDs in the mutation.
func (m *AttachmentMutation) ClassCoverAttachmentsIDs() (ids []int) {
	for id := range m.class_cover_attachments {
		ids = append(ids, id)
	}
	return
}

// ResetClassCoverAttachments resets all changes to the "class_cover_attachments" edge.
func (m *AttachmentMutation) ResetClassCoverAttachments() {
	m.class_cover_attachments = nil
	m.clearedclass_cover_attachments = false
	m.removedclass_cover_attachments = nil
}

// SetCoursewareAttachmentID sets the "courseware_attachment" edge to the KcCourseSmallCategory entity by id.
func (m *AttachmentMutation) SetCoursewareAttachmentID(id int) {
	m.courseware_attachment = &id
}

// ClearCoursewareAttachment clears the "courseware_attachment" edge to the KcCourseSmallCategory entity.
func (m *AttachmentMutation) ClearCoursewareAttachment() {
	m.clearedcourseware_attachment = true
}

// CoursewareAttachmentCleared reports if the "courseware_attachment" edge to the KcCourseSmallCategory entity was cleared.
func (m *AttachmentMutation) CoursewareAttachmentCleared() bool {
	return m.clearedcourseware_attachment
}

// CoursewareAttachmentID returns the "courseware_attachment" edge ID in the mutation.
func (m *AttachmentMutation) CoursewareAttachmentID() (id int, exists bool) {
	if m.courseware_attachment != nil {
		return *m.courseware_attachment, true
	}
	return
}

// CoursewareAttachmentIDs returns the "courseware_attachment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CoursewareAttachmentID instead. It exists only for internal usage by the builders.
func (m *AttachmentMutation) CoursewareAttachmentIDs() (ids []int) {
	if id := m.courseware_attachment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCoursewareAttachment resets all changes to the "courseware_attachment" edge.
func (m *AttachmentMutation) ResetCoursewareAttachment() {
	m.courseware_attachment = nil
	m.clearedcourseware_attachment = false
}

// SetOrderAttachmentID sets the "order_attachment" edge to the KcCourseSmallCategory entity by id.
func (m *AttachmentMutation) SetOrderAttachmentID(id int) {
	m.order_attachment = &id
}

// ClearOrderAttachment clears the "order_attachment" edge to the KcCourseSmallCategory entity.
func (m *AttachmentMutation) ClearOrderAttachment() {
	m.clearedorder_attachment = true
}

// OrderAttachmentCleared reports if the "order_attachment" edge to the KcCourseSmallCategory entity was cleared.
func (m *AttachmentMutation) OrderAttachmentCleared() bool {
	return m.clearedorder_attachment
}

// OrderAttachmentID returns the "order_attachment" edge ID in the mutation.
func (m *AttachmentMutation) OrderAttachmentID() (id int, exists bool) {
	if m.order_attachment != nil {
		return *m.order_attachment, true
	}
	return
}

// OrderAttachmentIDs returns the "order_attachment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderAttachmentID instead. It exists only for internal usage by the builders.
func (m *AttachmentMutation) OrderAttachmentIDs() (ids []int) {
	if id := m.order_attachment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrderAttachment resets all changes to the "order_attachment" edge.
func (m *AttachmentMutation) ResetOrderAttachment() {
	m.order_attachment = nil
	m.clearedorder_attachment = false
}

// AddVideoTaskAttachmentIDs adds the "video_task_attachment" edge to the KcVideoUploadTask entity by ids.
func (m *AttachmentMutation) AddVideoTaskAttachmentIDs(ids ...int) {
	if m.video_task_attachment == nil {
		m.video_task_attachment = make(map[int]struct{})
	}
	for i := range ids {
		m.video_task_attachment[ids[i]] = struct{}{}
	}
}

// ClearVideoTaskAttachment clears the "video_task_attachment" edge to the KcVideoUploadTask entity.
func (m *AttachmentMutation) ClearVideoTaskAttachment() {
	m.clearedvideo_task_attachment = true
}

// VideoTaskAttachmentCleared reports if the "video_task_attachment" edge to the KcVideoUploadTask entity was cleared.
func (m *AttachmentMutation) VideoTaskAttachmentCleared() bool {
	return m.clearedvideo_task_attachment
}

// RemoveVideoTaskAttachmentIDs removes the "video_task_attachment" edge to the KcVideoUploadTask entity by IDs.
func (m *AttachmentMutation) RemoveVideoTaskAttachmentIDs(ids ...int) {
	if m.removedvideo_task_attachment == nil {
		m.removedvideo_task_attachment = make(map[int]struct{})
	}
	for i := range ids {
		m.removedvideo_task_attachment[ids[i]] = struct{}{}
	}
}

// RemovedVideoTaskAttachment returns the removed IDs of the "video_task_attachment" edge to the KcVideoUploadTask entity.
func (m *AttachmentMutation) RemovedVideoTaskAttachmentIDs() (ids []int) {
	for id := range m.removedvideo_task_attachment {
		ids = append(ids, id)
	}
	return
}

// VideoTaskAttachmentIDs returns the "video_task_attachment" edge IDs in the mutation.
func (m *AttachmentMutation) VideoTaskAttachmentIDs() (ids []int) {
	for id := range m.video_task_attachment {
		ids = append(ids, id)
	}
	return
}

// ResetVideoTaskAttachment resets all changes to the "video_task_attachment" edge.
func (m *AttachmentMutation) ResetVideoTaskAttachment() {
	m.video_task_attachment = nil
	m.clearedvideo_task_attachment = false
	m.removedvideo_task_attachment = nil
}

// AddAskAttachmentIDs adds the "ask_attachments" edge to the UserAskAnswerAttachment entity by ids.
func (m *AttachmentMutation) AddAskAttachmentIDs(ids ...int) {
	if m.ask_attachments == nil {
		m.ask_attachments = make(map[int]struct{})
	}
	for i := range ids {
		m.ask_attachments[ids[i]] = struct{}{}
	}
}

// ClearAskAttachments clears the "ask_attachments" edge to the UserAskAnswerAttachment entity.
func (m *AttachmentMutation) ClearAskAttachments() {
	m.clearedask_attachments = true
}

// AskAttachmentsCleared reports if the "ask_attachments" edge to the UserAskAnswerAttachment entity was cleared.
func (m *AttachmentMutation) AskAttachmentsCleared() bool {
	return m.clearedask_attachments
}

// RemoveAskAttachmentIDs removes the "ask_attachments" edge to the UserAskAnswerAttachment entity by IDs.
func (m *AttachmentMutation) RemoveAskAttachmentIDs(ids ...int) {
	if m.removedask_attachments == nil {
		m.removedask_attachments = make(map[int]struct{})
	}
	for i := range ids {
		m.removedask_attachments[ids[i]] = struct{}{}
	}
}

// RemovedAskAttachments returns the removed IDs of the "ask_attachments" edge to the UserAskAnswerAttachment entity.
func (m *AttachmentMutation) RemovedAskAttachmentsIDs() (ids []int) {
	for id := range m.removedask_attachments {
		ids = append(ids, id)
	}
	return
}

// AskAttachmentsIDs returns the "ask_attachments" edge IDs in the mutation.
func (m *AttachmentMutation) AskAttachmentsIDs() (ids []int) {
	for id := range m.ask_attachments {
		ids = append(ids, id)
	}
	return
}

// ResetAskAttachments resets all changes to the "ask_attachments" edge.
func (m *AttachmentMutation) ResetAskAttachments() {
	m.ask_attachments = nil
	m.clearedask_attachments = false
	m.removedask_attachments = nil
}

// Op returns the operation name.
func (m *AttachmentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Attachment).
func (m *AttachmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AttachmentMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.uuid != nil {
		fields = append(fields, attachment.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, attachment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, attachment.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, attachment.FieldDeletedAt)
	}
	if m.filename != nil {
		fields = append(fields, attachment.FieldFilename)
	}
	if m.file_size != nil {
		fields = append(fields, attachment.FieldFileSize)
	}
	if m.mime_type != nil {
		fields = append(fields, attachment.FieldMimeType)
	}
	if m.user_id != nil {
		fields = append(fields, attachment.FieldUserID)
	}
	if m.admin_id != nil {
		fields = append(fields, attachment.FieldAdminID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AttachmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case attachment.FieldUUID:
		return m.UUID()
	case attachment.FieldCreatedAt:
		return m.CreatedAt()
	case attachment.FieldUpdatedAt:
		return m.UpdatedAt()
	case attachment.FieldDeletedAt:
		return m.DeletedAt()
	case attachment.FieldFilename:
		return m.Filename()
	case attachment.FieldFileSize:
		return m.FileSize()
	case attachment.FieldMimeType:
		return m.MimeType()
	case attachment.FieldUserID:
		return m.UserID()
	case attachment.FieldAdminID:
		return m.AdminID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AttachmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case attachment.FieldUUID:
		return m.OldUUID(ctx)
	case attachment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case attachment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case attachment.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case attachment.FieldFilename:
		return m.OldFilename(ctx)
	case attachment.FieldFileSize:
		return m.OldFileSize(ctx)
	case attachment.FieldMimeType:
		return m.OldMimeType(ctx)
	case attachment.FieldUserID:
		return m.OldUserID(ctx)
	case attachment.FieldAdminID:
		return m.OldAdminID(ctx)
	}
	return nil, fmt.Errorf("unknown Attachment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AttachmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case attachment.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case attachment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case attachment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case attachment.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case attachment.FieldFilename:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilename(v)
		return nil
	case attachment.FieldFileSize:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileSize(v)
		return nil
	case attachment.FieldMimeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMimeType(v)
		return nil
	case attachment.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case attachment.FieldAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdminID(v)
		return nil
	}
	return fmt.Errorf("unknown Attachment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AttachmentMutation) AddedFields() []string {
	var fields []string
	if m.addfile_size != nil {
		fields = append(fields, attachment.FieldFileSize)
	}
	if m.adduser_id != nil {
		fields = append(fields, attachment.FieldUserID)
	}
	if m.addadmin_id != nil {
		fields = append(fields, attachment.FieldAdminID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AttachmentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case attachment.FieldFileSize:
		return m.AddedFileSize()
	case attachment.FieldUserID:
		return m.AddedUserID()
	case attachment.FieldAdminID:
		return m.AddedAdminID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AttachmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case attachment.FieldFileSize:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFileSize(v)
		return nil
	case attachment.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case attachment.FieldAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAdminID(v)
		return nil
	}
	return fmt.Errorf("unknown Attachment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AttachmentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(attachment.FieldCreatedAt) {
		fields = append(fields, attachment.FieldCreatedAt)
	}
	if m.FieldCleared(attachment.FieldUpdatedAt) {
		fields = append(fields, attachment.FieldUpdatedAt)
	}
	if m.FieldCleared(attachment.FieldDeletedAt) {
		fields = append(fields, attachment.FieldDeletedAt)
	}
	if m.FieldCleared(attachment.FieldUserID) {
		fields = append(fields, attachment.FieldUserID)
	}
	if m.FieldCleared(attachment.FieldAdminID) {
		fields = append(fields, attachment.FieldAdminID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AttachmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AttachmentMutation) ClearField(name string) error {
	switch name {
	case attachment.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case attachment.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case attachment.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case attachment.FieldUserID:
		m.ClearUserID()
		return nil
	case attachment.FieldAdminID:
		m.ClearAdminID()
		return nil
	}
	return fmt.Errorf("unknown Attachment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AttachmentMutation) ResetField(name string) error {
	switch name {
	case attachment.FieldUUID:
		m.ResetUUID()
		return nil
	case attachment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case attachment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case attachment.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case attachment.FieldFilename:
		m.ResetFilename()
		return nil
	case attachment.FieldFileSize:
		m.ResetFileSize()
		return nil
	case attachment.FieldMimeType:
		m.ResetMimeType()
		return nil
	case attachment.FieldUserID:
		m.ResetUserID()
		return nil
	case attachment.FieldAdminID:
		m.ResetAdminID()
		return nil
	}
	return fmt.Errorf("unknown Attachment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AttachmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 16)
	if m.major_detail_cover_img != nil {
		edges = append(edges, attachment.EdgeMajorDetailCoverImg)
	}
	if m.major_detail_subject_img != nil {
		edges = append(edges, attachment.EdgeMajorDetailSubjectImg)
	}
	if m.major_teacher_attachment != nil {
		edges = append(edges, attachment.EdgeMajorTeacherAttachment)
	}
	if m.major_service_attachment != nil {
		edges = append(edges, attachment.EdgeMajorServiceAttachment)
	}
	if m.advertise != nil {
		edges = append(edges, attachment.EdgeAdvertise)
	}
	if m.message_attachment != nil {
		edges = append(edges, attachment.EdgeMessageAttachment)
	}
	if m.share_poster_attachments != nil {
		edges = append(edges, attachment.EdgeSharePosterAttachments)
	}
	if m.teacher_attachments != nil {
		edges = append(edges, attachment.EdgeTeacherAttachments)
	}
	if m.admin_img_id != nil {
		edges = append(edges, attachment.EdgeAdminImgID)
	}
	if m.small_category_attachments != nil {
		edges = append(edges, attachment.EdgeSmallCategoryAttachments)
	}
	if m.course_attachments != nil {
		edges = append(edges, attachment.EdgeCourseAttachments)
	}
	if m.class_cover_attachments != nil {
		edges = append(edges, attachment.EdgeClassCoverAttachments)
	}
	if m.courseware_attachment != nil {
		edges = append(edges, attachment.EdgeCoursewareAttachment)
	}
	if m.order_attachment != nil {
		edges = append(edges, attachment.EdgeOrderAttachment)
	}
	if m.video_task_attachment != nil {
		edges = append(edges, attachment.EdgeVideoTaskAttachment)
	}
	if m.ask_attachments != nil {
		edges = append(edges, attachment.EdgeAskAttachments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AttachmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case attachment.EdgeMajorDetailCoverImg:
		ids := make([]ent.Value, 0, len(m.major_detail_cover_img))
		for id := range m.major_detail_cover_img {
			ids = append(ids, id)
		}
		return ids
	case attachment.EdgeMajorDetailSubjectImg:
		ids := make([]ent.Value, 0, len(m.major_detail_subject_img))
		for id := range m.major_detail_subject_img {
			ids = append(ids, id)
		}
		return ids
	case attachment.EdgeMajorTeacherAttachment:
		ids := make([]ent.Value, 0, len(m.major_teacher_attachment))
		for id := range m.major_teacher_attachment {
			ids = append(ids, id)
		}
		return ids
	case attachment.EdgeMajorServiceAttachment:
		ids := make([]ent.Value, 0, len(m.major_service_attachment))
		for id := range m.major_service_attachment {
			ids = append(ids, id)
		}
		return ids
	case attachment.EdgeAdvertise:
		ids := make([]ent.Value, 0, len(m.advertise))
		for id := range m.advertise {
			ids = append(ids, id)
		}
		return ids
	case attachment.EdgeMessageAttachment:
		ids := make([]ent.Value, 0, len(m.message_attachment))
		for id := range m.message_attachment {
			ids = append(ids, id)
		}
		return ids
	case attachment.EdgeSharePosterAttachments:
		ids := make([]ent.Value, 0, len(m.share_poster_attachments))
		for id := range m.share_poster_attachments {
			ids = append(ids, id)
		}
		return ids
	case attachment.EdgeTeacherAttachments:
		ids := make([]ent.Value, 0, len(m.teacher_attachments))
		for id := range m.teacher_attachments {
			ids = append(ids, id)
		}
		return ids
	case attachment.EdgeAdminImgID:
		if id := m.admin_img_id; id != nil {
			return []ent.Value{*id}
		}
	case attachment.EdgeSmallCategoryAttachments:
		ids := make([]ent.Value, 0, len(m.small_category_attachments))
		for id := range m.small_category_attachments {
			ids = append(ids, id)
		}
		return ids
	case attachment.EdgeCourseAttachments:
		ids := make([]ent.Value, 0, len(m.course_attachments))
		for id := range m.course_attachments {
			ids = append(ids, id)
		}
		return ids
	case attachment.EdgeClassCoverAttachments:
		ids := make([]ent.Value, 0, len(m.class_cover_attachments))
		for id := range m.class_cover_attachments {
			ids = append(ids, id)
		}
		return ids
	case attachment.EdgeCoursewareAttachment:
		if id := m.courseware_attachment; id != nil {
			return []ent.Value{*id}
		}
	case attachment.EdgeOrderAttachment:
		if id := m.order_attachment; id != nil {
			return []ent.Value{*id}
		}
	case attachment.EdgeVideoTaskAttachment:
		ids := make([]ent.Value, 0, len(m.video_task_attachment))
		for id := range m.video_task_attachment {
			ids = append(ids, id)
		}
		return ids
	case attachment.EdgeAskAttachments:
		ids := make([]ent.Value, 0, len(m.ask_attachments))
		for id := range m.ask_attachments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AttachmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 16)
	if m.removedmajor_detail_cover_img != nil {
		edges = append(edges, attachment.EdgeMajorDetailCoverImg)
	}
	if m.removedmajor_detail_subject_img != nil {
		edges = append(edges, attachment.EdgeMajorDetailSubjectImg)
	}
	if m.removedmajor_teacher_attachment != nil {
		edges = append(edges, attachment.EdgeMajorTeacherAttachment)
	}
	if m.removedmajor_service_attachment != nil {
		edges = append(edges, attachment.EdgeMajorServiceAttachment)
	}
	if m.removedadvertise != nil {
		edges = append(edges, attachment.EdgeAdvertise)
	}
	if m.removedmessage_attachment != nil {
		edges = append(edges, attachment.EdgeMessageAttachment)
	}
	if m.removedshare_poster_attachments != nil {
		edges = append(edges, attachment.EdgeSharePosterAttachments)
	}
	if m.removedteacher_attachments != nil {
		edges = append(edges, attachment.EdgeTeacherAttachments)
	}
	if m.removedsmall_category_attachments != nil {
		edges = append(edges, attachment.EdgeSmallCategoryAttachments)
	}
	if m.removedcourse_attachments != nil {
		edges = append(edges, attachment.EdgeCourseAttachments)
	}
	if m.removedclass_cover_attachments != nil {
		edges = append(edges, attachment.EdgeClassCoverAttachments)
	}
	if m.removedvideo_task_attachment != nil {
		edges = append(edges, attachment.EdgeVideoTaskAttachment)
	}
	if m.removedask_attachments != nil {
		edges = append(edges, attachment.EdgeAskAttachments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AttachmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case attachment.EdgeMajorDetailCoverImg:
		ids := make([]ent.Value, 0, len(m.removedmajor_detail_cover_img))
		for id := range m.removedmajor_detail_cover_img {
			ids = append(ids, id)
		}
		return ids
	case attachment.EdgeMajorDetailSubjectImg:
		ids := make([]ent.Value, 0, len(m.removedmajor_detail_subject_img))
		for id := range m.removedmajor_detail_subject_img {
			ids = append(ids, id)
		}
		return ids
	case attachment.EdgeMajorTeacherAttachment:
		ids := make([]ent.Value, 0, len(m.removedmajor_teacher_attachment))
		for id := range m.removedmajor_teacher_attachment {
			ids = append(ids, id)
		}
		return ids
	case attachment.EdgeMajorServiceAttachment:
		ids := make([]ent.Value, 0, len(m.removedmajor_service_attachment))
		for id := range m.removedmajor_service_attachment {
			ids = append(ids, id)
		}
		return ids
	case attachment.EdgeAdvertise:
		ids := make([]ent.Value, 0, len(m.removedadvertise))
		for id := range m.removedadvertise {
			ids = append(ids, id)
		}
		return ids
	case attachment.EdgeMessageAttachment:
		ids := make([]ent.Value, 0, len(m.removedmessage_attachment))
		for id := range m.removedmessage_attachment {
			ids = append(ids, id)
		}
		return ids
	case attachment.EdgeSharePosterAttachments:
		ids := make([]ent.Value, 0, len(m.removedshare_poster_attachments))
		for id := range m.removedshare_poster_attachments {
			ids = append(ids, id)
		}
		return ids
	case attachment.EdgeTeacherAttachments:
		ids := make([]ent.Value, 0, len(m.removedteacher_attachments))
		for id := range m.removedteacher_attachments {
			ids = append(ids, id)
		}
		return ids
	case attachment.EdgeSmallCategoryAttachments:
		ids := make([]ent.Value, 0, len(m.removedsmall_category_attachments))
		for id := range m.removedsmall_category_attachments {
			ids = append(ids, id)
		}
		return ids
	case attachment.EdgeCourseAttachments:
		ids := make([]ent.Value, 0, len(m.removedcourse_attachments))
		for id := range m.removedcourse_attachments {
			ids = append(ids, id)
		}
		return ids
	case attachment.EdgeClassCoverAttachments:
		ids := make([]ent.Value, 0, len(m.removedclass_cover_attachments))
		for id := range m.removedclass_cover_attachments {
			ids = append(ids, id)
		}
		return ids
	case attachment.EdgeVideoTaskAttachment:
		ids := make([]ent.Value, 0, len(m.removedvideo_task_attachment))
		for id := range m.removedvideo_task_attachment {
			ids = append(ids, id)
		}
		return ids
	case attachment.EdgeAskAttachments:
		ids := make([]ent.Value, 0, len(m.removedask_attachments))
		for id := range m.removedask_attachments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AttachmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 16)
	if m.clearedmajor_detail_cover_img {
		edges = append(edges, attachment.EdgeMajorDetailCoverImg)
	}
	if m.clearedmajor_detail_subject_img {
		edges = append(edges, attachment.EdgeMajorDetailSubjectImg)
	}
	if m.clearedmajor_teacher_attachment {
		edges = append(edges, attachment.EdgeMajorTeacherAttachment)
	}
	if m.clearedmajor_service_attachment {
		edges = append(edges, attachment.EdgeMajorServiceAttachment)
	}
	if m.clearedadvertise {
		edges = append(edges, attachment.EdgeAdvertise)
	}
	if m.clearedmessage_attachment {
		edges = append(edges, attachment.EdgeMessageAttachment)
	}
	if m.clearedshare_poster_attachments {
		edges = append(edges, attachment.EdgeSharePosterAttachments)
	}
	if m.clearedteacher_attachments {
		edges = append(edges, attachment.EdgeTeacherAttachments)
	}
	if m.clearedadmin_img_id {
		edges = append(edges, attachment.EdgeAdminImgID)
	}
	if m.clearedsmall_category_attachments {
		edges = append(edges, attachment.EdgeSmallCategoryAttachments)
	}
	if m.clearedcourse_attachments {
		edges = append(edges, attachment.EdgeCourseAttachments)
	}
	if m.clearedclass_cover_attachments {
		edges = append(edges, attachment.EdgeClassCoverAttachments)
	}
	if m.clearedcourseware_attachment {
		edges = append(edges, attachment.EdgeCoursewareAttachment)
	}
	if m.clearedorder_attachment {
		edges = append(edges, attachment.EdgeOrderAttachment)
	}
	if m.clearedvideo_task_attachment {
		edges = append(edges, attachment.EdgeVideoTaskAttachment)
	}
	if m.clearedask_attachments {
		edges = append(edges, attachment.EdgeAskAttachments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AttachmentMutation) EdgeCleared(name string) bool {
	switch name {
	case attachment.EdgeMajorDetailCoverImg:
		return m.clearedmajor_detail_cover_img
	case attachment.EdgeMajorDetailSubjectImg:
		return m.clearedmajor_detail_subject_img
	case attachment.EdgeMajorTeacherAttachment:
		return m.clearedmajor_teacher_attachment
	case attachment.EdgeMajorServiceAttachment:
		return m.clearedmajor_service_attachment
	case attachment.EdgeAdvertise:
		return m.clearedadvertise
	case attachment.EdgeMessageAttachment:
		return m.clearedmessage_attachment
	case attachment.EdgeSharePosterAttachments:
		return m.clearedshare_poster_attachments
	case attachment.EdgeTeacherAttachments:
		return m.clearedteacher_attachments
	case attachment.EdgeAdminImgID:
		return m.clearedadmin_img_id
	case attachment.EdgeSmallCategoryAttachments:
		return m.clearedsmall_category_attachments
	case attachment.EdgeCourseAttachments:
		return m.clearedcourse_attachments
	case attachment.EdgeClassCoverAttachments:
		return m.clearedclass_cover_attachments
	case attachment.EdgeCoursewareAttachment:
		return m.clearedcourseware_attachment
	case attachment.EdgeOrderAttachment:
		return m.clearedorder_attachment
	case attachment.EdgeVideoTaskAttachment:
		return m.clearedvideo_task_attachment
	case attachment.EdgeAskAttachments:
		return m.clearedask_attachments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AttachmentMutation) ClearEdge(name string) error {
	switch name {
	case attachment.EdgeAdminImgID:
		m.ClearAdminImgID()
		return nil
	case attachment.EdgeCoursewareAttachment:
		m.ClearCoursewareAttachment()
		return nil
	case attachment.EdgeOrderAttachment:
		m.ClearOrderAttachment()
		return nil
	}
	return fmt.Errorf("unknown Attachment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AttachmentMutation) ResetEdge(name string) error {
	switch name {
	case attachment.EdgeMajorDetailCoverImg:
		m.ResetMajorDetailCoverImg()
		return nil
	case attachment.EdgeMajorDetailSubjectImg:
		m.ResetMajorDetailSubjectImg()
		return nil
	case attachment.EdgeMajorTeacherAttachment:
		m.ResetMajorTeacherAttachment()
		return nil
	case attachment.EdgeMajorServiceAttachment:
		m.ResetMajorServiceAttachment()
		return nil
	case attachment.EdgeAdvertise:
		m.ResetAdvertise()
		return nil
	case attachment.EdgeMessageAttachment:
		m.ResetMessageAttachment()
		return nil
	case attachment.EdgeSharePosterAttachments:
		m.ResetSharePosterAttachments()
		return nil
	case attachment.EdgeTeacherAttachments:
		m.ResetTeacherAttachments()
		return nil
	case attachment.EdgeAdminImgID:
		m.ResetAdminImgID()
		return nil
	case attachment.EdgeSmallCategoryAttachments:
		m.ResetSmallCategoryAttachments()
		return nil
	case attachment.EdgeCourseAttachments:
		m.ResetCourseAttachments()
		return nil
	case attachment.EdgeClassCoverAttachments:
		m.ResetClassCoverAttachments()
		return nil
	case attachment.EdgeCoursewareAttachment:
		m.ResetCoursewareAttachment()
		return nil
	case attachment.EdgeOrderAttachment:
		m.ResetOrderAttachment()
		return nil
	case attachment.EdgeVideoTaskAttachment:
		m.ResetVideoTaskAttachment()
		return nil
	case attachment.EdgeAskAttachments:
		m.ResetAskAttachments()
		return nil
	}
	return fmt.Errorf("unknown Attachment edge %s", name)
}

// CityMutation represents an operation that mutates the City nodes in the graph.
type CityMutation struct {
	config
	op               Op
	typ              string
	id               *int
	uuid             *string
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	name             *string
	status           *uint8
	addstatus        *uint8
	code             *string
	desc             *string
	sort_order       *int
	addsort_order    *int
	clearedFields    map[string]struct{}
	kc_class         map[int]struct{}
	removedkc_class  map[int]struct{}
	clearedkc_class  bool
	course           map[int]struct{}
	removedcourse    map[int]struct{}
	clearedcourse    bool
	user_city        map[int]struct{}
	removeduser_city map[int]struct{}
	cleareduser_city bool
	done             bool
	oldValue         func(context.Context) (*City, error)
	predicates       []predicate.City
}

var _ ent.Mutation = (*CityMutation)(nil)

// cityOption allows management of the mutation configuration using functional options.
type cityOption func(*CityMutation)

// newCityMutation creates new mutation for the City entity.
func newCityMutation(c config, op Op, opts ...cityOption) *CityMutation {
	m := &CityMutation{
		config:        c,
		op:            op,
		typ:           TypeCity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCityID sets the ID field of the mutation.
func withCityID(id int) cityOption {
	return func(m *CityMutation) {
		var (
			err   error
			once  sync.Once
			value *City
		)
		m.oldValue = func(ctx context.Context) (*City, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().City.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCity sets the old City of the mutation.
func withCity(node *City) cityOption {
	return func(m *CityMutation) {
		m.oldValue = func(context.Context) (*City, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *CityMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *CityMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *CityMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *CityMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CityMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CityMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *CityMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[city.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *CityMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[city.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CityMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, city.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CityMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CityMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *CityMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[city.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *CityMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[city.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CityMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, city.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CityMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CityMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CityMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[city.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CityMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[city.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CityMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, city.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *CityMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CityMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CityMutation) ResetName() {
	m.name = nil
}

// SetStatus sets the "status" field.
func (m *CityMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *CityMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *CityMutation) AddStatus(u uint8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *CityMutation) AddedStatus() (r uint8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *CityMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetCode sets the "code" field.
func (m *CityMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *CityMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *CityMutation) ResetCode() {
	m.code = nil
}

// SetDesc sets the "desc" field.
func (m *CityMutation) SetDesc(s string) {
	m.desc = &s
}

// Desc returns the value of the "desc" field in the mutation.
func (m *CityMutation) Desc() (r string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldDesc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// ResetDesc resets all changes to the "desc" field.
func (m *CityMutation) ResetDesc() {
	m.desc = nil
}

// SetSortOrder sets the "sort_order" field.
func (m *CityMutation) SetSortOrder(i int) {
	m.sort_order = &i
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *CityMutation) SortOrder() (r int, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldSortOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds i to the "sort_order" field.
func (m *CityMutation) AddSortOrder(i int) {
	if m.addsort_order != nil {
		*m.addsort_order += i
	} else {
		m.addsort_order = &i
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *CityMutation) AddedSortOrder() (r int, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *CityMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
}

// AddKcClasIDs adds the "kc_class" edge to the KcClass entity by ids.
func (m *CityMutation) AddKcClasIDs(ids ...int) {
	if m.kc_class == nil {
		m.kc_class = make(map[int]struct{})
	}
	for i := range ids {
		m.kc_class[ids[i]] = struct{}{}
	}
}

// ClearKcClass clears the "kc_class" edge to the KcClass entity.
func (m *CityMutation) ClearKcClass() {
	m.clearedkc_class = true
}

// KcClassCleared reports if the "kc_class" edge to the KcClass entity was cleared.
func (m *CityMutation) KcClassCleared() bool {
	return m.clearedkc_class
}

// RemoveKcClasIDs removes the "kc_class" edge to the KcClass entity by IDs.
func (m *CityMutation) RemoveKcClasIDs(ids ...int) {
	if m.removedkc_class == nil {
		m.removedkc_class = make(map[int]struct{})
	}
	for i := range ids {
		m.removedkc_class[ids[i]] = struct{}{}
	}
}

// RemovedKcClass returns the removed IDs of the "kc_class" edge to the KcClass entity.
func (m *CityMutation) RemovedKcClassIDs() (ids []int) {
	for id := range m.removedkc_class {
		ids = append(ids, id)
	}
	return
}

// KcClassIDs returns the "kc_class" edge IDs in the mutation.
func (m *CityMutation) KcClassIDs() (ids []int) {
	for id := range m.kc_class {
		ids = append(ids, id)
	}
	return
}

// ResetKcClass resets all changes to the "kc_class" edge.
func (m *CityMutation) ResetKcClass() {
	m.kc_class = nil
	m.clearedkc_class = false
	m.removedkc_class = nil
}

// AddCourseIDs adds the "course" edge to the KcCourse entity by ids.
func (m *CityMutation) AddCourseIDs(ids ...int) {
	if m.course == nil {
		m.course = make(map[int]struct{})
	}
	for i := range ids {
		m.course[ids[i]] = struct{}{}
	}
}

// ClearCourse clears the "course" edge to the KcCourse entity.
func (m *CityMutation) ClearCourse() {
	m.clearedcourse = true
}

// CourseCleared reports if the "course" edge to the KcCourse entity was cleared.
func (m *CityMutation) CourseCleared() bool {
	return m.clearedcourse
}

// RemoveCourseIDs removes the "course" edge to the KcCourse entity by IDs.
func (m *CityMutation) RemoveCourseIDs(ids ...int) {
	if m.removedcourse == nil {
		m.removedcourse = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcourse[ids[i]] = struct{}{}
	}
}

// RemovedCourse returns the removed IDs of the "course" edge to the KcCourse entity.
func (m *CityMutation) RemovedCourseIDs() (ids []int) {
	for id := range m.removedcourse {
		ids = append(ids, id)
	}
	return
}

// CourseIDs returns the "course" edge IDs in the mutation.
func (m *CityMutation) CourseIDs() (ids []int) {
	for id := range m.course {
		ids = append(ids, id)
	}
	return
}

// ResetCourse resets all changes to the "course" edge.
func (m *CityMutation) ResetCourse() {
	m.course = nil
	m.clearedcourse = false
	m.removedcourse = nil
}

// AddUserCityIDs adds the "user_city" edge to the User entity by ids.
func (m *CityMutation) AddUserCityIDs(ids ...int) {
	if m.user_city == nil {
		m.user_city = make(map[int]struct{})
	}
	for i := range ids {
		m.user_city[ids[i]] = struct{}{}
	}
}

// ClearUserCity clears the "user_city" edge to the User entity.
func (m *CityMutation) ClearUserCity() {
	m.cleareduser_city = true
}

// UserCityCleared reports if the "user_city" edge to the User entity was cleared.
func (m *CityMutation) UserCityCleared() bool {
	return m.cleareduser_city
}

// RemoveUserCityIDs removes the "user_city" edge to the User entity by IDs.
func (m *CityMutation) RemoveUserCityIDs(ids ...int) {
	if m.removeduser_city == nil {
		m.removeduser_city = make(map[int]struct{})
	}
	for i := range ids {
		m.removeduser_city[ids[i]] = struct{}{}
	}
}

// RemovedUserCity returns the removed IDs of the "user_city" edge to the User entity.
func (m *CityMutation) RemovedUserCityIDs() (ids []int) {
	for id := range m.removeduser_city {
		ids = append(ids, id)
	}
	return
}

// UserCityIDs returns the "user_city" edge IDs in the mutation.
func (m *CityMutation) UserCityIDs() (ids []int) {
	for id := range m.user_city {
		ids = append(ids, id)
	}
	return
}

// ResetUserCity resets all changes to the "user_city" edge.
func (m *CityMutation) ResetUserCity() {
	m.user_city = nil
	m.cleareduser_city = false
	m.removeduser_city = nil
}

// Op returns the operation name.
func (m *CityMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (City).
func (m *CityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CityMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.uuid != nil {
		fields = append(fields, city.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, city.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, city.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, city.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, city.FieldName)
	}
	if m.status != nil {
		fields = append(fields, city.FieldStatus)
	}
	if m.code != nil {
		fields = append(fields, city.FieldCode)
	}
	if m.desc != nil {
		fields = append(fields, city.FieldDesc)
	}
	if m.sort_order != nil {
		fields = append(fields, city.FieldSortOrder)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case city.FieldUUID:
		return m.UUID()
	case city.FieldCreatedAt:
		return m.CreatedAt()
	case city.FieldUpdatedAt:
		return m.UpdatedAt()
	case city.FieldDeletedAt:
		return m.DeletedAt()
	case city.FieldName:
		return m.Name()
	case city.FieldStatus:
		return m.Status()
	case city.FieldCode:
		return m.Code()
	case city.FieldDesc:
		return m.Desc()
	case city.FieldSortOrder:
		return m.SortOrder()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case city.FieldUUID:
		return m.OldUUID(ctx)
	case city.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case city.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case city.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case city.FieldName:
		return m.OldName(ctx)
	case city.FieldStatus:
		return m.OldStatus(ctx)
	case city.FieldCode:
		return m.OldCode(ctx)
	case city.FieldDesc:
		return m.OldDesc(ctx)
	case city.FieldSortOrder:
		return m.OldSortOrder(ctx)
	}
	return nil, fmt.Errorf("unknown City field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case city.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case city.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case city.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case city.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case city.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case city.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case city.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case city.FieldDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	case city.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown City field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CityMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, city.FieldStatus)
	}
	if m.addsort_order != nil {
		fields = append(fields, city.FieldSortOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CityMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case city.FieldStatus:
		return m.AddedStatus()
	case city.FieldSortOrder:
		return m.AddedSortOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CityMutation) AddField(name string, value ent.Value) error {
	switch name {
	case city.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case city.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown City numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CityMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(city.FieldCreatedAt) {
		fields = append(fields, city.FieldCreatedAt)
	}
	if m.FieldCleared(city.FieldUpdatedAt) {
		fields = append(fields, city.FieldUpdatedAt)
	}
	if m.FieldCleared(city.FieldDeletedAt) {
		fields = append(fields, city.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CityMutation) ClearField(name string) error {
	switch name {
	case city.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case city.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case city.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown City nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CityMutation) ResetField(name string) error {
	switch name {
	case city.FieldUUID:
		m.ResetUUID()
		return nil
	case city.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case city.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case city.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case city.FieldName:
		m.ResetName()
		return nil
	case city.FieldStatus:
		m.ResetStatus()
		return nil
	case city.FieldCode:
		m.ResetCode()
		return nil
	case city.FieldDesc:
		m.ResetDesc()
		return nil
	case city.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	}
	return fmt.Errorf("unknown City field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CityMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.kc_class != nil {
		edges = append(edges, city.EdgeKcClass)
	}
	if m.course != nil {
		edges = append(edges, city.EdgeCourse)
	}
	if m.user_city != nil {
		edges = append(edges, city.EdgeUserCity)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case city.EdgeKcClass:
		ids := make([]ent.Value, 0, len(m.kc_class))
		for id := range m.kc_class {
			ids = append(ids, id)
		}
		return ids
	case city.EdgeCourse:
		ids := make([]ent.Value, 0, len(m.course))
		for id := range m.course {
			ids = append(ids, id)
		}
		return ids
	case city.EdgeUserCity:
		ids := make([]ent.Value, 0, len(m.user_city))
		for id := range m.user_city {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedkc_class != nil {
		edges = append(edges, city.EdgeKcClass)
	}
	if m.removedcourse != nil {
		edges = append(edges, city.EdgeCourse)
	}
	if m.removeduser_city != nil {
		edges = append(edges, city.EdgeUserCity)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case city.EdgeKcClass:
		ids := make([]ent.Value, 0, len(m.removedkc_class))
		for id := range m.removedkc_class {
			ids = append(ids, id)
		}
		return ids
	case city.EdgeCourse:
		ids := make([]ent.Value, 0, len(m.removedcourse))
		for id := range m.removedcourse {
			ids = append(ids, id)
		}
		return ids
	case city.EdgeUserCity:
		ids := make([]ent.Value, 0, len(m.removeduser_city))
		for id := range m.removeduser_city {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedkc_class {
		edges = append(edges, city.EdgeKcClass)
	}
	if m.clearedcourse {
		edges = append(edges, city.EdgeCourse)
	}
	if m.cleareduser_city {
		edges = append(edges, city.EdgeUserCity)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CityMutation) EdgeCleared(name string) bool {
	switch name {
	case city.EdgeKcClass:
		return m.clearedkc_class
	case city.EdgeCourse:
		return m.clearedcourse
	case city.EdgeUserCity:
		return m.cleareduser_city
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CityMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown City unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CityMutation) ResetEdge(name string) error {
	switch name {
	case city.EdgeKcClass:
		m.ResetKcClass()
		return nil
	case city.EdgeCourse:
		m.ResetCourse()
		return nil
	case city.EdgeUserCity:
		m.ResetUserCity()
		return nil
	}
	return fmt.Errorf("unknown City edge %s", name)
}

// CollectionMutation represents an operation that mutates the Collection nodes in the graph.
type CollectionMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	uuid                  *string
	created_at            *time.Time
	updated_at            *time.Time
	deleted_at            *time.Time
	_type                 *int
	add_type              *int
	user_id               *int
	adduser_id            *int
	exam_id               *int
	addexam_id            *int
	sec_id                *int
	addsec_id             *int
	question_bank_id      *int
	addquestion_bank_id   *int
	exam_question_type    *int
	addexam_question_type *int
	clearedFields         map[string]struct{}
	question              *int
	clearedquestion       bool
	done                  bool
	oldValue              func(context.Context) (*Collection, error)
	predicates            []predicate.Collection
}

var _ ent.Mutation = (*CollectionMutation)(nil)

// collectionOption allows management of the mutation configuration using functional options.
type collectionOption func(*CollectionMutation)

// newCollectionMutation creates new mutation for the Collection entity.
func newCollectionMutation(c config, op Op, opts ...collectionOption) *CollectionMutation {
	m := &CollectionMutation{
		config:        c,
		op:            op,
		typ:           TypeCollection,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCollectionID sets the ID field of the mutation.
func withCollectionID(id int) collectionOption {
	return func(m *CollectionMutation) {
		var (
			err   error
			once  sync.Once
			value *Collection
		)
		m.oldValue = func(ctx context.Context) (*Collection, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Collection.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCollection sets the old Collection of the mutation.
func withCollection(node *Collection) collectionOption {
	return func(m *CollectionMutation) {
		m.oldValue = func(context.Context) (*Collection, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CollectionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CollectionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *CollectionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *CollectionMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *CollectionMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the Collection entity.
// If the Collection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectionMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *CollectionMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CollectionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CollectionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Collection entity.
// If the Collection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectionMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *CollectionMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[collection.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *CollectionMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[collection.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CollectionMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, collection.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CollectionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CollectionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Collection entity.
// If the Collection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectionMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *CollectionMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[collection.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *CollectionMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[collection.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CollectionMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, collection.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CollectionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CollectionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Collection entity.
// If the Collection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectionMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CollectionMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[collection.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CollectionMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[collection.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CollectionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, collection.FieldDeletedAt)
}

// SetType sets the "type" field.
func (m *CollectionMutation) SetType(i int) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *CollectionMutation) GetType() (r int, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Collection entity.
// If the Collection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectionMutation) OldType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to the "type" field.
func (m *CollectionMutation) AddType(i int) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *CollectionMutation) AddedType() (r int, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ClearType clears the value of the "type" field.
func (m *CollectionMutation) ClearType() {
	m._type = nil
	m.add_type = nil
	m.clearedFields[collection.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *CollectionMutation) TypeCleared() bool {
	_, ok := m.clearedFields[collection.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *CollectionMutation) ResetType() {
	m._type = nil
	m.add_type = nil
	delete(m.clearedFields, collection.FieldType)
}

// SetValueID sets the "value_id" field.
func (m *CollectionMutation) SetValueID(i int) {
	m.question = &i
}

// ValueID returns the value of the "value_id" field in the mutation.
func (m *CollectionMutation) ValueID() (r int, exists bool) {
	v := m.question
	if v == nil {
		return
	}
	return *v, true
}

// OldValueID returns the old "value_id" field's value of the Collection entity.
// If the Collection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectionMutation) OldValueID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldValueID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldValueID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValueID: %w", err)
	}
	return oldValue.ValueID, nil
}

// ClearValueID clears the value of the "value_id" field.
func (m *CollectionMutation) ClearValueID() {
	m.question = nil
	m.clearedFields[collection.FieldValueID] = struct{}{}
}

// ValueIDCleared returns if the "value_id" field was cleared in this mutation.
func (m *CollectionMutation) ValueIDCleared() bool {
	_, ok := m.clearedFields[collection.FieldValueID]
	return ok
}

// ResetValueID resets all changes to the "value_id" field.
func (m *CollectionMutation) ResetValueID() {
	m.question = nil
	delete(m.clearedFields, collection.FieldValueID)
}

// SetUserID sets the "user_id" field.
func (m *CollectionMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *CollectionMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Collection entity.
// If the Collection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectionMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *CollectionMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *CollectionMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearUserID clears the value of the "user_id" field.
func (m *CollectionMutation) ClearUserID() {
	m.user_id = nil
	m.adduser_id = nil
	m.clearedFields[collection.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *CollectionMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[collection.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *CollectionMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
	delete(m.clearedFields, collection.FieldUserID)
}

// SetExamID sets the "exam_id" field.
func (m *CollectionMutation) SetExamID(i int) {
	m.exam_id = &i
	m.addexam_id = nil
}

// ExamID returns the value of the "exam_id" field in the mutation.
func (m *CollectionMutation) ExamID() (r int, exists bool) {
	v := m.exam_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExamID returns the old "exam_id" field's value of the Collection entity.
// If the Collection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectionMutation) OldExamID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExamID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExamID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamID: %w", err)
	}
	return oldValue.ExamID, nil
}

// AddExamID adds i to the "exam_id" field.
func (m *CollectionMutation) AddExamID(i int) {
	if m.addexam_id != nil {
		*m.addexam_id += i
	} else {
		m.addexam_id = &i
	}
}

// AddedExamID returns the value that was added to the "exam_id" field in this mutation.
func (m *CollectionMutation) AddedExamID() (r int, exists bool) {
	v := m.addexam_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearExamID clears the value of the "exam_id" field.
func (m *CollectionMutation) ClearExamID() {
	m.exam_id = nil
	m.addexam_id = nil
	m.clearedFields[collection.FieldExamID] = struct{}{}
}

// ExamIDCleared returns if the "exam_id" field was cleared in this mutation.
func (m *CollectionMutation) ExamIDCleared() bool {
	_, ok := m.clearedFields[collection.FieldExamID]
	return ok
}

// ResetExamID resets all changes to the "exam_id" field.
func (m *CollectionMutation) ResetExamID() {
	m.exam_id = nil
	m.addexam_id = nil
	delete(m.clearedFields, collection.FieldExamID)
}

// SetSecID sets the "sec_id" field.
func (m *CollectionMutation) SetSecID(i int) {
	m.sec_id = &i
	m.addsec_id = nil
}

// SecID returns the value of the "sec_id" field in the mutation.
func (m *CollectionMutation) SecID() (r int, exists bool) {
	v := m.sec_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSecID returns the old "sec_id" field's value of the Collection entity.
// If the Collection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectionMutation) OldSecID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSecID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSecID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecID: %w", err)
	}
	return oldValue.SecID, nil
}

// AddSecID adds i to the "sec_id" field.
func (m *CollectionMutation) AddSecID(i int) {
	if m.addsec_id != nil {
		*m.addsec_id += i
	} else {
		m.addsec_id = &i
	}
}

// AddedSecID returns the value that was added to the "sec_id" field in this mutation.
func (m *CollectionMutation) AddedSecID() (r int, exists bool) {
	v := m.addsec_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearSecID clears the value of the "sec_id" field.
func (m *CollectionMutation) ClearSecID() {
	m.sec_id = nil
	m.addsec_id = nil
	m.clearedFields[collection.FieldSecID] = struct{}{}
}

// SecIDCleared returns if the "sec_id" field was cleared in this mutation.
func (m *CollectionMutation) SecIDCleared() bool {
	_, ok := m.clearedFields[collection.FieldSecID]
	return ok
}

// ResetSecID resets all changes to the "sec_id" field.
func (m *CollectionMutation) ResetSecID() {
	m.sec_id = nil
	m.addsec_id = nil
	delete(m.clearedFields, collection.FieldSecID)
}

// SetQuestionBankID sets the "question_bank_id" field.
func (m *CollectionMutation) SetQuestionBankID(i int) {
	m.question_bank_id = &i
	m.addquestion_bank_id = nil
}

// QuestionBankID returns the value of the "question_bank_id" field in the mutation.
func (m *CollectionMutation) QuestionBankID() (r int, exists bool) {
	v := m.question_bank_id
	if v == nil {
		return
	}
	return *v, true
}

// OldQuestionBankID returns the old "question_bank_id" field's value of the Collection entity.
// If the Collection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectionMutation) OldQuestionBankID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldQuestionBankID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldQuestionBankID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuestionBankID: %w", err)
	}
	return oldValue.QuestionBankID, nil
}

// AddQuestionBankID adds i to the "question_bank_id" field.
func (m *CollectionMutation) AddQuestionBankID(i int) {
	if m.addquestion_bank_id != nil {
		*m.addquestion_bank_id += i
	} else {
		m.addquestion_bank_id = &i
	}
}

// AddedQuestionBankID returns the value that was added to the "question_bank_id" field in this mutation.
func (m *CollectionMutation) AddedQuestionBankID() (r int, exists bool) {
	v := m.addquestion_bank_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearQuestionBankID clears the value of the "question_bank_id" field.
func (m *CollectionMutation) ClearQuestionBankID() {
	m.question_bank_id = nil
	m.addquestion_bank_id = nil
	m.clearedFields[collection.FieldQuestionBankID] = struct{}{}
}

// QuestionBankIDCleared returns if the "question_bank_id" field was cleared in this mutation.
func (m *CollectionMutation) QuestionBankIDCleared() bool {
	_, ok := m.clearedFields[collection.FieldQuestionBankID]
	return ok
}

// ResetQuestionBankID resets all changes to the "question_bank_id" field.
func (m *CollectionMutation) ResetQuestionBankID() {
	m.question_bank_id = nil
	m.addquestion_bank_id = nil
	delete(m.clearedFields, collection.FieldQuestionBankID)
}

// SetExamQuestionType sets the "exam_question_type" field.
func (m *CollectionMutation) SetExamQuestionType(i int) {
	m.exam_question_type = &i
	m.addexam_question_type = nil
}

// ExamQuestionType returns the value of the "exam_question_type" field in the mutation.
func (m *CollectionMutation) ExamQuestionType() (r int, exists bool) {
	v := m.exam_question_type
	if v == nil {
		return
	}
	return *v, true
}

// OldExamQuestionType returns the old "exam_question_type" field's value of the Collection entity.
// If the Collection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectionMutation) OldExamQuestionType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExamQuestionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExamQuestionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamQuestionType: %w", err)
	}
	return oldValue.ExamQuestionType, nil
}

// AddExamQuestionType adds i to the "exam_question_type" field.
func (m *CollectionMutation) AddExamQuestionType(i int) {
	if m.addexam_question_type != nil {
		*m.addexam_question_type += i
	} else {
		m.addexam_question_type = &i
	}
}

// AddedExamQuestionType returns the value that was added to the "exam_question_type" field in this mutation.
func (m *CollectionMutation) AddedExamQuestionType() (r int, exists bool) {
	v := m.addexam_question_type
	if v == nil {
		return
	}
	return *v, true
}

// ClearExamQuestionType clears the value of the "exam_question_type" field.
func (m *CollectionMutation) ClearExamQuestionType() {
	m.exam_question_type = nil
	m.addexam_question_type = nil
	m.clearedFields[collection.FieldExamQuestionType] = struct{}{}
}

// ExamQuestionTypeCleared returns if the "exam_question_type" field was cleared in this mutation.
func (m *CollectionMutation) ExamQuestionTypeCleared() bool {
	_, ok := m.clearedFields[collection.FieldExamQuestionType]
	return ok
}

// ResetExamQuestionType resets all changes to the "exam_question_type" field.
func (m *CollectionMutation) ResetExamQuestionType() {
	m.exam_question_type = nil
	m.addexam_question_type = nil
	delete(m.clearedFields, collection.FieldExamQuestionType)
}

// SetQuestionID sets the "question" edge to the TkQuestion entity by id.
func (m *CollectionMutation) SetQuestionID(id int) {
	m.question = &id
}

// ClearQuestion clears the "question" edge to the TkQuestion entity.
func (m *CollectionMutation) ClearQuestion() {
	m.clearedquestion = true
}

// QuestionCleared reports if the "question" edge to the TkQuestion entity was cleared.
func (m *CollectionMutation) QuestionCleared() bool {
	return m.ValueIDCleared() || m.clearedquestion
}

// QuestionID returns the "question" edge ID in the mutation.
func (m *CollectionMutation) QuestionID() (id int, exists bool) {
	if m.question != nil {
		return *m.question, true
	}
	return
}

// QuestionIDs returns the "question" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// QuestionID instead. It exists only for internal usage by the builders.
func (m *CollectionMutation) QuestionIDs() (ids []int) {
	if id := m.question; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetQuestion resets all changes to the "question" edge.
func (m *CollectionMutation) ResetQuestion() {
	m.question = nil
	m.clearedquestion = false
}

// Op returns the operation name.
func (m *CollectionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Collection).
func (m *CollectionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CollectionMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.uuid != nil {
		fields = append(fields, collection.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, collection.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, collection.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, collection.FieldDeletedAt)
	}
	if m._type != nil {
		fields = append(fields, collection.FieldType)
	}
	if m.question != nil {
		fields = append(fields, collection.FieldValueID)
	}
	if m.user_id != nil {
		fields = append(fields, collection.FieldUserID)
	}
	if m.exam_id != nil {
		fields = append(fields, collection.FieldExamID)
	}
	if m.sec_id != nil {
		fields = append(fields, collection.FieldSecID)
	}
	if m.question_bank_id != nil {
		fields = append(fields, collection.FieldQuestionBankID)
	}
	if m.exam_question_type != nil {
		fields = append(fields, collection.FieldExamQuestionType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CollectionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case collection.FieldUUID:
		return m.UUID()
	case collection.FieldCreatedAt:
		return m.CreatedAt()
	case collection.FieldUpdatedAt:
		return m.UpdatedAt()
	case collection.FieldDeletedAt:
		return m.DeletedAt()
	case collection.FieldType:
		return m.GetType()
	case collection.FieldValueID:
		return m.ValueID()
	case collection.FieldUserID:
		return m.UserID()
	case collection.FieldExamID:
		return m.ExamID()
	case collection.FieldSecID:
		return m.SecID()
	case collection.FieldQuestionBankID:
		return m.QuestionBankID()
	case collection.FieldExamQuestionType:
		return m.ExamQuestionType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CollectionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case collection.FieldUUID:
		return m.OldUUID(ctx)
	case collection.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case collection.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case collection.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case collection.FieldType:
		return m.OldType(ctx)
	case collection.FieldValueID:
		return m.OldValueID(ctx)
	case collection.FieldUserID:
		return m.OldUserID(ctx)
	case collection.FieldExamID:
		return m.OldExamID(ctx)
	case collection.FieldSecID:
		return m.OldSecID(ctx)
	case collection.FieldQuestionBankID:
		return m.OldQuestionBankID(ctx)
	case collection.FieldExamQuestionType:
		return m.OldExamQuestionType(ctx)
	}
	return nil, fmt.Errorf("unknown Collection field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CollectionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case collection.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case collection.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case collection.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case collection.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case collection.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case collection.FieldValueID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValueID(v)
		return nil
	case collection.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case collection.FieldExamID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamID(v)
		return nil
	case collection.FieldSecID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecID(v)
		return nil
	case collection.FieldQuestionBankID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuestionBankID(v)
		return nil
	case collection.FieldExamQuestionType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamQuestionType(v)
		return nil
	}
	return fmt.Errorf("unknown Collection field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CollectionMutation) AddedFields() []string {
	var fields []string
	if m.add_type != nil {
		fields = append(fields, collection.FieldType)
	}
	if m.adduser_id != nil {
		fields = append(fields, collection.FieldUserID)
	}
	if m.addexam_id != nil {
		fields = append(fields, collection.FieldExamID)
	}
	if m.addsec_id != nil {
		fields = append(fields, collection.FieldSecID)
	}
	if m.addquestion_bank_id != nil {
		fields = append(fields, collection.FieldQuestionBankID)
	}
	if m.addexam_question_type != nil {
		fields = append(fields, collection.FieldExamQuestionType)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CollectionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case collection.FieldType:
		return m.AddedType()
	case collection.FieldUserID:
		return m.AddedUserID()
	case collection.FieldExamID:
		return m.AddedExamID()
	case collection.FieldSecID:
		return m.AddedSecID()
	case collection.FieldQuestionBankID:
		return m.AddedQuestionBankID()
	case collection.FieldExamQuestionType:
		return m.AddedExamQuestionType()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CollectionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case collection.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case collection.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case collection.FieldExamID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExamID(v)
		return nil
	case collection.FieldSecID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSecID(v)
		return nil
	case collection.FieldQuestionBankID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuestionBankID(v)
		return nil
	case collection.FieldExamQuestionType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExamQuestionType(v)
		return nil
	}
	return fmt.Errorf("unknown Collection numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CollectionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(collection.FieldCreatedAt) {
		fields = append(fields, collection.FieldCreatedAt)
	}
	if m.FieldCleared(collection.FieldUpdatedAt) {
		fields = append(fields, collection.FieldUpdatedAt)
	}
	if m.FieldCleared(collection.FieldDeletedAt) {
		fields = append(fields, collection.FieldDeletedAt)
	}
	if m.FieldCleared(collection.FieldType) {
		fields = append(fields, collection.FieldType)
	}
	if m.FieldCleared(collection.FieldValueID) {
		fields = append(fields, collection.FieldValueID)
	}
	if m.FieldCleared(collection.FieldUserID) {
		fields = append(fields, collection.FieldUserID)
	}
	if m.FieldCleared(collection.FieldExamID) {
		fields = append(fields, collection.FieldExamID)
	}
	if m.FieldCleared(collection.FieldSecID) {
		fields = append(fields, collection.FieldSecID)
	}
	if m.FieldCleared(collection.FieldQuestionBankID) {
		fields = append(fields, collection.FieldQuestionBankID)
	}
	if m.FieldCleared(collection.FieldExamQuestionType) {
		fields = append(fields, collection.FieldExamQuestionType)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CollectionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CollectionMutation) ClearField(name string) error {
	switch name {
	case collection.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case collection.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case collection.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case collection.FieldType:
		m.ClearType()
		return nil
	case collection.FieldValueID:
		m.ClearValueID()
		return nil
	case collection.FieldUserID:
		m.ClearUserID()
		return nil
	case collection.FieldExamID:
		m.ClearExamID()
		return nil
	case collection.FieldSecID:
		m.ClearSecID()
		return nil
	case collection.FieldQuestionBankID:
		m.ClearQuestionBankID()
		return nil
	case collection.FieldExamQuestionType:
		m.ClearExamQuestionType()
		return nil
	}
	return fmt.Errorf("unknown Collection nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CollectionMutation) ResetField(name string) error {
	switch name {
	case collection.FieldUUID:
		m.ResetUUID()
		return nil
	case collection.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case collection.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case collection.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case collection.FieldType:
		m.ResetType()
		return nil
	case collection.FieldValueID:
		m.ResetValueID()
		return nil
	case collection.FieldUserID:
		m.ResetUserID()
		return nil
	case collection.FieldExamID:
		m.ResetExamID()
		return nil
	case collection.FieldSecID:
		m.ResetSecID()
		return nil
	case collection.FieldQuestionBankID:
		m.ResetQuestionBankID()
		return nil
	case collection.FieldExamQuestionType:
		m.ResetExamQuestionType()
		return nil
	}
	return fmt.Errorf("unknown Collection field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CollectionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.question != nil {
		edges = append(edges, collection.EdgeQuestion)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CollectionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case collection.EdgeQuestion:
		if id := m.question; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CollectionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CollectionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CollectionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedquestion {
		edges = append(edges, collection.EdgeQuestion)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CollectionMutation) EdgeCleared(name string) bool {
	switch name {
	case collection.EdgeQuestion:
		return m.clearedquestion
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CollectionMutation) ClearEdge(name string) error {
	switch name {
	case collection.EdgeQuestion:
		m.ClearQuestion()
		return nil
	}
	return fmt.Errorf("unknown Collection unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CollectionMutation) ResetEdge(name string) error {
	switch name {
	case collection.EdgeQuestion:
		m.ResetQuestion()
		return nil
	}
	return fmt.Errorf("unknown Collection edge %s", name)
}

// HotSearchMutation represents an operation that mutates the HotSearch nodes in the graph.
type HotSearchMutation struct {
	config
	op              Op
	typ             string
	id              *int
	uuid            *string
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *time.Time
	name            *string
	status          *uint8
	addstatus       *uint8
	search_count    *int
	addsearch_count *int
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*HotSearch, error)
	predicates      []predicate.HotSearch
}

var _ ent.Mutation = (*HotSearchMutation)(nil)

// hotsearchOption allows management of the mutation configuration using functional options.
type hotsearchOption func(*HotSearchMutation)

// newHotSearchMutation creates new mutation for the HotSearch entity.
func newHotSearchMutation(c config, op Op, opts ...hotsearchOption) *HotSearchMutation {
	m := &HotSearchMutation{
		config:        c,
		op:            op,
		typ:           TypeHotSearch,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHotSearchID sets the ID field of the mutation.
func withHotSearchID(id int) hotsearchOption {
	return func(m *HotSearchMutation) {
		var (
			err   error
			once  sync.Once
			value *HotSearch
		)
		m.oldValue = func(ctx context.Context) (*HotSearch, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HotSearch.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHotSearch sets the old HotSearch of the mutation.
func withHotSearch(node *HotSearch) hotsearchOption {
	return func(m *HotSearchMutation) {
		m.oldValue = func(context.Context) (*HotSearch, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HotSearchMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HotSearchMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *HotSearchMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *HotSearchMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *HotSearchMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the HotSearch entity.
// If the HotSearch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HotSearchMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *HotSearchMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *HotSearchMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *HotSearchMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the HotSearch entity.
// If the HotSearch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HotSearchMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *HotSearchMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[hotsearch.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *HotSearchMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[hotsearch.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *HotSearchMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, hotsearch.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *HotSearchMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *HotSearchMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the HotSearch entity.
// If the HotSearch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HotSearchMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *HotSearchMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[hotsearch.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *HotSearchMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[hotsearch.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *HotSearchMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, hotsearch.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *HotSearchMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *HotSearchMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the HotSearch entity.
// If the HotSearch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HotSearchMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *HotSearchMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[hotsearch.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *HotSearchMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[hotsearch.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *HotSearchMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, hotsearch.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *HotSearchMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *HotSearchMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the HotSearch entity.
// If the HotSearch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HotSearchMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *HotSearchMutation) ResetName() {
	m.name = nil
}

// SetStatus sets the "status" field.
func (m *HotSearchMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *HotSearchMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the HotSearch entity.
// If the HotSearch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HotSearchMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *HotSearchMutation) AddStatus(u uint8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *HotSearchMutation) AddedStatus() (r uint8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *HotSearchMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetSearchCount sets the "search_count" field.
func (m *HotSearchMutation) SetSearchCount(i int) {
	m.search_count = &i
	m.addsearch_count = nil
}

// SearchCount returns the value of the "search_count" field in the mutation.
func (m *HotSearchMutation) SearchCount() (r int, exists bool) {
	v := m.search_count
	if v == nil {
		return
	}
	return *v, true
}

// OldSearchCount returns the old "search_count" field's value of the HotSearch entity.
// If the HotSearch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HotSearchMutation) OldSearchCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSearchCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSearchCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSearchCount: %w", err)
	}
	return oldValue.SearchCount, nil
}

// AddSearchCount adds i to the "search_count" field.
func (m *HotSearchMutation) AddSearchCount(i int) {
	if m.addsearch_count != nil {
		*m.addsearch_count += i
	} else {
		m.addsearch_count = &i
	}
}

// AddedSearchCount returns the value that was added to the "search_count" field in this mutation.
func (m *HotSearchMutation) AddedSearchCount() (r int, exists bool) {
	v := m.addsearch_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetSearchCount resets all changes to the "search_count" field.
func (m *HotSearchMutation) ResetSearchCount() {
	m.search_count = nil
	m.addsearch_count = nil
}

// Op returns the operation name.
func (m *HotSearchMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (HotSearch).
func (m *HotSearchMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HotSearchMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.uuid != nil {
		fields = append(fields, hotsearch.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, hotsearch.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, hotsearch.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, hotsearch.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, hotsearch.FieldName)
	}
	if m.status != nil {
		fields = append(fields, hotsearch.FieldStatus)
	}
	if m.search_count != nil {
		fields = append(fields, hotsearch.FieldSearchCount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HotSearchMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hotsearch.FieldUUID:
		return m.UUID()
	case hotsearch.FieldCreatedAt:
		return m.CreatedAt()
	case hotsearch.FieldUpdatedAt:
		return m.UpdatedAt()
	case hotsearch.FieldDeletedAt:
		return m.DeletedAt()
	case hotsearch.FieldName:
		return m.Name()
	case hotsearch.FieldStatus:
		return m.Status()
	case hotsearch.FieldSearchCount:
		return m.SearchCount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HotSearchMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hotsearch.FieldUUID:
		return m.OldUUID(ctx)
	case hotsearch.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case hotsearch.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case hotsearch.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case hotsearch.FieldName:
		return m.OldName(ctx)
	case hotsearch.FieldStatus:
		return m.OldStatus(ctx)
	case hotsearch.FieldSearchCount:
		return m.OldSearchCount(ctx)
	}
	return nil, fmt.Errorf("unknown HotSearch field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HotSearchMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hotsearch.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case hotsearch.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case hotsearch.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case hotsearch.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case hotsearch.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case hotsearch.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case hotsearch.FieldSearchCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSearchCount(v)
		return nil
	}
	return fmt.Errorf("unknown HotSearch field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HotSearchMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, hotsearch.FieldStatus)
	}
	if m.addsearch_count != nil {
		fields = append(fields, hotsearch.FieldSearchCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HotSearchMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case hotsearch.FieldStatus:
		return m.AddedStatus()
	case hotsearch.FieldSearchCount:
		return m.AddedSearchCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HotSearchMutation) AddField(name string, value ent.Value) error {
	switch name {
	case hotsearch.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case hotsearch.FieldSearchCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSearchCount(v)
		return nil
	}
	return fmt.Errorf("unknown HotSearch numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HotSearchMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(hotsearch.FieldCreatedAt) {
		fields = append(fields, hotsearch.FieldCreatedAt)
	}
	if m.FieldCleared(hotsearch.FieldUpdatedAt) {
		fields = append(fields, hotsearch.FieldUpdatedAt)
	}
	if m.FieldCleared(hotsearch.FieldDeletedAt) {
		fields = append(fields, hotsearch.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HotSearchMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HotSearchMutation) ClearField(name string) error {
	switch name {
	case hotsearch.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case hotsearch.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case hotsearch.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown HotSearch nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HotSearchMutation) ResetField(name string) error {
	switch name {
	case hotsearch.FieldUUID:
		m.ResetUUID()
		return nil
	case hotsearch.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case hotsearch.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case hotsearch.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case hotsearch.FieldName:
		m.ResetName()
		return nil
	case hotsearch.FieldStatus:
		m.ResetStatus()
		return nil
	case hotsearch.FieldSearchCount:
		m.ResetSearchCount()
		return nil
	}
	return fmt.Errorf("unknown HotSearch field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HotSearchMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HotSearchMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HotSearchMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HotSearchMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HotSearchMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HotSearchMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HotSearchMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown HotSearch unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HotSearchMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown HotSearch edge %s", name)
}

// ImportTaskMutation represents an operation that mutates the ImportTask nodes in the graph.
type ImportTaskMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	uuid                *string
	created_at          *time.Time
	updated_at          *time.Time
	deleted_at          *time.Time
	import_name         *string
	status              *uint8
	addstatus           *uint8
	_path               *string
	total               *int
	addtotal            *int
	created_admin_id    *int
	addcreated_admin_id *int
	remark              *string
	clearedFields       map[string]struct{}
	done                bool
	oldValue            func(context.Context) (*ImportTask, error)
	predicates          []predicate.ImportTask
}

var _ ent.Mutation = (*ImportTaskMutation)(nil)

// importtaskOption allows management of the mutation configuration using functional options.
type importtaskOption func(*ImportTaskMutation)

// newImportTaskMutation creates new mutation for the ImportTask entity.
func newImportTaskMutation(c config, op Op, opts ...importtaskOption) *ImportTaskMutation {
	m := &ImportTaskMutation{
		config:        c,
		op:            op,
		typ:           TypeImportTask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withImportTaskID sets the ID field of the mutation.
func withImportTaskID(id int) importtaskOption {
	return func(m *ImportTaskMutation) {
		var (
			err   error
			once  sync.Once
			value *ImportTask
		)
		m.oldValue = func(ctx context.Context) (*ImportTask, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ImportTask.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withImportTask sets the old ImportTask of the mutation.
func withImportTask(node *ImportTask) importtaskOption {
	return func(m *ImportTaskMutation) {
		m.oldValue = func(context.Context) (*ImportTask, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ImportTaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ImportTaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *ImportTaskMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *ImportTaskMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *ImportTaskMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the ImportTask entity.
// If the ImportTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImportTaskMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *ImportTaskMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ImportTaskMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ImportTaskMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ImportTask entity.
// If the ImportTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImportTaskMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *ImportTaskMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[importtask.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *ImportTaskMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[importtask.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ImportTaskMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, importtask.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ImportTaskMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ImportTaskMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ImportTask entity.
// If the ImportTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImportTaskMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *ImportTaskMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[importtask.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *ImportTaskMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[importtask.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ImportTaskMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, importtask.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ImportTaskMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ImportTaskMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ImportTask entity.
// If the ImportTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImportTaskMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ImportTaskMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[importtask.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ImportTaskMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[importtask.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ImportTaskMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, importtask.FieldDeletedAt)
}

// SetImportName sets the "import_name" field.
func (m *ImportTaskMutation) SetImportName(s string) {
	m.import_name = &s
}

// ImportName returns the value of the "import_name" field in the mutation.
func (m *ImportTaskMutation) ImportName() (r string, exists bool) {
	v := m.import_name
	if v == nil {
		return
	}
	return *v, true
}

// OldImportName returns the old "import_name" field's value of the ImportTask entity.
// If the ImportTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImportTaskMutation) OldImportName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldImportName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldImportName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImportName: %w", err)
	}
	return oldValue.ImportName, nil
}

// ResetImportName resets all changes to the "import_name" field.
func (m *ImportTaskMutation) ResetImportName() {
	m.import_name = nil
}

// SetStatus sets the "status" field.
func (m *ImportTaskMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *ImportTaskMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ImportTask entity.
// If the ImportTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImportTaskMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *ImportTaskMutation) AddStatus(u uint8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *ImportTaskMutation) AddedStatus() (r uint8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *ImportTaskMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetPath sets the "path" field.
func (m *ImportTaskMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *ImportTaskMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the ImportTask entity.
// If the ImportTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImportTaskMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath resets all changes to the "path" field.
func (m *ImportTaskMutation) ResetPath() {
	m._path = nil
}

// SetTotal sets the "total" field.
func (m *ImportTaskMutation) SetTotal(i int) {
	m.total = &i
	m.addtotal = nil
}

// Total returns the value of the "total" field in the mutation.
func (m *ImportTaskMutation) Total() (r int, exists bool) {
	v := m.total
	if v == nil {
		return
	}
	return *v, true
}

// OldTotal returns the old "total" field's value of the ImportTask entity.
// If the ImportTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImportTaskMutation) OldTotal(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotal: %w", err)
	}
	return oldValue.Total, nil
}

// AddTotal adds i to the "total" field.
func (m *ImportTaskMutation) AddTotal(i int) {
	if m.addtotal != nil {
		*m.addtotal += i
	} else {
		m.addtotal = &i
	}
}

// AddedTotal returns the value that was added to the "total" field in this mutation.
func (m *ImportTaskMutation) AddedTotal() (r int, exists bool) {
	v := m.addtotal
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotal resets all changes to the "total" field.
func (m *ImportTaskMutation) ResetTotal() {
	m.total = nil
	m.addtotal = nil
}

// SetCreatedAdminID sets the "created_admin_id" field.
func (m *ImportTaskMutation) SetCreatedAdminID(i int) {
	m.created_admin_id = &i
	m.addcreated_admin_id = nil
}

// CreatedAdminID returns the value of the "created_admin_id" field in the mutation.
func (m *ImportTaskMutation) CreatedAdminID() (r int, exists bool) {
	v := m.created_admin_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAdminID returns the old "created_admin_id" field's value of the ImportTask entity.
// If the ImportTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImportTaskMutation) OldCreatedAdminID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAdminID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAdminID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAdminID: %w", err)
	}
	return oldValue.CreatedAdminID, nil
}

// AddCreatedAdminID adds i to the "created_admin_id" field.
func (m *ImportTaskMutation) AddCreatedAdminID(i int) {
	if m.addcreated_admin_id != nil {
		*m.addcreated_admin_id += i
	} else {
		m.addcreated_admin_id = &i
	}
}

// AddedCreatedAdminID returns the value that was added to the "created_admin_id" field in this mutation.
func (m *ImportTaskMutation) AddedCreatedAdminID() (r int, exists bool) {
	v := m.addcreated_admin_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAdminID resets all changes to the "created_admin_id" field.
func (m *ImportTaskMutation) ResetCreatedAdminID() {
	m.created_admin_id = nil
	m.addcreated_admin_id = nil
}

// SetRemark sets the "remark" field.
func (m *ImportTaskMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *ImportTaskMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the ImportTask entity.
// If the ImportTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImportTaskMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ResetRemark resets all changes to the "remark" field.
func (m *ImportTaskMutation) ResetRemark() {
	m.remark = nil
}

// Op returns the operation name.
func (m *ImportTaskMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ImportTask).
func (m *ImportTaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ImportTaskMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.uuid != nil {
		fields = append(fields, importtask.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, importtask.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, importtask.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, importtask.FieldDeletedAt)
	}
	if m.import_name != nil {
		fields = append(fields, importtask.FieldImportName)
	}
	if m.status != nil {
		fields = append(fields, importtask.FieldStatus)
	}
	if m._path != nil {
		fields = append(fields, importtask.FieldPath)
	}
	if m.total != nil {
		fields = append(fields, importtask.FieldTotal)
	}
	if m.created_admin_id != nil {
		fields = append(fields, importtask.FieldCreatedAdminID)
	}
	if m.remark != nil {
		fields = append(fields, importtask.FieldRemark)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ImportTaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case importtask.FieldUUID:
		return m.UUID()
	case importtask.FieldCreatedAt:
		return m.CreatedAt()
	case importtask.FieldUpdatedAt:
		return m.UpdatedAt()
	case importtask.FieldDeletedAt:
		return m.DeletedAt()
	case importtask.FieldImportName:
		return m.ImportName()
	case importtask.FieldStatus:
		return m.Status()
	case importtask.FieldPath:
		return m.Path()
	case importtask.FieldTotal:
		return m.Total()
	case importtask.FieldCreatedAdminID:
		return m.CreatedAdminID()
	case importtask.FieldRemark:
		return m.Remark()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ImportTaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case importtask.FieldUUID:
		return m.OldUUID(ctx)
	case importtask.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case importtask.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case importtask.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case importtask.FieldImportName:
		return m.OldImportName(ctx)
	case importtask.FieldStatus:
		return m.OldStatus(ctx)
	case importtask.FieldPath:
		return m.OldPath(ctx)
	case importtask.FieldTotal:
		return m.OldTotal(ctx)
	case importtask.FieldCreatedAdminID:
		return m.OldCreatedAdminID(ctx)
	case importtask.FieldRemark:
		return m.OldRemark(ctx)
	}
	return nil, fmt.Errorf("unknown ImportTask field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImportTaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case importtask.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case importtask.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case importtask.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case importtask.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case importtask.FieldImportName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImportName(v)
		return nil
	case importtask.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case importtask.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case importtask.FieldTotal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotal(v)
		return nil
	case importtask.FieldCreatedAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAdminID(v)
		return nil
	case importtask.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	}
	return fmt.Errorf("unknown ImportTask field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ImportTaskMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, importtask.FieldStatus)
	}
	if m.addtotal != nil {
		fields = append(fields, importtask.FieldTotal)
	}
	if m.addcreated_admin_id != nil {
		fields = append(fields, importtask.FieldCreatedAdminID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ImportTaskMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case importtask.FieldStatus:
		return m.AddedStatus()
	case importtask.FieldTotal:
		return m.AddedTotal()
	case importtask.FieldCreatedAdminID:
		return m.AddedCreatedAdminID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImportTaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	case importtask.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case importtask.FieldTotal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotal(v)
		return nil
	case importtask.FieldCreatedAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAdminID(v)
		return nil
	}
	return fmt.Errorf("unknown ImportTask numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ImportTaskMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(importtask.FieldCreatedAt) {
		fields = append(fields, importtask.FieldCreatedAt)
	}
	if m.FieldCleared(importtask.FieldUpdatedAt) {
		fields = append(fields, importtask.FieldUpdatedAt)
	}
	if m.FieldCleared(importtask.FieldDeletedAt) {
		fields = append(fields, importtask.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ImportTaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ImportTaskMutation) ClearField(name string) error {
	switch name {
	case importtask.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case importtask.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case importtask.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown ImportTask nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ImportTaskMutation) ResetField(name string) error {
	switch name {
	case importtask.FieldUUID:
		m.ResetUUID()
		return nil
	case importtask.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case importtask.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case importtask.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case importtask.FieldImportName:
		m.ResetImportName()
		return nil
	case importtask.FieldStatus:
		m.ResetStatus()
		return nil
	case importtask.FieldPath:
		m.ResetPath()
		return nil
	case importtask.FieldTotal:
		m.ResetTotal()
		return nil
	case importtask.FieldCreatedAdminID:
		m.ResetCreatedAdminID()
		return nil
	case importtask.FieldRemark:
		m.ResetRemark()
		return nil
	}
	return fmt.Errorf("unknown ImportTask field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ImportTaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ImportTaskMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ImportTaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ImportTaskMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ImportTaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ImportTaskMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ImportTaskMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ImportTask unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ImportTaskMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ImportTask edge %s", name)
}

// InformationClassifyMutation represents an operation that mutates the InformationClassify nodes in the graph.
type InformationClassifyMutation struct {
	config
	op            Op
	typ           string
	id            *int
	uuid          *string
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	name          *string
	status        *uint8
	addstatus     *uint8
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*InformationClassify, error)
	predicates    []predicate.InformationClassify
}

var _ ent.Mutation = (*InformationClassifyMutation)(nil)

// informationclassifyOption allows management of the mutation configuration using functional options.
type informationclassifyOption func(*InformationClassifyMutation)

// newInformationClassifyMutation creates new mutation for the InformationClassify entity.
func newInformationClassifyMutation(c config, op Op, opts ...informationclassifyOption) *InformationClassifyMutation {
	m := &InformationClassifyMutation{
		config:        c,
		op:            op,
		typ:           TypeInformationClassify,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInformationClassifyID sets the ID field of the mutation.
func withInformationClassifyID(id int) informationclassifyOption {
	return func(m *InformationClassifyMutation) {
		var (
			err   error
			once  sync.Once
			value *InformationClassify
		)
		m.oldValue = func(ctx context.Context) (*InformationClassify, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InformationClassify.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInformationClassify sets the old InformationClassify of the mutation.
func withInformationClassify(node *InformationClassify) informationclassifyOption {
	return func(m *InformationClassifyMutation) {
		m.oldValue = func(context.Context) (*InformationClassify, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InformationClassifyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InformationClassifyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *InformationClassifyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *InformationClassifyMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *InformationClassifyMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the InformationClassify entity.
// If the InformationClassify object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InformationClassifyMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *InformationClassifyMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *InformationClassifyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InformationClassifyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the InformationClassify entity.
// If the InformationClassify object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InformationClassifyMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *InformationClassifyMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[informationclassify.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *InformationClassifyMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[informationclassify.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InformationClassifyMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, informationclassify.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *InformationClassifyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *InformationClassifyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the InformationClassify entity.
// If the InformationClassify object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InformationClassifyMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *InformationClassifyMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[informationclassify.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *InformationClassifyMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[informationclassify.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *InformationClassifyMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, informationclassify.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *InformationClassifyMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *InformationClassifyMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the InformationClassify entity.
// If the InformationClassify object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InformationClassifyMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *InformationClassifyMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[informationclassify.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *InformationClassifyMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[informationclassify.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *InformationClassifyMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, informationclassify.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *InformationClassifyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *InformationClassifyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the InformationClassify entity.
// If the InformationClassify object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InformationClassifyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *InformationClassifyMutation) ResetName() {
	m.name = nil
}

// SetStatus sets the "status" field.
func (m *InformationClassifyMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *InformationClassifyMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the InformationClassify entity.
// If the InformationClassify object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InformationClassifyMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *InformationClassifyMutation) AddStatus(u uint8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *InformationClassifyMutation) AddedStatus() (r uint8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *InformationClassifyMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// Op returns the operation name.
func (m *InformationClassifyMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (InformationClassify).
func (m *InformationClassifyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InformationClassifyMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.uuid != nil {
		fields = append(fields, informationclassify.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, informationclassify.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, informationclassify.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, informationclassify.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, informationclassify.FieldName)
	}
	if m.status != nil {
		fields = append(fields, informationclassify.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InformationClassifyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case informationclassify.FieldUUID:
		return m.UUID()
	case informationclassify.FieldCreatedAt:
		return m.CreatedAt()
	case informationclassify.FieldUpdatedAt:
		return m.UpdatedAt()
	case informationclassify.FieldDeletedAt:
		return m.DeletedAt()
	case informationclassify.FieldName:
		return m.Name()
	case informationclassify.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InformationClassifyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case informationclassify.FieldUUID:
		return m.OldUUID(ctx)
	case informationclassify.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case informationclassify.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case informationclassify.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case informationclassify.FieldName:
		return m.OldName(ctx)
	case informationclassify.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown InformationClassify field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InformationClassifyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case informationclassify.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case informationclassify.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case informationclassify.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case informationclassify.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case informationclassify.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case informationclassify.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown InformationClassify field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InformationClassifyMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, informationclassify.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InformationClassifyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case informationclassify.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InformationClassifyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case informationclassify.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown InformationClassify numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InformationClassifyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(informationclassify.FieldCreatedAt) {
		fields = append(fields, informationclassify.FieldCreatedAt)
	}
	if m.FieldCleared(informationclassify.FieldUpdatedAt) {
		fields = append(fields, informationclassify.FieldUpdatedAt)
	}
	if m.FieldCleared(informationclassify.FieldDeletedAt) {
		fields = append(fields, informationclassify.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InformationClassifyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InformationClassifyMutation) ClearField(name string) error {
	switch name {
	case informationclassify.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case informationclassify.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case informationclassify.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown InformationClassify nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InformationClassifyMutation) ResetField(name string) error {
	switch name {
	case informationclassify.FieldUUID:
		m.ResetUUID()
		return nil
	case informationclassify.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case informationclassify.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case informationclassify.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case informationclassify.FieldName:
		m.ResetName()
		return nil
	case informationclassify.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown InformationClassify field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InformationClassifyMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InformationClassifyMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InformationClassifyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InformationClassifyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InformationClassifyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InformationClassifyMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InformationClassifyMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown InformationClassify unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InformationClassifyMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown InformationClassify edge %s", name)
}

// ItemCategoryMutation represents an operation that mutates the ItemCategory nodes in the graph.
type ItemCategoryMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	uuid                       *string
	created_at                 *time.Time
	updated_at                 *time.Time
	deleted_at                 *time.Time
	name                       *string
	status                     *uint8
	addstatus                  *uint8
	code                       *string
	desc                       *string
	sort_order                 *int
	addsort_order              *int
	clearedFields              map[string]struct{}
	item_question_banks        map[int]struct{}
	removeditem_question_banks map[int]struct{}
	cleareditem_question_banks bool
	kc_class                   *int
	clearedkc_class            bool
	course                     map[int]struct{}
	removedcourse              map[int]struct{}
	clearedcourse              bool
	user_item_cate             map[int]struct{}
	removeduser_item_cate      map[int]struct{}
	cleareduser_item_cate      bool
	parent                     *int
	clearedparent              bool
	children                   map[int]struct{}
	removedchildren            map[int]struct{}
	clearedchildren            bool
	done                       bool
	oldValue                   func(context.Context) (*ItemCategory, error)
	predicates                 []predicate.ItemCategory
}

var _ ent.Mutation = (*ItemCategoryMutation)(nil)

// itemcategoryOption allows management of the mutation configuration using functional options.
type itemcategoryOption func(*ItemCategoryMutation)

// newItemCategoryMutation creates new mutation for the ItemCategory entity.
func newItemCategoryMutation(c config, op Op, opts ...itemcategoryOption) *ItemCategoryMutation {
	m := &ItemCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeItemCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withItemCategoryID sets the ID field of the mutation.
func withItemCategoryID(id int) itemcategoryOption {
	return func(m *ItemCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *ItemCategory
		)
		m.oldValue = func(ctx context.Context) (*ItemCategory, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ItemCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withItemCategory sets the old ItemCategory of the mutation.
func withItemCategory(node *ItemCategory) itemcategoryOption {
	return func(m *ItemCategoryMutation) {
		m.oldValue = func(context.Context) (*ItemCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ItemCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ItemCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *ItemCategoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *ItemCategoryMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *ItemCategoryMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the ItemCategory entity.
// If the ItemCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemCategoryMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *ItemCategoryMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ItemCategoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ItemCategoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ItemCategory entity.
// If the ItemCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemCategoryMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *ItemCategoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[itemcategory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *ItemCategoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[itemcategory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ItemCategoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, itemcategory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ItemCategoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ItemCategoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ItemCategory entity.
// If the ItemCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemCategoryMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *ItemCategoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[itemcategory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *ItemCategoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[itemcategory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ItemCategoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, itemcategory.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ItemCategoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ItemCategoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ItemCategory entity.
// If the ItemCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemCategoryMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ItemCategoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[itemcategory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ItemCategoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[itemcategory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ItemCategoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, itemcategory.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *ItemCategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ItemCategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ItemCategory entity.
// If the ItemCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemCategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ItemCategoryMutation) ResetName() {
	m.name = nil
}

// SetStatus sets the "status" field.
func (m *ItemCategoryMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *ItemCategoryMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ItemCategory entity.
// If the ItemCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemCategoryMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *ItemCategoryMutation) AddStatus(u uint8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *ItemCategoryMutation) AddedStatus() (r uint8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *ItemCategoryMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetCode sets the "code" field.
func (m *ItemCategoryMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *ItemCategoryMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the ItemCategory entity.
// If the ItemCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemCategoryMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *ItemCategoryMutation) ResetCode() {
	m.code = nil
}

// SetDesc sets the "desc" field.
func (m *ItemCategoryMutation) SetDesc(s string) {
	m.desc = &s
}

// Desc returns the value of the "desc" field in the mutation.
func (m *ItemCategoryMutation) Desc() (r string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the ItemCategory entity.
// If the ItemCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemCategoryMutation) OldDesc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// ResetDesc resets all changes to the "desc" field.
func (m *ItemCategoryMutation) ResetDesc() {
	m.desc = nil
}

// SetPid sets the "pid" field.
func (m *ItemCategoryMutation) SetPid(i int) {
	m.parent = &i
}

// Pid returns the value of the "pid" field in the mutation.
func (m *ItemCategoryMutation) Pid() (r int, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldPid returns the old "pid" field's value of the ItemCategory entity.
// If the ItemCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemCategoryMutation) OldPid(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPid: %w", err)
	}
	return oldValue.Pid, nil
}

// ClearPid clears the value of the "pid" field.
func (m *ItemCategoryMutation) ClearPid() {
	m.parent = nil
	m.clearedFields[itemcategory.FieldPid] = struct{}{}
}

// PidCleared returns if the "pid" field was cleared in this mutation.
func (m *ItemCategoryMutation) PidCleared() bool {
	_, ok := m.clearedFields[itemcategory.FieldPid]
	return ok
}

// ResetPid resets all changes to the "pid" field.
func (m *ItemCategoryMutation) ResetPid() {
	m.parent = nil
	delete(m.clearedFields, itemcategory.FieldPid)
}

// SetSortOrder sets the "sort_order" field.
func (m *ItemCategoryMutation) SetSortOrder(i int) {
	m.sort_order = &i
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *ItemCategoryMutation) SortOrder() (r int, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the ItemCategory entity.
// If the ItemCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemCategoryMutation) OldSortOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds i to the "sort_order" field.
func (m *ItemCategoryMutation) AddSortOrder(i int) {
	if m.addsort_order != nil {
		*m.addsort_order += i
	} else {
		m.addsort_order = &i
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *ItemCategoryMutation) AddedSortOrder() (r int, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *ItemCategoryMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
}

// AddItemQuestionBankIDs adds the "item_question_banks" edge to the TkQuestionBank entity by ids.
func (m *ItemCategoryMutation) AddItemQuestionBankIDs(ids ...int) {
	if m.item_question_banks == nil {
		m.item_question_banks = make(map[int]struct{})
	}
	for i := range ids {
		m.item_question_banks[ids[i]] = struct{}{}
	}
}

// ClearItemQuestionBanks clears the "item_question_banks" edge to the TkQuestionBank entity.
func (m *ItemCategoryMutation) ClearItemQuestionBanks() {
	m.cleareditem_question_banks = true
}

// ItemQuestionBanksCleared reports if the "item_question_banks" edge to the TkQuestionBank entity was cleared.
func (m *ItemCategoryMutation) ItemQuestionBanksCleared() bool {
	return m.cleareditem_question_banks
}

// RemoveItemQuestionBankIDs removes the "item_question_banks" edge to the TkQuestionBank entity by IDs.
func (m *ItemCategoryMutation) RemoveItemQuestionBankIDs(ids ...int) {
	if m.removeditem_question_banks == nil {
		m.removeditem_question_banks = make(map[int]struct{})
	}
	for i := range ids {
		m.removeditem_question_banks[ids[i]] = struct{}{}
	}
}

// RemovedItemQuestionBanks returns the removed IDs of the "item_question_banks" edge to the TkQuestionBank entity.
func (m *ItemCategoryMutation) RemovedItemQuestionBanksIDs() (ids []int) {
	for id := range m.removeditem_question_banks {
		ids = append(ids, id)
	}
	return
}

// ItemQuestionBanksIDs returns the "item_question_banks" edge IDs in the mutation.
func (m *ItemCategoryMutation) ItemQuestionBanksIDs() (ids []int) {
	for id := range m.item_question_banks {
		ids = append(ids, id)
	}
	return
}

// ResetItemQuestionBanks resets all changes to the "item_question_banks" edge.
func (m *ItemCategoryMutation) ResetItemQuestionBanks() {
	m.item_question_banks = nil
	m.cleareditem_question_banks = false
	m.removeditem_question_banks = nil
}

// SetKcClassID sets the "kc_class" edge to the KcClass entity by id.
func (m *ItemCategoryMutation) SetKcClassID(id int) {
	m.kc_class = &id
}

// ClearKcClass clears the "kc_class" edge to the KcClass entity.
func (m *ItemCategoryMutation) ClearKcClass() {
	m.clearedkc_class = true
}

// KcClassCleared reports if the "kc_class" edge to the KcClass entity was cleared.
func (m *ItemCategoryMutation) KcClassCleared() bool {
	return m.clearedkc_class
}

// KcClassID returns the "kc_class" edge ID in the mutation.
func (m *ItemCategoryMutation) KcClassID() (id int, exists bool) {
	if m.kc_class != nil {
		return *m.kc_class, true
	}
	return
}

// KcClassIDs returns the "kc_class" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// KcClassID instead. It exists only for internal usage by the builders.
func (m *ItemCategoryMutation) KcClassIDs() (ids []int) {
	if id := m.kc_class; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetKcClass resets all changes to the "kc_class" edge.
func (m *ItemCategoryMutation) ResetKcClass() {
	m.kc_class = nil
	m.clearedkc_class = false
}

// AddCourseIDs adds the "course" edge to the KcCourse entity by ids.
func (m *ItemCategoryMutation) AddCourseIDs(ids ...int) {
	if m.course == nil {
		m.course = make(map[int]struct{})
	}
	for i := range ids {
		m.course[ids[i]] = struct{}{}
	}
}

// ClearCourse clears the "course" edge to the KcCourse entity.
func (m *ItemCategoryMutation) ClearCourse() {
	m.clearedcourse = true
}

// CourseCleared reports if the "course" edge to the KcCourse entity was cleared.
func (m *ItemCategoryMutation) CourseCleared() bool {
	return m.clearedcourse
}

// RemoveCourseIDs removes the "course" edge to the KcCourse entity by IDs.
func (m *ItemCategoryMutation) RemoveCourseIDs(ids ...int) {
	if m.removedcourse == nil {
		m.removedcourse = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcourse[ids[i]] = struct{}{}
	}
}

// RemovedCourse returns the removed IDs of the "course" edge to the KcCourse entity.
func (m *ItemCategoryMutation) RemovedCourseIDs() (ids []int) {
	for id := range m.removedcourse {
		ids = append(ids, id)
	}
	return
}

// CourseIDs returns the "course" edge IDs in the mutation.
func (m *ItemCategoryMutation) CourseIDs() (ids []int) {
	for id := range m.course {
		ids = append(ids, id)
	}
	return
}

// ResetCourse resets all changes to the "course" edge.
func (m *ItemCategoryMutation) ResetCourse() {
	m.course = nil
	m.clearedcourse = false
	m.removedcourse = nil
}

// AddUserItemCateIDs adds the "user_item_cate" edge to the User entity by ids.
func (m *ItemCategoryMutation) AddUserItemCateIDs(ids ...int) {
	if m.user_item_cate == nil {
		m.user_item_cate = make(map[int]struct{})
	}
	for i := range ids {
		m.user_item_cate[ids[i]] = struct{}{}
	}
}

// ClearUserItemCate clears the "user_item_cate" edge to the User entity.
func (m *ItemCategoryMutation) ClearUserItemCate() {
	m.cleareduser_item_cate = true
}

// UserItemCateCleared reports if the "user_item_cate" edge to the User entity was cleared.
func (m *ItemCategoryMutation) UserItemCateCleared() bool {
	return m.cleareduser_item_cate
}

// RemoveUserItemCateIDs removes the "user_item_cate" edge to the User entity by IDs.
func (m *ItemCategoryMutation) RemoveUserItemCateIDs(ids ...int) {
	if m.removeduser_item_cate == nil {
		m.removeduser_item_cate = make(map[int]struct{})
	}
	for i := range ids {
		m.removeduser_item_cate[ids[i]] = struct{}{}
	}
}

// RemovedUserItemCate returns the removed IDs of the "user_item_cate" edge to the User entity.
func (m *ItemCategoryMutation) RemovedUserItemCateIDs() (ids []int) {
	for id := range m.removeduser_item_cate {
		ids = append(ids, id)
	}
	return
}

// UserItemCateIDs returns the "user_item_cate" edge IDs in the mutation.
func (m *ItemCategoryMutation) UserItemCateIDs() (ids []int) {
	for id := range m.user_item_cate {
		ids = append(ids, id)
	}
	return
}

// ResetUserItemCate resets all changes to the "user_item_cate" edge.
func (m *ItemCategoryMutation) ResetUserItemCate() {
	m.user_item_cate = nil
	m.cleareduser_item_cate = false
	m.removeduser_item_cate = nil
}

// SetParentID sets the "parent" edge to the ItemCategory entity by id.
func (m *ItemCategoryMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the ItemCategory entity.
func (m *ItemCategoryMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the ItemCategory entity was cleared.
func (m *ItemCategoryMutation) ParentCleared() bool {
	return m.PidCleared() || m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *ItemCategoryMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *ItemCategoryMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *ItemCategoryMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the ItemCategory entity by ids.
func (m *ItemCategoryMutation) AddChildIDs(ids ...int) {
	if m.children == nil {
		m.children = make(map[int]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the ItemCategory entity.
func (m *ItemCategoryMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the ItemCategory entity was cleared.
func (m *ItemCategoryMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the ItemCategory entity by IDs.
func (m *ItemCategoryMutation) RemoveChildIDs(ids ...int) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int]struct{})
	}
	for i := range ids {
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the ItemCategory entity.
func (m *ItemCategoryMutation) RemovedChildrenIDs() (ids []int) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *ItemCategoryMutation) ChildrenIDs() (ids []int) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *ItemCategoryMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// Op returns the operation name.
func (m *ItemCategoryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ItemCategory).
func (m *ItemCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ItemCategoryMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.uuid != nil {
		fields = append(fields, itemcategory.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, itemcategory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, itemcategory.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, itemcategory.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, itemcategory.FieldName)
	}
	if m.status != nil {
		fields = append(fields, itemcategory.FieldStatus)
	}
	if m.code != nil {
		fields = append(fields, itemcategory.FieldCode)
	}
	if m.desc != nil {
		fields = append(fields, itemcategory.FieldDesc)
	}
	if m.parent != nil {
		fields = append(fields, itemcategory.FieldPid)
	}
	if m.sort_order != nil {
		fields = append(fields, itemcategory.FieldSortOrder)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ItemCategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case itemcategory.FieldUUID:
		return m.UUID()
	case itemcategory.FieldCreatedAt:
		return m.CreatedAt()
	case itemcategory.FieldUpdatedAt:
		return m.UpdatedAt()
	case itemcategory.FieldDeletedAt:
		return m.DeletedAt()
	case itemcategory.FieldName:
		return m.Name()
	case itemcategory.FieldStatus:
		return m.Status()
	case itemcategory.FieldCode:
		return m.Code()
	case itemcategory.FieldDesc:
		return m.Desc()
	case itemcategory.FieldPid:
		return m.Pid()
	case itemcategory.FieldSortOrder:
		return m.SortOrder()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ItemCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case itemcategory.FieldUUID:
		return m.OldUUID(ctx)
	case itemcategory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case itemcategory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case itemcategory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case itemcategory.FieldName:
		return m.OldName(ctx)
	case itemcategory.FieldStatus:
		return m.OldStatus(ctx)
	case itemcategory.FieldCode:
		return m.OldCode(ctx)
	case itemcategory.FieldDesc:
		return m.OldDesc(ctx)
	case itemcategory.FieldPid:
		return m.OldPid(ctx)
	case itemcategory.FieldSortOrder:
		return m.OldSortOrder(ctx)
	}
	return nil, fmt.Errorf("unknown ItemCategory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ItemCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case itemcategory.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case itemcategory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case itemcategory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case itemcategory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case itemcategory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case itemcategory.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case itemcategory.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case itemcategory.FieldDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	case itemcategory.FieldPid:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPid(v)
		return nil
	case itemcategory.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown ItemCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ItemCategoryMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, itemcategory.FieldStatus)
	}
	if m.addsort_order != nil {
		fields = append(fields, itemcategory.FieldSortOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ItemCategoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case itemcategory.FieldStatus:
		return m.AddedStatus()
	case itemcategory.FieldSortOrder:
		return m.AddedSortOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ItemCategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case itemcategory.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case itemcategory.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown ItemCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ItemCategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(itemcategory.FieldCreatedAt) {
		fields = append(fields, itemcategory.FieldCreatedAt)
	}
	if m.FieldCleared(itemcategory.FieldUpdatedAt) {
		fields = append(fields, itemcategory.FieldUpdatedAt)
	}
	if m.FieldCleared(itemcategory.FieldDeletedAt) {
		fields = append(fields, itemcategory.FieldDeletedAt)
	}
	if m.FieldCleared(itemcategory.FieldPid) {
		fields = append(fields, itemcategory.FieldPid)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ItemCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ItemCategoryMutation) ClearField(name string) error {
	switch name {
	case itemcategory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case itemcategory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case itemcategory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case itemcategory.FieldPid:
		m.ClearPid()
		return nil
	}
	return fmt.Errorf("unknown ItemCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ItemCategoryMutation) ResetField(name string) error {
	switch name {
	case itemcategory.FieldUUID:
		m.ResetUUID()
		return nil
	case itemcategory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case itemcategory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case itemcategory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case itemcategory.FieldName:
		m.ResetName()
		return nil
	case itemcategory.FieldStatus:
		m.ResetStatus()
		return nil
	case itemcategory.FieldCode:
		m.ResetCode()
		return nil
	case itemcategory.FieldDesc:
		m.ResetDesc()
		return nil
	case itemcategory.FieldPid:
		m.ResetPid()
		return nil
	case itemcategory.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	}
	return fmt.Errorf("unknown ItemCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ItemCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.item_question_banks != nil {
		edges = append(edges, itemcategory.EdgeItemQuestionBanks)
	}
	if m.kc_class != nil {
		edges = append(edges, itemcategory.EdgeKcClass)
	}
	if m.course != nil {
		edges = append(edges, itemcategory.EdgeCourse)
	}
	if m.user_item_cate != nil {
		edges = append(edges, itemcategory.EdgeUserItemCate)
	}
	if m.parent != nil {
		edges = append(edges, itemcategory.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, itemcategory.EdgeChildren)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ItemCategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case itemcategory.EdgeItemQuestionBanks:
		ids := make([]ent.Value, 0, len(m.item_question_banks))
		for id := range m.item_question_banks {
			ids = append(ids, id)
		}
		return ids
	case itemcategory.EdgeKcClass:
		if id := m.kc_class; id != nil {
			return []ent.Value{*id}
		}
	case itemcategory.EdgeCourse:
		ids := make([]ent.Value, 0, len(m.course))
		for id := range m.course {
			ids = append(ids, id)
		}
		return ids
	case itemcategory.EdgeUserItemCate:
		ids := make([]ent.Value, 0, len(m.user_item_cate))
		for id := range m.user_item_cate {
			ids = append(ids, id)
		}
		return ids
	case itemcategory.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case itemcategory.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ItemCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removeditem_question_banks != nil {
		edges = append(edges, itemcategory.EdgeItemQuestionBanks)
	}
	if m.removedcourse != nil {
		edges = append(edges, itemcategory.EdgeCourse)
	}
	if m.removeduser_item_cate != nil {
		edges = append(edges, itemcategory.EdgeUserItemCate)
	}
	if m.removedchildren != nil {
		edges = append(edges, itemcategory.EdgeChildren)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ItemCategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case itemcategory.EdgeItemQuestionBanks:
		ids := make([]ent.Value, 0, len(m.removeditem_question_banks))
		for id := range m.removeditem_question_banks {
			ids = append(ids, id)
		}
		return ids
	case itemcategory.EdgeCourse:
		ids := make([]ent.Value, 0, len(m.removedcourse))
		for id := range m.removedcourse {
			ids = append(ids, id)
		}
		return ids
	case itemcategory.EdgeUserItemCate:
		ids := make([]ent.Value, 0, len(m.removeduser_item_cate))
		for id := range m.removeduser_item_cate {
			ids = append(ids, id)
		}
		return ids
	case itemcategory.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ItemCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.cleareditem_question_banks {
		edges = append(edges, itemcategory.EdgeItemQuestionBanks)
	}
	if m.clearedkc_class {
		edges = append(edges, itemcategory.EdgeKcClass)
	}
	if m.clearedcourse {
		edges = append(edges, itemcategory.EdgeCourse)
	}
	if m.cleareduser_item_cate {
		edges = append(edges, itemcategory.EdgeUserItemCate)
	}
	if m.clearedparent {
		edges = append(edges, itemcategory.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, itemcategory.EdgeChildren)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ItemCategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case itemcategory.EdgeItemQuestionBanks:
		return m.cleareditem_question_banks
	case itemcategory.EdgeKcClass:
		return m.clearedkc_class
	case itemcategory.EdgeCourse:
		return m.clearedcourse
	case itemcategory.EdgeUserItemCate:
		return m.cleareduser_item_cate
	case itemcategory.EdgeParent:
		return m.clearedparent
	case itemcategory.EdgeChildren:
		return m.clearedchildren
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ItemCategoryMutation) ClearEdge(name string) error {
	switch name {
	case itemcategory.EdgeKcClass:
		m.ClearKcClass()
		return nil
	case itemcategory.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown ItemCategory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ItemCategoryMutation) ResetEdge(name string) error {
	switch name {
	case itemcategory.EdgeItemQuestionBanks:
		m.ResetItemQuestionBanks()
		return nil
	case itemcategory.EdgeKcClass:
		m.ResetKcClass()
		return nil
	case itemcategory.EdgeCourse:
		m.ResetCourse()
		return nil
	case itemcategory.EdgeUserItemCate:
		m.ResetUserItemCate()
		return nil
	case itemcategory.EdgeParent:
		m.ResetParent()
		return nil
	case itemcategory.EdgeChildren:
		m.ResetChildren()
		return nil
	}
	return fmt.Errorf("unknown ItemCategory edge %s", name)
}

// KcClassMutation represents an operation that mutates the KcClass nodes in the graph.
type KcClassMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	uuid                    *string
	created_at              *time.Time
	updated_at              *time.Time
	deleted_at              *time.Time
	class_title             *string
	class_code              *string
	class_desc              *string
	is_display              *uint8
	addis_display           *uint8
	is_buy                  *uint8
	addis_buy               *uint8
	class_period_type       *uint8
	addclass_period_type    *uint8
	class_start_date        *time.Time
	class_end_date          *time.Time
	closing_date            *time.Time
	days_validity           *int
	adddays_validity        *int
	status                  *uint8
	addstatus               *uint8
	price                   *float64
	addprice                *float64
	student_count           *int
	addstudent_count        *int
	course_count            *int
	addcourse_count         *int
	clearedFields           map[string]struct{}
	majors                  map[int]struct{}
	removedmajors           map[int]struct{}
	clearedmajors           bool
	item                    *int
	cleareditem             bool
	city                    *int
	clearedcity             bool
	admin                   *int
	clearedadmin            bool
	attachment              *int
	clearedattachment       bool
	master_teachers         *int
	clearedmaster_teachers  bool
	class_teachers          map[int]struct{}
	removedclass_teachers   map[int]struct{}
	clearedclass_teachers   bool
	kc_class_courses        map[int]struct{}
	removedkc_class_courses map[int]struct{}
	clearedkc_class_courses bool
	kc_user_classes         map[int]struct{}
	removedkc_user_classes  map[int]struct{}
	clearedkc_user_classes  bool
	message_classes         map[int]struct{}
	removedmessage_classes  map[int]struct{}
	clearedmessage_classes  bool
	done                    bool
	oldValue                func(context.Context) (*KcClass, error)
	predicates              []predicate.KcClass
}

var _ ent.Mutation = (*KcClassMutation)(nil)

// kcclassOption allows management of the mutation configuration using functional options.
type kcclassOption func(*KcClassMutation)

// newKcClassMutation creates new mutation for the KcClass entity.
func newKcClassMutation(c config, op Op, opts ...kcclassOption) *KcClassMutation {
	m := &KcClassMutation{
		config:        c,
		op:            op,
		typ:           TypeKcClass,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withKcClassID sets the ID field of the mutation.
func withKcClassID(id int) kcclassOption {
	return func(m *KcClassMutation) {
		var (
			err   error
			once  sync.Once
			value *KcClass
		)
		m.oldValue = func(ctx context.Context) (*KcClass, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().KcClass.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withKcClass sets the old KcClass of the mutation.
func withKcClass(node *KcClass) kcclassOption {
	return func(m *KcClassMutation) {
		m.oldValue = func(context.Context) (*KcClass, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m KcClassMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m KcClassMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *KcClassMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *KcClassMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *KcClassMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the KcClass entity.
// If the KcClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcClassMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *KcClassMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *KcClassMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *KcClassMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the KcClass entity.
// If the KcClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcClassMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *KcClassMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[kcclass.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *KcClassMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[kcclass.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *KcClassMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, kcclass.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *KcClassMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *KcClassMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the KcClass entity.
// If the KcClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcClassMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *KcClassMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[kcclass.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *KcClassMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[kcclass.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *KcClassMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, kcclass.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *KcClassMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *KcClassMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the KcClass entity.
// If the KcClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcClassMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *KcClassMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[kcclass.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *KcClassMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[kcclass.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *KcClassMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, kcclass.FieldDeletedAt)
}

// SetClassTitle sets the "class_title" field.
func (m *KcClassMutation) SetClassTitle(s string) {
	m.class_title = &s
}

// ClassTitle returns the value of the "class_title" field in the mutation.
func (m *KcClassMutation) ClassTitle() (r string, exists bool) {
	v := m.class_title
	if v == nil {
		return
	}
	return *v, true
}

// OldClassTitle returns the old "class_title" field's value of the KcClass entity.
// If the KcClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcClassMutation) OldClassTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldClassTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldClassTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClassTitle: %w", err)
	}
	return oldValue.ClassTitle, nil
}

// ResetClassTitle resets all changes to the "class_title" field.
func (m *KcClassMutation) ResetClassTitle() {
	m.class_title = nil
}

// SetClassCode sets the "class_code" field.
func (m *KcClassMutation) SetClassCode(s string) {
	m.class_code = &s
}

// ClassCode returns the value of the "class_code" field in the mutation.
func (m *KcClassMutation) ClassCode() (r string, exists bool) {
	v := m.class_code
	if v == nil {
		return
	}
	return *v, true
}

// OldClassCode returns the old "class_code" field's value of the KcClass entity.
// If the KcClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcClassMutation) OldClassCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldClassCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldClassCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClassCode: %w", err)
	}
	return oldValue.ClassCode, nil
}

// ResetClassCode resets all changes to the "class_code" field.
func (m *KcClassMutation) ResetClassCode() {
	m.class_code = nil
}

// SetClassDesc sets the "class_desc" field.
func (m *KcClassMutation) SetClassDesc(s string) {
	m.class_desc = &s
}

// ClassDesc returns the value of the "class_desc" field in the mutation.
func (m *KcClassMutation) ClassDesc() (r string, exists bool) {
	v := m.class_desc
	if v == nil {
		return
	}
	return *v, true
}

// OldClassDesc returns the old "class_desc" field's value of the KcClass entity.
// If the KcClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcClassMutation) OldClassDesc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldClassDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldClassDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClassDesc: %w", err)
	}
	return oldValue.ClassDesc, nil
}

// ResetClassDesc resets all changes to the "class_desc" field.
func (m *KcClassMutation) ResetClassDesc() {
	m.class_desc = nil
}

// SetIsDisplay sets the "is_display" field.
func (m *KcClassMutation) SetIsDisplay(u uint8) {
	m.is_display = &u
	m.addis_display = nil
}

// IsDisplay returns the value of the "is_display" field in the mutation.
func (m *KcClassMutation) IsDisplay() (r uint8, exists bool) {
	v := m.is_display
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDisplay returns the old "is_display" field's value of the KcClass entity.
// If the KcClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcClassMutation) OldIsDisplay(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsDisplay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsDisplay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDisplay: %w", err)
	}
	return oldValue.IsDisplay, nil
}

// AddIsDisplay adds u to the "is_display" field.
func (m *KcClassMutation) AddIsDisplay(u uint8) {
	if m.addis_display != nil {
		*m.addis_display += u
	} else {
		m.addis_display = &u
	}
}

// AddedIsDisplay returns the value that was added to the "is_display" field in this mutation.
func (m *KcClassMutation) AddedIsDisplay() (r uint8, exists bool) {
	v := m.addis_display
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDisplay resets all changes to the "is_display" field.
func (m *KcClassMutation) ResetIsDisplay() {
	m.is_display = nil
	m.addis_display = nil
}

// SetIsBuy sets the "is_buy" field.
func (m *KcClassMutation) SetIsBuy(u uint8) {
	m.is_buy = &u
	m.addis_buy = nil
}

// IsBuy returns the value of the "is_buy" field in the mutation.
func (m *KcClassMutation) IsBuy() (r uint8, exists bool) {
	v := m.is_buy
	if v == nil {
		return
	}
	return *v, true
}

// OldIsBuy returns the old "is_buy" field's value of the KcClass entity.
// If the KcClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcClassMutation) OldIsBuy(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsBuy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsBuy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsBuy: %w", err)
	}
	return oldValue.IsBuy, nil
}

// AddIsBuy adds u to the "is_buy" field.
func (m *KcClassMutation) AddIsBuy(u uint8) {
	if m.addis_buy != nil {
		*m.addis_buy += u
	} else {
		m.addis_buy = &u
	}
}

// AddedIsBuy returns the value that was added to the "is_buy" field in this mutation.
func (m *KcClassMutation) AddedIsBuy() (r uint8, exists bool) {
	v := m.addis_buy
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsBuy resets all changes to the "is_buy" field.
func (m *KcClassMutation) ResetIsBuy() {
	m.is_buy = nil
	m.addis_buy = nil
}

// SetClassPeriodType sets the "class_period_type" field.
func (m *KcClassMutation) SetClassPeriodType(u uint8) {
	m.class_period_type = &u
	m.addclass_period_type = nil
}

// ClassPeriodType returns the value of the "class_period_type" field in the mutation.
func (m *KcClassMutation) ClassPeriodType() (r uint8, exists bool) {
	v := m.class_period_type
	if v == nil {
		return
	}
	return *v, true
}

// OldClassPeriodType returns the old "class_period_type" field's value of the KcClass entity.
// If the KcClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcClassMutation) OldClassPeriodType(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldClassPeriodType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldClassPeriodType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClassPeriodType: %w", err)
	}
	return oldValue.ClassPeriodType, nil
}

// AddClassPeriodType adds u to the "class_period_type" field.
func (m *KcClassMutation) AddClassPeriodType(u uint8) {
	if m.addclass_period_type != nil {
		*m.addclass_period_type += u
	} else {
		m.addclass_period_type = &u
	}
}

// AddedClassPeriodType returns the value that was added to the "class_period_type" field in this mutation.
func (m *KcClassMutation) AddedClassPeriodType() (r uint8, exists bool) {
	v := m.addclass_period_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetClassPeriodType resets all changes to the "class_period_type" field.
func (m *KcClassMutation) ResetClassPeriodType() {
	m.class_period_type = nil
	m.addclass_period_type = nil
}

// SetClassStartDate sets the "class_start_date" field.
func (m *KcClassMutation) SetClassStartDate(t time.Time) {
	m.class_start_date = &t
}

// ClassStartDate returns the value of the "class_start_date" field in the mutation.
func (m *KcClassMutation) ClassStartDate() (r time.Time, exists bool) {
	v := m.class_start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldClassStartDate returns the old "class_start_date" field's value of the KcClass entity.
// If the KcClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcClassMutation) OldClassStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldClassStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldClassStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClassStartDate: %w", err)
	}
	return oldValue.ClassStartDate, nil
}

// ClearClassStartDate clears the value of the "class_start_date" field.
func (m *KcClassMutation) ClearClassStartDate() {
	m.class_start_date = nil
	m.clearedFields[kcclass.FieldClassStartDate] = struct{}{}
}

// ClassStartDateCleared returns if the "class_start_date" field was cleared in this mutation.
func (m *KcClassMutation) ClassStartDateCleared() bool {
	_, ok := m.clearedFields[kcclass.FieldClassStartDate]
	return ok
}

// ResetClassStartDate resets all changes to the "class_start_date" field.
func (m *KcClassMutation) ResetClassStartDate() {
	m.class_start_date = nil
	delete(m.clearedFields, kcclass.FieldClassStartDate)
}

// SetClassEndDate sets the "class_end_date" field.
func (m *KcClassMutation) SetClassEndDate(t time.Time) {
	m.class_end_date = &t
}

// ClassEndDate returns the value of the "class_end_date" field in the mutation.
func (m *KcClassMutation) ClassEndDate() (r time.Time, exists bool) {
	v := m.class_end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldClassEndDate returns the old "class_end_date" field's value of the KcClass entity.
// If the KcClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcClassMutation) OldClassEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldClassEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldClassEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClassEndDate: %w", err)
	}
	return oldValue.ClassEndDate, nil
}

// ClearClassEndDate clears the value of the "class_end_date" field.
func (m *KcClassMutation) ClearClassEndDate() {
	m.class_end_date = nil
	m.clearedFields[kcclass.FieldClassEndDate] = struct{}{}
}

// ClassEndDateCleared returns if the "class_end_date" field was cleared in this mutation.
func (m *KcClassMutation) ClassEndDateCleared() bool {
	_, ok := m.clearedFields[kcclass.FieldClassEndDate]
	return ok
}

// ResetClassEndDate resets all changes to the "class_end_date" field.
func (m *KcClassMutation) ResetClassEndDate() {
	m.class_end_date = nil
	delete(m.clearedFields, kcclass.FieldClassEndDate)
}

// SetClosingDate sets the "closing_date" field.
func (m *KcClassMutation) SetClosingDate(t time.Time) {
	m.closing_date = &t
}

// ClosingDate returns the value of the "closing_date" field in the mutation.
func (m *KcClassMutation) ClosingDate() (r time.Time, exists bool) {
	v := m.closing_date
	if v == nil {
		return
	}
	return *v, true
}

// OldClosingDate returns the old "closing_date" field's value of the KcClass entity.
// If the KcClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcClassMutation) OldClosingDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldClosingDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldClosingDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClosingDate: %w", err)
	}
	return oldValue.ClosingDate, nil
}

// ClearClosingDate clears the value of the "closing_date" field.
func (m *KcClassMutation) ClearClosingDate() {
	m.closing_date = nil
	m.clearedFields[kcclass.FieldClosingDate] = struct{}{}
}

// ClosingDateCleared returns if the "closing_date" field was cleared in this mutation.
func (m *KcClassMutation) ClosingDateCleared() bool {
	_, ok := m.clearedFields[kcclass.FieldClosingDate]
	return ok
}

// ResetClosingDate resets all changes to the "closing_date" field.
func (m *KcClassMutation) ResetClosingDate() {
	m.closing_date = nil
	delete(m.clearedFields, kcclass.FieldClosingDate)
}

// SetDaysValidity sets the "days_validity" field.
func (m *KcClassMutation) SetDaysValidity(i int) {
	m.days_validity = &i
	m.adddays_validity = nil
}

// DaysValidity returns the value of the "days_validity" field in the mutation.
func (m *KcClassMutation) DaysValidity() (r int, exists bool) {
	v := m.days_validity
	if v == nil {
		return
	}
	return *v, true
}

// OldDaysValidity returns the old "days_validity" field's value of the KcClass entity.
// If the KcClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcClassMutation) OldDaysValidity(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDaysValidity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDaysValidity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDaysValidity: %w", err)
	}
	return oldValue.DaysValidity, nil
}

// AddDaysValidity adds i to the "days_validity" field.
func (m *KcClassMutation) AddDaysValidity(i int) {
	if m.adddays_validity != nil {
		*m.adddays_validity += i
	} else {
		m.adddays_validity = &i
	}
}

// AddedDaysValidity returns the value that was added to the "days_validity" field in this mutation.
func (m *KcClassMutation) AddedDaysValidity() (r int, exists bool) {
	v := m.adddays_validity
	if v == nil {
		return
	}
	return *v, true
}

// ResetDaysValidity resets all changes to the "days_validity" field.
func (m *KcClassMutation) ResetDaysValidity() {
	m.days_validity = nil
	m.adddays_validity = nil
}

// SetClassHeadMasterID sets the "class_head_master_id" field.
func (m *KcClassMutation) SetClassHeadMasterID(i int) {
	m.master_teachers = &i
}

// ClassHeadMasterID returns the value of the "class_head_master_id" field in the mutation.
func (m *KcClassMutation) ClassHeadMasterID() (r int, exists bool) {
	v := m.master_teachers
	if v == nil {
		return
	}
	return *v, true
}

// OldClassHeadMasterID returns the old "class_head_master_id" field's value of the KcClass entity.
// If the KcClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcClassMutation) OldClassHeadMasterID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldClassHeadMasterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldClassHeadMasterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClassHeadMasterID: %w", err)
	}
	return oldValue.ClassHeadMasterID, nil
}

// ClearClassHeadMasterID clears the value of the "class_head_master_id" field.
func (m *KcClassMutation) ClearClassHeadMasterID() {
	m.master_teachers = nil
	m.clearedFields[kcclass.FieldClassHeadMasterID] = struct{}{}
}

// ClassHeadMasterIDCleared returns if the "class_head_master_id" field was cleared in this mutation.
func (m *KcClassMutation) ClassHeadMasterIDCleared() bool {
	_, ok := m.clearedFields[kcclass.FieldClassHeadMasterID]
	return ok
}

// ResetClassHeadMasterID resets all changes to the "class_head_master_id" field.
func (m *KcClassMutation) ResetClassHeadMasterID() {
	m.master_teachers = nil
	delete(m.clearedFields, kcclass.FieldClassHeadMasterID)
}

// SetClassCoverImgID sets the "class_cover_img_id" field.
func (m *KcClassMutation) SetClassCoverImgID(i int) {
	m.attachment = &i
}

// ClassCoverImgID returns the value of the "class_cover_img_id" field in the mutation.
func (m *KcClassMutation) ClassCoverImgID() (r int, exists bool) {
	v := m.attachment
	if v == nil {
		return
	}
	return *v, true
}

// OldClassCoverImgID returns the old "class_cover_img_id" field's value of the KcClass entity.
// If the KcClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcClassMutation) OldClassCoverImgID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldClassCoverImgID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldClassCoverImgID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClassCoverImgID: %w", err)
	}
	return oldValue.ClassCoverImgID, nil
}

// ClearClassCoverImgID clears the value of the "class_cover_img_id" field.
func (m *KcClassMutation) ClearClassCoverImgID() {
	m.attachment = nil
	m.clearedFields[kcclass.FieldClassCoverImgID] = struct{}{}
}

// ClassCoverImgIDCleared returns if the "class_cover_img_id" field was cleared in this mutation.
func (m *KcClassMutation) ClassCoverImgIDCleared() bool {
	_, ok := m.clearedFields[kcclass.FieldClassCoverImgID]
	return ok
}

// ResetClassCoverImgID resets all changes to the "class_cover_img_id" field.
func (m *KcClassMutation) ResetClassCoverImgID() {
	m.attachment = nil
	delete(m.clearedFields, kcclass.FieldClassCoverImgID)
}

// SetStatus sets the "status" field.
func (m *KcClassMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *KcClassMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the KcClass entity.
// If the KcClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcClassMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *KcClassMutation) AddStatus(u uint8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *KcClassMutation) AddedStatus() (r uint8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *KcClassMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetPrice sets the "price" field.
func (m *KcClassMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *KcClassMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the KcClass entity.
// If the KcClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcClassMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *KcClassMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *KcClassMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *KcClassMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetStudentCount sets the "student_count" field.
func (m *KcClassMutation) SetStudentCount(i int) {
	m.student_count = &i
	m.addstudent_count = nil
}

// StudentCount returns the value of the "student_count" field in the mutation.
func (m *KcClassMutation) StudentCount() (r int, exists bool) {
	v := m.student_count
	if v == nil {
		return
	}
	return *v, true
}

// OldStudentCount returns the old "student_count" field's value of the KcClass entity.
// If the KcClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcClassMutation) OldStudentCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStudentCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStudentCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStudentCount: %w", err)
	}
	return oldValue.StudentCount, nil
}

// AddStudentCount adds i to the "student_count" field.
func (m *KcClassMutation) AddStudentCount(i int) {
	if m.addstudent_count != nil {
		*m.addstudent_count += i
	} else {
		m.addstudent_count = &i
	}
}

// AddedStudentCount returns the value that was added to the "student_count" field in this mutation.
func (m *KcClassMutation) AddedStudentCount() (r int, exists bool) {
	v := m.addstudent_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetStudentCount resets all changes to the "student_count" field.
func (m *KcClassMutation) ResetStudentCount() {
	m.student_count = nil
	m.addstudent_count = nil
}

// SetCourseCount sets the "course_count" field.
func (m *KcClassMutation) SetCourseCount(i int) {
	m.course_count = &i
	m.addcourse_count = nil
}

// CourseCount returns the value of the "course_count" field in the mutation.
func (m *KcClassMutation) CourseCount() (r int, exists bool) {
	v := m.course_count
	if v == nil {
		return
	}
	return *v, true
}

// OldCourseCount returns the old "course_count" field's value of the KcClass entity.
// If the KcClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcClassMutation) OldCourseCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCourseCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCourseCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCourseCount: %w", err)
	}
	return oldValue.CourseCount, nil
}

// AddCourseCount adds i to the "course_count" field.
func (m *KcClassMutation) AddCourseCount(i int) {
	if m.addcourse_count != nil {
		*m.addcourse_count += i
	} else {
		m.addcourse_count = &i
	}
}

// AddedCourseCount returns the value that was added to the "course_count" field in this mutation.
func (m *KcClassMutation) AddedCourseCount() (r int, exists bool) {
	v := m.addcourse_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetCourseCount resets all changes to the "course_count" field.
func (m *KcClassMutation) ResetCourseCount() {
	m.course_count = nil
	m.addcourse_count = nil
}

// SetCateID sets the "cate_id" field.
func (m *KcClassMutation) SetCateID(i int) {
	m.item = &i
}

// CateID returns the value of the "cate_id" field in the mutation.
func (m *KcClassMutation) CateID() (r int, exists bool) {
	v := m.item
	if v == nil {
		return
	}
	return *v, true
}

// OldCateID returns the old "cate_id" field's value of the KcClass entity.
// If the KcClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcClassMutation) OldCateID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCateID: %w", err)
	}
	return oldValue.CateID, nil
}

// ClearCateID clears the value of the "cate_id" field.
func (m *KcClassMutation) ClearCateID() {
	m.item = nil
	m.clearedFields[kcclass.FieldCateID] = struct{}{}
}

// CateIDCleared returns if the "cate_id" field was cleared in this mutation.
func (m *KcClassMutation) CateIDCleared() bool {
	_, ok := m.clearedFields[kcclass.FieldCateID]
	return ok
}

// ResetCateID resets all changes to the "cate_id" field.
func (m *KcClassMutation) ResetCateID() {
	m.item = nil
	delete(m.clearedFields, kcclass.FieldCateID)
}

// SetCityID sets the "city_id" field.
func (m *KcClassMutation) SetCityID(i int) {
	m.city = &i
}

// CityID returns the value of the "city_id" field in the mutation.
func (m *KcClassMutation) CityID() (r int, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCityID returns the old "city_id" field's value of the KcClass entity.
// If the KcClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcClassMutation) OldCityID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCityID: %w", err)
	}
	return oldValue.CityID, nil
}

// ClearCityID clears the value of the "city_id" field.
func (m *KcClassMutation) ClearCityID() {
	m.city = nil
	m.clearedFields[kcclass.FieldCityID] = struct{}{}
}

// CityIDCleared returns if the "city_id" field was cleared in this mutation.
func (m *KcClassMutation) CityIDCleared() bool {
	_, ok := m.clearedFields[kcclass.FieldCityID]
	return ok
}

// ResetCityID resets all changes to the "city_id" field.
func (m *KcClassMutation) ResetCityID() {
	m.city = nil
	delete(m.clearedFields, kcclass.FieldCityID)
}

// SetCreatedAdminID sets the "created_admin_id" field.
func (m *KcClassMutation) SetCreatedAdminID(i int) {
	m.admin = &i
}

// CreatedAdminID returns the value of the "created_admin_id" field in the mutation.
func (m *KcClassMutation) CreatedAdminID() (r int, exists bool) {
	v := m.admin
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAdminID returns the old "created_admin_id" field's value of the KcClass entity.
// If the KcClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcClassMutation) OldCreatedAdminID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAdminID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAdminID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAdminID: %w", err)
	}
	return oldValue.CreatedAdminID, nil
}

// ClearCreatedAdminID clears the value of the "created_admin_id" field.
func (m *KcClassMutation) ClearCreatedAdminID() {
	m.admin = nil
	m.clearedFields[kcclass.FieldCreatedAdminID] = struct{}{}
}

// CreatedAdminIDCleared returns if the "created_admin_id" field was cleared in this mutation.
func (m *KcClassMutation) CreatedAdminIDCleared() bool {
	_, ok := m.clearedFields[kcclass.FieldCreatedAdminID]
	return ok
}

// ResetCreatedAdminID resets all changes to the "created_admin_id" field.
func (m *KcClassMutation) ResetCreatedAdminID() {
	m.admin = nil
	delete(m.clearedFields, kcclass.FieldCreatedAdminID)
}

// AddMajorIDs adds the "majors" edge to the Major entity by ids.
func (m *KcClassMutation) AddMajorIDs(ids ...int) {
	if m.majors == nil {
		m.majors = make(map[int]struct{})
	}
	for i := range ids {
		m.majors[ids[i]] = struct{}{}
	}
}

// ClearMajors clears the "majors" edge to the Major entity.
func (m *KcClassMutation) ClearMajors() {
	m.clearedmajors = true
}

// MajorsCleared reports if the "majors" edge to the Major entity was cleared.
func (m *KcClassMutation) MajorsCleared() bool {
	return m.clearedmajors
}

// RemoveMajorIDs removes the "majors" edge to the Major entity by IDs.
func (m *KcClassMutation) RemoveMajorIDs(ids ...int) {
	if m.removedmajors == nil {
		m.removedmajors = make(map[int]struct{})
	}
	for i := range ids {
		m.removedmajors[ids[i]] = struct{}{}
	}
}

// RemovedMajors returns the removed IDs of the "majors" edge to the Major entity.
func (m *KcClassMutation) RemovedMajorsIDs() (ids []int) {
	for id := range m.removedmajors {
		ids = append(ids, id)
	}
	return
}

// MajorsIDs returns the "majors" edge IDs in the mutation.
func (m *KcClassMutation) MajorsIDs() (ids []int) {
	for id := range m.majors {
		ids = append(ids, id)
	}
	return
}

// ResetMajors resets all changes to the "majors" edge.
func (m *KcClassMutation) ResetMajors() {
	m.majors = nil
	m.clearedmajors = false
	m.removedmajors = nil
}

// SetItemID sets the "item" edge to the ItemCategory entity by id.
func (m *KcClassMutation) SetItemID(id int) {
	m.item = &id
}

// ClearItem clears the "item" edge to the ItemCategory entity.
func (m *KcClassMutation) ClearItem() {
	m.cleareditem = true
}

// ItemCleared reports if the "item" edge to the ItemCategory entity was cleared.
func (m *KcClassMutation) ItemCleared() bool {
	return m.CateIDCleared() || m.cleareditem
}

// ItemID returns the "item" edge ID in the mutation.
func (m *KcClassMutation) ItemID() (id int, exists bool) {
	if m.item != nil {
		return *m.item, true
	}
	return
}

// ItemIDs returns the "item" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ItemID instead. It exists only for internal usage by the builders.
func (m *KcClassMutation) ItemIDs() (ids []int) {
	if id := m.item; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetItem resets all changes to the "item" edge.
func (m *KcClassMutation) ResetItem() {
	m.item = nil
	m.cleareditem = false
}

// ClearCity clears the "city" edge to the City entity.
func (m *KcClassMutation) ClearCity() {
	m.clearedcity = true
}

// CityCleared reports if the "city" edge to the City entity was cleared.
func (m *KcClassMutation) CityCleared() bool {
	return m.CityIDCleared() || m.clearedcity
}

// CityIDs returns the "city" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CityID instead. It exists only for internal usage by the builders.
func (m *KcClassMutation) CityIDs() (ids []int) {
	if id := m.city; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCity resets all changes to the "city" edge.
func (m *KcClassMutation) ResetCity() {
	m.city = nil
	m.clearedcity = false
}

// SetAdminID sets the "admin" edge to the Admin entity by id.
func (m *KcClassMutation) SetAdminID(id int) {
	m.admin = &id
}

// ClearAdmin clears the "admin" edge to the Admin entity.
func (m *KcClassMutation) ClearAdmin() {
	m.clearedadmin = true
}

// AdminCleared reports if the "admin" edge to the Admin entity was cleared.
func (m *KcClassMutation) AdminCleared() bool {
	return m.CreatedAdminIDCleared() || m.clearedadmin
}

// AdminID returns the "admin" edge ID in the mutation.
func (m *KcClassMutation) AdminID() (id int, exists bool) {
	if m.admin != nil {
		return *m.admin, true
	}
	return
}

// AdminIDs returns the "admin" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AdminID instead. It exists only for internal usage by the builders.
func (m *KcClassMutation) AdminIDs() (ids []int) {
	if id := m.admin; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAdmin resets all changes to the "admin" edge.
func (m *KcClassMutation) ResetAdmin() {
	m.admin = nil
	m.clearedadmin = false
}

// SetAttachmentID sets the "attachment" edge to the Attachment entity by id.
func (m *KcClassMutation) SetAttachmentID(id int) {
	m.attachment = &id
}

// ClearAttachment clears the "attachment" edge to the Attachment entity.
func (m *KcClassMutation) ClearAttachment() {
	m.clearedattachment = true
}

// AttachmentCleared reports if the "attachment" edge to the Attachment entity was cleared.
func (m *KcClassMutation) AttachmentCleared() bool {
	return m.ClassCoverImgIDCleared() || m.clearedattachment
}

// AttachmentID returns the "attachment" edge ID in the mutation.
func (m *KcClassMutation) AttachmentID() (id int, exists bool) {
	if m.attachment != nil {
		return *m.attachment, true
	}
	return
}

// AttachmentIDs returns the "attachment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AttachmentID instead. It exists only for internal usage by the builders.
func (m *KcClassMutation) AttachmentIDs() (ids []int) {
	if id := m.attachment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAttachment resets all changes to the "attachment" edge.
func (m *KcClassMutation) ResetAttachment() {
	m.attachment = nil
	m.clearedattachment = false
}

// SetMasterTeachersID sets the "master_teachers" edge to the Teacher entity by id.
func (m *KcClassMutation) SetMasterTeachersID(id int) {
	m.master_teachers = &id
}

// ClearMasterTeachers clears the "master_teachers" edge to the Teacher entity.
func (m *KcClassMutation) ClearMasterTeachers() {
	m.clearedmaster_teachers = true
}

// MasterTeachersCleared reports if the "master_teachers" edge to the Teacher entity was cleared.
func (m *KcClassMutation) MasterTeachersCleared() bool {
	return m.ClassHeadMasterIDCleared() || m.clearedmaster_teachers
}

// MasterTeachersID returns the "master_teachers" edge ID in the mutation.
func (m *KcClassMutation) MasterTeachersID() (id int, exists bool) {
	if m.master_teachers != nil {
		return *m.master_teachers, true
	}
	return
}

// MasterTeachersIDs returns the "master_teachers" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MasterTeachersID instead. It exists only for internal usage by the builders.
func (m *KcClassMutation) MasterTeachersIDs() (ids []int) {
	if id := m.master_teachers; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMasterTeachers resets all changes to the "master_teachers" edge.
func (m *KcClassMutation) ResetMasterTeachers() {
	m.master_teachers = nil
	m.clearedmaster_teachers = false
}

// AddClassTeacherIDs adds the "class_teachers" edge to the KcClassTeacher entity by ids.
func (m *KcClassMutation) AddClassTeacherIDs(ids ...int) {
	if m.class_teachers == nil {
		m.class_teachers = make(map[int]struct{})
	}
	for i := range ids {
		m.class_teachers[ids[i]] = struct{}{}
	}
}

// ClearClassTeachers clears the "class_teachers" edge to the KcClassTeacher entity.
func (m *KcClassMutation) ClearClassTeachers() {
	m.clearedclass_teachers = true
}

// ClassTeachersCleared reports if the "class_teachers" edge to the KcClassTeacher entity was cleared.
func (m *KcClassMutation) ClassTeachersCleared() bool {
	return m.clearedclass_teachers
}

// RemoveClassTeacherIDs removes the "class_teachers" edge to the KcClassTeacher entity by IDs.
func (m *KcClassMutation) RemoveClassTeacherIDs(ids ...int) {
	if m.removedclass_teachers == nil {
		m.removedclass_teachers = make(map[int]struct{})
	}
	for i := range ids {
		m.removedclass_teachers[ids[i]] = struct{}{}
	}
}

// RemovedClassTeachers returns the removed IDs of the "class_teachers" edge to the KcClassTeacher entity.
func (m *KcClassMutation) RemovedClassTeachersIDs() (ids []int) {
	for id := range m.removedclass_teachers {
		ids = append(ids, id)
	}
	return
}

// ClassTeachersIDs returns the "class_teachers" edge IDs in the mutation.
func (m *KcClassMutation) ClassTeachersIDs() (ids []int) {
	for id := range m.class_teachers {
		ids = append(ids, id)
	}
	return
}

// ResetClassTeachers resets all changes to the "class_teachers" edge.
func (m *KcClassMutation) ResetClassTeachers() {
	m.class_teachers = nil
	m.clearedclass_teachers = false
	m.removedclass_teachers = nil
}

// AddKcClassCourseIDs adds the "kc_class_courses" edge to the KcCourse entity by ids.
func (m *KcClassMutation) AddKcClassCourseIDs(ids ...int) {
	if m.kc_class_courses == nil {
		m.kc_class_courses = make(map[int]struct{})
	}
	for i := range ids {
		m.kc_class_courses[ids[i]] = struct{}{}
	}
}

// ClearKcClassCourses clears the "kc_class_courses" edge to the KcCourse entity.
func (m *KcClassMutation) ClearKcClassCourses() {
	m.clearedkc_class_courses = true
}

// KcClassCoursesCleared reports if the "kc_class_courses" edge to the KcCourse entity was cleared.
func (m *KcClassMutation) KcClassCoursesCleared() bool {
	return m.clearedkc_class_courses
}

// RemoveKcClassCourseIDs removes the "kc_class_courses" edge to the KcCourse entity by IDs.
func (m *KcClassMutation) RemoveKcClassCourseIDs(ids ...int) {
	if m.removedkc_class_courses == nil {
		m.removedkc_class_courses = make(map[int]struct{})
	}
	for i := range ids {
		m.removedkc_class_courses[ids[i]] = struct{}{}
	}
}

// RemovedKcClassCourses returns the removed IDs of the "kc_class_courses" edge to the KcCourse entity.
func (m *KcClassMutation) RemovedKcClassCoursesIDs() (ids []int) {
	for id := range m.removedkc_class_courses {
		ids = append(ids, id)
	}
	return
}

// KcClassCoursesIDs returns the "kc_class_courses" edge IDs in the mutation.
func (m *KcClassMutation) KcClassCoursesIDs() (ids []int) {
	for id := range m.kc_class_courses {
		ids = append(ids, id)
	}
	return
}

// ResetKcClassCourses resets all changes to the "kc_class_courses" edge.
func (m *KcClassMutation) ResetKcClassCourses() {
	m.kc_class_courses = nil
	m.clearedkc_class_courses = false
	m.removedkc_class_courses = nil
}

// AddKcUserClassIDs adds the "kc_user_classes" edge to the KcUserClass entity by ids.
func (m *KcClassMutation) AddKcUserClassIDs(ids ...int) {
	if m.kc_user_classes == nil {
		m.kc_user_classes = make(map[int]struct{})
	}
	for i := range ids {
		m.kc_user_classes[ids[i]] = struct{}{}
	}
}

// ClearKcUserClasses clears the "kc_user_classes" edge to the KcUserClass entity.
func (m *KcClassMutation) ClearKcUserClasses() {
	m.clearedkc_user_classes = true
}

// KcUserClassesCleared reports if the "kc_user_classes" edge to the KcUserClass entity was cleared.
func (m *KcClassMutation) KcUserClassesCleared() bool {
	return m.clearedkc_user_classes
}

// RemoveKcUserClassIDs removes the "kc_user_classes" edge to the KcUserClass entity by IDs.
func (m *KcClassMutation) RemoveKcUserClassIDs(ids ...int) {
	if m.removedkc_user_classes == nil {
		m.removedkc_user_classes = make(map[int]struct{})
	}
	for i := range ids {
		m.removedkc_user_classes[ids[i]] = struct{}{}
	}
}

// RemovedKcUserClasses returns the removed IDs of the "kc_user_classes" edge to the KcUserClass entity.
func (m *KcClassMutation) RemovedKcUserClassesIDs() (ids []int) {
	for id := range m.removedkc_user_classes {
		ids = append(ids, id)
	}
	return
}

// KcUserClassesIDs returns the "kc_user_classes" edge IDs in the mutation.
func (m *KcClassMutation) KcUserClassesIDs() (ids []int) {
	for id := range m.kc_user_classes {
		ids = append(ids, id)
	}
	return
}

// ResetKcUserClasses resets all changes to the "kc_user_classes" edge.
func (m *KcClassMutation) ResetKcUserClasses() {
	m.kc_user_classes = nil
	m.clearedkc_user_classes = false
	m.removedkc_user_classes = nil
}

// AddMessageClassIDs adds the "message_classes" edge to the Message entity by ids.
func (m *KcClassMutation) AddMessageClassIDs(ids ...int) {
	if m.message_classes == nil {
		m.message_classes = make(map[int]struct{})
	}
	for i := range ids {
		m.message_classes[ids[i]] = struct{}{}
	}
}

// ClearMessageClasses clears the "message_classes" edge to the Message entity.
func (m *KcClassMutation) ClearMessageClasses() {
	m.clearedmessage_classes = true
}

// MessageClassesCleared reports if the "message_classes" edge to the Message entity was cleared.
func (m *KcClassMutation) MessageClassesCleared() bool {
	return m.clearedmessage_classes
}

// RemoveMessageClassIDs removes the "message_classes" edge to the Message entity by IDs.
func (m *KcClassMutation) RemoveMessageClassIDs(ids ...int) {
	if m.removedmessage_classes == nil {
		m.removedmessage_classes = make(map[int]struct{})
	}
	for i := range ids {
		m.removedmessage_classes[ids[i]] = struct{}{}
	}
}

// RemovedMessageClasses returns the removed IDs of the "message_classes" edge to the Message entity.
func (m *KcClassMutation) RemovedMessageClassesIDs() (ids []int) {
	for id := range m.removedmessage_classes {
		ids = append(ids, id)
	}
	return
}

// MessageClassesIDs returns the "message_classes" edge IDs in the mutation.
func (m *KcClassMutation) MessageClassesIDs() (ids []int) {
	for id := range m.message_classes {
		ids = append(ids, id)
	}
	return
}

// ResetMessageClasses resets all changes to the "message_classes" edge.
func (m *KcClassMutation) ResetMessageClasses() {
	m.message_classes = nil
	m.clearedmessage_classes = false
	m.removedmessage_classes = nil
}

// Op returns the operation name.
func (m *KcClassMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (KcClass).
func (m *KcClassMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *KcClassMutation) Fields() []string {
	fields := make([]string, 0, 23)
	if m.uuid != nil {
		fields = append(fields, kcclass.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, kcclass.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, kcclass.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, kcclass.FieldDeletedAt)
	}
	if m.class_title != nil {
		fields = append(fields, kcclass.FieldClassTitle)
	}
	if m.class_code != nil {
		fields = append(fields, kcclass.FieldClassCode)
	}
	if m.class_desc != nil {
		fields = append(fields, kcclass.FieldClassDesc)
	}
	if m.is_display != nil {
		fields = append(fields, kcclass.FieldIsDisplay)
	}
	if m.is_buy != nil {
		fields = append(fields, kcclass.FieldIsBuy)
	}
	if m.class_period_type != nil {
		fields = append(fields, kcclass.FieldClassPeriodType)
	}
	if m.class_start_date != nil {
		fields = append(fields, kcclass.FieldClassStartDate)
	}
	if m.class_end_date != nil {
		fields = append(fields, kcclass.FieldClassEndDate)
	}
	if m.closing_date != nil {
		fields = append(fields, kcclass.FieldClosingDate)
	}
	if m.days_validity != nil {
		fields = append(fields, kcclass.FieldDaysValidity)
	}
	if m.master_teachers != nil {
		fields = append(fields, kcclass.FieldClassHeadMasterID)
	}
	if m.attachment != nil {
		fields = append(fields, kcclass.FieldClassCoverImgID)
	}
	if m.status != nil {
		fields = append(fields, kcclass.FieldStatus)
	}
	if m.price != nil {
		fields = append(fields, kcclass.FieldPrice)
	}
	if m.student_count != nil {
		fields = append(fields, kcclass.FieldStudentCount)
	}
	if m.course_count != nil {
		fields = append(fields, kcclass.FieldCourseCount)
	}
	if m.item != nil {
		fields = append(fields, kcclass.FieldCateID)
	}
	if m.city != nil {
		fields = append(fields, kcclass.FieldCityID)
	}
	if m.admin != nil {
		fields = append(fields, kcclass.FieldCreatedAdminID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *KcClassMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case kcclass.FieldUUID:
		return m.UUID()
	case kcclass.FieldCreatedAt:
		return m.CreatedAt()
	case kcclass.FieldUpdatedAt:
		return m.UpdatedAt()
	case kcclass.FieldDeletedAt:
		return m.DeletedAt()
	case kcclass.FieldClassTitle:
		return m.ClassTitle()
	case kcclass.FieldClassCode:
		return m.ClassCode()
	case kcclass.FieldClassDesc:
		return m.ClassDesc()
	case kcclass.FieldIsDisplay:
		return m.IsDisplay()
	case kcclass.FieldIsBuy:
		return m.IsBuy()
	case kcclass.FieldClassPeriodType:
		return m.ClassPeriodType()
	case kcclass.FieldClassStartDate:
		return m.ClassStartDate()
	case kcclass.FieldClassEndDate:
		return m.ClassEndDate()
	case kcclass.FieldClosingDate:
		return m.ClosingDate()
	case kcclass.FieldDaysValidity:
		return m.DaysValidity()
	case kcclass.FieldClassHeadMasterID:
		return m.ClassHeadMasterID()
	case kcclass.FieldClassCoverImgID:
		return m.ClassCoverImgID()
	case kcclass.FieldStatus:
		return m.Status()
	case kcclass.FieldPrice:
		return m.Price()
	case kcclass.FieldStudentCount:
		return m.StudentCount()
	case kcclass.FieldCourseCount:
		return m.CourseCount()
	case kcclass.FieldCateID:
		return m.CateID()
	case kcclass.FieldCityID:
		return m.CityID()
	case kcclass.FieldCreatedAdminID:
		return m.CreatedAdminID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *KcClassMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case kcclass.FieldUUID:
		return m.OldUUID(ctx)
	case kcclass.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case kcclass.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case kcclass.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case kcclass.FieldClassTitle:
		return m.OldClassTitle(ctx)
	case kcclass.FieldClassCode:
		return m.OldClassCode(ctx)
	case kcclass.FieldClassDesc:
		return m.OldClassDesc(ctx)
	case kcclass.FieldIsDisplay:
		return m.OldIsDisplay(ctx)
	case kcclass.FieldIsBuy:
		return m.OldIsBuy(ctx)
	case kcclass.FieldClassPeriodType:
		return m.OldClassPeriodType(ctx)
	case kcclass.FieldClassStartDate:
		return m.OldClassStartDate(ctx)
	case kcclass.FieldClassEndDate:
		return m.OldClassEndDate(ctx)
	case kcclass.FieldClosingDate:
		return m.OldClosingDate(ctx)
	case kcclass.FieldDaysValidity:
		return m.OldDaysValidity(ctx)
	case kcclass.FieldClassHeadMasterID:
		return m.OldClassHeadMasterID(ctx)
	case kcclass.FieldClassCoverImgID:
		return m.OldClassCoverImgID(ctx)
	case kcclass.FieldStatus:
		return m.OldStatus(ctx)
	case kcclass.FieldPrice:
		return m.OldPrice(ctx)
	case kcclass.FieldStudentCount:
		return m.OldStudentCount(ctx)
	case kcclass.FieldCourseCount:
		return m.OldCourseCount(ctx)
	case kcclass.FieldCateID:
		return m.OldCateID(ctx)
	case kcclass.FieldCityID:
		return m.OldCityID(ctx)
	case kcclass.FieldCreatedAdminID:
		return m.OldCreatedAdminID(ctx)
	}
	return nil, fmt.Errorf("unknown KcClass field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KcClassMutation) SetField(name string, value ent.Value) error {
	switch name {
	case kcclass.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case kcclass.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case kcclass.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case kcclass.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case kcclass.FieldClassTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClassTitle(v)
		return nil
	case kcclass.FieldClassCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClassCode(v)
		return nil
	case kcclass.FieldClassDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClassDesc(v)
		return nil
	case kcclass.FieldIsDisplay:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDisplay(v)
		return nil
	case kcclass.FieldIsBuy:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsBuy(v)
		return nil
	case kcclass.FieldClassPeriodType:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClassPeriodType(v)
		return nil
	case kcclass.FieldClassStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClassStartDate(v)
		return nil
	case kcclass.FieldClassEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClassEndDate(v)
		return nil
	case kcclass.FieldClosingDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClosingDate(v)
		return nil
	case kcclass.FieldDaysValidity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDaysValidity(v)
		return nil
	case kcclass.FieldClassHeadMasterID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClassHeadMasterID(v)
		return nil
	case kcclass.FieldClassCoverImgID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClassCoverImgID(v)
		return nil
	case kcclass.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case kcclass.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case kcclass.FieldStudentCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStudentCount(v)
		return nil
	case kcclass.FieldCourseCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCourseCount(v)
		return nil
	case kcclass.FieldCateID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCateID(v)
		return nil
	case kcclass.FieldCityID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCityID(v)
		return nil
	case kcclass.FieldCreatedAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAdminID(v)
		return nil
	}
	return fmt.Errorf("unknown KcClass field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *KcClassMutation) AddedFields() []string {
	var fields []string
	if m.addis_display != nil {
		fields = append(fields, kcclass.FieldIsDisplay)
	}
	if m.addis_buy != nil {
		fields = append(fields, kcclass.FieldIsBuy)
	}
	if m.addclass_period_type != nil {
		fields = append(fields, kcclass.FieldClassPeriodType)
	}
	if m.adddays_validity != nil {
		fields = append(fields, kcclass.FieldDaysValidity)
	}
	if m.addstatus != nil {
		fields = append(fields, kcclass.FieldStatus)
	}
	if m.addprice != nil {
		fields = append(fields, kcclass.FieldPrice)
	}
	if m.addstudent_count != nil {
		fields = append(fields, kcclass.FieldStudentCount)
	}
	if m.addcourse_count != nil {
		fields = append(fields, kcclass.FieldCourseCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *KcClassMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case kcclass.FieldIsDisplay:
		return m.AddedIsDisplay()
	case kcclass.FieldIsBuy:
		return m.AddedIsBuy()
	case kcclass.FieldClassPeriodType:
		return m.AddedClassPeriodType()
	case kcclass.FieldDaysValidity:
		return m.AddedDaysValidity()
	case kcclass.FieldStatus:
		return m.AddedStatus()
	case kcclass.FieldPrice:
		return m.AddedPrice()
	case kcclass.FieldStudentCount:
		return m.AddedStudentCount()
	case kcclass.FieldCourseCount:
		return m.AddedCourseCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KcClassMutation) AddField(name string, value ent.Value) error {
	switch name {
	case kcclass.FieldIsDisplay:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDisplay(v)
		return nil
	case kcclass.FieldIsBuy:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsBuy(v)
		return nil
	case kcclass.FieldClassPeriodType:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddClassPeriodType(v)
		return nil
	case kcclass.FieldDaysValidity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDaysValidity(v)
		return nil
	case kcclass.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case kcclass.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case kcclass.FieldStudentCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStudentCount(v)
		return nil
	case kcclass.FieldCourseCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCourseCount(v)
		return nil
	}
	return fmt.Errorf("unknown KcClass numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *KcClassMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(kcclass.FieldCreatedAt) {
		fields = append(fields, kcclass.FieldCreatedAt)
	}
	if m.FieldCleared(kcclass.FieldUpdatedAt) {
		fields = append(fields, kcclass.FieldUpdatedAt)
	}
	if m.FieldCleared(kcclass.FieldDeletedAt) {
		fields = append(fields, kcclass.FieldDeletedAt)
	}
	if m.FieldCleared(kcclass.FieldClassStartDate) {
		fields = append(fields, kcclass.FieldClassStartDate)
	}
	if m.FieldCleared(kcclass.FieldClassEndDate) {
		fields = append(fields, kcclass.FieldClassEndDate)
	}
	if m.FieldCleared(kcclass.FieldClosingDate) {
		fields = append(fields, kcclass.FieldClosingDate)
	}
	if m.FieldCleared(kcclass.FieldClassHeadMasterID) {
		fields = append(fields, kcclass.FieldClassHeadMasterID)
	}
	if m.FieldCleared(kcclass.FieldClassCoverImgID) {
		fields = append(fields, kcclass.FieldClassCoverImgID)
	}
	if m.FieldCleared(kcclass.FieldCateID) {
		fields = append(fields, kcclass.FieldCateID)
	}
	if m.FieldCleared(kcclass.FieldCityID) {
		fields = append(fields, kcclass.FieldCityID)
	}
	if m.FieldCleared(kcclass.FieldCreatedAdminID) {
		fields = append(fields, kcclass.FieldCreatedAdminID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *KcClassMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *KcClassMutation) ClearField(name string) error {
	switch name {
	case kcclass.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case kcclass.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case kcclass.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case kcclass.FieldClassStartDate:
		m.ClearClassStartDate()
		return nil
	case kcclass.FieldClassEndDate:
		m.ClearClassEndDate()
		return nil
	case kcclass.FieldClosingDate:
		m.ClearClosingDate()
		return nil
	case kcclass.FieldClassHeadMasterID:
		m.ClearClassHeadMasterID()
		return nil
	case kcclass.FieldClassCoverImgID:
		m.ClearClassCoverImgID()
		return nil
	case kcclass.FieldCateID:
		m.ClearCateID()
		return nil
	case kcclass.FieldCityID:
		m.ClearCityID()
		return nil
	case kcclass.FieldCreatedAdminID:
		m.ClearCreatedAdminID()
		return nil
	}
	return fmt.Errorf("unknown KcClass nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *KcClassMutation) ResetField(name string) error {
	switch name {
	case kcclass.FieldUUID:
		m.ResetUUID()
		return nil
	case kcclass.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case kcclass.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case kcclass.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case kcclass.FieldClassTitle:
		m.ResetClassTitle()
		return nil
	case kcclass.FieldClassCode:
		m.ResetClassCode()
		return nil
	case kcclass.FieldClassDesc:
		m.ResetClassDesc()
		return nil
	case kcclass.FieldIsDisplay:
		m.ResetIsDisplay()
		return nil
	case kcclass.FieldIsBuy:
		m.ResetIsBuy()
		return nil
	case kcclass.FieldClassPeriodType:
		m.ResetClassPeriodType()
		return nil
	case kcclass.FieldClassStartDate:
		m.ResetClassStartDate()
		return nil
	case kcclass.FieldClassEndDate:
		m.ResetClassEndDate()
		return nil
	case kcclass.FieldClosingDate:
		m.ResetClosingDate()
		return nil
	case kcclass.FieldDaysValidity:
		m.ResetDaysValidity()
		return nil
	case kcclass.FieldClassHeadMasterID:
		m.ResetClassHeadMasterID()
		return nil
	case kcclass.FieldClassCoverImgID:
		m.ResetClassCoverImgID()
		return nil
	case kcclass.FieldStatus:
		m.ResetStatus()
		return nil
	case kcclass.FieldPrice:
		m.ResetPrice()
		return nil
	case kcclass.FieldStudentCount:
		m.ResetStudentCount()
		return nil
	case kcclass.FieldCourseCount:
		m.ResetCourseCount()
		return nil
	case kcclass.FieldCateID:
		m.ResetCateID()
		return nil
	case kcclass.FieldCityID:
		m.ResetCityID()
		return nil
	case kcclass.FieldCreatedAdminID:
		m.ResetCreatedAdminID()
		return nil
	}
	return fmt.Errorf("unknown KcClass field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *KcClassMutation) AddedEdges() []string {
	edges := make([]string, 0, 10)
	if m.majors != nil {
		edges = append(edges, kcclass.EdgeMajors)
	}
	if m.item != nil {
		edges = append(edges, kcclass.EdgeItem)
	}
	if m.city != nil {
		edges = append(edges, kcclass.EdgeCity)
	}
	if m.admin != nil {
		edges = append(edges, kcclass.EdgeAdmin)
	}
	if m.attachment != nil {
		edges = append(edges, kcclass.EdgeAttachment)
	}
	if m.master_teachers != nil {
		edges = append(edges, kcclass.EdgeMasterTeachers)
	}
	if m.class_teachers != nil {
		edges = append(edges, kcclass.EdgeClassTeachers)
	}
	if m.kc_class_courses != nil {
		edges = append(edges, kcclass.EdgeKcClassCourses)
	}
	if m.kc_user_classes != nil {
		edges = append(edges, kcclass.EdgeKcUserClasses)
	}
	if m.message_classes != nil {
		edges = append(edges, kcclass.EdgeMessageClasses)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *KcClassMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case kcclass.EdgeMajors:
		ids := make([]ent.Value, 0, len(m.majors))
		for id := range m.majors {
			ids = append(ids, id)
		}
		return ids
	case kcclass.EdgeItem:
		if id := m.item; id != nil {
			return []ent.Value{*id}
		}
	case kcclass.EdgeCity:
		if id := m.city; id != nil {
			return []ent.Value{*id}
		}
	case kcclass.EdgeAdmin:
		if id := m.admin; id != nil {
			return []ent.Value{*id}
		}
	case kcclass.EdgeAttachment:
		if id := m.attachment; id != nil {
			return []ent.Value{*id}
		}
	case kcclass.EdgeMasterTeachers:
		if id := m.master_teachers; id != nil {
			return []ent.Value{*id}
		}
	case kcclass.EdgeClassTeachers:
		ids := make([]ent.Value, 0, len(m.class_teachers))
		for id := range m.class_teachers {
			ids = append(ids, id)
		}
		return ids
	case kcclass.EdgeKcClassCourses:
		ids := make([]ent.Value, 0, len(m.kc_class_courses))
		for id := range m.kc_class_courses {
			ids = append(ids, id)
		}
		return ids
	case kcclass.EdgeKcUserClasses:
		ids := make([]ent.Value, 0, len(m.kc_user_classes))
		for id := range m.kc_user_classes {
			ids = append(ids, id)
		}
		return ids
	case kcclass.EdgeMessageClasses:
		ids := make([]ent.Value, 0, len(m.message_classes))
		for id := range m.message_classes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *KcClassMutation) RemovedEdges() []string {
	edges := make([]string, 0, 10)
	if m.removedmajors != nil {
		edges = append(edges, kcclass.EdgeMajors)
	}
	if m.removedclass_teachers != nil {
		edges = append(edges, kcclass.EdgeClassTeachers)
	}
	if m.removedkc_class_courses != nil {
		edges = append(edges, kcclass.EdgeKcClassCourses)
	}
	if m.removedkc_user_classes != nil {
		edges = append(edges, kcclass.EdgeKcUserClasses)
	}
	if m.removedmessage_classes != nil {
		edges = append(edges, kcclass.EdgeMessageClasses)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *KcClassMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case kcclass.EdgeMajors:
		ids := make([]ent.Value, 0, len(m.removedmajors))
		for id := range m.removedmajors {
			ids = append(ids, id)
		}
		return ids
	case kcclass.EdgeClassTeachers:
		ids := make([]ent.Value, 0, len(m.removedclass_teachers))
		for id := range m.removedclass_teachers {
			ids = append(ids, id)
		}
		return ids
	case kcclass.EdgeKcClassCourses:
		ids := make([]ent.Value, 0, len(m.removedkc_class_courses))
		for id := range m.removedkc_class_courses {
			ids = append(ids, id)
		}
		return ids
	case kcclass.EdgeKcUserClasses:
		ids := make([]ent.Value, 0, len(m.removedkc_user_classes))
		for id := range m.removedkc_user_classes {
			ids = append(ids, id)
		}
		return ids
	case kcclass.EdgeMessageClasses:
		ids := make([]ent.Value, 0, len(m.removedmessage_classes))
		for id := range m.removedmessage_classes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *KcClassMutation) ClearedEdges() []string {
	edges := make([]string, 0, 10)
	if m.clearedmajors {
		edges = append(edges, kcclass.EdgeMajors)
	}
	if m.cleareditem {
		edges = append(edges, kcclass.EdgeItem)
	}
	if m.clearedcity {
		edges = append(edges, kcclass.EdgeCity)
	}
	if m.clearedadmin {
		edges = append(edges, kcclass.EdgeAdmin)
	}
	if m.clearedattachment {
		edges = append(edges, kcclass.EdgeAttachment)
	}
	if m.clearedmaster_teachers {
		edges = append(edges, kcclass.EdgeMasterTeachers)
	}
	if m.clearedclass_teachers {
		edges = append(edges, kcclass.EdgeClassTeachers)
	}
	if m.clearedkc_class_courses {
		edges = append(edges, kcclass.EdgeKcClassCourses)
	}
	if m.clearedkc_user_classes {
		edges = append(edges, kcclass.EdgeKcUserClasses)
	}
	if m.clearedmessage_classes {
		edges = append(edges, kcclass.EdgeMessageClasses)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *KcClassMutation) EdgeCleared(name string) bool {
	switch name {
	case kcclass.EdgeMajors:
		return m.clearedmajors
	case kcclass.EdgeItem:
		return m.cleareditem
	case kcclass.EdgeCity:
		return m.clearedcity
	case kcclass.EdgeAdmin:
		return m.clearedadmin
	case kcclass.EdgeAttachment:
		return m.clearedattachment
	case kcclass.EdgeMasterTeachers:
		return m.clearedmaster_teachers
	case kcclass.EdgeClassTeachers:
		return m.clearedclass_teachers
	case kcclass.EdgeKcClassCourses:
		return m.clearedkc_class_courses
	case kcclass.EdgeKcUserClasses:
		return m.clearedkc_user_classes
	case kcclass.EdgeMessageClasses:
		return m.clearedmessage_classes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *KcClassMutation) ClearEdge(name string) error {
	switch name {
	case kcclass.EdgeItem:
		m.ClearItem()
		return nil
	case kcclass.EdgeCity:
		m.ClearCity()
		return nil
	case kcclass.EdgeAdmin:
		m.ClearAdmin()
		return nil
	case kcclass.EdgeAttachment:
		m.ClearAttachment()
		return nil
	case kcclass.EdgeMasterTeachers:
		m.ClearMasterTeachers()
		return nil
	}
	return fmt.Errorf("unknown KcClass unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *KcClassMutation) ResetEdge(name string) error {
	switch name {
	case kcclass.EdgeMajors:
		m.ResetMajors()
		return nil
	case kcclass.EdgeItem:
		m.ResetItem()
		return nil
	case kcclass.EdgeCity:
		m.ResetCity()
		return nil
	case kcclass.EdgeAdmin:
		m.ResetAdmin()
		return nil
	case kcclass.EdgeAttachment:
		m.ResetAttachment()
		return nil
	case kcclass.EdgeMasterTeachers:
		m.ResetMasterTeachers()
		return nil
	case kcclass.EdgeClassTeachers:
		m.ResetClassTeachers()
		return nil
	case kcclass.EdgeKcClassCourses:
		m.ResetKcClassCourses()
		return nil
	case kcclass.EdgeKcUserClasses:
		m.ResetKcUserClasses()
		return nil
	case kcclass.EdgeMessageClasses:
		m.ResetMessageClasses()
		return nil
	}
	return fmt.Errorf("unknown KcClass edge %s", name)
}

// KcClassTeacherMutation represents an operation that mutates the KcClassTeacher nodes in the graph.
type KcClassTeacherMutation struct {
	config
	op             Op
	typ            string
	id             *int
	show_status    *uint8
	addshow_status *uint8
	sort_order     *int
	addsort_order  *int
	clearedFields  map[string]struct{}
	teacher        *int
	clearedteacher bool
	class          *int
	clearedclass   bool
	done           bool
	oldValue       func(context.Context) (*KcClassTeacher, error)
	predicates     []predicate.KcClassTeacher
}

var _ ent.Mutation = (*KcClassTeacherMutation)(nil)

// kcclassteacherOption allows management of the mutation configuration using functional options.
type kcclassteacherOption func(*KcClassTeacherMutation)

// newKcClassTeacherMutation creates new mutation for the KcClassTeacher entity.
func newKcClassTeacherMutation(c config, op Op, opts ...kcclassteacherOption) *KcClassTeacherMutation {
	m := &KcClassTeacherMutation{
		config:        c,
		op:            op,
		typ:           TypeKcClassTeacher,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withKcClassTeacherID sets the ID field of the mutation.
func withKcClassTeacherID(id int) kcclassteacherOption {
	return func(m *KcClassTeacherMutation) {
		var (
			err   error
			once  sync.Once
			value *KcClassTeacher
		)
		m.oldValue = func(ctx context.Context) (*KcClassTeacher, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().KcClassTeacher.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withKcClassTeacher sets the old KcClassTeacher of the mutation.
func withKcClassTeacher(node *KcClassTeacher) kcclassteacherOption {
	return func(m *KcClassTeacherMutation) {
		m.oldValue = func(context.Context) (*KcClassTeacher, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m KcClassTeacherMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m KcClassTeacherMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *KcClassTeacherMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetShowStatus sets the "show_status" field.
func (m *KcClassTeacherMutation) SetShowStatus(u uint8) {
	m.show_status = &u
	m.addshow_status = nil
}

// ShowStatus returns the value of the "show_status" field in the mutation.
func (m *KcClassTeacherMutation) ShowStatus() (r uint8, exists bool) {
	v := m.show_status
	if v == nil {
		return
	}
	return *v, true
}

// OldShowStatus returns the old "show_status" field's value of the KcClassTeacher entity.
// If the KcClassTeacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcClassTeacherMutation) OldShowStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShowStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShowStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShowStatus: %w", err)
	}
	return oldValue.ShowStatus, nil
}

// AddShowStatus adds u to the "show_status" field.
func (m *KcClassTeacherMutation) AddShowStatus(u uint8) {
	if m.addshow_status != nil {
		*m.addshow_status += u
	} else {
		m.addshow_status = &u
	}
}

// AddedShowStatus returns the value that was added to the "show_status" field in this mutation.
func (m *KcClassTeacherMutation) AddedShowStatus() (r uint8, exists bool) {
	v := m.addshow_status
	if v == nil {
		return
	}
	return *v, true
}

// ResetShowStatus resets all changes to the "show_status" field.
func (m *KcClassTeacherMutation) ResetShowStatus() {
	m.show_status = nil
	m.addshow_status = nil
}

// SetSortOrder sets the "sort_order" field.
func (m *KcClassTeacherMutation) SetSortOrder(i int) {
	m.sort_order = &i
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *KcClassTeacherMutation) SortOrder() (r int, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the KcClassTeacher entity.
// If the KcClassTeacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcClassTeacherMutation) OldSortOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds i to the "sort_order" field.
func (m *KcClassTeacherMutation) AddSortOrder(i int) {
	if m.addsort_order != nil {
		*m.addsort_order += i
	} else {
		m.addsort_order = &i
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *KcClassTeacherMutation) AddedSortOrder() (r int, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *KcClassTeacherMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
}

// SetClassID sets the "class_id" field.
func (m *KcClassTeacherMutation) SetClassID(i int) {
	m.class = &i
}

// ClassID returns the value of the "class_id" field in the mutation.
func (m *KcClassTeacherMutation) ClassID() (r int, exists bool) {
	v := m.class
	if v == nil {
		return
	}
	return *v, true
}

// OldClassID returns the old "class_id" field's value of the KcClassTeacher entity.
// If the KcClassTeacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcClassTeacherMutation) OldClassID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldClassID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldClassID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClassID: %w", err)
	}
	return oldValue.ClassID, nil
}

// ClearClassID clears the value of the "class_id" field.
func (m *KcClassTeacherMutation) ClearClassID() {
	m.class = nil
	m.clearedFields[kcclassteacher.FieldClassID] = struct{}{}
}

// ClassIDCleared returns if the "class_id" field was cleared in this mutation.
func (m *KcClassTeacherMutation) ClassIDCleared() bool {
	_, ok := m.clearedFields[kcclassteacher.FieldClassID]
	return ok
}

// ResetClassID resets all changes to the "class_id" field.
func (m *KcClassTeacherMutation) ResetClassID() {
	m.class = nil
	delete(m.clearedFields, kcclassteacher.FieldClassID)
}

// SetTeacherID sets the "teacher_id" field.
func (m *KcClassTeacherMutation) SetTeacherID(i int) {
	m.teacher = &i
}

// TeacherID returns the value of the "teacher_id" field in the mutation.
func (m *KcClassTeacherMutation) TeacherID() (r int, exists bool) {
	v := m.teacher
	if v == nil {
		return
	}
	return *v, true
}

// OldTeacherID returns the old "teacher_id" field's value of the KcClassTeacher entity.
// If the KcClassTeacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcClassTeacherMutation) OldTeacherID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTeacherID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTeacherID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeacherID: %w", err)
	}
	return oldValue.TeacherID, nil
}

// ClearTeacherID clears the value of the "teacher_id" field.
func (m *KcClassTeacherMutation) ClearTeacherID() {
	m.teacher = nil
	m.clearedFields[kcclassteacher.FieldTeacherID] = struct{}{}
}

// TeacherIDCleared returns if the "teacher_id" field was cleared in this mutation.
func (m *KcClassTeacherMutation) TeacherIDCleared() bool {
	_, ok := m.clearedFields[kcclassteacher.FieldTeacherID]
	return ok
}

// ResetTeacherID resets all changes to the "teacher_id" field.
func (m *KcClassTeacherMutation) ResetTeacherID() {
	m.teacher = nil
	delete(m.clearedFields, kcclassteacher.FieldTeacherID)
}

// ClearTeacher clears the "teacher" edge to the Teacher entity.
func (m *KcClassTeacherMutation) ClearTeacher() {
	m.clearedteacher = true
}

// TeacherCleared reports if the "teacher" edge to the Teacher entity was cleared.
func (m *KcClassTeacherMutation) TeacherCleared() bool {
	return m.TeacherIDCleared() || m.clearedteacher
}

// TeacherIDs returns the "teacher" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeacherID instead. It exists only for internal usage by the builders.
func (m *KcClassTeacherMutation) TeacherIDs() (ids []int) {
	if id := m.teacher; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeacher resets all changes to the "teacher" edge.
func (m *KcClassTeacherMutation) ResetTeacher() {
	m.teacher = nil
	m.clearedteacher = false
}

// ClearClass clears the "class" edge to the KcClass entity.
func (m *KcClassTeacherMutation) ClearClass() {
	m.clearedclass = true
}

// ClassCleared reports if the "class" edge to the KcClass entity was cleared.
func (m *KcClassTeacherMutation) ClassCleared() bool {
	return m.ClassIDCleared() || m.clearedclass
}

// ClassIDs returns the "class" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClassID instead. It exists only for internal usage by the builders.
func (m *KcClassTeacherMutation) ClassIDs() (ids []int) {
	if id := m.class; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClass resets all changes to the "class" edge.
func (m *KcClassTeacherMutation) ResetClass() {
	m.class = nil
	m.clearedclass = false
}

// Op returns the operation name.
func (m *KcClassTeacherMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (KcClassTeacher).
func (m *KcClassTeacherMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *KcClassTeacherMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.show_status != nil {
		fields = append(fields, kcclassteacher.FieldShowStatus)
	}
	if m.sort_order != nil {
		fields = append(fields, kcclassteacher.FieldSortOrder)
	}
	if m.class != nil {
		fields = append(fields, kcclassteacher.FieldClassID)
	}
	if m.teacher != nil {
		fields = append(fields, kcclassteacher.FieldTeacherID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *KcClassTeacherMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case kcclassteacher.FieldShowStatus:
		return m.ShowStatus()
	case kcclassteacher.FieldSortOrder:
		return m.SortOrder()
	case kcclassteacher.FieldClassID:
		return m.ClassID()
	case kcclassteacher.FieldTeacherID:
		return m.TeacherID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *KcClassTeacherMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case kcclassteacher.FieldShowStatus:
		return m.OldShowStatus(ctx)
	case kcclassteacher.FieldSortOrder:
		return m.OldSortOrder(ctx)
	case kcclassteacher.FieldClassID:
		return m.OldClassID(ctx)
	case kcclassteacher.FieldTeacherID:
		return m.OldTeacherID(ctx)
	}
	return nil, fmt.Errorf("unknown KcClassTeacher field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KcClassTeacherMutation) SetField(name string, value ent.Value) error {
	switch name {
	case kcclassteacher.FieldShowStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShowStatus(v)
		return nil
	case kcclassteacher.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	case kcclassteacher.FieldClassID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClassID(v)
		return nil
	case kcclassteacher.FieldTeacherID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeacherID(v)
		return nil
	}
	return fmt.Errorf("unknown KcClassTeacher field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *KcClassTeacherMutation) AddedFields() []string {
	var fields []string
	if m.addshow_status != nil {
		fields = append(fields, kcclassteacher.FieldShowStatus)
	}
	if m.addsort_order != nil {
		fields = append(fields, kcclassteacher.FieldSortOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *KcClassTeacherMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case kcclassteacher.FieldShowStatus:
		return m.AddedShowStatus()
	case kcclassteacher.FieldSortOrder:
		return m.AddedSortOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KcClassTeacherMutation) AddField(name string, value ent.Value) error {
	switch name {
	case kcclassteacher.FieldShowStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShowStatus(v)
		return nil
	case kcclassteacher.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown KcClassTeacher numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *KcClassTeacherMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(kcclassteacher.FieldClassID) {
		fields = append(fields, kcclassteacher.FieldClassID)
	}
	if m.FieldCleared(kcclassteacher.FieldTeacherID) {
		fields = append(fields, kcclassteacher.FieldTeacherID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *KcClassTeacherMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *KcClassTeacherMutation) ClearField(name string) error {
	switch name {
	case kcclassteacher.FieldClassID:
		m.ClearClassID()
		return nil
	case kcclassteacher.FieldTeacherID:
		m.ClearTeacherID()
		return nil
	}
	return fmt.Errorf("unknown KcClassTeacher nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *KcClassTeacherMutation) ResetField(name string) error {
	switch name {
	case kcclassteacher.FieldShowStatus:
		m.ResetShowStatus()
		return nil
	case kcclassteacher.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	case kcclassteacher.FieldClassID:
		m.ResetClassID()
		return nil
	case kcclassteacher.FieldTeacherID:
		m.ResetTeacherID()
		return nil
	}
	return fmt.Errorf("unknown KcClassTeacher field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *KcClassTeacherMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.teacher != nil {
		edges = append(edges, kcclassteacher.EdgeTeacher)
	}
	if m.class != nil {
		edges = append(edges, kcclassteacher.EdgeClass)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *KcClassTeacherMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case kcclassteacher.EdgeTeacher:
		if id := m.teacher; id != nil {
			return []ent.Value{*id}
		}
	case kcclassteacher.EdgeClass:
		if id := m.class; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *KcClassTeacherMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *KcClassTeacherMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *KcClassTeacherMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedteacher {
		edges = append(edges, kcclassteacher.EdgeTeacher)
	}
	if m.clearedclass {
		edges = append(edges, kcclassteacher.EdgeClass)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *KcClassTeacherMutation) EdgeCleared(name string) bool {
	switch name {
	case kcclassteacher.EdgeTeacher:
		return m.clearedteacher
	case kcclassteacher.EdgeClass:
		return m.clearedclass
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *KcClassTeacherMutation) ClearEdge(name string) error {
	switch name {
	case kcclassteacher.EdgeTeacher:
		m.ClearTeacher()
		return nil
	case kcclassteacher.EdgeClass:
		m.ClearClass()
		return nil
	}
	return fmt.Errorf("unknown KcClassTeacher unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *KcClassTeacherMutation) ResetEdge(name string) error {
	switch name {
	case kcclassteacher.EdgeTeacher:
		m.ResetTeacher()
		return nil
	case kcclassteacher.EdgeClass:
		m.ResetClass()
		return nil
	}
	return fmt.Errorf("unknown KcClassTeacher edge %s", name)
}

// KcCourseMutation represents an operation that mutates the KcCourse nodes in the graph.
type KcCourseMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int
	uuid                          *string
	created_at                    *time.Time
	updated_at                    *time.Time
	deleted_at                    *time.Time
	course_name                   *string
	course_type                   *uint8
	addcourse_type                *uint8
	people_num                    *int
	addpeople_num                 *int
	course_price                  *float64
	addcourse_price               *float64
	course_desc                   *string
	push_status                   *uint8
	addpush_status                *uint8
	clearedFields                 map[string]struct{}
	major                         map[int]struct{}
	removedmajor                  map[int]struct{}
	clearedmajor                  bool
	item                          *int
	cleareditem                   bool
	city                          *int
	clearedcity                   bool
	admin                         *int
	clearedadmin                  bool
	question_bank                 *int
	clearedquestion_bank          bool
	attachment                    *int
	clearedattachment             bool
	course_teachers               map[int]struct{}
	removedcourse_teachers        map[int]struct{}
	clearedcourse_teachers        bool
	classes                       map[int]struct{}
	removedclasses                map[int]struct{}
	clearedclasses                bool
	course_small_categorys        map[int]struct{}
	removedcourse_small_categorys map[int]struct{}
	clearedcourse_small_categorys bool
	course_appraise               map[int]struct{}
	removedcourse_appraise        map[int]struct{}
	clearedcourse_appraise        bool
	course_chapters               map[int]struct{}
	removedcourse_chapters        map[int]struct{}
	clearedcourse_chapters        bool
	kc_user_courses               map[int]struct{}
	removedkc_user_courses        map[int]struct{}
	clearedkc_user_courses        bool
	message_courses               map[int]struct{}
	removedmessage_courses        map[int]struct{}
	clearedmessage_courses        bool
	done                          bool
	oldValue                      func(context.Context) (*KcCourse, error)
	predicates                    []predicate.KcCourse
}

var _ ent.Mutation = (*KcCourseMutation)(nil)

// kccourseOption allows management of the mutation configuration using functional options.
type kccourseOption func(*KcCourseMutation)

// newKcCourseMutation creates new mutation for the KcCourse entity.
func newKcCourseMutation(c config, op Op, opts ...kccourseOption) *KcCourseMutation {
	m := &KcCourseMutation{
		config:        c,
		op:            op,
		typ:           TypeKcCourse,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withKcCourseID sets the ID field of the mutation.
func withKcCourseID(id int) kccourseOption {
	return func(m *KcCourseMutation) {
		var (
			err   error
			once  sync.Once
			value *KcCourse
		)
		m.oldValue = func(ctx context.Context) (*KcCourse, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().KcCourse.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withKcCourse sets the old KcCourse of the mutation.
func withKcCourse(node *KcCourse) kccourseOption {
	return func(m *KcCourseMutation) {
		m.oldValue = func(context.Context) (*KcCourse, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m KcCourseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m KcCourseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *KcCourseMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *KcCourseMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *KcCourseMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the KcCourse entity.
// If the KcCourse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcCourseMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *KcCourseMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *KcCourseMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *KcCourseMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the KcCourse entity.
// If the KcCourse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcCourseMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *KcCourseMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[kccourse.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *KcCourseMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[kccourse.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *KcCourseMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, kccourse.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *KcCourseMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *KcCourseMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the KcCourse entity.
// If the KcCourse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcCourseMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *KcCourseMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[kccourse.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *KcCourseMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[kccourse.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *KcCourseMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, kccourse.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *KcCourseMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *KcCourseMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the KcCourse entity.
// If the KcCourse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcCourseMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *KcCourseMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[kccourse.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *KcCourseMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[kccourse.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *KcCourseMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, kccourse.FieldDeletedAt)
}

// SetCourseName sets the "course_name" field.
func (m *KcCourseMutation) SetCourseName(s string) {
	m.course_name = &s
}

// CourseName returns the value of the "course_name" field in the mutation.
func (m *KcCourseMutation) CourseName() (r string, exists bool) {
	v := m.course_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCourseName returns the old "course_name" field's value of the KcCourse entity.
// If the KcCourse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcCourseMutation) OldCourseName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCourseName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCourseName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCourseName: %w", err)
	}
	return oldValue.CourseName, nil
}

// ResetCourseName resets all changes to the "course_name" field.
func (m *KcCourseMutation) ResetCourseName() {
	m.course_name = nil
}

// SetCourseType sets the "course_type" field.
func (m *KcCourseMutation) SetCourseType(u uint8) {
	m.course_type = &u
	m.addcourse_type = nil
}

// CourseType returns the value of the "course_type" field in the mutation.
func (m *KcCourseMutation) CourseType() (r uint8, exists bool) {
	v := m.course_type
	if v == nil {
		return
	}
	return *v, true
}

// OldCourseType returns the old "course_type" field's value of the KcCourse entity.
// If the KcCourse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcCourseMutation) OldCourseType(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCourseType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCourseType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCourseType: %w", err)
	}
	return oldValue.CourseType, nil
}

// AddCourseType adds u to the "course_type" field.
func (m *KcCourseMutation) AddCourseType(u uint8) {
	if m.addcourse_type != nil {
		*m.addcourse_type += u
	} else {
		m.addcourse_type = &u
	}
}

// AddedCourseType returns the value that was added to the "course_type" field in this mutation.
func (m *KcCourseMutation) AddedCourseType() (r uint8, exists bool) {
	v := m.addcourse_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetCourseType resets all changes to the "course_type" field.
func (m *KcCourseMutation) ResetCourseType() {
	m.course_type = nil
	m.addcourse_type = nil
}

// SetPeopleNum sets the "people_num" field.
func (m *KcCourseMutation) SetPeopleNum(i int) {
	m.people_num = &i
	m.addpeople_num = nil
}

// PeopleNum returns the value of the "people_num" field in the mutation.
func (m *KcCourseMutation) PeopleNum() (r int, exists bool) {
	v := m.people_num
	if v == nil {
		return
	}
	return *v, true
}

// OldPeopleNum returns the old "people_num" field's value of the KcCourse entity.
// If the KcCourse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcCourseMutation) OldPeopleNum(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPeopleNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPeopleNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPeopleNum: %w", err)
	}
	return oldValue.PeopleNum, nil
}

// AddPeopleNum adds i to the "people_num" field.
func (m *KcCourseMutation) AddPeopleNum(i int) {
	if m.addpeople_num != nil {
		*m.addpeople_num += i
	} else {
		m.addpeople_num = &i
	}
}

// AddedPeopleNum returns the value that was added to the "people_num" field in this mutation.
func (m *KcCourseMutation) AddedPeopleNum() (r int, exists bool) {
	v := m.addpeople_num
	if v == nil {
		return
	}
	return *v, true
}

// ResetPeopleNum resets all changes to the "people_num" field.
func (m *KcCourseMutation) ResetPeopleNum() {
	m.people_num = nil
	m.addpeople_num = nil
}

// SetCoursePrice sets the "course_price" field.
func (m *KcCourseMutation) SetCoursePrice(f float64) {
	m.course_price = &f
	m.addcourse_price = nil
}

// CoursePrice returns the value of the "course_price" field in the mutation.
func (m *KcCourseMutation) CoursePrice() (r float64, exists bool) {
	v := m.course_price
	if v == nil {
		return
	}
	return *v, true
}

// OldCoursePrice returns the old "course_price" field's value of the KcCourse entity.
// If the KcCourse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcCourseMutation) OldCoursePrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCoursePrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCoursePrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoursePrice: %w", err)
	}
	return oldValue.CoursePrice, nil
}

// AddCoursePrice adds f to the "course_price" field.
func (m *KcCourseMutation) AddCoursePrice(f float64) {
	if m.addcourse_price != nil {
		*m.addcourse_price += f
	} else {
		m.addcourse_price = &f
	}
}

// AddedCoursePrice returns the value that was added to the "course_price" field in this mutation.
func (m *KcCourseMutation) AddedCoursePrice() (r float64, exists bool) {
	v := m.addcourse_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetCoursePrice resets all changes to the "course_price" field.
func (m *KcCourseMutation) ResetCoursePrice() {
	m.course_price = nil
	m.addcourse_price = nil
}

// SetCourseDesc sets the "course_desc" field.
func (m *KcCourseMutation) SetCourseDesc(s string) {
	m.course_desc = &s
}

// CourseDesc returns the value of the "course_desc" field in the mutation.
func (m *KcCourseMutation) CourseDesc() (r string, exists bool) {
	v := m.course_desc
	if v == nil {
		return
	}
	return *v, true
}

// OldCourseDesc returns the old "course_desc" field's value of the KcCourse entity.
// If the KcCourse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcCourseMutation) OldCourseDesc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCourseDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCourseDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCourseDesc: %w", err)
	}
	return oldValue.CourseDesc, nil
}

// ResetCourseDesc resets all changes to the "course_desc" field.
func (m *KcCourseMutation) ResetCourseDesc() {
	m.course_desc = nil
}

// SetPushStatus sets the "push_status" field.
func (m *KcCourseMutation) SetPushStatus(u uint8) {
	m.push_status = &u
	m.addpush_status = nil
}

// PushStatus returns the value of the "push_status" field in the mutation.
func (m *KcCourseMutation) PushStatus() (r uint8, exists bool) {
	v := m.push_status
	if v == nil {
		return
	}
	return *v, true
}

// OldPushStatus returns the old "push_status" field's value of the KcCourse entity.
// If the KcCourse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcCourseMutation) OldPushStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPushStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPushStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPushStatus: %w", err)
	}
	return oldValue.PushStatus, nil
}

// AddPushStatus adds u to the "push_status" field.
func (m *KcCourseMutation) AddPushStatus(u uint8) {
	if m.addpush_status != nil {
		*m.addpush_status += u
	} else {
		m.addpush_status = &u
	}
}

// AddedPushStatus returns the value that was added to the "push_status" field in this mutation.
func (m *KcCourseMutation) AddedPushStatus() (r uint8, exists bool) {
	v := m.addpush_status
	if v == nil {
		return
	}
	return *v, true
}

// ResetPushStatus resets all changes to the "push_status" field.
func (m *KcCourseMutation) ResetPushStatus() {
	m.push_status = nil
	m.addpush_status = nil
}

// SetCateID sets the "cate_id" field.
func (m *KcCourseMutation) SetCateID(i int) {
	m.item = &i
}

// CateID returns the value of the "cate_id" field in the mutation.
func (m *KcCourseMutation) CateID() (r int, exists bool) {
	v := m.item
	if v == nil {
		return
	}
	return *v, true
}

// OldCateID returns the old "cate_id" field's value of the KcCourse entity.
// If the KcCourse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcCourseMutation) OldCateID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCateID: %w", err)
	}
	return oldValue.CateID, nil
}

// ClearCateID clears the value of the "cate_id" field.
func (m *KcCourseMutation) ClearCateID() {
	m.item = nil
	m.clearedFields[kccourse.FieldCateID] = struct{}{}
}

// CateIDCleared returns if the "cate_id" field was cleared in this mutation.
func (m *KcCourseMutation) CateIDCleared() bool {
	_, ok := m.clearedFields[kccourse.FieldCateID]
	return ok
}

// ResetCateID resets all changes to the "cate_id" field.
func (m *KcCourseMutation) ResetCateID() {
	m.item = nil
	delete(m.clearedFields, kccourse.FieldCateID)
}

// SetCityID sets the "city_id" field.
func (m *KcCourseMutation) SetCityID(i int) {
	m.city = &i
}

// CityID returns the value of the "city_id" field in the mutation.
func (m *KcCourseMutation) CityID() (r int, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCityID returns the old "city_id" field's value of the KcCourse entity.
// If the KcCourse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcCourseMutation) OldCityID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCityID: %w", err)
	}
	return oldValue.CityID, nil
}

// ClearCityID clears the value of the "city_id" field.
func (m *KcCourseMutation) ClearCityID() {
	m.city = nil
	m.clearedFields[kccourse.FieldCityID] = struct{}{}
}

// CityIDCleared returns if the "city_id" field was cleared in this mutation.
func (m *KcCourseMutation) CityIDCleared() bool {
	_, ok := m.clearedFields[kccourse.FieldCityID]
	return ok
}

// ResetCityID resets all changes to the "city_id" field.
func (m *KcCourseMutation) ResetCityID() {
	m.city = nil
	delete(m.clearedFields, kccourse.FieldCityID)
}

// SetQuestionBankID sets the "question_bank_id" field.
func (m *KcCourseMutation) SetQuestionBankID(i int) {
	m.question_bank = &i
}

// QuestionBankID returns the value of the "question_bank_id" field in the mutation.
func (m *KcCourseMutation) QuestionBankID() (r int, exists bool) {
	v := m.question_bank
	if v == nil {
		return
	}
	return *v, true
}

// OldQuestionBankID returns the old "question_bank_id" field's value of the KcCourse entity.
// If the KcCourse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcCourseMutation) OldQuestionBankID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldQuestionBankID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldQuestionBankID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuestionBankID: %w", err)
	}
	return oldValue.QuestionBankID, nil
}

// ClearQuestionBankID clears the value of the "question_bank_id" field.
func (m *KcCourseMutation) ClearQuestionBankID() {
	m.question_bank = nil
	m.clearedFields[kccourse.FieldQuestionBankID] = struct{}{}
}

// QuestionBankIDCleared returns if the "question_bank_id" field was cleared in this mutation.
func (m *KcCourseMutation) QuestionBankIDCleared() bool {
	_, ok := m.clearedFields[kccourse.FieldQuestionBankID]
	return ok
}

// ResetQuestionBankID resets all changes to the "question_bank_id" field.
func (m *KcCourseMutation) ResetQuestionBankID() {
	m.question_bank = nil
	delete(m.clearedFields, kccourse.FieldQuestionBankID)
}

// SetCourseCoverImgID sets the "course_cover_img_id" field.
func (m *KcCourseMutation) SetCourseCoverImgID(i int) {
	m.attachment = &i
}

// CourseCoverImgID returns the value of the "course_cover_img_id" field in the mutation.
func (m *KcCourseMutation) CourseCoverImgID() (r int, exists bool) {
	v := m.attachment
	if v == nil {
		return
	}
	return *v, true
}

// OldCourseCoverImgID returns the old "course_cover_img_id" field's value of the KcCourse entity.
// If the KcCourse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcCourseMutation) OldCourseCoverImgID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCourseCoverImgID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCourseCoverImgID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCourseCoverImgID: %w", err)
	}
	return oldValue.CourseCoverImgID, nil
}

// ClearCourseCoverImgID clears the value of the "course_cover_img_id" field.
func (m *KcCourseMutation) ClearCourseCoverImgID() {
	m.attachment = nil
	m.clearedFields[kccourse.FieldCourseCoverImgID] = struct{}{}
}

// CourseCoverImgIDCleared returns if the "course_cover_img_id" field was cleared in this mutation.
func (m *KcCourseMutation) CourseCoverImgIDCleared() bool {
	_, ok := m.clearedFields[kccourse.FieldCourseCoverImgID]
	return ok
}

// ResetCourseCoverImgID resets all changes to the "course_cover_img_id" field.
func (m *KcCourseMutation) ResetCourseCoverImgID() {
	m.attachment = nil
	delete(m.clearedFields, kccourse.FieldCourseCoverImgID)
}

// SetCreatedAdminID sets the "created_admin_id" field.
func (m *KcCourseMutation) SetCreatedAdminID(i int) {
	m.admin = &i
}

// CreatedAdminID returns the value of the "created_admin_id" field in the mutation.
func (m *KcCourseMutation) CreatedAdminID() (r int, exists bool) {
	v := m.admin
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAdminID returns the old "created_admin_id" field's value of the KcCourse entity.
// If the KcCourse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcCourseMutation) OldCreatedAdminID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAdminID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAdminID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAdminID: %w", err)
	}
	return oldValue.CreatedAdminID, nil
}

// ClearCreatedAdminID clears the value of the "created_admin_id" field.
func (m *KcCourseMutation) ClearCreatedAdminID() {
	m.admin = nil
	m.clearedFields[kccourse.FieldCreatedAdminID] = struct{}{}
}

// CreatedAdminIDCleared returns if the "created_admin_id" field was cleared in this mutation.
func (m *KcCourseMutation) CreatedAdminIDCleared() bool {
	_, ok := m.clearedFields[kccourse.FieldCreatedAdminID]
	return ok
}

// ResetCreatedAdminID resets all changes to the "created_admin_id" field.
func (m *KcCourseMutation) ResetCreatedAdminID() {
	m.admin = nil
	delete(m.clearedFields, kccourse.FieldCreatedAdminID)
}

// AddMajorIDs adds the "major" edge to the Major entity by ids.
func (m *KcCourseMutation) AddMajorIDs(ids ...int) {
	if m.major == nil {
		m.major = make(map[int]struct{})
	}
	for i := range ids {
		m.major[ids[i]] = struct{}{}
	}
}

// ClearMajor clears the "major" edge to the Major entity.
func (m *KcCourseMutation) ClearMajor() {
	m.clearedmajor = true
}

// MajorCleared reports if the "major" edge to the Major entity was cleared.
func (m *KcCourseMutation) MajorCleared() bool {
	return m.clearedmajor
}

// RemoveMajorIDs removes the "major" edge to the Major entity by IDs.
func (m *KcCourseMutation) RemoveMajorIDs(ids ...int) {
	if m.removedmajor == nil {
		m.removedmajor = make(map[int]struct{})
	}
	for i := range ids {
		m.removedmajor[ids[i]] = struct{}{}
	}
}

// RemovedMajor returns the removed IDs of the "major" edge to the Major entity.
func (m *KcCourseMutation) RemovedMajorIDs() (ids []int) {
	for id := range m.removedmajor {
		ids = append(ids, id)
	}
	return
}

// MajorIDs returns the "major" edge IDs in the mutation.
func (m *KcCourseMutation) MajorIDs() (ids []int) {
	for id := range m.major {
		ids = append(ids, id)
	}
	return
}

// ResetMajor resets all changes to the "major" edge.
func (m *KcCourseMutation) ResetMajor() {
	m.major = nil
	m.clearedmajor = false
	m.removedmajor = nil
}

// SetItemID sets the "item" edge to the ItemCategory entity by id.
func (m *KcCourseMutation) SetItemID(id int) {
	m.item = &id
}

// ClearItem clears the "item" edge to the ItemCategory entity.
func (m *KcCourseMutation) ClearItem() {
	m.cleareditem = true
}

// ItemCleared reports if the "item" edge to the ItemCategory entity was cleared.
func (m *KcCourseMutation) ItemCleared() bool {
	return m.CateIDCleared() || m.cleareditem
}

// ItemID returns the "item" edge ID in the mutation.
func (m *KcCourseMutation) ItemID() (id int, exists bool) {
	if m.item != nil {
		return *m.item, true
	}
	return
}

// ItemIDs returns the "item" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ItemID instead. It exists only for internal usage by the builders.
func (m *KcCourseMutation) ItemIDs() (ids []int) {
	if id := m.item; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetItem resets all changes to the "item" edge.
func (m *KcCourseMutation) ResetItem() {
	m.item = nil
	m.cleareditem = false
}

// ClearCity clears the "city" edge to the City entity.
func (m *KcCourseMutation) ClearCity() {
	m.clearedcity = true
}

// CityCleared reports if the "city" edge to the City entity was cleared.
func (m *KcCourseMutation) CityCleared() bool {
	return m.CityIDCleared() || m.clearedcity
}

// CityIDs returns the "city" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CityID instead. It exists only for internal usage by the builders.
func (m *KcCourseMutation) CityIDs() (ids []int) {
	if id := m.city; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCity resets all changes to the "city" edge.
func (m *KcCourseMutation) ResetCity() {
	m.city = nil
	m.clearedcity = false
}

// SetAdminID sets the "admin" edge to the Admin entity by id.
func (m *KcCourseMutation) SetAdminID(id int) {
	m.admin = &id
}

// ClearAdmin clears the "admin" edge to the Admin entity.
func (m *KcCourseMutation) ClearAdmin() {
	m.clearedadmin = true
}

// AdminCleared reports if the "admin" edge to the Admin entity was cleared.
func (m *KcCourseMutation) AdminCleared() bool {
	return m.CreatedAdminIDCleared() || m.clearedadmin
}

// AdminID returns the "admin" edge ID in the mutation.
func (m *KcCourseMutation) AdminID() (id int, exists bool) {
	if m.admin != nil {
		return *m.admin, true
	}
	return
}

// AdminIDs returns the "admin" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AdminID instead. It exists only for internal usage by the builders.
func (m *KcCourseMutation) AdminIDs() (ids []int) {
	if id := m.admin; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAdmin resets all changes to the "admin" edge.
func (m *KcCourseMutation) ResetAdmin() {
	m.admin = nil
	m.clearedadmin = false
}

// ClearQuestionBank clears the "question_bank" edge to the TkQuestionBank entity.
func (m *KcCourseMutation) ClearQuestionBank() {
	m.clearedquestion_bank = true
}

// QuestionBankCleared reports if the "question_bank" edge to the TkQuestionBank entity was cleared.
func (m *KcCourseMutation) QuestionBankCleared() bool {
	return m.QuestionBankIDCleared() || m.clearedquestion_bank
}

// QuestionBankIDs returns the "question_bank" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// QuestionBankID instead. It exists only for internal usage by the builders.
func (m *KcCourseMutation) QuestionBankIDs() (ids []int) {
	if id := m.question_bank; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetQuestionBank resets all changes to the "question_bank" edge.
func (m *KcCourseMutation) ResetQuestionBank() {
	m.question_bank = nil
	m.clearedquestion_bank = false
}

// SetAttachmentID sets the "attachment" edge to the Attachment entity by id.
func (m *KcCourseMutation) SetAttachmentID(id int) {
	m.attachment = &id
}

// ClearAttachment clears the "attachment" edge to the Attachment entity.
func (m *KcCourseMutation) ClearAttachment() {
	m.clearedattachment = true
}

// AttachmentCleared reports if the "attachment" edge to the Attachment entity was cleared.
func (m *KcCourseMutation) AttachmentCleared() bool {
	return m.CourseCoverImgIDCleared() || m.clearedattachment
}

// AttachmentID returns the "attachment" edge ID in the mutation.
func (m *KcCourseMutation) AttachmentID() (id int, exists bool) {
	if m.attachment != nil {
		return *m.attachment, true
	}
	return
}

// AttachmentIDs returns the "attachment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AttachmentID instead. It exists only for internal usage by the builders.
func (m *KcCourseMutation) AttachmentIDs() (ids []int) {
	if id := m.attachment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAttachment resets all changes to the "attachment" edge.
func (m *KcCourseMutation) ResetAttachment() {
	m.attachment = nil
	m.clearedattachment = false
}

// AddCourseTeacherIDs adds the "course_teachers" edge to the KcCourseTeacher entity by ids.
func (m *KcCourseMutation) AddCourseTeacherIDs(ids ...int) {
	if m.course_teachers == nil {
		m.course_teachers = make(map[int]struct{})
	}
	for i := range ids {
		m.course_teachers[ids[i]] = struct{}{}
	}
}

// ClearCourseTeachers clears the "course_teachers" edge to the KcCourseTeacher entity.
func (m *KcCourseMutation) ClearCourseTeachers() {
	m.clearedcourse_teachers = true
}

// CourseTeachersCleared reports if the "course_teachers" edge to the KcCourseTeacher entity was cleared.
func (m *KcCourseMutation) CourseTeachersCleared() bool {
	return m.clearedcourse_teachers
}

// RemoveCourseTeacherIDs removes the "course_teachers" edge to the KcCourseTeacher entity by IDs.
func (m *KcCourseMutation) RemoveCourseTeacherIDs(ids ...int) {
	if m.removedcourse_teachers == nil {
		m.removedcourse_teachers = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcourse_teachers[ids[i]] = struct{}{}
	}
}

// RemovedCourseTeachers returns the removed IDs of the "course_teachers" edge to the KcCourseTeacher entity.
func (m *KcCourseMutation) RemovedCourseTeachersIDs() (ids []int) {
	for id := range m.removedcourse_teachers {
		ids = append(ids, id)
	}
	return
}

// CourseTeachersIDs returns the "course_teachers" edge IDs in the mutation.
func (m *KcCourseMutation) CourseTeachersIDs() (ids []int) {
	for id := range m.course_teachers {
		ids = append(ids, id)
	}
	return
}

// ResetCourseTeachers resets all changes to the "course_teachers" edge.
func (m *KcCourseMutation) ResetCourseTeachers() {
	m.course_teachers = nil
	m.clearedcourse_teachers = false
	m.removedcourse_teachers = nil
}

// AddClassIDs adds the "classes" edge to the KcClass entity by ids.
func (m *KcCourseMutation) AddClassIDs(ids ...int) {
	if m.classes == nil {
		m.classes = make(map[int]struct{})
	}
	for i := range ids {
		m.classes[ids[i]] = struct{}{}
	}
}

// ClearClasses clears the "classes" edge to the KcClass entity.
func (m *KcCourseMutation) ClearClasses() {
	m.clearedclasses = true
}

// ClassesCleared reports if the "classes" edge to the KcClass entity was cleared.
func (m *KcCourseMutation) ClassesCleared() bool {
	return m.clearedclasses
}

// RemoveClassIDs removes the "classes" edge to the KcClass entity by IDs.
func (m *KcCourseMutation) RemoveClassIDs(ids ...int) {
	if m.removedclasses == nil {
		m.removedclasses = make(map[int]struct{})
	}
	for i := range ids {
		m.removedclasses[ids[i]] = struct{}{}
	}
}

// RemovedClasses returns the removed IDs of the "classes" edge to the KcClass entity.
func (m *KcCourseMutation) RemovedClassesIDs() (ids []int) {
	for id := range m.removedclasses {
		ids = append(ids, id)
	}
	return
}

// ClassesIDs returns the "classes" edge IDs in the mutation.
func (m *KcCourseMutation) ClassesIDs() (ids []int) {
	for id := range m.classes {
		ids = append(ids, id)
	}
	return
}

// ResetClasses resets all changes to the "classes" edge.
func (m *KcCourseMutation) ResetClasses() {
	m.classes = nil
	m.clearedclasses = false
	m.removedclasses = nil
}

// AddCourseSmallCategoryIDs adds the "course_small_categorys" edge to the KcCourseSmallCategory entity by ids.
func (m *KcCourseMutation) AddCourseSmallCategoryIDs(ids ...int) {
	if m.course_small_categorys == nil {
		m.course_small_categorys = make(map[int]struct{})
	}
	for i := range ids {
		m.course_small_categorys[ids[i]] = struct{}{}
	}
}

// ClearCourseSmallCategorys clears the "course_small_categorys" edge to the KcCourseSmallCategory entity.
func (m *KcCourseMutation) ClearCourseSmallCategorys() {
	m.clearedcourse_small_categorys = true
}

// CourseSmallCategorysCleared reports if the "course_small_categorys" edge to the KcCourseSmallCategory entity was cleared.
func (m *KcCourseMutation) CourseSmallCategorysCleared() bool {
	return m.clearedcourse_small_categorys
}

// RemoveCourseSmallCategoryIDs removes the "course_small_categorys" edge to the KcCourseSmallCategory entity by IDs.
func (m *KcCourseMutation) RemoveCourseSmallCategoryIDs(ids ...int) {
	if m.removedcourse_small_categorys == nil {
		m.removedcourse_small_categorys = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcourse_small_categorys[ids[i]] = struct{}{}
	}
}

// RemovedCourseSmallCategorys returns the removed IDs of the "course_small_categorys" edge to the KcCourseSmallCategory entity.
func (m *KcCourseMutation) RemovedCourseSmallCategorysIDs() (ids []int) {
	for id := range m.removedcourse_small_categorys {
		ids = append(ids, id)
	}
	return
}

// CourseSmallCategorysIDs returns the "course_small_categorys" edge IDs in the mutation.
func (m *KcCourseMutation) CourseSmallCategorysIDs() (ids []int) {
	for id := range m.course_small_categorys {
		ids = append(ids, id)
	}
	return
}

// ResetCourseSmallCategorys resets all changes to the "course_small_categorys" edge.
func (m *KcCourseMutation) ResetCourseSmallCategorys() {
	m.course_small_categorys = nil
	m.clearedcourse_small_categorys = false
	m.removedcourse_small_categorys = nil
}

// AddCourseAppraiseIDs adds the "course_appraise" edge to the UserCourseAppraise entity by ids.
func (m *KcCourseMutation) AddCourseAppraiseIDs(ids ...int) {
	if m.course_appraise == nil {
		m.course_appraise = make(map[int]struct{})
	}
	for i := range ids {
		m.course_appraise[ids[i]] = struct{}{}
	}
}

// ClearCourseAppraise clears the "course_appraise" edge to the UserCourseAppraise entity.
func (m *KcCourseMutation) ClearCourseAppraise() {
	m.clearedcourse_appraise = true
}

// CourseAppraiseCleared reports if the "course_appraise" edge to the UserCourseAppraise entity was cleared.
func (m *KcCourseMutation) CourseAppraiseCleared() bool {
	return m.clearedcourse_appraise
}

// RemoveCourseAppraiseIDs removes the "course_appraise" edge to the UserCourseAppraise entity by IDs.
func (m *KcCourseMutation) RemoveCourseAppraiseIDs(ids ...int) {
	if m.removedcourse_appraise == nil {
		m.removedcourse_appraise = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcourse_appraise[ids[i]] = struct{}{}
	}
}

// RemovedCourseAppraise returns the removed IDs of the "course_appraise" edge to the UserCourseAppraise entity.
func (m *KcCourseMutation) RemovedCourseAppraiseIDs() (ids []int) {
	for id := range m.removedcourse_appraise {
		ids = append(ids, id)
	}
	return
}

// CourseAppraiseIDs returns the "course_appraise" edge IDs in the mutation.
func (m *KcCourseMutation) CourseAppraiseIDs() (ids []int) {
	for id := range m.course_appraise {
		ids = append(ids, id)
	}
	return
}

// ResetCourseAppraise resets all changes to the "course_appraise" edge.
func (m *KcCourseMutation) ResetCourseAppraise() {
	m.course_appraise = nil
	m.clearedcourse_appraise = false
	m.removedcourse_appraise = nil
}

// AddCourseChapterIDs adds the "course_chapters" edge to the KcCourseChapter entity by ids.
func (m *KcCourseMutation) AddCourseChapterIDs(ids ...int) {
	if m.course_chapters == nil {
		m.course_chapters = make(map[int]struct{})
	}
	for i := range ids {
		m.course_chapters[ids[i]] = struct{}{}
	}
}

// ClearCourseChapters clears the "course_chapters" edge to the KcCourseChapter entity.
func (m *KcCourseMutation) ClearCourseChapters() {
	m.clearedcourse_chapters = true
}

// CourseChaptersCleared reports if the "course_chapters" edge to the KcCourseChapter entity was cleared.
func (m *KcCourseMutation) CourseChaptersCleared() bool {
	return m.clearedcourse_chapters
}

// RemoveCourseChapterIDs removes the "course_chapters" edge to the KcCourseChapter entity by IDs.
func (m *KcCourseMutation) RemoveCourseChapterIDs(ids ...int) {
	if m.removedcourse_chapters == nil {
		m.removedcourse_chapters = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcourse_chapters[ids[i]] = struct{}{}
	}
}

// RemovedCourseChapters returns the removed IDs of the "course_chapters" edge to the KcCourseChapter entity.
func (m *KcCourseMutation) RemovedCourseChaptersIDs() (ids []int) {
	for id := range m.removedcourse_chapters {
		ids = append(ids, id)
	}
	return
}

// CourseChaptersIDs returns the "course_chapters" edge IDs in the mutation.
func (m *KcCourseMutation) CourseChaptersIDs() (ids []int) {
	for id := range m.course_chapters {
		ids = append(ids, id)
	}
	return
}

// ResetCourseChapters resets all changes to the "course_chapters" edge.
func (m *KcCourseMutation) ResetCourseChapters() {
	m.course_chapters = nil
	m.clearedcourse_chapters = false
	m.removedcourse_chapters = nil
}

// AddKcUserCourseIDs adds the "kc_user_courses" edge to the KcUserCourse entity by ids.
func (m *KcCourseMutation) AddKcUserCourseIDs(ids ...int) {
	if m.kc_user_courses == nil {
		m.kc_user_courses = make(map[int]struct{})
	}
	for i := range ids {
		m.kc_user_courses[ids[i]] = struct{}{}
	}
}

// ClearKcUserCourses clears the "kc_user_courses" edge to the KcUserCourse entity.
func (m *KcCourseMutation) ClearKcUserCourses() {
	m.clearedkc_user_courses = true
}

// KcUserCoursesCleared reports if the "kc_user_courses" edge to the KcUserCourse entity was cleared.
func (m *KcCourseMutation) KcUserCoursesCleared() bool {
	return m.clearedkc_user_courses
}

// RemoveKcUserCourseIDs removes the "kc_user_courses" edge to the KcUserCourse entity by IDs.
func (m *KcCourseMutation) RemoveKcUserCourseIDs(ids ...int) {
	if m.removedkc_user_courses == nil {
		m.removedkc_user_courses = make(map[int]struct{})
	}
	for i := range ids {
		m.removedkc_user_courses[ids[i]] = struct{}{}
	}
}

// RemovedKcUserCourses returns the removed IDs of the "kc_user_courses" edge to the KcUserCourse entity.
func (m *KcCourseMutation) RemovedKcUserCoursesIDs() (ids []int) {
	for id := range m.removedkc_user_courses {
		ids = append(ids, id)
	}
	return
}

// KcUserCoursesIDs returns the "kc_user_courses" edge IDs in the mutation.
func (m *KcCourseMutation) KcUserCoursesIDs() (ids []int) {
	for id := range m.kc_user_courses {
		ids = append(ids, id)
	}
	return
}

// ResetKcUserCourses resets all changes to the "kc_user_courses" edge.
func (m *KcCourseMutation) ResetKcUserCourses() {
	m.kc_user_courses = nil
	m.clearedkc_user_courses = false
	m.removedkc_user_courses = nil
}

// AddMessageCourseIDs adds the "message_courses" edge to the Message entity by ids.
func (m *KcCourseMutation) AddMessageCourseIDs(ids ...int) {
	if m.message_courses == nil {
		m.message_courses = make(map[int]struct{})
	}
	for i := range ids {
		m.message_courses[ids[i]] = struct{}{}
	}
}

// ClearMessageCourses clears the "message_courses" edge to the Message entity.
func (m *KcCourseMutation) ClearMessageCourses() {
	m.clearedmessage_courses = true
}

// MessageCoursesCleared reports if the "message_courses" edge to the Message entity was cleared.
func (m *KcCourseMutation) MessageCoursesCleared() bool {
	return m.clearedmessage_courses
}

// RemoveMessageCourseIDs removes the "message_courses" edge to the Message entity by IDs.
func (m *KcCourseMutation) RemoveMessageCourseIDs(ids ...int) {
	if m.removedmessage_courses == nil {
		m.removedmessage_courses = make(map[int]struct{})
	}
	for i := range ids {
		m.removedmessage_courses[ids[i]] = struct{}{}
	}
}

// RemovedMessageCourses returns the removed IDs of the "message_courses" edge to the Message entity.
func (m *KcCourseMutation) RemovedMessageCoursesIDs() (ids []int) {
	for id := range m.removedmessage_courses {
		ids = append(ids, id)
	}
	return
}

// MessageCoursesIDs returns the "message_courses" edge IDs in the mutation.
func (m *KcCourseMutation) MessageCoursesIDs() (ids []int) {
	for id := range m.message_courses {
		ids = append(ids, id)
	}
	return
}

// ResetMessageCourses resets all changes to the "message_courses" edge.
func (m *KcCourseMutation) ResetMessageCourses() {
	m.message_courses = nil
	m.clearedmessage_courses = false
	m.removedmessage_courses = nil
}

// Op returns the operation name.
func (m *KcCourseMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (KcCourse).
func (m *KcCourseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *KcCourseMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.uuid != nil {
		fields = append(fields, kccourse.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, kccourse.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, kccourse.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, kccourse.FieldDeletedAt)
	}
	if m.course_name != nil {
		fields = append(fields, kccourse.FieldCourseName)
	}
	if m.course_type != nil {
		fields = append(fields, kccourse.FieldCourseType)
	}
	if m.people_num != nil {
		fields = append(fields, kccourse.FieldPeopleNum)
	}
	if m.course_price != nil {
		fields = append(fields, kccourse.FieldCoursePrice)
	}
	if m.course_desc != nil {
		fields = append(fields, kccourse.FieldCourseDesc)
	}
	if m.push_status != nil {
		fields = append(fields, kccourse.FieldPushStatus)
	}
	if m.item != nil {
		fields = append(fields, kccourse.FieldCateID)
	}
	if m.city != nil {
		fields = append(fields, kccourse.FieldCityID)
	}
	if m.question_bank != nil {
		fields = append(fields, kccourse.FieldQuestionBankID)
	}
	if m.attachment != nil {
		fields = append(fields, kccourse.FieldCourseCoverImgID)
	}
	if m.admin != nil {
		fields = append(fields, kccourse.FieldCreatedAdminID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *KcCourseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case kccourse.FieldUUID:
		return m.UUID()
	case kccourse.FieldCreatedAt:
		return m.CreatedAt()
	case kccourse.FieldUpdatedAt:
		return m.UpdatedAt()
	case kccourse.FieldDeletedAt:
		return m.DeletedAt()
	case kccourse.FieldCourseName:
		return m.CourseName()
	case kccourse.FieldCourseType:
		return m.CourseType()
	case kccourse.FieldPeopleNum:
		return m.PeopleNum()
	case kccourse.FieldCoursePrice:
		return m.CoursePrice()
	case kccourse.FieldCourseDesc:
		return m.CourseDesc()
	case kccourse.FieldPushStatus:
		return m.PushStatus()
	case kccourse.FieldCateID:
		return m.CateID()
	case kccourse.FieldCityID:
		return m.CityID()
	case kccourse.FieldQuestionBankID:
		return m.QuestionBankID()
	case kccourse.FieldCourseCoverImgID:
		return m.CourseCoverImgID()
	case kccourse.FieldCreatedAdminID:
		return m.CreatedAdminID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *KcCourseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case kccourse.FieldUUID:
		return m.OldUUID(ctx)
	case kccourse.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case kccourse.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case kccourse.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case kccourse.FieldCourseName:
		return m.OldCourseName(ctx)
	case kccourse.FieldCourseType:
		return m.OldCourseType(ctx)
	case kccourse.FieldPeopleNum:
		return m.OldPeopleNum(ctx)
	case kccourse.FieldCoursePrice:
		return m.OldCoursePrice(ctx)
	case kccourse.FieldCourseDesc:
		return m.OldCourseDesc(ctx)
	case kccourse.FieldPushStatus:
		return m.OldPushStatus(ctx)
	case kccourse.FieldCateID:
		return m.OldCateID(ctx)
	case kccourse.FieldCityID:
		return m.OldCityID(ctx)
	case kccourse.FieldQuestionBankID:
		return m.OldQuestionBankID(ctx)
	case kccourse.FieldCourseCoverImgID:
		return m.OldCourseCoverImgID(ctx)
	case kccourse.FieldCreatedAdminID:
		return m.OldCreatedAdminID(ctx)
	}
	return nil, fmt.Errorf("unknown KcCourse field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KcCourseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case kccourse.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case kccourse.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case kccourse.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case kccourse.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case kccourse.FieldCourseName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCourseName(v)
		return nil
	case kccourse.FieldCourseType:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCourseType(v)
		return nil
	case kccourse.FieldPeopleNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPeopleNum(v)
		return nil
	case kccourse.FieldCoursePrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoursePrice(v)
		return nil
	case kccourse.FieldCourseDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCourseDesc(v)
		return nil
	case kccourse.FieldPushStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPushStatus(v)
		return nil
	case kccourse.FieldCateID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCateID(v)
		return nil
	case kccourse.FieldCityID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCityID(v)
		return nil
	case kccourse.FieldQuestionBankID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuestionBankID(v)
		return nil
	case kccourse.FieldCourseCoverImgID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCourseCoverImgID(v)
		return nil
	case kccourse.FieldCreatedAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAdminID(v)
		return nil
	}
	return fmt.Errorf("unknown KcCourse field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *KcCourseMutation) AddedFields() []string {
	var fields []string
	if m.addcourse_type != nil {
		fields = append(fields, kccourse.FieldCourseType)
	}
	if m.addpeople_num != nil {
		fields = append(fields, kccourse.FieldPeopleNum)
	}
	if m.addcourse_price != nil {
		fields = append(fields, kccourse.FieldCoursePrice)
	}
	if m.addpush_status != nil {
		fields = append(fields, kccourse.FieldPushStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *KcCourseMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case kccourse.FieldCourseType:
		return m.AddedCourseType()
	case kccourse.FieldPeopleNum:
		return m.AddedPeopleNum()
	case kccourse.FieldCoursePrice:
		return m.AddedCoursePrice()
	case kccourse.FieldPushStatus:
		return m.AddedPushStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KcCourseMutation) AddField(name string, value ent.Value) error {
	switch name {
	case kccourse.FieldCourseType:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCourseType(v)
		return nil
	case kccourse.FieldPeopleNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPeopleNum(v)
		return nil
	case kccourse.FieldCoursePrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCoursePrice(v)
		return nil
	case kccourse.FieldPushStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPushStatus(v)
		return nil
	}
	return fmt.Errorf("unknown KcCourse numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *KcCourseMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(kccourse.FieldCreatedAt) {
		fields = append(fields, kccourse.FieldCreatedAt)
	}
	if m.FieldCleared(kccourse.FieldUpdatedAt) {
		fields = append(fields, kccourse.FieldUpdatedAt)
	}
	if m.FieldCleared(kccourse.FieldDeletedAt) {
		fields = append(fields, kccourse.FieldDeletedAt)
	}
	if m.FieldCleared(kccourse.FieldCateID) {
		fields = append(fields, kccourse.FieldCateID)
	}
	if m.FieldCleared(kccourse.FieldCityID) {
		fields = append(fields, kccourse.FieldCityID)
	}
	if m.FieldCleared(kccourse.FieldQuestionBankID) {
		fields = append(fields, kccourse.FieldQuestionBankID)
	}
	if m.FieldCleared(kccourse.FieldCourseCoverImgID) {
		fields = append(fields, kccourse.FieldCourseCoverImgID)
	}
	if m.FieldCleared(kccourse.FieldCreatedAdminID) {
		fields = append(fields, kccourse.FieldCreatedAdminID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *KcCourseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *KcCourseMutation) ClearField(name string) error {
	switch name {
	case kccourse.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case kccourse.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case kccourse.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case kccourse.FieldCateID:
		m.ClearCateID()
		return nil
	case kccourse.FieldCityID:
		m.ClearCityID()
		return nil
	case kccourse.FieldQuestionBankID:
		m.ClearQuestionBankID()
		return nil
	case kccourse.FieldCourseCoverImgID:
		m.ClearCourseCoverImgID()
		return nil
	case kccourse.FieldCreatedAdminID:
		m.ClearCreatedAdminID()
		return nil
	}
	return fmt.Errorf("unknown KcCourse nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *KcCourseMutation) ResetField(name string) error {
	switch name {
	case kccourse.FieldUUID:
		m.ResetUUID()
		return nil
	case kccourse.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case kccourse.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case kccourse.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case kccourse.FieldCourseName:
		m.ResetCourseName()
		return nil
	case kccourse.FieldCourseType:
		m.ResetCourseType()
		return nil
	case kccourse.FieldPeopleNum:
		m.ResetPeopleNum()
		return nil
	case kccourse.FieldCoursePrice:
		m.ResetCoursePrice()
		return nil
	case kccourse.FieldCourseDesc:
		m.ResetCourseDesc()
		return nil
	case kccourse.FieldPushStatus:
		m.ResetPushStatus()
		return nil
	case kccourse.FieldCateID:
		m.ResetCateID()
		return nil
	case kccourse.FieldCityID:
		m.ResetCityID()
		return nil
	case kccourse.FieldQuestionBankID:
		m.ResetQuestionBankID()
		return nil
	case kccourse.FieldCourseCoverImgID:
		m.ResetCourseCoverImgID()
		return nil
	case kccourse.FieldCreatedAdminID:
		m.ResetCreatedAdminID()
		return nil
	}
	return fmt.Errorf("unknown KcCourse field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *KcCourseMutation) AddedEdges() []string {
	edges := make([]string, 0, 13)
	if m.major != nil {
		edges = append(edges, kccourse.EdgeMajor)
	}
	if m.item != nil {
		edges = append(edges, kccourse.EdgeItem)
	}
	if m.city != nil {
		edges = append(edges, kccourse.EdgeCity)
	}
	if m.admin != nil {
		edges = append(edges, kccourse.EdgeAdmin)
	}
	if m.question_bank != nil {
		edges = append(edges, kccourse.EdgeQuestionBank)
	}
	if m.attachment != nil {
		edges = append(edges, kccourse.EdgeAttachment)
	}
	if m.course_teachers != nil {
		edges = append(edges, kccourse.EdgeCourseTeachers)
	}
	if m.classes != nil {
		edges = append(edges, kccourse.EdgeClasses)
	}
	if m.course_small_categorys != nil {
		edges = append(edges, kccourse.EdgeCourseSmallCategorys)
	}
	if m.course_appraise != nil {
		edges = append(edges, kccourse.EdgeCourseAppraise)
	}
	if m.course_chapters != nil {
		edges = append(edges, kccourse.EdgeCourseChapters)
	}
	if m.kc_user_courses != nil {
		edges = append(edges, kccourse.EdgeKcUserCourses)
	}
	if m.message_courses != nil {
		edges = append(edges, kccourse.EdgeMessageCourses)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *KcCourseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case kccourse.EdgeMajor:
		ids := make([]ent.Value, 0, len(m.major))
		for id := range m.major {
			ids = append(ids, id)
		}
		return ids
	case kccourse.EdgeItem:
		if id := m.item; id != nil {
			return []ent.Value{*id}
		}
	case kccourse.EdgeCity:
		if id := m.city; id != nil {
			return []ent.Value{*id}
		}
	case kccourse.EdgeAdmin:
		if id := m.admin; id != nil {
			return []ent.Value{*id}
		}
	case kccourse.EdgeQuestionBank:
		if id := m.question_bank; id != nil {
			return []ent.Value{*id}
		}
	case kccourse.EdgeAttachment:
		if id := m.attachment; id != nil {
			return []ent.Value{*id}
		}
	case kccourse.EdgeCourseTeachers:
		ids := make([]ent.Value, 0, len(m.course_teachers))
		for id := range m.course_teachers {
			ids = append(ids, id)
		}
		return ids
	case kccourse.EdgeClasses:
		ids := make([]ent.Value, 0, len(m.classes))
		for id := range m.classes {
			ids = append(ids, id)
		}
		return ids
	case kccourse.EdgeCourseSmallCategorys:
		ids := make([]ent.Value, 0, len(m.course_small_categorys))
		for id := range m.course_small_categorys {
			ids = append(ids, id)
		}
		return ids
	case kccourse.EdgeCourseAppraise:
		ids := make([]ent.Value, 0, len(m.course_appraise))
		for id := range m.course_appraise {
			ids = append(ids, id)
		}
		return ids
	case kccourse.EdgeCourseChapters:
		ids := make([]ent.Value, 0, len(m.course_chapters))
		for id := range m.course_chapters {
			ids = append(ids, id)
		}
		return ids
	case kccourse.EdgeKcUserCourses:
		ids := make([]ent.Value, 0, len(m.kc_user_courses))
		for id := range m.kc_user_courses {
			ids = append(ids, id)
		}
		return ids
	case kccourse.EdgeMessageCourses:
		ids := make([]ent.Value, 0, len(m.message_courses))
		for id := range m.message_courses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *KcCourseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 13)
	if m.removedmajor != nil {
		edges = append(edges, kccourse.EdgeMajor)
	}
	if m.removedcourse_teachers != nil {
		edges = append(edges, kccourse.EdgeCourseTeachers)
	}
	if m.removedclasses != nil {
		edges = append(edges, kccourse.EdgeClasses)
	}
	if m.removedcourse_small_categorys != nil {
		edges = append(edges, kccourse.EdgeCourseSmallCategorys)
	}
	if m.removedcourse_appraise != nil {
		edges = append(edges, kccourse.EdgeCourseAppraise)
	}
	if m.removedcourse_chapters != nil {
		edges = append(edges, kccourse.EdgeCourseChapters)
	}
	if m.removedkc_user_courses != nil {
		edges = append(edges, kccourse.EdgeKcUserCourses)
	}
	if m.removedmessage_courses != nil {
		edges = append(edges, kccourse.EdgeMessageCourses)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *KcCourseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case kccourse.EdgeMajor:
		ids := make([]ent.Value, 0, len(m.removedmajor))
		for id := range m.removedmajor {
			ids = append(ids, id)
		}
		return ids
	case kccourse.EdgeCourseTeachers:
		ids := make([]ent.Value, 0, len(m.removedcourse_teachers))
		for id := range m.removedcourse_teachers {
			ids = append(ids, id)
		}
		return ids
	case kccourse.EdgeClasses:
		ids := make([]ent.Value, 0, len(m.removedclasses))
		for id := range m.removedclasses {
			ids = append(ids, id)
		}
		return ids
	case kccourse.EdgeCourseSmallCategorys:
		ids := make([]ent.Value, 0, len(m.removedcourse_small_categorys))
		for id := range m.removedcourse_small_categorys {
			ids = append(ids, id)
		}
		return ids
	case kccourse.EdgeCourseAppraise:
		ids := make([]ent.Value, 0, len(m.removedcourse_appraise))
		for id := range m.removedcourse_appraise {
			ids = append(ids, id)
		}
		return ids
	case kccourse.EdgeCourseChapters:
		ids := make([]ent.Value, 0, len(m.removedcourse_chapters))
		for id := range m.removedcourse_chapters {
			ids = append(ids, id)
		}
		return ids
	case kccourse.EdgeKcUserCourses:
		ids := make([]ent.Value, 0, len(m.removedkc_user_courses))
		for id := range m.removedkc_user_courses {
			ids = append(ids, id)
		}
		return ids
	case kccourse.EdgeMessageCourses:
		ids := make([]ent.Value, 0, len(m.removedmessage_courses))
		for id := range m.removedmessage_courses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *KcCourseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 13)
	if m.clearedmajor {
		edges = append(edges, kccourse.EdgeMajor)
	}
	if m.cleareditem {
		edges = append(edges, kccourse.EdgeItem)
	}
	if m.clearedcity {
		edges = append(edges, kccourse.EdgeCity)
	}
	if m.clearedadmin {
		edges = append(edges, kccourse.EdgeAdmin)
	}
	if m.clearedquestion_bank {
		edges = append(edges, kccourse.EdgeQuestionBank)
	}
	if m.clearedattachment {
		edges = append(edges, kccourse.EdgeAttachment)
	}
	if m.clearedcourse_teachers {
		edges = append(edges, kccourse.EdgeCourseTeachers)
	}
	if m.clearedclasses {
		edges = append(edges, kccourse.EdgeClasses)
	}
	if m.clearedcourse_small_categorys {
		edges = append(edges, kccourse.EdgeCourseSmallCategorys)
	}
	if m.clearedcourse_appraise {
		edges = append(edges, kccourse.EdgeCourseAppraise)
	}
	if m.clearedcourse_chapters {
		edges = append(edges, kccourse.EdgeCourseChapters)
	}
	if m.clearedkc_user_courses {
		edges = append(edges, kccourse.EdgeKcUserCourses)
	}
	if m.clearedmessage_courses {
		edges = append(edges, kccourse.EdgeMessageCourses)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *KcCourseMutation) EdgeCleared(name string) bool {
	switch name {
	case kccourse.EdgeMajor:
		return m.clearedmajor
	case kccourse.EdgeItem:
		return m.cleareditem
	case kccourse.EdgeCity:
		return m.clearedcity
	case kccourse.EdgeAdmin:
		return m.clearedadmin
	case kccourse.EdgeQuestionBank:
		return m.clearedquestion_bank
	case kccourse.EdgeAttachment:
		return m.clearedattachment
	case kccourse.EdgeCourseTeachers:
		return m.clearedcourse_teachers
	case kccourse.EdgeClasses:
		return m.clearedclasses
	case kccourse.EdgeCourseSmallCategorys:
		return m.clearedcourse_small_categorys
	case kccourse.EdgeCourseAppraise:
		return m.clearedcourse_appraise
	case kccourse.EdgeCourseChapters:
		return m.clearedcourse_chapters
	case kccourse.EdgeKcUserCourses:
		return m.clearedkc_user_courses
	case kccourse.EdgeMessageCourses:
		return m.clearedmessage_courses
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *KcCourseMutation) ClearEdge(name string) error {
	switch name {
	case kccourse.EdgeItem:
		m.ClearItem()
		return nil
	case kccourse.EdgeCity:
		m.ClearCity()
		return nil
	case kccourse.EdgeAdmin:
		m.ClearAdmin()
		return nil
	case kccourse.EdgeQuestionBank:
		m.ClearQuestionBank()
		return nil
	case kccourse.EdgeAttachment:
		m.ClearAttachment()
		return nil
	}
	return fmt.Errorf("unknown KcCourse unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *KcCourseMutation) ResetEdge(name string) error {
	switch name {
	case kccourse.EdgeMajor:
		m.ResetMajor()
		return nil
	case kccourse.EdgeItem:
		m.ResetItem()
		return nil
	case kccourse.EdgeCity:
		m.ResetCity()
		return nil
	case kccourse.EdgeAdmin:
		m.ResetAdmin()
		return nil
	case kccourse.EdgeQuestionBank:
		m.ResetQuestionBank()
		return nil
	case kccourse.EdgeAttachment:
		m.ResetAttachment()
		return nil
	case kccourse.EdgeCourseTeachers:
		m.ResetCourseTeachers()
		return nil
	case kccourse.EdgeClasses:
		m.ResetClasses()
		return nil
	case kccourse.EdgeCourseSmallCategorys:
		m.ResetCourseSmallCategorys()
		return nil
	case kccourse.EdgeCourseAppraise:
		m.ResetCourseAppraise()
		return nil
	case kccourse.EdgeCourseChapters:
		m.ResetCourseChapters()
		return nil
	case kccourse.EdgeKcUserCourses:
		m.ResetKcUserCourses()
		return nil
	case kccourse.EdgeMessageCourses:
		m.ResetMessageCourses()
		return nil
	}
	return fmt.Errorf("unknown KcCourse edge %s", name)
}

// KcCourseChapterMutation represents an operation that mutates the KcCourseChapter nodes in the graph.
type KcCourseChapterMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	title                        *string
	clearedFields                map[string]struct{}
	chapter_course               *int
	clearedchapter_course        bool
	chapter_sections             map[int]struct{}
	removedchapter_sections      map[int]struct{}
	clearedchapter_sections      bool
	course_small_chapters        map[int]struct{}
	removedcourse_small_chapters map[int]struct{}
	clearedcourse_small_chapters bool
	done                         bool
	oldValue                     func(context.Context) (*KcCourseChapter, error)
	predicates                   []predicate.KcCourseChapter
}

var _ ent.Mutation = (*KcCourseChapterMutation)(nil)

// kccoursechapterOption allows management of the mutation configuration using functional options.
type kccoursechapterOption func(*KcCourseChapterMutation)

// newKcCourseChapterMutation creates new mutation for the KcCourseChapter entity.
func newKcCourseChapterMutation(c config, op Op, opts ...kccoursechapterOption) *KcCourseChapterMutation {
	m := &KcCourseChapterMutation{
		config:        c,
		op:            op,
		typ:           TypeKcCourseChapter,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withKcCourseChapterID sets the ID field of the mutation.
func withKcCourseChapterID(id int) kccoursechapterOption {
	return func(m *KcCourseChapterMutation) {
		var (
			err   error
			once  sync.Once
			value *KcCourseChapter
		)
		m.oldValue = func(ctx context.Context) (*KcCourseChapter, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().KcCourseChapter.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withKcCourseChapter sets the old KcCourseChapter of the mutation.
func withKcCourseChapter(node *KcCourseChapter) kccoursechapterOption {
	return func(m *KcCourseChapterMutation) {
		m.oldValue = func(context.Context) (*KcCourseChapter, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m KcCourseChapterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m KcCourseChapterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *KcCourseChapterMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCourseID sets the "course_id" field.
func (m *KcCourseChapterMutation) SetCourseID(i int) {
	m.chapter_course = &i
}

// CourseID returns the value of the "course_id" field in the mutation.
func (m *KcCourseChapterMutation) CourseID() (r int, exists bool) {
	v := m.chapter_course
	if v == nil {
		return
	}
	return *v, true
}

// OldCourseID returns the old "course_id" field's value of the KcCourseChapter entity.
// If the KcCourseChapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcCourseChapterMutation) OldCourseID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCourseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCourseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCourseID: %w", err)
	}
	return oldValue.CourseID, nil
}

// ClearCourseID clears the value of the "course_id" field.
func (m *KcCourseChapterMutation) ClearCourseID() {
	m.chapter_course = nil
	m.clearedFields[kccoursechapter.FieldCourseID] = struct{}{}
}

// CourseIDCleared returns if the "course_id" field was cleared in this mutation.
func (m *KcCourseChapterMutation) CourseIDCleared() bool {
	_, ok := m.clearedFields[kccoursechapter.FieldCourseID]
	return ok
}

// ResetCourseID resets all changes to the "course_id" field.
func (m *KcCourseChapterMutation) ResetCourseID() {
	m.chapter_course = nil
	delete(m.clearedFields, kccoursechapter.FieldCourseID)
}

// SetTitle sets the "title" field.
func (m *KcCourseChapterMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *KcCourseChapterMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the KcCourseChapter entity.
// If the KcCourseChapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcCourseChapterMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *KcCourseChapterMutation) ResetTitle() {
	m.title = nil
}

// SetChapterCourseID sets the "chapter_course" edge to the KcCourse entity by id.
func (m *KcCourseChapterMutation) SetChapterCourseID(id int) {
	m.chapter_course = &id
}

// ClearChapterCourse clears the "chapter_course" edge to the KcCourse entity.
func (m *KcCourseChapterMutation) ClearChapterCourse() {
	m.clearedchapter_course = true
}

// ChapterCourseCleared reports if the "chapter_course" edge to the KcCourse entity was cleared.
func (m *KcCourseChapterMutation) ChapterCourseCleared() bool {
	return m.CourseIDCleared() || m.clearedchapter_course
}

// ChapterCourseID returns the "chapter_course" edge ID in the mutation.
func (m *KcCourseChapterMutation) ChapterCourseID() (id int, exists bool) {
	if m.chapter_course != nil {
		return *m.chapter_course, true
	}
	return
}

// ChapterCourseIDs returns the "chapter_course" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChapterCourseID instead. It exists only for internal usage by the builders.
func (m *KcCourseChapterMutation) ChapterCourseIDs() (ids []int) {
	if id := m.chapter_course; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChapterCourse resets all changes to the "chapter_course" edge.
func (m *KcCourseChapterMutation) ResetChapterCourse() {
	m.chapter_course = nil
	m.clearedchapter_course = false
}

// AddChapterSectionIDs adds the "chapter_sections" edge to the KcCourseSection entity by ids.
func (m *KcCourseChapterMutation) AddChapterSectionIDs(ids ...int) {
	if m.chapter_sections == nil {
		m.chapter_sections = make(map[int]struct{})
	}
	for i := range ids {
		m.chapter_sections[ids[i]] = struct{}{}
	}
}

// ClearChapterSections clears the "chapter_sections" edge to the KcCourseSection entity.
func (m *KcCourseChapterMutation) ClearChapterSections() {
	m.clearedchapter_sections = true
}

// ChapterSectionsCleared reports if the "chapter_sections" edge to the KcCourseSection entity was cleared.
func (m *KcCourseChapterMutation) ChapterSectionsCleared() bool {
	return m.clearedchapter_sections
}

// RemoveChapterSectionIDs removes the "chapter_sections" edge to the KcCourseSection entity by IDs.
func (m *KcCourseChapterMutation) RemoveChapterSectionIDs(ids ...int) {
	if m.removedchapter_sections == nil {
		m.removedchapter_sections = make(map[int]struct{})
	}
	for i := range ids {
		m.removedchapter_sections[ids[i]] = struct{}{}
	}
}

// RemovedChapterSections returns the removed IDs of the "chapter_sections" edge to the KcCourseSection entity.
func (m *KcCourseChapterMutation) RemovedChapterSectionsIDs() (ids []int) {
	for id := range m.removedchapter_sections {
		ids = append(ids, id)
	}
	return
}

// ChapterSectionsIDs returns the "chapter_sections" edge IDs in the mutation.
func (m *KcCourseChapterMutation) ChapterSectionsIDs() (ids []int) {
	for id := range m.chapter_sections {
		ids = append(ids, id)
	}
	return
}

// ResetChapterSections resets all changes to the "chapter_sections" edge.
func (m *KcCourseChapterMutation) ResetChapterSections() {
	m.chapter_sections = nil
	m.clearedchapter_sections = false
	m.removedchapter_sections = nil
}

// AddCourseSmallChapterIDs adds the "course_small_chapters" edge to the KcCourseSmallCategory entity by ids.
func (m *KcCourseChapterMutation) AddCourseSmallChapterIDs(ids ...int) {
	if m.course_small_chapters == nil {
		m.course_small_chapters = make(map[int]struct{})
	}
	for i := range ids {
		m.course_small_chapters[ids[i]] = struct{}{}
	}
}

// ClearCourseSmallChapters clears the "course_small_chapters" edge to the KcCourseSmallCategory entity.
func (m *KcCourseChapterMutation) ClearCourseSmallChapters() {
	m.clearedcourse_small_chapters = true
}

// CourseSmallChaptersCleared reports if the "course_small_chapters" edge to the KcCourseSmallCategory entity was cleared.
func (m *KcCourseChapterMutation) CourseSmallChaptersCleared() bool {
	return m.clearedcourse_small_chapters
}

// RemoveCourseSmallChapterIDs removes the "course_small_chapters" edge to the KcCourseSmallCategory entity by IDs.
func (m *KcCourseChapterMutation) RemoveCourseSmallChapterIDs(ids ...int) {
	if m.removedcourse_small_chapters == nil {
		m.removedcourse_small_chapters = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcourse_small_chapters[ids[i]] = struct{}{}
	}
}

// RemovedCourseSmallChapters returns the removed IDs of the "course_small_chapters" edge to the KcCourseSmallCategory entity.
func (m *KcCourseChapterMutation) RemovedCourseSmallChaptersIDs() (ids []int) {
	for id := range m.removedcourse_small_chapters {
		ids = append(ids, id)
	}
	return
}

// CourseSmallChaptersIDs returns the "course_small_chapters" edge IDs in the mutation.
func (m *KcCourseChapterMutation) CourseSmallChaptersIDs() (ids []int) {
	for id := range m.course_small_chapters {
		ids = append(ids, id)
	}
	return
}

// ResetCourseSmallChapters resets all changes to the "course_small_chapters" edge.
func (m *KcCourseChapterMutation) ResetCourseSmallChapters() {
	m.course_small_chapters = nil
	m.clearedcourse_small_chapters = false
	m.removedcourse_small_chapters = nil
}

// Op returns the operation name.
func (m *KcCourseChapterMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (KcCourseChapter).
func (m *KcCourseChapterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *KcCourseChapterMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.chapter_course != nil {
		fields = append(fields, kccoursechapter.FieldCourseID)
	}
	if m.title != nil {
		fields = append(fields, kccoursechapter.FieldTitle)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *KcCourseChapterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case kccoursechapter.FieldCourseID:
		return m.CourseID()
	case kccoursechapter.FieldTitle:
		return m.Title()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *KcCourseChapterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case kccoursechapter.FieldCourseID:
		return m.OldCourseID(ctx)
	case kccoursechapter.FieldTitle:
		return m.OldTitle(ctx)
	}
	return nil, fmt.Errorf("unknown KcCourseChapter field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KcCourseChapterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case kccoursechapter.FieldCourseID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCourseID(v)
		return nil
	case kccoursechapter.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	}
	return fmt.Errorf("unknown KcCourseChapter field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *KcCourseChapterMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *KcCourseChapterMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KcCourseChapterMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown KcCourseChapter numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *KcCourseChapterMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(kccoursechapter.FieldCourseID) {
		fields = append(fields, kccoursechapter.FieldCourseID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *KcCourseChapterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *KcCourseChapterMutation) ClearField(name string) error {
	switch name {
	case kccoursechapter.FieldCourseID:
		m.ClearCourseID()
		return nil
	}
	return fmt.Errorf("unknown KcCourseChapter nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *KcCourseChapterMutation) ResetField(name string) error {
	switch name {
	case kccoursechapter.FieldCourseID:
		m.ResetCourseID()
		return nil
	case kccoursechapter.FieldTitle:
		m.ResetTitle()
		return nil
	}
	return fmt.Errorf("unknown KcCourseChapter field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *KcCourseChapterMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.chapter_course != nil {
		edges = append(edges, kccoursechapter.EdgeChapterCourse)
	}
	if m.chapter_sections != nil {
		edges = append(edges, kccoursechapter.EdgeChapterSections)
	}
	if m.course_small_chapters != nil {
		edges = append(edges, kccoursechapter.EdgeCourseSmallChapters)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *KcCourseChapterMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case kccoursechapter.EdgeChapterCourse:
		if id := m.chapter_course; id != nil {
			return []ent.Value{*id}
		}
	case kccoursechapter.EdgeChapterSections:
		ids := make([]ent.Value, 0, len(m.chapter_sections))
		for id := range m.chapter_sections {
			ids = append(ids, id)
		}
		return ids
	case kccoursechapter.EdgeCourseSmallChapters:
		ids := make([]ent.Value, 0, len(m.course_small_chapters))
		for id := range m.course_small_chapters {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *KcCourseChapterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedchapter_sections != nil {
		edges = append(edges, kccoursechapter.EdgeChapterSections)
	}
	if m.removedcourse_small_chapters != nil {
		edges = append(edges, kccoursechapter.EdgeCourseSmallChapters)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *KcCourseChapterMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case kccoursechapter.EdgeChapterSections:
		ids := make([]ent.Value, 0, len(m.removedchapter_sections))
		for id := range m.removedchapter_sections {
			ids = append(ids, id)
		}
		return ids
	case kccoursechapter.EdgeCourseSmallChapters:
		ids := make([]ent.Value, 0, len(m.removedcourse_small_chapters))
		for id := range m.removedcourse_small_chapters {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *KcCourseChapterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedchapter_course {
		edges = append(edges, kccoursechapter.EdgeChapterCourse)
	}
	if m.clearedchapter_sections {
		edges = append(edges, kccoursechapter.EdgeChapterSections)
	}
	if m.clearedcourse_small_chapters {
		edges = append(edges, kccoursechapter.EdgeCourseSmallChapters)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *KcCourseChapterMutation) EdgeCleared(name string) bool {
	switch name {
	case kccoursechapter.EdgeChapterCourse:
		return m.clearedchapter_course
	case kccoursechapter.EdgeChapterSections:
		return m.clearedchapter_sections
	case kccoursechapter.EdgeCourseSmallChapters:
		return m.clearedcourse_small_chapters
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *KcCourseChapterMutation) ClearEdge(name string) error {
	switch name {
	case kccoursechapter.EdgeChapterCourse:
		m.ClearChapterCourse()
		return nil
	}
	return fmt.Errorf("unknown KcCourseChapter unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *KcCourseChapterMutation) ResetEdge(name string) error {
	switch name {
	case kccoursechapter.EdgeChapterCourse:
		m.ResetChapterCourse()
		return nil
	case kccoursechapter.EdgeChapterSections:
		m.ResetChapterSections()
		return nil
	case kccoursechapter.EdgeCourseSmallChapters:
		m.ResetCourseSmallChapters()
		return nil
	}
	return fmt.Errorf("unknown KcCourseChapter edge %s", name)
}

// KcCourseSectionMutation represents an operation that mutates the KcCourseSection nodes in the graph.
type KcCourseSectionMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	title                        *string
	clearedFields                map[string]struct{}
	chapter                      *int
	clearedchapter               bool
	course_small_sections        map[int]struct{}
	removedcourse_small_sections map[int]struct{}
	clearedcourse_small_sections bool
	done                         bool
	oldValue                     func(context.Context) (*KcCourseSection, error)
	predicates                   []predicate.KcCourseSection
}

var _ ent.Mutation = (*KcCourseSectionMutation)(nil)

// kccoursesectionOption allows management of the mutation configuration using functional options.
type kccoursesectionOption func(*KcCourseSectionMutation)

// newKcCourseSectionMutation creates new mutation for the KcCourseSection entity.
func newKcCourseSectionMutation(c config, op Op, opts ...kccoursesectionOption) *KcCourseSectionMutation {
	m := &KcCourseSectionMutation{
		config:        c,
		op:            op,
		typ:           TypeKcCourseSection,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withKcCourseSectionID sets the ID field of the mutation.
func withKcCourseSectionID(id int) kccoursesectionOption {
	return func(m *KcCourseSectionMutation) {
		var (
			err   error
			once  sync.Once
			value *KcCourseSection
		)
		m.oldValue = func(ctx context.Context) (*KcCourseSection, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().KcCourseSection.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withKcCourseSection sets the old KcCourseSection of the mutation.
func withKcCourseSection(node *KcCourseSection) kccoursesectionOption {
	return func(m *KcCourseSectionMutation) {
		m.oldValue = func(context.Context) (*KcCourseSection, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m KcCourseSectionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m KcCourseSectionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *KcCourseSectionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCourseChapterID sets the "course_chapter_id" field.
func (m *KcCourseSectionMutation) SetCourseChapterID(i int) {
	m.chapter = &i
}

// CourseChapterID returns the value of the "course_chapter_id" field in the mutation.
func (m *KcCourseSectionMutation) CourseChapterID() (r int, exists bool) {
	v := m.chapter
	if v == nil {
		return
	}
	return *v, true
}

// OldCourseChapterID returns the old "course_chapter_id" field's value of the KcCourseSection entity.
// If the KcCourseSection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcCourseSectionMutation) OldCourseChapterID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCourseChapterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCourseChapterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCourseChapterID: %w", err)
	}
	return oldValue.CourseChapterID, nil
}

// ClearCourseChapterID clears the value of the "course_chapter_id" field.
func (m *KcCourseSectionMutation) ClearCourseChapterID() {
	m.chapter = nil
	m.clearedFields[kccoursesection.FieldCourseChapterID] = struct{}{}
}

// CourseChapterIDCleared returns if the "course_chapter_id" field was cleared in this mutation.
func (m *KcCourseSectionMutation) CourseChapterIDCleared() bool {
	_, ok := m.clearedFields[kccoursesection.FieldCourseChapterID]
	return ok
}

// ResetCourseChapterID resets all changes to the "course_chapter_id" field.
func (m *KcCourseSectionMutation) ResetCourseChapterID() {
	m.chapter = nil
	delete(m.clearedFields, kccoursesection.FieldCourseChapterID)
}

// SetTitle sets the "title" field.
func (m *KcCourseSectionMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *KcCourseSectionMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the KcCourseSection entity.
// If the KcCourseSection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcCourseSectionMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *KcCourseSectionMutation) ResetTitle() {
	m.title = nil
}

// SetChapterID sets the "chapter" edge to the KcCourseChapter entity by id.
func (m *KcCourseSectionMutation) SetChapterID(id int) {
	m.chapter = &id
}

// ClearChapter clears the "chapter" edge to the KcCourseChapter entity.
func (m *KcCourseSectionMutation) ClearChapter() {
	m.clearedchapter = true
}

// ChapterCleared reports if the "chapter" edge to the KcCourseChapter entity was cleared.
func (m *KcCourseSectionMutation) ChapterCleared() bool {
	return m.CourseChapterIDCleared() || m.clearedchapter
}

// ChapterID returns the "chapter" edge ID in the mutation.
func (m *KcCourseSectionMutation) ChapterID() (id int, exists bool) {
	if m.chapter != nil {
		return *m.chapter, true
	}
	return
}

// ChapterIDs returns the "chapter" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChapterID instead. It exists only for internal usage by the builders.
func (m *KcCourseSectionMutation) ChapterIDs() (ids []int) {
	if id := m.chapter; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChapter resets all changes to the "chapter" edge.
func (m *KcCourseSectionMutation) ResetChapter() {
	m.chapter = nil
	m.clearedchapter = false
}

// AddCourseSmallSectionIDs adds the "course_small_sections" edge to the KcCourseSmallCategory entity by ids.
func (m *KcCourseSectionMutation) AddCourseSmallSectionIDs(ids ...int) {
	if m.course_small_sections == nil {
		m.course_small_sections = make(map[int]struct{})
	}
	for i := range ids {
		m.course_small_sections[ids[i]] = struct{}{}
	}
}

// ClearCourseSmallSections clears the "course_small_sections" edge to the KcCourseSmallCategory entity.
func (m *KcCourseSectionMutation) ClearCourseSmallSections() {
	m.clearedcourse_small_sections = true
}

// CourseSmallSectionsCleared reports if the "course_small_sections" edge to the KcCourseSmallCategory entity was cleared.
func (m *KcCourseSectionMutation) CourseSmallSectionsCleared() bool {
	return m.clearedcourse_small_sections
}

// RemoveCourseSmallSectionIDs removes the "course_small_sections" edge to the KcCourseSmallCategory entity by IDs.
func (m *KcCourseSectionMutation) RemoveCourseSmallSectionIDs(ids ...int) {
	if m.removedcourse_small_sections == nil {
		m.removedcourse_small_sections = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcourse_small_sections[ids[i]] = struct{}{}
	}
}

// RemovedCourseSmallSections returns the removed IDs of the "course_small_sections" edge to the KcCourseSmallCategory entity.
func (m *KcCourseSectionMutation) RemovedCourseSmallSectionsIDs() (ids []int) {
	for id := range m.removedcourse_small_sections {
		ids = append(ids, id)
	}
	return
}

// CourseSmallSectionsIDs returns the "course_small_sections" edge IDs in the mutation.
func (m *KcCourseSectionMutation) CourseSmallSectionsIDs() (ids []int) {
	for id := range m.course_small_sections {
		ids = append(ids, id)
	}
	return
}

// ResetCourseSmallSections resets all changes to the "course_small_sections" edge.
func (m *KcCourseSectionMutation) ResetCourseSmallSections() {
	m.course_small_sections = nil
	m.clearedcourse_small_sections = false
	m.removedcourse_small_sections = nil
}

// Op returns the operation name.
func (m *KcCourseSectionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (KcCourseSection).
func (m *KcCourseSectionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *KcCourseSectionMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.chapter != nil {
		fields = append(fields, kccoursesection.FieldCourseChapterID)
	}
	if m.title != nil {
		fields = append(fields, kccoursesection.FieldTitle)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *KcCourseSectionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case kccoursesection.FieldCourseChapterID:
		return m.CourseChapterID()
	case kccoursesection.FieldTitle:
		return m.Title()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *KcCourseSectionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case kccoursesection.FieldCourseChapterID:
		return m.OldCourseChapterID(ctx)
	case kccoursesection.FieldTitle:
		return m.OldTitle(ctx)
	}
	return nil, fmt.Errorf("unknown KcCourseSection field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KcCourseSectionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case kccoursesection.FieldCourseChapterID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCourseChapterID(v)
		return nil
	case kccoursesection.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	}
	return fmt.Errorf("unknown KcCourseSection field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *KcCourseSectionMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *KcCourseSectionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KcCourseSectionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown KcCourseSection numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *KcCourseSectionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(kccoursesection.FieldCourseChapterID) {
		fields = append(fields, kccoursesection.FieldCourseChapterID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *KcCourseSectionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *KcCourseSectionMutation) ClearField(name string) error {
	switch name {
	case kccoursesection.FieldCourseChapterID:
		m.ClearCourseChapterID()
		return nil
	}
	return fmt.Errorf("unknown KcCourseSection nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *KcCourseSectionMutation) ResetField(name string) error {
	switch name {
	case kccoursesection.FieldCourseChapterID:
		m.ResetCourseChapterID()
		return nil
	case kccoursesection.FieldTitle:
		m.ResetTitle()
		return nil
	}
	return fmt.Errorf("unknown KcCourseSection field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *KcCourseSectionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.chapter != nil {
		edges = append(edges, kccoursesection.EdgeChapter)
	}
	if m.course_small_sections != nil {
		edges = append(edges, kccoursesection.EdgeCourseSmallSections)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *KcCourseSectionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case kccoursesection.EdgeChapter:
		if id := m.chapter; id != nil {
			return []ent.Value{*id}
		}
	case kccoursesection.EdgeCourseSmallSections:
		ids := make([]ent.Value, 0, len(m.course_small_sections))
		for id := range m.course_small_sections {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *KcCourseSectionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcourse_small_sections != nil {
		edges = append(edges, kccoursesection.EdgeCourseSmallSections)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *KcCourseSectionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case kccoursesection.EdgeCourseSmallSections:
		ids := make([]ent.Value, 0, len(m.removedcourse_small_sections))
		for id := range m.removedcourse_small_sections {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *KcCourseSectionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedchapter {
		edges = append(edges, kccoursesection.EdgeChapter)
	}
	if m.clearedcourse_small_sections {
		edges = append(edges, kccoursesection.EdgeCourseSmallSections)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *KcCourseSectionMutation) EdgeCleared(name string) bool {
	switch name {
	case kccoursesection.EdgeChapter:
		return m.clearedchapter
	case kccoursesection.EdgeCourseSmallSections:
		return m.clearedcourse_small_sections
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *KcCourseSectionMutation) ClearEdge(name string) error {
	switch name {
	case kccoursesection.EdgeChapter:
		m.ClearChapter()
		return nil
	}
	return fmt.Errorf("unknown KcCourseSection unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *KcCourseSectionMutation) ResetEdge(name string) error {
	switch name {
	case kccoursesection.EdgeChapter:
		m.ResetChapter()
		return nil
	case kccoursesection.EdgeCourseSmallSections:
		m.ResetCourseSmallSections()
		return nil
	}
	return fmt.Errorf("unknown KcCourseSection edge %s", name)
}

// KcCourseSmallCategoryMutation represents an operation that mutates the KcCourseSmallCategory nodes in the graph.
type KcCourseSmallCategoryMutation struct {
	config
	op                                       Op
	typ                                      string
	id                                       *int
	uuid                                     *string
	created_at                               *time.Time
	updated_at                               *time.Time
	deleted_at                               *time.Time
	small_name                               *string
	viewing_time                             *int
	addviewing_time                          *int
	finish_type                              *uint8
	addfinish_type                           *uint8
	teach_type                               *uint8
	addteach_type                            *uint8
	_type                                    *uint8
	add_type                                 *uint8
	live_small_start                         *time.Time
	live_small_status                        *int8
	addlive_small_status                     *int8
	live_room_id                             *int
	addlive_room_id                          *int
	back_video_id                            *int
	addback_video_id                         *int
	false_video_id                           *int
	addfalse_video_id                        *int
	order_video_id                           *int
	addorder_video_id                        *int
	live_small_time                          *int
	addlive_small_time                       *int
	push_status                              *uint8
	addpush_status                           *uint8
	live_small_remark                        *string
	courseware_name                          *string
	attachment_count                         *int
	addattachment_count                      *int
	question_count                           *int
	addquestion_count                        *int
	exam_count                               *int
	addexam_count                            *int
	homework_count                           *int
	addhomework_count                        *int
	study_count                              *int
	addstudy_count                           *int
	finish_count                             *int
	addfinish_count                          *int
	average_view_duration                    *int
	addaverage_view_duration                 *int
	clearedFields                            map[string]struct{}
	course                                   *int
	clearedcourse                            bool
	chapter                                  *int
	clearedchapter                           bool
	section                                  *int
	clearedsection                           bool
	course_small_category_attachments        map[int]struct{}
	removedcourse_small_category_attachments map[int]struct{}
	clearedcourse_small_category_attachments bool
	course_small_category_exampapers         map[int]struct{}
	removedcourse_small_category_exampapers  map[int]struct{}
	clearedcourse_small_category_exampapers  bool
	course_small_category_questions          map[int]struct{}
	removedcourse_small_category_questions   map[int]struct{}
	clearedcourse_small_category_questions   bool
	course_appraise_smalls                   map[int]struct{}
	removedcourse_appraise_smalls            map[int]struct{}
	clearedcourse_appraise_smalls            bool
	video_record_small                       map[int]struct{}
	removedvideo_record_small                map[int]struct{}
	clearedvideo_record_small                bool
	cs_attachment                            *int
	clearedcs_attachment                     bool
	od_attachment                            *int
	clearedod_attachment                     bool
	done                                     bool
	oldValue                                 func(context.Context) (*KcCourseSmallCategory, error)
	predicates                               []predicate.KcCourseSmallCategory
}

var _ ent.Mutation = (*KcCourseSmallCategoryMutation)(nil)

// kccoursesmallcategoryOption allows management of the mutation configuration using functional options.
type kccoursesmallcategoryOption func(*KcCourseSmallCategoryMutation)

// newKcCourseSmallCategoryMutation creates new mutation for the KcCourseSmallCategory entity.
func newKcCourseSmallCategoryMutation(c config, op Op, opts ...kccoursesmallcategoryOption) *KcCourseSmallCategoryMutation {
	m := &KcCourseSmallCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeKcCourseSmallCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withKcCourseSmallCategoryID sets the ID field of the mutation.
func withKcCourseSmallCategoryID(id int) kccoursesmallcategoryOption {
	return func(m *KcCourseSmallCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *KcCourseSmallCategory
		)
		m.oldValue = func(ctx context.Context) (*KcCourseSmallCategory, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().KcCourseSmallCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withKcCourseSmallCategory sets the old KcCourseSmallCategory of the mutation.
func withKcCourseSmallCategory(node *KcCourseSmallCategory) kccoursesmallcategoryOption {
	return func(m *KcCourseSmallCategoryMutation) {
		m.oldValue = func(context.Context) (*KcCourseSmallCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m KcCourseSmallCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m KcCourseSmallCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *KcCourseSmallCategoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *KcCourseSmallCategoryMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *KcCourseSmallCategoryMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the KcCourseSmallCategory entity.
// If the KcCourseSmallCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcCourseSmallCategoryMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *KcCourseSmallCategoryMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *KcCourseSmallCategoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *KcCourseSmallCategoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the KcCourseSmallCategory entity.
// If the KcCourseSmallCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcCourseSmallCategoryMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *KcCourseSmallCategoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[kccoursesmallcategory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *KcCourseSmallCategoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[kccoursesmallcategory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *KcCourseSmallCategoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, kccoursesmallcategory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *KcCourseSmallCategoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *KcCourseSmallCategoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the KcCourseSmallCategory entity.
// If the KcCourseSmallCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcCourseSmallCategoryMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *KcCourseSmallCategoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[kccoursesmallcategory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *KcCourseSmallCategoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[kccoursesmallcategory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *KcCourseSmallCategoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, kccoursesmallcategory.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *KcCourseSmallCategoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *KcCourseSmallCategoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the KcCourseSmallCategory entity.
// If the KcCourseSmallCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcCourseSmallCategoryMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *KcCourseSmallCategoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[kccoursesmallcategory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *KcCourseSmallCategoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[kccoursesmallcategory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *KcCourseSmallCategoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, kccoursesmallcategory.FieldDeletedAt)
}

// SetSmallName sets the "small_name" field.
func (m *KcCourseSmallCategoryMutation) SetSmallName(s string) {
	m.small_name = &s
}

// SmallName returns the value of the "small_name" field in the mutation.
func (m *KcCourseSmallCategoryMutation) SmallName() (r string, exists bool) {
	v := m.small_name
	if v == nil {
		return
	}
	return *v, true
}

// OldSmallName returns the old "small_name" field's value of the KcCourseSmallCategory entity.
// If the KcCourseSmallCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcCourseSmallCategoryMutation) OldSmallName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSmallName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSmallName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSmallName: %w", err)
	}
	return oldValue.SmallName, nil
}

// ResetSmallName resets all changes to the "small_name" field.
func (m *KcCourseSmallCategoryMutation) ResetSmallName() {
	m.small_name = nil
}

// SetViewingTime sets the "viewing_time" field.
func (m *KcCourseSmallCategoryMutation) SetViewingTime(i int) {
	m.viewing_time = &i
	m.addviewing_time = nil
}

// ViewingTime returns the value of the "viewing_time" field in the mutation.
func (m *KcCourseSmallCategoryMutation) ViewingTime() (r int, exists bool) {
	v := m.viewing_time
	if v == nil {
		return
	}
	return *v, true
}

// OldViewingTime returns the old "viewing_time" field's value of the KcCourseSmallCategory entity.
// If the KcCourseSmallCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcCourseSmallCategoryMutation) OldViewingTime(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldViewingTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldViewingTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldViewingTime: %w", err)
	}
	return oldValue.ViewingTime, nil
}

// AddViewingTime adds i to the "viewing_time" field.
func (m *KcCourseSmallCategoryMutation) AddViewingTime(i int) {
	if m.addviewing_time != nil {
		*m.addviewing_time += i
	} else {
		m.addviewing_time = &i
	}
}

// AddedViewingTime returns the value that was added to the "viewing_time" field in this mutation.
func (m *KcCourseSmallCategoryMutation) AddedViewingTime() (r int, exists bool) {
	v := m.addviewing_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetViewingTime resets all changes to the "viewing_time" field.
func (m *KcCourseSmallCategoryMutation) ResetViewingTime() {
	m.viewing_time = nil
	m.addviewing_time = nil
}

// SetFinishType sets the "finish_type" field.
func (m *KcCourseSmallCategoryMutation) SetFinishType(u uint8) {
	m.finish_type = &u
	m.addfinish_type = nil
}

// FinishType returns the value of the "finish_type" field in the mutation.
func (m *KcCourseSmallCategoryMutation) FinishType() (r uint8, exists bool) {
	v := m.finish_type
	if v == nil {
		return
	}
	return *v, true
}

// OldFinishType returns the old "finish_type" field's value of the KcCourseSmallCategory entity.
// If the KcCourseSmallCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcCourseSmallCategoryMutation) OldFinishType(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFinishType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFinishType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinishType: %w", err)
	}
	return oldValue.FinishType, nil
}

// AddFinishType adds u to the "finish_type" field.
func (m *KcCourseSmallCategoryMutation) AddFinishType(u uint8) {
	if m.addfinish_type != nil {
		*m.addfinish_type += u
	} else {
		m.addfinish_type = &u
	}
}

// AddedFinishType returns the value that was added to the "finish_type" field in this mutation.
func (m *KcCourseSmallCategoryMutation) AddedFinishType() (r uint8, exists bool) {
	v := m.addfinish_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetFinishType resets all changes to the "finish_type" field.
func (m *KcCourseSmallCategoryMutation) ResetFinishType() {
	m.finish_type = nil
	m.addfinish_type = nil
}

// SetTeachType sets the "teach_type" field.
func (m *KcCourseSmallCategoryMutation) SetTeachType(u uint8) {
	m.teach_type = &u
	m.addteach_type = nil
}

// TeachType returns the value of the "teach_type" field in the mutation.
func (m *KcCourseSmallCategoryMutation) TeachType() (r uint8, exists bool) {
	v := m.teach_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTeachType returns the old "teach_type" field's value of the KcCourseSmallCategory entity.
// If the KcCourseSmallCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcCourseSmallCategoryMutation) OldTeachType(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTeachType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTeachType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeachType: %w", err)
	}
	return oldValue.TeachType, nil
}

// AddTeachType adds u to the "teach_type" field.
func (m *KcCourseSmallCategoryMutation) AddTeachType(u uint8) {
	if m.addteach_type != nil {
		*m.addteach_type += u
	} else {
		m.addteach_type = &u
	}
}

// AddedTeachType returns the value that was added to the "teach_type" field in this mutation.
func (m *KcCourseSmallCategoryMutation) AddedTeachType() (r uint8, exists bool) {
	v := m.addteach_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetTeachType resets all changes to the "teach_type" field.
func (m *KcCourseSmallCategoryMutation) ResetTeachType() {
	m.teach_type = nil
	m.addteach_type = nil
}

// SetType sets the "type" field.
func (m *KcCourseSmallCategoryMutation) SetType(u uint8) {
	m._type = &u
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *KcCourseSmallCategoryMutation) GetType() (r uint8, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the KcCourseSmallCategory entity.
// If the KcCourseSmallCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcCourseSmallCategoryMutation) OldType(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds u to the "type" field.
func (m *KcCourseSmallCategoryMutation) AddType(u uint8) {
	if m.add_type != nil {
		*m.add_type += u
	} else {
		m.add_type = &u
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *KcCourseSmallCategoryMutation) AddedType() (r uint8, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *KcCourseSmallCategoryMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetLiveSmallStart sets the "live_small_start" field.
func (m *KcCourseSmallCategoryMutation) SetLiveSmallStart(t time.Time) {
	m.live_small_start = &t
}

// LiveSmallStart returns the value of the "live_small_start" field in the mutation.
func (m *KcCourseSmallCategoryMutation) LiveSmallStart() (r time.Time, exists bool) {
	v := m.live_small_start
	if v == nil {
		return
	}
	return *v, true
}

// OldLiveSmallStart returns the old "live_small_start" field's value of the KcCourseSmallCategory entity.
// If the KcCourseSmallCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcCourseSmallCategoryMutation) OldLiveSmallStart(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLiveSmallStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLiveSmallStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLiveSmallStart: %w", err)
	}
	return oldValue.LiveSmallStart, nil
}

// ClearLiveSmallStart clears the value of the "live_small_start" field.
func (m *KcCourseSmallCategoryMutation) ClearLiveSmallStart() {
	m.live_small_start = nil
	m.clearedFields[kccoursesmallcategory.FieldLiveSmallStart] = struct{}{}
}

// LiveSmallStartCleared returns if the "live_small_start" field was cleared in this mutation.
func (m *KcCourseSmallCategoryMutation) LiveSmallStartCleared() bool {
	_, ok := m.clearedFields[kccoursesmallcategory.FieldLiveSmallStart]
	return ok
}

// ResetLiveSmallStart resets all changes to the "live_small_start" field.
func (m *KcCourseSmallCategoryMutation) ResetLiveSmallStart() {
	m.live_small_start = nil
	delete(m.clearedFields, kccoursesmallcategory.FieldLiveSmallStart)
}

// SetLiveSmallStatus sets the "live_small_status" field.
func (m *KcCourseSmallCategoryMutation) SetLiveSmallStatus(i int8) {
	m.live_small_status = &i
	m.addlive_small_status = nil
}

// LiveSmallStatus returns the value of the "live_small_status" field in the mutation.
func (m *KcCourseSmallCategoryMutation) LiveSmallStatus() (r int8, exists bool) {
	v := m.live_small_status
	if v == nil {
		return
	}
	return *v, true
}

// OldLiveSmallStatus returns the old "live_small_status" field's value of the KcCourseSmallCategory entity.
// If the KcCourseSmallCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcCourseSmallCategoryMutation) OldLiveSmallStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLiveSmallStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLiveSmallStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLiveSmallStatus: %w", err)
	}
	return oldValue.LiveSmallStatus, nil
}

// AddLiveSmallStatus adds i to the "live_small_status" field.
func (m *KcCourseSmallCategoryMutation) AddLiveSmallStatus(i int8) {
	if m.addlive_small_status != nil {
		*m.addlive_small_status += i
	} else {
		m.addlive_small_status = &i
	}
}

// AddedLiveSmallStatus returns the value that was added to the "live_small_status" field in this mutation.
func (m *KcCourseSmallCategoryMutation) AddedLiveSmallStatus() (r int8, exists bool) {
	v := m.addlive_small_status
	if v == nil {
		return
	}
	return *v, true
}

// ResetLiveSmallStatus resets all changes to the "live_small_status" field.
func (m *KcCourseSmallCategoryMutation) ResetLiveSmallStatus() {
	m.live_small_status = nil
	m.addlive_small_status = nil
}

// SetLiveRoomID sets the "live_room_id" field.
func (m *KcCourseSmallCategoryMutation) SetLiveRoomID(i int) {
	m.live_room_id = &i
	m.addlive_room_id = nil
}

// LiveRoomID returns the value of the "live_room_id" field in the mutation.
func (m *KcCourseSmallCategoryMutation) LiveRoomID() (r int, exists bool) {
	v := m.live_room_id
	if v == nil {
		return
	}
	return *v, true
}

// OldLiveRoomID returns the old "live_room_id" field's value of the KcCourseSmallCategory entity.
// If the KcCourseSmallCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcCourseSmallCategoryMutation) OldLiveRoomID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLiveRoomID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLiveRoomID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLiveRoomID: %w", err)
	}
	return oldValue.LiveRoomID, nil
}

// AddLiveRoomID adds i to the "live_room_id" field.
func (m *KcCourseSmallCategoryMutation) AddLiveRoomID(i int) {
	if m.addlive_room_id != nil {
		*m.addlive_room_id += i
	} else {
		m.addlive_room_id = &i
	}
}

// AddedLiveRoomID returns the value that was added to the "live_room_id" field in this mutation.
func (m *KcCourseSmallCategoryMutation) AddedLiveRoomID() (r int, exists bool) {
	v := m.addlive_room_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearLiveRoomID clears the value of the "live_room_id" field.
func (m *KcCourseSmallCategoryMutation) ClearLiveRoomID() {
	m.live_room_id = nil
	m.addlive_room_id = nil
	m.clearedFields[kccoursesmallcategory.FieldLiveRoomID] = struct{}{}
}

// LiveRoomIDCleared returns if the "live_room_id" field was cleared in this mutation.
func (m *KcCourseSmallCategoryMutation) LiveRoomIDCleared() bool {
	_, ok := m.clearedFields[kccoursesmallcategory.FieldLiveRoomID]
	return ok
}

// ResetLiveRoomID resets all changes to the "live_room_id" field.
func (m *KcCourseSmallCategoryMutation) ResetLiveRoomID() {
	m.live_room_id = nil
	m.addlive_room_id = nil
	delete(m.clearedFields, kccoursesmallcategory.FieldLiveRoomID)
}

// SetBackVideoID sets the "back_video_id" field.
func (m *KcCourseSmallCategoryMutation) SetBackVideoID(i int) {
	m.back_video_id = &i
	m.addback_video_id = nil
}

// BackVideoID returns the value of the "back_video_id" field in the mutation.
func (m *KcCourseSmallCategoryMutation) BackVideoID() (r int, exists bool) {
	v := m.back_video_id
	if v == nil {
		return
	}
	return *v, true
}

// OldBackVideoID returns the old "back_video_id" field's value of the KcCourseSmallCategory entity.
// If the KcCourseSmallCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcCourseSmallCategoryMutation) OldBackVideoID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBackVideoID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBackVideoID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBackVideoID: %w", err)
	}
	return oldValue.BackVideoID, nil
}

// AddBackVideoID adds i to the "back_video_id" field.
func (m *KcCourseSmallCategoryMutation) AddBackVideoID(i int) {
	if m.addback_video_id != nil {
		*m.addback_video_id += i
	} else {
		m.addback_video_id = &i
	}
}

// AddedBackVideoID returns the value that was added to the "back_video_id" field in this mutation.
func (m *KcCourseSmallCategoryMutation) AddedBackVideoID() (r int, exists bool) {
	v := m.addback_video_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearBackVideoID clears the value of the "back_video_id" field.
func (m *KcCourseSmallCategoryMutation) ClearBackVideoID() {
	m.back_video_id = nil
	m.addback_video_id = nil
	m.clearedFields[kccoursesmallcategory.FieldBackVideoID] = struct{}{}
}

// BackVideoIDCleared returns if the "back_video_id" field was cleared in this mutation.
func (m *KcCourseSmallCategoryMutation) BackVideoIDCleared() bool {
	_, ok := m.clearedFields[kccoursesmallcategory.FieldBackVideoID]
	return ok
}

// ResetBackVideoID resets all changes to the "back_video_id" field.
func (m *KcCourseSmallCategoryMutation) ResetBackVideoID() {
	m.back_video_id = nil
	m.addback_video_id = nil
	delete(m.clearedFields, kccoursesmallcategory.FieldBackVideoID)
}

// SetFalseVideoID sets the "false_video_id" field.
func (m *KcCourseSmallCategoryMutation) SetFalseVideoID(i int) {
	m.false_video_id = &i
	m.addfalse_video_id = nil
}

// FalseVideoID returns the value of the "false_video_id" field in the mutation.
func (m *KcCourseSmallCategoryMutation) FalseVideoID() (r int, exists bool) {
	v := m.false_video_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFalseVideoID returns the old "false_video_id" field's value of the KcCourseSmallCategory entity.
// If the KcCourseSmallCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcCourseSmallCategoryMutation) OldFalseVideoID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFalseVideoID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFalseVideoID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFalseVideoID: %w", err)
	}
	return oldValue.FalseVideoID, nil
}

// AddFalseVideoID adds i to the "false_video_id" field.
func (m *KcCourseSmallCategoryMutation) AddFalseVideoID(i int) {
	if m.addfalse_video_id != nil {
		*m.addfalse_video_id += i
	} else {
		m.addfalse_video_id = &i
	}
}

// AddedFalseVideoID returns the value that was added to the "false_video_id" field in this mutation.
func (m *KcCourseSmallCategoryMutation) AddedFalseVideoID() (r int, exists bool) {
	v := m.addfalse_video_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearFalseVideoID clears the value of the "false_video_id" field.
func (m *KcCourseSmallCategoryMutation) ClearFalseVideoID() {
	m.false_video_id = nil
	m.addfalse_video_id = nil
	m.clearedFields[kccoursesmallcategory.FieldFalseVideoID] = struct{}{}
}

// FalseVideoIDCleared returns if the "false_video_id" field was cleared in this mutation.
func (m *KcCourseSmallCategoryMutation) FalseVideoIDCleared() bool {
	_, ok := m.clearedFields[kccoursesmallcategory.FieldFalseVideoID]
	return ok
}

// ResetFalseVideoID resets all changes to the "false_video_id" field.
func (m *KcCourseSmallCategoryMutation) ResetFalseVideoID() {
	m.false_video_id = nil
	m.addfalse_video_id = nil
	delete(m.clearedFields, kccoursesmallcategory.FieldFalseVideoID)
}

// SetOrderVideoID sets the "order_video_id" field.
func (m *KcCourseSmallCategoryMutation) SetOrderVideoID(i int) {
	m.order_video_id = &i
	m.addorder_video_id = nil
}

// OrderVideoID returns the value of the "order_video_id" field in the mutation.
func (m *KcCourseSmallCategoryMutation) OrderVideoID() (r int, exists bool) {
	v := m.order_video_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderVideoID returns the old "order_video_id" field's value of the KcCourseSmallCategory entity.
// If the KcCourseSmallCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcCourseSmallCategoryMutation) OldOrderVideoID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOrderVideoID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOrderVideoID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderVideoID: %w", err)
	}
	return oldValue.OrderVideoID, nil
}

// AddOrderVideoID adds i to the "order_video_id" field.
func (m *KcCourseSmallCategoryMutation) AddOrderVideoID(i int) {
	if m.addorder_video_id != nil {
		*m.addorder_video_id += i
	} else {
		m.addorder_video_id = &i
	}
}

// AddedOrderVideoID returns the value that was added to the "order_video_id" field in this mutation.
func (m *KcCourseSmallCategoryMutation) AddedOrderVideoID() (r int, exists bool) {
	v := m.addorder_video_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearOrderVideoID clears the value of the "order_video_id" field.
func (m *KcCourseSmallCategoryMutation) ClearOrderVideoID() {
	m.order_video_id = nil
	m.addorder_video_id = nil
	m.clearedFields[kccoursesmallcategory.FieldOrderVideoID] = struct{}{}
}

// OrderVideoIDCleared returns if the "order_video_id" field was cleared in this mutation.
func (m *KcCourseSmallCategoryMutation) OrderVideoIDCleared() bool {
	_, ok := m.clearedFields[kccoursesmallcategory.FieldOrderVideoID]
	return ok
}

// ResetOrderVideoID resets all changes to the "order_video_id" field.
func (m *KcCourseSmallCategoryMutation) ResetOrderVideoID() {
	m.order_video_id = nil
	m.addorder_video_id = nil
	delete(m.clearedFields, kccoursesmallcategory.FieldOrderVideoID)
}

// SetOrderVideoAttachID sets the "order_video_attach_id" field.
func (m *KcCourseSmallCategoryMutation) SetOrderVideoAttachID(i int) {
	m.od_attachment = &i
}

// OrderVideoAttachID returns the value of the "order_video_attach_id" field in the mutation.
func (m *KcCourseSmallCategoryMutation) OrderVideoAttachID() (r int, exists bool) {
	v := m.od_attachment
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderVideoAttachID returns the old "order_video_attach_id" field's value of the KcCourseSmallCategory entity.
// If the KcCourseSmallCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcCourseSmallCategoryMutation) OldOrderVideoAttachID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOrderVideoAttachID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOrderVideoAttachID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderVideoAttachID: %w", err)
	}
	return oldValue.OrderVideoAttachID, nil
}

// ClearOrderVideoAttachID clears the value of the "order_video_attach_id" field.
func (m *KcCourseSmallCategoryMutation) ClearOrderVideoAttachID() {
	m.od_attachment = nil
	m.clearedFields[kccoursesmallcategory.FieldOrderVideoAttachID] = struct{}{}
}

// OrderVideoAttachIDCleared returns if the "order_video_attach_id" field was cleared in this mutation.
func (m *KcCourseSmallCategoryMutation) OrderVideoAttachIDCleared() bool {
	_, ok := m.clearedFields[kccoursesmallcategory.FieldOrderVideoAttachID]
	return ok
}

// ResetOrderVideoAttachID resets all changes to the "order_video_attach_id" field.
func (m *KcCourseSmallCategoryMutation) ResetOrderVideoAttachID() {
	m.od_attachment = nil
	delete(m.clearedFields, kccoursesmallcategory.FieldOrderVideoAttachID)
}

// SetLiveSmallTime sets the "live_small_time" field.
func (m *KcCourseSmallCategoryMutation) SetLiveSmallTime(i int) {
	m.live_small_time = &i
	m.addlive_small_time = nil
}

// LiveSmallTime returns the value of the "live_small_time" field in the mutation.
func (m *KcCourseSmallCategoryMutation) LiveSmallTime() (r int, exists bool) {
	v := m.live_small_time
	if v == nil {
		return
	}
	return *v, true
}

// OldLiveSmallTime returns the old "live_small_time" field's value of the KcCourseSmallCategory entity.
// If the KcCourseSmallCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcCourseSmallCategoryMutation) OldLiveSmallTime(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLiveSmallTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLiveSmallTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLiveSmallTime: %w", err)
	}
	return oldValue.LiveSmallTime, nil
}

// AddLiveSmallTime adds i to the "live_small_time" field.
func (m *KcCourseSmallCategoryMutation) AddLiveSmallTime(i int) {
	if m.addlive_small_time != nil {
		*m.addlive_small_time += i
	} else {
		m.addlive_small_time = &i
	}
}

// AddedLiveSmallTime returns the value that was added to the "live_small_time" field in this mutation.
func (m *KcCourseSmallCategoryMutation) AddedLiveSmallTime() (r int, exists bool) {
	v := m.addlive_small_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetLiveSmallTime resets all changes to the "live_small_time" field.
func (m *KcCourseSmallCategoryMutation) ResetLiveSmallTime() {
	m.live_small_time = nil
	m.addlive_small_time = nil
}

// SetPushStatus sets the "push_status" field.
func (m *KcCourseSmallCategoryMutation) SetPushStatus(u uint8) {
	m.push_status = &u
	m.addpush_status = nil
}

// PushStatus returns the value of the "push_status" field in the mutation.
func (m *KcCourseSmallCategoryMutation) PushStatus() (r uint8, exists bool) {
	v := m.push_status
	if v == nil {
		return
	}
	return *v, true
}

// OldPushStatus returns the old "push_status" field's value of the KcCourseSmallCategory entity.
// If the KcCourseSmallCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcCourseSmallCategoryMutation) OldPushStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPushStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPushStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPushStatus: %w", err)
	}
	return oldValue.PushStatus, nil
}

// AddPushStatus adds u to the "push_status" field.
func (m *KcCourseSmallCategoryMutation) AddPushStatus(u uint8) {
	if m.addpush_status != nil {
		*m.addpush_status += u
	} else {
		m.addpush_status = &u
	}
}

// AddedPushStatus returns the value that was added to the "push_status" field in this mutation.
func (m *KcCourseSmallCategoryMutation) AddedPushStatus() (r uint8, exists bool) {
	v := m.addpush_status
	if v == nil {
		return
	}
	return *v, true
}

// ResetPushStatus resets all changes to the "push_status" field.
func (m *KcCourseSmallCategoryMutation) ResetPushStatus() {
	m.push_status = nil
	m.addpush_status = nil
}

// SetLiveSmallRemark sets the "live_small_remark" field.
func (m *KcCourseSmallCategoryMutation) SetLiveSmallRemark(s string) {
	m.live_small_remark = &s
}

// LiveSmallRemark returns the value of the "live_small_remark" field in the mutation.
func (m *KcCourseSmallCategoryMutation) LiveSmallRemark() (r string, exists bool) {
	v := m.live_small_remark
	if v == nil {
		return
	}
	return *v, true
}

// OldLiveSmallRemark returns the old "live_small_remark" field's value of the KcCourseSmallCategory entity.
// If the KcCourseSmallCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcCourseSmallCategoryMutation) OldLiveSmallRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLiveSmallRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLiveSmallRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLiveSmallRemark: %w", err)
	}
	return oldValue.LiveSmallRemark, nil
}

// ResetLiveSmallRemark resets all changes to the "live_small_remark" field.
func (m *KcCourseSmallCategoryMutation) ResetLiveSmallRemark() {
	m.live_small_remark = nil
}

// SetCoursewareAttachID sets the "courseware_attach_id" field.
func (m *KcCourseSmallCategoryMutation) SetCoursewareAttachID(i int) {
	m.cs_attachment = &i
}

// CoursewareAttachID returns the value of the "courseware_attach_id" field in the mutation.
func (m *KcCourseSmallCategoryMutation) CoursewareAttachID() (r int, exists bool) {
	v := m.cs_attachment
	if v == nil {
		return
	}
	return *v, true
}

// OldCoursewareAttachID returns the old "courseware_attach_id" field's value of the KcCourseSmallCategory entity.
// If the KcCourseSmallCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcCourseSmallCategoryMutation) OldCoursewareAttachID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCoursewareAttachID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCoursewareAttachID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoursewareAttachID: %w", err)
	}
	return oldValue.CoursewareAttachID, nil
}

// ClearCoursewareAttachID clears the value of the "courseware_attach_id" field.
func (m *KcCourseSmallCategoryMutation) ClearCoursewareAttachID() {
	m.cs_attachment = nil
	m.clearedFields[kccoursesmallcategory.FieldCoursewareAttachID] = struct{}{}
}

// CoursewareAttachIDCleared returns if the "courseware_attach_id" field was cleared in this mutation.
func (m *KcCourseSmallCategoryMutation) CoursewareAttachIDCleared() bool {
	_, ok := m.clearedFields[kccoursesmallcategory.FieldCoursewareAttachID]
	return ok
}

// ResetCoursewareAttachID resets all changes to the "courseware_attach_id" field.
func (m *KcCourseSmallCategoryMutation) ResetCoursewareAttachID() {
	m.cs_attachment = nil
	delete(m.clearedFields, kccoursesmallcategory.FieldCoursewareAttachID)
}

// SetCoursewareName sets the "courseware_name" field.
func (m *KcCourseSmallCategoryMutation) SetCoursewareName(s string) {
	m.courseware_name = &s
}

// CoursewareName returns the value of the "courseware_name" field in the mutation.
func (m *KcCourseSmallCategoryMutation) CoursewareName() (r string, exists bool) {
	v := m.courseware_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCoursewareName returns the old "courseware_name" field's value of the KcCourseSmallCategory entity.
// If the KcCourseSmallCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcCourseSmallCategoryMutation) OldCoursewareName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCoursewareName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCoursewareName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoursewareName: %w", err)
	}
	return oldValue.CoursewareName, nil
}

// ResetCoursewareName resets all changes to the "courseware_name" field.
func (m *KcCourseSmallCategoryMutation) ResetCoursewareName() {
	m.courseware_name = nil
}

// SetAttachmentCount sets the "attachment_count" field.
func (m *KcCourseSmallCategoryMutation) SetAttachmentCount(i int) {
	m.attachment_count = &i
	m.addattachment_count = nil
}

// AttachmentCount returns the value of the "attachment_count" field in the mutation.
func (m *KcCourseSmallCategoryMutation) AttachmentCount() (r int, exists bool) {
	v := m.attachment_count
	if v == nil {
		return
	}
	return *v, true
}

// OldAttachmentCount returns the old "attachment_count" field's value of the KcCourseSmallCategory entity.
// If the KcCourseSmallCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcCourseSmallCategoryMutation) OldAttachmentCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAttachmentCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAttachmentCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttachmentCount: %w", err)
	}
	return oldValue.AttachmentCount, nil
}

// AddAttachmentCount adds i to the "attachment_count" field.
func (m *KcCourseSmallCategoryMutation) AddAttachmentCount(i int) {
	if m.addattachment_count != nil {
		*m.addattachment_count += i
	} else {
		m.addattachment_count = &i
	}
}

// AddedAttachmentCount returns the value that was added to the "attachment_count" field in this mutation.
func (m *KcCourseSmallCategoryMutation) AddedAttachmentCount() (r int, exists bool) {
	v := m.addattachment_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetAttachmentCount resets all changes to the "attachment_count" field.
func (m *KcCourseSmallCategoryMutation) ResetAttachmentCount() {
	m.attachment_count = nil
	m.addattachment_count = nil
}

// SetQuestionCount sets the "question_count" field.
func (m *KcCourseSmallCategoryMutation) SetQuestionCount(i int) {
	m.question_count = &i
	m.addquestion_count = nil
}

// QuestionCount returns the value of the "question_count" field in the mutation.
func (m *KcCourseSmallCategoryMutation) QuestionCount() (r int, exists bool) {
	v := m.question_count
	if v == nil {
		return
	}
	return *v, true
}

// OldQuestionCount returns the old "question_count" field's value of the KcCourseSmallCategory entity.
// If the KcCourseSmallCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcCourseSmallCategoryMutation) OldQuestionCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldQuestionCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldQuestionCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuestionCount: %w", err)
	}
	return oldValue.QuestionCount, nil
}

// AddQuestionCount adds i to the "question_count" field.
func (m *KcCourseSmallCategoryMutation) AddQuestionCount(i int) {
	if m.addquestion_count != nil {
		*m.addquestion_count += i
	} else {
		m.addquestion_count = &i
	}
}

// AddedQuestionCount returns the value that was added to the "question_count" field in this mutation.
func (m *KcCourseSmallCategoryMutation) AddedQuestionCount() (r int, exists bool) {
	v := m.addquestion_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuestionCount resets all changes to the "question_count" field.
func (m *KcCourseSmallCategoryMutation) ResetQuestionCount() {
	m.question_count = nil
	m.addquestion_count = nil
}

// SetExamCount sets the "exam_count" field.
func (m *KcCourseSmallCategoryMutation) SetExamCount(i int) {
	m.exam_count = &i
	m.addexam_count = nil
}

// ExamCount returns the value of the "exam_count" field in the mutation.
func (m *KcCourseSmallCategoryMutation) ExamCount() (r int, exists bool) {
	v := m.exam_count
	if v == nil {
		return
	}
	return *v, true
}

// OldExamCount returns the old "exam_count" field's value of the KcCourseSmallCategory entity.
// If the KcCourseSmallCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcCourseSmallCategoryMutation) OldExamCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExamCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExamCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamCount: %w", err)
	}
	return oldValue.ExamCount, nil
}

// AddExamCount adds i to the "exam_count" field.
func (m *KcCourseSmallCategoryMutation) AddExamCount(i int) {
	if m.addexam_count != nil {
		*m.addexam_count += i
	} else {
		m.addexam_count = &i
	}
}

// AddedExamCount returns the value that was added to the "exam_count" field in this mutation.
func (m *KcCourseSmallCategoryMutation) AddedExamCount() (r int, exists bool) {
	v := m.addexam_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetExamCount resets all changes to the "exam_count" field.
func (m *KcCourseSmallCategoryMutation) ResetExamCount() {
	m.exam_count = nil
	m.addexam_count = nil
}

// SetHomeworkCount sets the "homework_count" field.
func (m *KcCourseSmallCategoryMutation) SetHomeworkCount(i int) {
	m.homework_count = &i
	m.addhomework_count = nil
}

// HomeworkCount returns the value of the "homework_count" field in the mutation.
func (m *KcCourseSmallCategoryMutation) HomeworkCount() (r int, exists bool) {
	v := m.homework_count
	if v == nil {
		return
	}
	return *v, true
}

// OldHomeworkCount returns the old "homework_count" field's value of the KcCourseSmallCategory entity.
// If the KcCourseSmallCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcCourseSmallCategoryMutation) OldHomeworkCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHomeworkCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHomeworkCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHomeworkCount: %w", err)
	}
	return oldValue.HomeworkCount, nil
}

// AddHomeworkCount adds i to the "homework_count" field.
func (m *KcCourseSmallCategoryMutation) AddHomeworkCount(i int) {
	if m.addhomework_count != nil {
		*m.addhomework_count += i
	} else {
		m.addhomework_count = &i
	}
}

// AddedHomeworkCount returns the value that was added to the "homework_count" field in this mutation.
func (m *KcCourseSmallCategoryMutation) AddedHomeworkCount() (r int, exists bool) {
	v := m.addhomework_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetHomeworkCount resets all changes to the "homework_count" field.
func (m *KcCourseSmallCategoryMutation) ResetHomeworkCount() {
	m.homework_count = nil
	m.addhomework_count = nil
}

// SetStudyCount sets the "study_count" field.
func (m *KcCourseSmallCategoryMutation) SetStudyCount(i int) {
	m.study_count = &i
	m.addstudy_count = nil
}

// StudyCount returns the value of the "study_count" field in the mutation.
func (m *KcCourseSmallCategoryMutation) StudyCount() (r int, exists bool) {
	v := m.study_count
	if v == nil {
		return
	}
	return *v, true
}

// OldStudyCount returns the old "study_count" field's value of the KcCourseSmallCategory entity.
// If the KcCourseSmallCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcCourseSmallCategoryMutation) OldStudyCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStudyCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStudyCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStudyCount: %w", err)
	}
	return oldValue.StudyCount, nil
}

// AddStudyCount adds i to the "study_count" field.
func (m *KcCourseSmallCategoryMutation) AddStudyCount(i int) {
	if m.addstudy_count != nil {
		*m.addstudy_count += i
	} else {
		m.addstudy_count = &i
	}
}

// AddedStudyCount returns the value that was added to the "study_count" field in this mutation.
func (m *KcCourseSmallCategoryMutation) AddedStudyCount() (r int, exists bool) {
	v := m.addstudy_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetStudyCount resets all changes to the "study_count" field.
func (m *KcCourseSmallCategoryMutation) ResetStudyCount() {
	m.study_count = nil
	m.addstudy_count = nil
}

// SetFinishCount sets the "finish_count" field.
func (m *KcCourseSmallCategoryMutation) SetFinishCount(i int) {
	m.finish_count = &i
	m.addfinish_count = nil
}

// FinishCount returns the value of the "finish_count" field in the mutation.
func (m *KcCourseSmallCategoryMutation) FinishCount() (r int, exists bool) {
	v := m.finish_count
	if v == nil {
		return
	}
	return *v, true
}

// OldFinishCount returns the old "finish_count" field's value of the KcCourseSmallCategory entity.
// If the KcCourseSmallCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcCourseSmallCategoryMutation) OldFinishCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFinishCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFinishCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinishCount: %w", err)
	}
	return oldValue.FinishCount, nil
}

// AddFinishCount adds i to the "finish_count" field.
func (m *KcCourseSmallCategoryMutation) AddFinishCount(i int) {
	if m.addfinish_count != nil {
		*m.addfinish_count += i
	} else {
		m.addfinish_count = &i
	}
}

// AddedFinishCount returns the value that was added to the "finish_count" field in this mutation.
func (m *KcCourseSmallCategoryMutation) AddedFinishCount() (r int, exists bool) {
	v := m.addfinish_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetFinishCount resets all changes to the "finish_count" field.
func (m *KcCourseSmallCategoryMutation) ResetFinishCount() {
	m.finish_count = nil
	m.addfinish_count = nil
}

// SetAverageViewDuration sets the "average_view_duration" field.
func (m *KcCourseSmallCategoryMutation) SetAverageViewDuration(i int) {
	m.average_view_duration = &i
	m.addaverage_view_duration = nil
}

// AverageViewDuration returns the value of the "average_view_duration" field in the mutation.
func (m *KcCourseSmallCategoryMutation) AverageViewDuration() (r int, exists bool) {
	v := m.average_view_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldAverageViewDuration returns the old "average_view_duration" field's value of the KcCourseSmallCategory entity.
// If the KcCourseSmallCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcCourseSmallCategoryMutation) OldAverageViewDuration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAverageViewDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAverageViewDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAverageViewDuration: %w", err)
	}
	return oldValue.AverageViewDuration, nil
}

// AddAverageViewDuration adds i to the "average_view_duration" field.
func (m *KcCourseSmallCategoryMutation) AddAverageViewDuration(i int) {
	if m.addaverage_view_duration != nil {
		*m.addaverage_view_duration += i
	} else {
		m.addaverage_view_duration = &i
	}
}

// AddedAverageViewDuration returns the value that was added to the "average_view_duration" field in this mutation.
func (m *KcCourseSmallCategoryMutation) AddedAverageViewDuration() (r int, exists bool) {
	v := m.addaverage_view_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetAverageViewDuration resets all changes to the "average_view_duration" field.
func (m *KcCourseSmallCategoryMutation) ResetAverageViewDuration() {
	m.average_view_duration = nil
	m.addaverage_view_duration = nil
}

// SetCourseID sets the "course_id" field.
func (m *KcCourseSmallCategoryMutation) SetCourseID(i int) {
	m.course = &i
}

// CourseID returns the value of the "course_id" field in the mutation.
func (m *KcCourseSmallCategoryMutation) CourseID() (r int, exists bool) {
	v := m.course
	if v == nil {
		return
	}
	return *v, true
}

// OldCourseID returns the old "course_id" field's value of the KcCourseSmallCategory entity.
// If the KcCourseSmallCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcCourseSmallCategoryMutation) OldCourseID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCourseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCourseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCourseID: %w", err)
	}
	return oldValue.CourseID, nil
}

// ClearCourseID clears the value of the "course_id" field.
func (m *KcCourseSmallCategoryMutation) ClearCourseID() {
	m.course = nil
	m.clearedFields[kccoursesmallcategory.FieldCourseID] = struct{}{}
}

// CourseIDCleared returns if the "course_id" field was cleared in this mutation.
func (m *KcCourseSmallCategoryMutation) CourseIDCleared() bool {
	_, ok := m.clearedFields[kccoursesmallcategory.FieldCourseID]
	return ok
}

// ResetCourseID resets all changes to the "course_id" field.
func (m *KcCourseSmallCategoryMutation) ResetCourseID() {
	m.course = nil
	delete(m.clearedFields, kccoursesmallcategory.FieldCourseID)
}

// SetChapterID sets the "chapter_id" field.
func (m *KcCourseSmallCategoryMutation) SetChapterID(i int) {
	m.chapter = &i
}

// ChapterID returns the value of the "chapter_id" field in the mutation.
func (m *KcCourseSmallCategoryMutation) ChapterID() (r int, exists bool) {
	v := m.chapter
	if v == nil {
		return
	}
	return *v, true
}

// OldChapterID returns the old "chapter_id" field's value of the KcCourseSmallCategory entity.
// If the KcCourseSmallCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcCourseSmallCategoryMutation) OldChapterID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldChapterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldChapterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChapterID: %w", err)
	}
	return oldValue.ChapterID, nil
}

// ClearChapterID clears the value of the "chapter_id" field.
func (m *KcCourseSmallCategoryMutation) ClearChapterID() {
	m.chapter = nil
	m.clearedFields[kccoursesmallcategory.FieldChapterID] = struct{}{}
}

// ChapterIDCleared returns if the "chapter_id" field was cleared in this mutation.
func (m *KcCourseSmallCategoryMutation) ChapterIDCleared() bool {
	_, ok := m.clearedFields[kccoursesmallcategory.FieldChapterID]
	return ok
}

// ResetChapterID resets all changes to the "chapter_id" field.
func (m *KcCourseSmallCategoryMutation) ResetChapterID() {
	m.chapter = nil
	delete(m.clearedFields, kccoursesmallcategory.FieldChapterID)
}

// SetSectionID sets the "section_id" field.
func (m *KcCourseSmallCategoryMutation) SetSectionID(i int) {
	m.section = &i
}

// SectionID returns the value of the "section_id" field in the mutation.
func (m *KcCourseSmallCategoryMutation) SectionID() (r int, exists bool) {
	v := m.section
	if v == nil {
		return
	}
	return *v, true
}

// OldSectionID returns the old "section_id" field's value of the KcCourseSmallCategory entity.
// If the KcCourseSmallCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcCourseSmallCategoryMutation) OldSectionID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSectionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSectionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSectionID: %w", err)
	}
	return oldValue.SectionID, nil
}

// ClearSectionID clears the value of the "section_id" field.
func (m *KcCourseSmallCategoryMutation) ClearSectionID() {
	m.section = nil
	m.clearedFields[kccoursesmallcategory.FieldSectionID] = struct{}{}
}

// SectionIDCleared returns if the "section_id" field was cleared in this mutation.
func (m *KcCourseSmallCategoryMutation) SectionIDCleared() bool {
	_, ok := m.clearedFields[kccoursesmallcategory.FieldSectionID]
	return ok
}

// ResetSectionID resets all changes to the "section_id" field.
func (m *KcCourseSmallCategoryMutation) ResetSectionID() {
	m.section = nil
	delete(m.clearedFields, kccoursesmallcategory.FieldSectionID)
}

// ClearCourse clears the "course" edge to the KcCourse entity.
func (m *KcCourseSmallCategoryMutation) ClearCourse() {
	m.clearedcourse = true
}

// CourseCleared reports if the "course" edge to the KcCourse entity was cleared.
func (m *KcCourseSmallCategoryMutation) CourseCleared() bool {
	return m.CourseIDCleared() || m.clearedcourse
}

// CourseIDs returns the "course" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CourseID instead. It exists only for internal usage by the builders.
func (m *KcCourseSmallCategoryMutation) CourseIDs() (ids []int) {
	if id := m.course; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCourse resets all changes to the "course" edge.
func (m *KcCourseSmallCategoryMutation) ResetCourse() {
	m.course = nil
	m.clearedcourse = false
}

// ClearChapter clears the "chapter" edge to the KcCourseChapter entity.
func (m *KcCourseSmallCategoryMutation) ClearChapter() {
	m.clearedchapter = true
}

// ChapterCleared reports if the "chapter" edge to the KcCourseChapter entity was cleared.
func (m *KcCourseSmallCategoryMutation) ChapterCleared() bool {
	return m.ChapterIDCleared() || m.clearedchapter
}

// ChapterIDs returns the "chapter" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChapterID instead. It exists only for internal usage by the builders.
func (m *KcCourseSmallCategoryMutation) ChapterIDs() (ids []int) {
	if id := m.chapter; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChapter resets all changes to the "chapter" edge.
func (m *KcCourseSmallCategoryMutation) ResetChapter() {
	m.chapter = nil
	m.clearedchapter = false
}

// ClearSection clears the "section" edge to the KcCourseSection entity.
func (m *KcCourseSmallCategoryMutation) ClearSection() {
	m.clearedsection = true
}

// SectionCleared reports if the "section" edge to the KcCourseSection entity was cleared.
func (m *KcCourseSmallCategoryMutation) SectionCleared() bool {
	return m.SectionIDCleared() || m.clearedsection
}

// SectionIDs returns the "section" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SectionID instead. It exists only for internal usage by the builders.
func (m *KcCourseSmallCategoryMutation) SectionIDs() (ids []int) {
	if id := m.section; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSection resets all changes to the "section" edge.
func (m *KcCourseSmallCategoryMutation) ResetSection() {
	m.section = nil
	m.clearedsection = false
}

// AddCourseSmallCategoryAttachmentIDs adds the "course_small_category_attachments" edge to the KcSmallCategoryAttachment entity by ids.
func (m *KcCourseSmallCategoryMutation) AddCourseSmallCategoryAttachmentIDs(ids ...int) {
	if m.course_small_category_attachments == nil {
		m.course_small_category_attachments = make(map[int]struct{})
	}
	for i := range ids {
		m.course_small_category_attachments[ids[i]] = struct{}{}
	}
}

// ClearCourseSmallCategoryAttachments clears the "course_small_category_attachments" edge to the KcSmallCategoryAttachment entity.
func (m *KcCourseSmallCategoryMutation) ClearCourseSmallCategoryAttachments() {
	m.clearedcourse_small_category_attachments = true
}

// CourseSmallCategoryAttachmentsCleared reports if the "course_small_category_attachments" edge to the KcSmallCategoryAttachment entity was cleared.
func (m *KcCourseSmallCategoryMutation) CourseSmallCategoryAttachmentsCleared() bool {
	return m.clearedcourse_small_category_attachments
}

// RemoveCourseSmallCategoryAttachmentIDs removes the "course_small_category_attachments" edge to the KcSmallCategoryAttachment entity by IDs.
func (m *KcCourseSmallCategoryMutation) RemoveCourseSmallCategoryAttachmentIDs(ids ...int) {
	if m.removedcourse_small_category_attachments == nil {
		m.removedcourse_small_category_attachments = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcourse_small_category_attachments[ids[i]] = struct{}{}
	}
}

// RemovedCourseSmallCategoryAttachments returns the removed IDs of the "course_small_category_attachments" edge to the KcSmallCategoryAttachment entity.
func (m *KcCourseSmallCategoryMutation) RemovedCourseSmallCategoryAttachmentsIDs() (ids []int) {
	for id := range m.removedcourse_small_category_attachments {
		ids = append(ids, id)
	}
	return
}

// CourseSmallCategoryAttachmentsIDs returns the "course_small_category_attachments" edge IDs in the mutation.
func (m *KcCourseSmallCategoryMutation) CourseSmallCategoryAttachmentsIDs() (ids []int) {
	for id := range m.course_small_category_attachments {
		ids = append(ids, id)
	}
	return
}

// ResetCourseSmallCategoryAttachments resets all changes to the "course_small_category_attachments" edge.
func (m *KcCourseSmallCategoryMutation) ResetCourseSmallCategoryAttachments() {
	m.course_small_category_attachments = nil
	m.clearedcourse_small_category_attachments = false
	m.removedcourse_small_category_attachments = nil
}

// AddCourseSmallCategoryExampaperIDs adds the "course_small_category_exampapers" edge to the KcSmallCategoryExamPaper entity by ids.
func (m *KcCourseSmallCategoryMutation) AddCourseSmallCategoryExampaperIDs(ids ...int) {
	if m.course_small_category_exampapers == nil {
		m.course_small_category_exampapers = make(map[int]struct{})
	}
	for i := range ids {
		m.course_small_category_exampapers[ids[i]] = struct{}{}
	}
}

// ClearCourseSmallCategoryExampapers clears the "course_small_category_exampapers" edge to the KcSmallCategoryExamPaper entity.
func (m *KcCourseSmallCategoryMutation) ClearCourseSmallCategoryExampapers() {
	m.clearedcourse_small_category_exampapers = true
}

// CourseSmallCategoryExampapersCleared reports if the "course_small_category_exampapers" edge to the KcSmallCategoryExamPaper entity was cleared.
func (m *KcCourseSmallCategoryMutation) CourseSmallCategoryExampapersCleared() bool {
	return m.clearedcourse_small_category_exampapers
}

// RemoveCourseSmallCategoryExampaperIDs removes the "course_small_category_exampapers" edge to the KcSmallCategoryExamPaper entity by IDs.
func (m *KcCourseSmallCategoryMutation) RemoveCourseSmallCategoryExampaperIDs(ids ...int) {
	if m.removedcourse_small_category_exampapers == nil {
		m.removedcourse_small_category_exampapers = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcourse_small_category_exampapers[ids[i]] = struct{}{}
	}
}

// RemovedCourseSmallCategoryExampapers returns the removed IDs of the "course_small_category_exampapers" edge to the KcSmallCategoryExamPaper entity.
func (m *KcCourseSmallCategoryMutation) RemovedCourseSmallCategoryExampapersIDs() (ids []int) {
	for id := range m.removedcourse_small_category_exampapers {
		ids = append(ids, id)
	}
	return
}

// CourseSmallCategoryExampapersIDs returns the "course_small_category_exampapers" edge IDs in the mutation.
func (m *KcCourseSmallCategoryMutation) CourseSmallCategoryExampapersIDs() (ids []int) {
	for id := range m.course_small_category_exampapers {
		ids = append(ids, id)
	}
	return
}

// ResetCourseSmallCategoryExampapers resets all changes to the "course_small_category_exampapers" edge.
func (m *KcCourseSmallCategoryMutation) ResetCourseSmallCategoryExampapers() {
	m.course_small_category_exampapers = nil
	m.clearedcourse_small_category_exampapers = false
	m.removedcourse_small_category_exampapers = nil
}

// AddCourseSmallCategoryQuestionIDs adds the "course_small_category_questions" edge to the KcSmallCategoryQuestion entity by ids.
func (m *KcCourseSmallCategoryMutation) AddCourseSmallCategoryQuestionIDs(ids ...int) {
	if m.course_small_category_questions == nil {
		m.course_small_category_questions = make(map[int]struct{})
	}
	for i := range ids {
		m.course_small_category_questions[ids[i]] = struct{}{}
	}
}

// ClearCourseSmallCategoryQuestions clears the "course_small_category_questions" edge to the KcSmallCategoryQuestion entity.
func (m *KcCourseSmallCategoryMutation) ClearCourseSmallCategoryQuestions() {
	m.clearedcourse_small_category_questions = true
}

// CourseSmallCategoryQuestionsCleared reports if the "course_small_category_questions" edge to the KcSmallCategoryQuestion entity was cleared.
func (m *KcCourseSmallCategoryMutation) CourseSmallCategoryQuestionsCleared() bool {
	return m.clearedcourse_small_category_questions
}

// RemoveCourseSmallCategoryQuestionIDs removes the "course_small_category_questions" edge to the KcSmallCategoryQuestion entity by IDs.
func (m *KcCourseSmallCategoryMutation) RemoveCourseSmallCategoryQuestionIDs(ids ...int) {
	if m.removedcourse_small_category_questions == nil {
		m.removedcourse_small_category_questions = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcourse_small_category_questions[ids[i]] = struct{}{}
	}
}

// RemovedCourseSmallCategoryQuestions returns the removed IDs of the "course_small_category_questions" edge to the KcSmallCategoryQuestion entity.
func (m *KcCourseSmallCategoryMutation) RemovedCourseSmallCategoryQuestionsIDs() (ids []int) {
	for id := range m.removedcourse_small_category_questions {
		ids = append(ids, id)
	}
	return
}

// CourseSmallCategoryQuestionsIDs returns the "course_small_category_questions" edge IDs in the mutation.
func (m *KcCourseSmallCategoryMutation) CourseSmallCategoryQuestionsIDs() (ids []int) {
	for id := range m.course_small_category_questions {
		ids = append(ids, id)
	}
	return
}

// ResetCourseSmallCategoryQuestions resets all changes to the "course_small_category_questions" edge.
func (m *KcCourseSmallCategoryMutation) ResetCourseSmallCategoryQuestions() {
	m.course_small_category_questions = nil
	m.clearedcourse_small_category_questions = false
	m.removedcourse_small_category_questions = nil
}

// AddCourseAppraiseSmallIDs adds the "course_appraise_smalls" edge to the UserCourseAppraise entity by ids.
func (m *KcCourseSmallCategoryMutation) AddCourseAppraiseSmallIDs(ids ...int) {
	if m.course_appraise_smalls == nil {
		m.course_appraise_smalls = make(map[int]struct{})
	}
	for i := range ids {
		m.course_appraise_smalls[ids[i]] = struct{}{}
	}
}

// ClearCourseAppraiseSmalls clears the "course_appraise_smalls" edge to the UserCourseAppraise entity.
func (m *KcCourseSmallCategoryMutation) ClearCourseAppraiseSmalls() {
	m.clearedcourse_appraise_smalls = true
}

// CourseAppraiseSmallsCleared reports if the "course_appraise_smalls" edge to the UserCourseAppraise entity was cleared.
func (m *KcCourseSmallCategoryMutation) CourseAppraiseSmallsCleared() bool {
	return m.clearedcourse_appraise_smalls
}

// RemoveCourseAppraiseSmallIDs removes the "course_appraise_smalls" edge to the UserCourseAppraise entity by IDs.
func (m *KcCourseSmallCategoryMutation) RemoveCourseAppraiseSmallIDs(ids ...int) {
	if m.removedcourse_appraise_smalls == nil {
		m.removedcourse_appraise_smalls = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcourse_appraise_smalls[ids[i]] = struct{}{}
	}
}

// RemovedCourseAppraiseSmalls returns the removed IDs of the "course_appraise_smalls" edge to the UserCourseAppraise entity.
func (m *KcCourseSmallCategoryMutation) RemovedCourseAppraiseSmallsIDs() (ids []int) {
	for id := range m.removedcourse_appraise_smalls {
		ids = append(ids, id)
	}
	return
}

// CourseAppraiseSmallsIDs returns the "course_appraise_smalls" edge IDs in the mutation.
func (m *KcCourseSmallCategoryMutation) CourseAppraiseSmallsIDs() (ids []int) {
	for id := range m.course_appraise_smalls {
		ids = append(ids, id)
	}
	return
}

// ResetCourseAppraiseSmalls resets all changes to the "course_appraise_smalls" edge.
func (m *KcCourseSmallCategoryMutation) ResetCourseAppraiseSmalls() {
	m.course_appraise_smalls = nil
	m.clearedcourse_appraise_smalls = false
	m.removedcourse_appraise_smalls = nil
}

// AddVideoRecordSmallIDs adds the "video_record_small" edge to the VideoRecord entity by ids.
func (m *KcCourseSmallCategoryMutation) AddVideoRecordSmallIDs(ids ...int) {
	if m.video_record_small == nil {
		m.video_record_small = make(map[int]struct{})
	}
	for i := range ids {
		m.video_record_small[ids[i]] = struct{}{}
	}
}

// ClearVideoRecordSmall clears the "video_record_small" edge to the VideoRecord entity.
func (m *KcCourseSmallCategoryMutation) ClearVideoRecordSmall() {
	m.clearedvideo_record_small = true
}

// VideoRecordSmallCleared reports if the "video_record_small" edge to the VideoRecord entity was cleared.
func (m *KcCourseSmallCategoryMutation) VideoRecordSmallCleared() bool {
	return m.clearedvideo_record_small
}

// RemoveVideoRecordSmallIDs removes the "video_record_small" edge to the VideoRecord entity by IDs.
func (m *KcCourseSmallCategoryMutation) RemoveVideoRecordSmallIDs(ids ...int) {
	if m.removedvideo_record_small == nil {
		m.removedvideo_record_small = make(map[int]struct{})
	}
	for i := range ids {
		m.removedvideo_record_small[ids[i]] = struct{}{}
	}
}

// RemovedVideoRecordSmall returns the removed IDs of the "video_record_small" edge to the VideoRecord entity.
func (m *KcCourseSmallCategoryMutation) RemovedVideoRecordSmallIDs() (ids []int) {
	for id := range m.removedvideo_record_small {
		ids = append(ids, id)
	}
	return
}

// VideoRecordSmallIDs returns the "video_record_small" edge IDs in the mutation.
func (m *KcCourseSmallCategoryMutation) VideoRecordSmallIDs() (ids []int) {
	for id := range m.video_record_small {
		ids = append(ids, id)
	}
	return
}

// ResetVideoRecordSmall resets all changes to the "video_record_small" edge.
func (m *KcCourseSmallCategoryMutation) ResetVideoRecordSmall() {
	m.video_record_small = nil
	m.clearedvideo_record_small = false
	m.removedvideo_record_small = nil
}

// SetCsAttachmentID sets the "cs_attachment" edge to the Attachment entity by id.
func (m *KcCourseSmallCategoryMutation) SetCsAttachmentID(id int) {
	m.cs_attachment = &id
}

// ClearCsAttachment clears the "cs_attachment" edge to the Attachment entity.
func (m *KcCourseSmallCategoryMutation) ClearCsAttachment() {
	m.clearedcs_attachment = true
}

// CsAttachmentCleared reports if the "cs_attachment" edge to the Attachment entity was cleared.
func (m *KcCourseSmallCategoryMutation) CsAttachmentCleared() bool {
	return m.CoursewareAttachIDCleared() || m.clearedcs_attachment
}

// CsAttachmentID returns the "cs_attachment" edge ID in the mutation.
func (m *KcCourseSmallCategoryMutation) CsAttachmentID() (id int, exists bool) {
	if m.cs_attachment != nil {
		return *m.cs_attachment, true
	}
	return
}

// CsAttachmentIDs returns the "cs_attachment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CsAttachmentID instead. It exists only for internal usage by the builders.
func (m *KcCourseSmallCategoryMutation) CsAttachmentIDs() (ids []int) {
	if id := m.cs_attachment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCsAttachment resets all changes to the "cs_attachment" edge.
func (m *KcCourseSmallCategoryMutation) ResetCsAttachment() {
	m.cs_attachment = nil
	m.clearedcs_attachment = false
}

// SetOdAttachmentID sets the "od_attachment" edge to the Attachment entity by id.
func (m *KcCourseSmallCategoryMutation) SetOdAttachmentID(id int) {
	m.od_attachment = &id
}

// ClearOdAttachment clears the "od_attachment" edge to the Attachment entity.
func (m *KcCourseSmallCategoryMutation) ClearOdAttachment() {
	m.clearedod_attachment = true
}

// OdAttachmentCleared reports if the "od_attachment" edge to the Attachment entity was cleared.
func (m *KcCourseSmallCategoryMutation) OdAttachmentCleared() bool {
	return m.OrderVideoAttachIDCleared() || m.clearedod_attachment
}

// OdAttachmentID returns the "od_attachment" edge ID in the mutation.
func (m *KcCourseSmallCategoryMutation) OdAttachmentID() (id int, exists bool) {
	if m.od_attachment != nil {
		return *m.od_attachment, true
	}
	return
}

// OdAttachmentIDs returns the "od_attachment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OdAttachmentID instead. It exists only for internal usage by the builders.
func (m *KcCourseSmallCategoryMutation) OdAttachmentIDs() (ids []int) {
	if id := m.od_attachment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOdAttachment resets all changes to the "od_attachment" edge.
func (m *KcCourseSmallCategoryMutation) ResetOdAttachment() {
	m.od_attachment = nil
	m.clearedod_attachment = false
}

// Op returns the operation name.
func (m *KcCourseSmallCategoryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (KcCourseSmallCategory).
func (m *KcCourseSmallCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *KcCourseSmallCategoryMutation) Fields() []string {
	fields := make([]string, 0, 31)
	if m.uuid != nil {
		fields = append(fields, kccoursesmallcategory.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, kccoursesmallcategory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, kccoursesmallcategory.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, kccoursesmallcategory.FieldDeletedAt)
	}
	if m.small_name != nil {
		fields = append(fields, kccoursesmallcategory.FieldSmallName)
	}
	if m.viewing_time != nil {
		fields = append(fields, kccoursesmallcategory.FieldViewingTime)
	}
	if m.finish_type != nil {
		fields = append(fields, kccoursesmallcategory.FieldFinishType)
	}
	if m.teach_type != nil {
		fields = append(fields, kccoursesmallcategory.FieldTeachType)
	}
	if m._type != nil {
		fields = append(fields, kccoursesmallcategory.FieldType)
	}
	if m.live_small_start != nil {
		fields = append(fields, kccoursesmallcategory.FieldLiveSmallStart)
	}
	if m.live_small_status != nil {
		fields = append(fields, kccoursesmallcategory.FieldLiveSmallStatus)
	}
	if m.live_room_id != nil {
		fields = append(fields, kccoursesmallcategory.FieldLiveRoomID)
	}
	if m.back_video_id != nil {
		fields = append(fields, kccoursesmallcategory.FieldBackVideoID)
	}
	if m.false_video_id != nil {
		fields = append(fields, kccoursesmallcategory.FieldFalseVideoID)
	}
	if m.order_video_id != nil {
		fields = append(fields, kccoursesmallcategory.FieldOrderVideoID)
	}
	if m.od_attachment != nil {
		fields = append(fields, kccoursesmallcategory.FieldOrderVideoAttachID)
	}
	if m.live_small_time != nil {
		fields = append(fields, kccoursesmallcategory.FieldLiveSmallTime)
	}
	if m.push_status != nil {
		fields = append(fields, kccoursesmallcategory.FieldPushStatus)
	}
	if m.live_small_remark != nil {
		fields = append(fields, kccoursesmallcategory.FieldLiveSmallRemark)
	}
	if m.cs_attachment != nil {
		fields = append(fields, kccoursesmallcategory.FieldCoursewareAttachID)
	}
	if m.courseware_name != nil {
		fields = append(fields, kccoursesmallcategory.FieldCoursewareName)
	}
	if m.attachment_count != nil {
		fields = append(fields, kccoursesmallcategory.FieldAttachmentCount)
	}
	if m.question_count != nil {
		fields = append(fields, kccoursesmallcategory.FieldQuestionCount)
	}
	if m.exam_count != nil {
		fields = append(fields, kccoursesmallcategory.FieldExamCount)
	}
	if m.homework_count != nil {
		fields = append(fields, kccoursesmallcategory.FieldHomeworkCount)
	}
	if m.study_count != nil {
		fields = append(fields, kccoursesmallcategory.FieldStudyCount)
	}
	if m.finish_count != nil {
		fields = append(fields, kccoursesmallcategory.FieldFinishCount)
	}
	if m.average_view_duration != nil {
		fields = append(fields, kccoursesmallcategory.FieldAverageViewDuration)
	}
	if m.course != nil {
		fields = append(fields, kccoursesmallcategory.FieldCourseID)
	}
	if m.chapter != nil {
		fields = append(fields, kccoursesmallcategory.FieldChapterID)
	}
	if m.section != nil {
		fields = append(fields, kccoursesmallcategory.FieldSectionID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *KcCourseSmallCategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case kccoursesmallcategory.FieldUUID:
		return m.UUID()
	case kccoursesmallcategory.FieldCreatedAt:
		return m.CreatedAt()
	case kccoursesmallcategory.FieldUpdatedAt:
		return m.UpdatedAt()
	case kccoursesmallcategory.FieldDeletedAt:
		return m.DeletedAt()
	case kccoursesmallcategory.FieldSmallName:
		return m.SmallName()
	case kccoursesmallcategory.FieldViewingTime:
		return m.ViewingTime()
	case kccoursesmallcategory.FieldFinishType:
		return m.FinishType()
	case kccoursesmallcategory.FieldTeachType:
		return m.TeachType()
	case kccoursesmallcategory.FieldType:
		return m.GetType()
	case kccoursesmallcategory.FieldLiveSmallStart:
		return m.LiveSmallStart()
	case kccoursesmallcategory.FieldLiveSmallStatus:
		return m.LiveSmallStatus()
	case kccoursesmallcategory.FieldLiveRoomID:
		return m.LiveRoomID()
	case kccoursesmallcategory.FieldBackVideoID:
		return m.BackVideoID()
	case kccoursesmallcategory.FieldFalseVideoID:
		return m.FalseVideoID()
	case kccoursesmallcategory.FieldOrderVideoID:
		return m.OrderVideoID()
	case kccoursesmallcategory.FieldOrderVideoAttachID:
		return m.OrderVideoAttachID()
	case kccoursesmallcategory.FieldLiveSmallTime:
		return m.LiveSmallTime()
	case kccoursesmallcategory.FieldPushStatus:
		return m.PushStatus()
	case kccoursesmallcategory.FieldLiveSmallRemark:
		return m.LiveSmallRemark()
	case kccoursesmallcategory.FieldCoursewareAttachID:
		return m.CoursewareAttachID()
	case kccoursesmallcategory.FieldCoursewareName:
		return m.CoursewareName()
	case kccoursesmallcategory.FieldAttachmentCount:
		return m.AttachmentCount()
	case kccoursesmallcategory.FieldQuestionCount:
		return m.QuestionCount()
	case kccoursesmallcategory.FieldExamCount:
		return m.ExamCount()
	case kccoursesmallcategory.FieldHomeworkCount:
		return m.HomeworkCount()
	case kccoursesmallcategory.FieldStudyCount:
		return m.StudyCount()
	case kccoursesmallcategory.FieldFinishCount:
		return m.FinishCount()
	case kccoursesmallcategory.FieldAverageViewDuration:
		return m.AverageViewDuration()
	case kccoursesmallcategory.FieldCourseID:
		return m.CourseID()
	case kccoursesmallcategory.FieldChapterID:
		return m.ChapterID()
	case kccoursesmallcategory.FieldSectionID:
		return m.SectionID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *KcCourseSmallCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case kccoursesmallcategory.FieldUUID:
		return m.OldUUID(ctx)
	case kccoursesmallcategory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case kccoursesmallcategory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case kccoursesmallcategory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case kccoursesmallcategory.FieldSmallName:
		return m.OldSmallName(ctx)
	case kccoursesmallcategory.FieldViewingTime:
		return m.OldViewingTime(ctx)
	case kccoursesmallcategory.FieldFinishType:
		return m.OldFinishType(ctx)
	case kccoursesmallcategory.FieldTeachType:
		return m.OldTeachType(ctx)
	case kccoursesmallcategory.FieldType:
		return m.OldType(ctx)
	case kccoursesmallcategory.FieldLiveSmallStart:
		return m.OldLiveSmallStart(ctx)
	case kccoursesmallcategory.FieldLiveSmallStatus:
		return m.OldLiveSmallStatus(ctx)
	case kccoursesmallcategory.FieldLiveRoomID:
		return m.OldLiveRoomID(ctx)
	case kccoursesmallcategory.FieldBackVideoID:
		return m.OldBackVideoID(ctx)
	case kccoursesmallcategory.FieldFalseVideoID:
		return m.OldFalseVideoID(ctx)
	case kccoursesmallcategory.FieldOrderVideoID:
		return m.OldOrderVideoID(ctx)
	case kccoursesmallcategory.FieldOrderVideoAttachID:
		return m.OldOrderVideoAttachID(ctx)
	case kccoursesmallcategory.FieldLiveSmallTime:
		return m.OldLiveSmallTime(ctx)
	case kccoursesmallcategory.FieldPushStatus:
		return m.OldPushStatus(ctx)
	case kccoursesmallcategory.FieldLiveSmallRemark:
		return m.OldLiveSmallRemark(ctx)
	case kccoursesmallcategory.FieldCoursewareAttachID:
		return m.OldCoursewareAttachID(ctx)
	case kccoursesmallcategory.FieldCoursewareName:
		return m.OldCoursewareName(ctx)
	case kccoursesmallcategory.FieldAttachmentCount:
		return m.OldAttachmentCount(ctx)
	case kccoursesmallcategory.FieldQuestionCount:
		return m.OldQuestionCount(ctx)
	case kccoursesmallcategory.FieldExamCount:
		return m.OldExamCount(ctx)
	case kccoursesmallcategory.FieldHomeworkCount:
		return m.OldHomeworkCount(ctx)
	case kccoursesmallcategory.FieldStudyCount:
		return m.OldStudyCount(ctx)
	case kccoursesmallcategory.FieldFinishCount:
		return m.OldFinishCount(ctx)
	case kccoursesmallcategory.FieldAverageViewDuration:
		return m.OldAverageViewDuration(ctx)
	case kccoursesmallcategory.FieldCourseID:
		return m.OldCourseID(ctx)
	case kccoursesmallcategory.FieldChapterID:
		return m.OldChapterID(ctx)
	case kccoursesmallcategory.FieldSectionID:
		return m.OldSectionID(ctx)
	}
	return nil, fmt.Errorf("unknown KcCourseSmallCategory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KcCourseSmallCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case kccoursesmallcategory.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case kccoursesmallcategory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case kccoursesmallcategory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case kccoursesmallcategory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case kccoursesmallcategory.FieldSmallName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSmallName(v)
		return nil
	case kccoursesmallcategory.FieldViewingTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetViewingTime(v)
		return nil
	case kccoursesmallcategory.FieldFinishType:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinishType(v)
		return nil
	case kccoursesmallcategory.FieldTeachType:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeachType(v)
		return nil
	case kccoursesmallcategory.FieldType:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case kccoursesmallcategory.FieldLiveSmallStart:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLiveSmallStart(v)
		return nil
	case kccoursesmallcategory.FieldLiveSmallStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLiveSmallStatus(v)
		return nil
	case kccoursesmallcategory.FieldLiveRoomID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLiveRoomID(v)
		return nil
	case kccoursesmallcategory.FieldBackVideoID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBackVideoID(v)
		return nil
	case kccoursesmallcategory.FieldFalseVideoID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFalseVideoID(v)
		return nil
	case kccoursesmallcategory.FieldOrderVideoID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderVideoID(v)
		return nil
	case kccoursesmallcategory.FieldOrderVideoAttachID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderVideoAttachID(v)
		return nil
	case kccoursesmallcategory.FieldLiveSmallTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLiveSmallTime(v)
		return nil
	case kccoursesmallcategory.FieldPushStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPushStatus(v)
		return nil
	case kccoursesmallcategory.FieldLiveSmallRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLiveSmallRemark(v)
		return nil
	case kccoursesmallcategory.FieldCoursewareAttachID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoursewareAttachID(v)
		return nil
	case kccoursesmallcategory.FieldCoursewareName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoursewareName(v)
		return nil
	case kccoursesmallcategory.FieldAttachmentCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttachmentCount(v)
		return nil
	case kccoursesmallcategory.FieldQuestionCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuestionCount(v)
		return nil
	case kccoursesmallcategory.FieldExamCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamCount(v)
		return nil
	case kccoursesmallcategory.FieldHomeworkCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHomeworkCount(v)
		return nil
	case kccoursesmallcategory.FieldStudyCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStudyCount(v)
		return nil
	case kccoursesmallcategory.FieldFinishCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinishCount(v)
		return nil
	case kccoursesmallcategory.FieldAverageViewDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAverageViewDuration(v)
		return nil
	case kccoursesmallcategory.FieldCourseID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCourseID(v)
		return nil
	case kccoursesmallcategory.FieldChapterID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChapterID(v)
		return nil
	case kccoursesmallcategory.FieldSectionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSectionID(v)
		return nil
	}
	return fmt.Errorf("unknown KcCourseSmallCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *KcCourseSmallCategoryMutation) AddedFields() []string {
	var fields []string
	if m.addviewing_time != nil {
		fields = append(fields, kccoursesmallcategory.FieldViewingTime)
	}
	if m.addfinish_type != nil {
		fields = append(fields, kccoursesmallcategory.FieldFinishType)
	}
	if m.addteach_type != nil {
		fields = append(fields, kccoursesmallcategory.FieldTeachType)
	}
	if m.add_type != nil {
		fields = append(fields, kccoursesmallcategory.FieldType)
	}
	if m.addlive_small_status != nil {
		fields = append(fields, kccoursesmallcategory.FieldLiveSmallStatus)
	}
	if m.addlive_room_id != nil {
		fields = append(fields, kccoursesmallcategory.FieldLiveRoomID)
	}
	if m.addback_video_id != nil {
		fields = append(fields, kccoursesmallcategory.FieldBackVideoID)
	}
	if m.addfalse_video_id != nil {
		fields = append(fields, kccoursesmallcategory.FieldFalseVideoID)
	}
	if m.addorder_video_id != nil {
		fields = append(fields, kccoursesmallcategory.FieldOrderVideoID)
	}
	if m.addlive_small_time != nil {
		fields = append(fields, kccoursesmallcategory.FieldLiveSmallTime)
	}
	if m.addpush_status != nil {
		fields = append(fields, kccoursesmallcategory.FieldPushStatus)
	}
	if m.addattachment_count != nil {
		fields = append(fields, kccoursesmallcategory.FieldAttachmentCount)
	}
	if m.addquestion_count != nil {
		fields = append(fields, kccoursesmallcategory.FieldQuestionCount)
	}
	if m.addexam_count != nil {
		fields = append(fields, kccoursesmallcategory.FieldExamCount)
	}
	if m.addhomework_count != nil {
		fields = append(fields, kccoursesmallcategory.FieldHomeworkCount)
	}
	if m.addstudy_count != nil {
		fields = append(fields, kccoursesmallcategory.FieldStudyCount)
	}
	if m.addfinish_count != nil {
		fields = append(fields, kccoursesmallcategory.FieldFinishCount)
	}
	if m.addaverage_view_duration != nil {
		fields = append(fields, kccoursesmallcategory.FieldAverageViewDuration)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *KcCourseSmallCategoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case kccoursesmallcategory.FieldViewingTime:
		return m.AddedViewingTime()
	case kccoursesmallcategory.FieldFinishType:
		return m.AddedFinishType()
	case kccoursesmallcategory.FieldTeachType:
		return m.AddedTeachType()
	case kccoursesmallcategory.FieldType:
		return m.AddedType()
	case kccoursesmallcategory.FieldLiveSmallStatus:
		return m.AddedLiveSmallStatus()
	case kccoursesmallcategory.FieldLiveRoomID:
		return m.AddedLiveRoomID()
	case kccoursesmallcategory.FieldBackVideoID:
		return m.AddedBackVideoID()
	case kccoursesmallcategory.FieldFalseVideoID:
		return m.AddedFalseVideoID()
	case kccoursesmallcategory.FieldOrderVideoID:
		return m.AddedOrderVideoID()
	case kccoursesmallcategory.FieldLiveSmallTime:
		return m.AddedLiveSmallTime()
	case kccoursesmallcategory.FieldPushStatus:
		return m.AddedPushStatus()
	case kccoursesmallcategory.FieldAttachmentCount:
		return m.AddedAttachmentCount()
	case kccoursesmallcategory.FieldQuestionCount:
		return m.AddedQuestionCount()
	case kccoursesmallcategory.FieldExamCount:
		return m.AddedExamCount()
	case kccoursesmallcategory.FieldHomeworkCount:
		return m.AddedHomeworkCount()
	case kccoursesmallcategory.FieldStudyCount:
		return m.AddedStudyCount()
	case kccoursesmallcategory.FieldFinishCount:
		return m.AddedFinishCount()
	case kccoursesmallcategory.FieldAverageViewDuration:
		return m.AddedAverageViewDuration()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KcCourseSmallCategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case kccoursesmallcategory.FieldViewingTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddViewingTime(v)
		return nil
	case kccoursesmallcategory.FieldFinishType:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFinishType(v)
		return nil
	case kccoursesmallcategory.FieldTeachType:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTeachType(v)
		return nil
	case kccoursesmallcategory.FieldType:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case kccoursesmallcategory.FieldLiveSmallStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLiveSmallStatus(v)
		return nil
	case kccoursesmallcategory.FieldLiveRoomID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLiveRoomID(v)
		return nil
	case kccoursesmallcategory.FieldBackVideoID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBackVideoID(v)
		return nil
	case kccoursesmallcategory.FieldFalseVideoID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFalseVideoID(v)
		return nil
	case kccoursesmallcategory.FieldOrderVideoID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderVideoID(v)
		return nil
	case kccoursesmallcategory.FieldLiveSmallTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLiveSmallTime(v)
		return nil
	case kccoursesmallcategory.FieldPushStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPushStatus(v)
		return nil
	case kccoursesmallcategory.FieldAttachmentCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAttachmentCount(v)
		return nil
	case kccoursesmallcategory.FieldQuestionCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuestionCount(v)
		return nil
	case kccoursesmallcategory.FieldExamCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExamCount(v)
		return nil
	case kccoursesmallcategory.FieldHomeworkCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHomeworkCount(v)
		return nil
	case kccoursesmallcategory.FieldStudyCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStudyCount(v)
		return nil
	case kccoursesmallcategory.FieldFinishCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFinishCount(v)
		return nil
	case kccoursesmallcategory.FieldAverageViewDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAverageViewDuration(v)
		return nil
	}
	return fmt.Errorf("unknown KcCourseSmallCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *KcCourseSmallCategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(kccoursesmallcategory.FieldCreatedAt) {
		fields = append(fields, kccoursesmallcategory.FieldCreatedAt)
	}
	if m.FieldCleared(kccoursesmallcategory.FieldUpdatedAt) {
		fields = append(fields, kccoursesmallcategory.FieldUpdatedAt)
	}
	if m.FieldCleared(kccoursesmallcategory.FieldDeletedAt) {
		fields = append(fields, kccoursesmallcategory.FieldDeletedAt)
	}
	if m.FieldCleared(kccoursesmallcategory.FieldLiveSmallStart) {
		fields = append(fields, kccoursesmallcategory.FieldLiveSmallStart)
	}
	if m.FieldCleared(kccoursesmallcategory.FieldLiveRoomID) {
		fields = append(fields, kccoursesmallcategory.FieldLiveRoomID)
	}
	if m.FieldCleared(kccoursesmallcategory.FieldBackVideoID) {
		fields = append(fields, kccoursesmallcategory.FieldBackVideoID)
	}
	if m.FieldCleared(kccoursesmallcategory.FieldFalseVideoID) {
		fields = append(fields, kccoursesmallcategory.FieldFalseVideoID)
	}
	if m.FieldCleared(kccoursesmallcategory.FieldOrderVideoID) {
		fields = append(fields, kccoursesmallcategory.FieldOrderVideoID)
	}
	if m.FieldCleared(kccoursesmallcategory.FieldOrderVideoAttachID) {
		fields = append(fields, kccoursesmallcategory.FieldOrderVideoAttachID)
	}
	if m.FieldCleared(kccoursesmallcategory.FieldCoursewareAttachID) {
		fields = append(fields, kccoursesmallcategory.FieldCoursewareAttachID)
	}
	if m.FieldCleared(kccoursesmallcategory.FieldCourseID) {
		fields = append(fields, kccoursesmallcategory.FieldCourseID)
	}
	if m.FieldCleared(kccoursesmallcategory.FieldChapterID) {
		fields = append(fields, kccoursesmallcategory.FieldChapterID)
	}
	if m.FieldCleared(kccoursesmallcategory.FieldSectionID) {
		fields = append(fields, kccoursesmallcategory.FieldSectionID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *KcCourseSmallCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *KcCourseSmallCategoryMutation) ClearField(name string) error {
	switch name {
	case kccoursesmallcategory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case kccoursesmallcategory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case kccoursesmallcategory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case kccoursesmallcategory.FieldLiveSmallStart:
		m.ClearLiveSmallStart()
		return nil
	case kccoursesmallcategory.FieldLiveRoomID:
		m.ClearLiveRoomID()
		return nil
	case kccoursesmallcategory.FieldBackVideoID:
		m.ClearBackVideoID()
		return nil
	case kccoursesmallcategory.FieldFalseVideoID:
		m.ClearFalseVideoID()
		return nil
	case kccoursesmallcategory.FieldOrderVideoID:
		m.ClearOrderVideoID()
		return nil
	case kccoursesmallcategory.FieldOrderVideoAttachID:
		m.ClearOrderVideoAttachID()
		return nil
	case kccoursesmallcategory.FieldCoursewareAttachID:
		m.ClearCoursewareAttachID()
		return nil
	case kccoursesmallcategory.FieldCourseID:
		m.ClearCourseID()
		return nil
	case kccoursesmallcategory.FieldChapterID:
		m.ClearChapterID()
		return nil
	case kccoursesmallcategory.FieldSectionID:
		m.ClearSectionID()
		return nil
	}
	return fmt.Errorf("unknown KcCourseSmallCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *KcCourseSmallCategoryMutation) ResetField(name string) error {
	switch name {
	case kccoursesmallcategory.FieldUUID:
		m.ResetUUID()
		return nil
	case kccoursesmallcategory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case kccoursesmallcategory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case kccoursesmallcategory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case kccoursesmallcategory.FieldSmallName:
		m.ResetSmallName()
		return nil
	case kccoursesmallcategory.FieldViewingTime:
		m.ResetViewingTime()
		return nil
	case kccoursesmallcategory.FieldFinishType:
		m.ResetFinishType()
		return nil
	case kccoursesmallcategory.FieldTeachType:
		m.ResetTeachType()
		return nil
	case kccoursesmallcategory.FieldType:
		m.ResetType()
		return nil
	case kccoursesmallcategory.FieldLiveSmallStart:
		m.ResetLiveSmallStart()
		return nil
	case kccoursesmallcategory.FieldLiveSmallStatus:
		m.ResetLiveSmallStatus()
		return nil
	case kccoursesmallcategory.FieldLiveRoomID:
		m.ResetLiveRoomID()
		return nil
	case kccoursesmallcategory.FieldBackVideoID:
		m.ResetBackVideoID()
		return nil
	case kccoursesmallcategory.FieldFalseVideoID:
		m.ResetFalseVideoID()
		return nil
	case kccoursesmallcategory.FieldOrderVideoID:
		m.ResetOrderVideoID()
		return nil
	case kccoursesmallcategory.FieldOrderVideoAttachID:
		m.ResetOrderVideoAttachID()
		return nil
	case kccoursesmallcategory.FieldLiveSmallTime:
		m.ResetLiveSmallTime()
		return nil
	case kccoursesmallcategory.FieldPushStatus:
		m.ResetPushStatus()
		return nil
	case kccoursesmallcategory.FieldLiveSmallRemark:
		m.ResetLiveSmallRemark()
		return nil
	case kccoursesmallcategory.FieldCoursewareAttachID:
		m.ResetCoursewareAttachID()
		return nil
	case kccoursesmallcategory.FieldCoursewareName:
		m.ResetCoursewareName()
		return nil
	case kccoursesmallcategory.FieldAttachmentCount:
		m.ResetAttachmentCount()
		return nil
	case kccoursesmallcategory.FieldQuestionCount:
		m.ResetQuestionCount()
		return nil
	case kccoursesmallcategory.FieldExamCount:
		m.ResetExamCount()
		return nil
	case kccoursesmallcategory.FieldHomeworkCount:
		m.ResetHomeworkCount()
		return nil
	case kccoursesmallcategory.FieldStudyCount:
		m.ResetStudyCount()
		return nil
	case kccoursesmallcategory.FieldFinishCount:
		m.ResetFinishCount()
		return nil
	case kccoursesmallcategory.FieldAverageViewDuration:
		m.ResetAverageViewDuration()
		return nil
	case kccoursesmallcategory.FieldCourseID:
		m.ResetCourseID()
		return nil
	case kccoursesmallcategory.FieldChapterID:
		m.ResetChapterID()
		return nil
	case kccoursesmallcategory.FieldSectionID:
		m.ResetSectionID()
		return nil
	}
	return fmt.Errorf("unknown KcCourseSmallCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *KcCourseSmallCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 10)
	if m.course != nil {
		edges = append(edges, kccoursesmallcategory.EdgeCourse)
	}
	if m.chapter != nil {
		edges = append(edges, kccoursesmallcategory.EdgeChapter)
	}
	if m.section != nil {
		edges = append(edges, kccoursesmallcategory.EdgeSection)
	}
	if m.course_small_category_attachments != nil {
		edges = append(edges, kccoursesmallcategory.EdgeCourseSmallCategoryAttachments)
	}
	if m.course_small_category_exampapers != nil {
		edges = append(edges, kccoursesmallcategory.EdgeCourseSmallCategoryExampapers)
	}
	if m.course_small_category_questions != nil {
		edges = append(edges, kccoursesmallcategory.EdgeCourseSmallCategoryQuestions)
	}
	if m.course_appraise_smalls != nil {
		edges = append(edges, kccoursesmallcategory.EdgeCourseAppraiseSmalls)
	}
	if m.video_record_small != nil {
		edges = append(edges, kccoursesmallcategory.EdgeVideoRecordSmall)
	}
	if m.cs_attachment != nil {
		edges = append(edges, kccoursesmallcategory.EdgeCsAttachment)
	}
	if m.od_attachment != nil {
		edges = append(edges, kccoursesmallcategory.EdgeOdAttachment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *KcCourseSmallCategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case kccoursesmallcategory.EdgeCourse:
		if id := m.course; id != nil {
			return []ent.Value{*id}
		}
	case kccoursesmallcategory.EdgeChapter:
		if id := m.chapter; id != nil {
			return []ent.Value{*id}
		}
	case kccoursesmallcategory.EdgeSection:
		if id := m.section; id != nil {
			return []ent.Value{*id}
		}
	case kccoursesmallcategory.EdgeCourseSmallCategoryAttachments:
		ids := make([]ent.Value, 0, len(m.course_small_category_attachments))
		for id := range m.course_small_category_attachments {
			ids = append(ids, id)
		}
		return ids
	case kccoursesmallcategory.EdgeCourseSmallCategoryExampapers:
		ids := make([]ent.Value, 0, len(m.course_small_category_exampapers))
		for id := range m.course_small_category_exampapers {
			ids = append(ids, id)
		}
		return ids
	case kccoursesmallcategory.EdgeCourseSmallCategoryQuestions:
		ids := make([]ent.Value, 0, len(m.course_small_category_questions))
		for id := range m.course_small_category_questions {
			ids = append(ids, id)
		}
		return ids
	case kccoursesmallcategory.EdgeCourseAppraiseSmalls:
		ids := make([]ent.Value, 0, len(m.course_appraise_smalls))
		for id := range m.course_appraise_smalls {
			ids = append(ids, id)
		}
		return ids
	case kccoursesmallcategory.EdgeVideoRecordSmall:
		ids := make([]ent.Value, 0, len(m.video_record_small))
		for id := range m.video_record_small {
			ids = append(ids, id)
		}
		return ids
	case kccoursesmallcategory.EdgeCsAttachment:
		if id := m.cs_attachment; id != nil {
			return []ent.Value{*id}
		}
	case kccoursesmallcategory.EdgeOdAttachment:
		if id := m.od_attachment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *KcCourseSmallCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 10)
	if m.removedcourse_small_category_attachments != nil {
		edges = append(edges, kccoursesmallcategory.EdgeCourseSmallCategoryAttachments)
	}
	if m.removedcourse_small_category_exampapers != nil {
		edges = append(edges, kccoursesmallcategory.EdgeCourseSmallCategoryExampapers)
	}
	if m.removedcourse_small_category_questions != nil {
		edges = append(edges, kccoursesmallcategory.EdgeCourseSmallCategoryQuestions)
	}
	if m.removedcourse_appraise_smalls != nil {
		edges = append(edges, kccoursesmallcategory.EdgeCourseAppraiseSmalls)
	}
	if m.removedvideo_record_small != nil {
		edges = append(edges, kccoursesmallcategory.EdgeVideoRecordSmall)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *KcCourseSmallCategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case kccoursesmallcategory.EdgeCourseSmallCategoryAttachments:
		ids := make([]ent.Value, 0, len(m.removedcourse_small_category_attachments))
		for id := range m.removedcourse_small_category_attachments {
			ids = append(ids, id)
		}
		return ids
	case kccoursesmallcategory.EdgeCourseSmallCategoryExampapers:
		ids := make([]ent.Value, 0, len(m.removedcourse_small_category_exampapers))
		for id := range m.removedcourse_small_category_exampapers {
			ids = append(ids, id)
		}
		return ids
	case kccoursesmallcategory.EdgeCourseSmallCategoryQuestions:
		ids := make([]ent.Value, 0, len(m.removedcourse_small_category_questions))
		for id := range m.removedcourse_small_category_questions {
			ids = append(ids, id)
		}
		return ids
	case kccoursesmallcategory.EdgeCourseAppraiseSmalls:
		ids := make([]ent.Value, 0, len(m.removedcourse_appraise_smalls))
		for id := range m.removedcourse_appraise_smalls {
			ids = append(ids, id)
		}
		return ids
	case kccoursesmallcategory.EdgeVideoRecordSmall:
		ids := make([]ent.Value, 0, len(m.removedvideo_record_small))
		for id := range m.removedvideo_record_small {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *KcCourseSmallCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 10)
	if m.clearedcourse {
		edges = append(edges, kccoursesmallcategory.EdgeCourse)
	}
	if m.clearedchapter {
		edges = append(edges, kccoursesmallcategory.EdgeChapter)
	}
	if m.clearedsection {
		edges = append(edges, kccoursesmallcategory.EdgeSection)
	}
	if m.clearedcourse_small_category_attachments {
		edges = append(edges, kccoursesmallcategory.EdgeCourseSmallCategoryAttachments)
	}
	if m.clearedcourse_small_category_exampapers {
		edges = append(edges, kccoursesmallcategory.EdgeCourseSmallCategoryExampapers)
	}
	if m.clearedcourse_small_category_questions {
		edges = append(edges, kccoursesmallcategory.EdgeCourseSmallCategoryQuestions)
	}
	if m.clearedcourse_appraise_smalls {
		edges = append(edges, kccoursesmallcategory.EdgeCourseAppraiseSmalls)
	}
	if m.clearedvideo_record_small {
		edges = append(edges, kccoursesmallcategory.EdgeVideoRecordSmall)
	}
	if m.clearedcs_attachment {
		edges = append(edges, kccoursesmallcategory.EdgeCsAttachment)
	}
	if m.clearedod_attachment {
		edges = append(edges, kccoursesmallcategory.EdgeOdAttachment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *KcCourseSmallCategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case kccoursesmallcategory.EdgeCourse:
		return m.clearedcourse
	case kccoursesmallcategory.EdgeChapter:
		return m.clearedchapter
	case kccoursesmallcategory.EdgeSection:
		return m.clearedsection
	case kccoursesmallcategory.EdgeCourseSmallCategoryAttachments:
		return m.clearedcourse_small_category_attachments
	case kccoursesmallcategory.EdgeCourseSmallCategoryExampapers:
		return m.clearedcourse_small_category_exampapers
	case kccoursesmallcategory.EdgeCourseSmallCategoryQuestions:
		return m.clearedcourse_small_category_questions
	case kccoursesmallcategory.EdgeCourseAppraiseSmalls:
		return m.clearedcourse_appraise_smalls
	case kccoursesmallcategory.EdgeVideoRecordSmall:
		return m.clearedvideo_record_small
	case kccoursesmallcategory.EdgeCsAttachment:
		return m.clearedcs_attachment
	case kccoursesmallcategory.EdgeOdAttachment:
		return m.clearedod_attachment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *KcCourseSmallCategoryMutation) ClearEdge(name string) error {
	switch name {
	case kccoursesmallcategory.EdgeCourse:
		m.ClearCourse()
		return nil
	case kccoursesmallcategory.EdgeChapter:
		m.ClearChapter()
		return nil
	case kccoursesmallcategory.EdgeSection:
		m.ClearSection()
		return nil
	case kccoursesmallcategory.EdgeCsAttachment:
		m.ClearCsAttachment()
		return nil
	case kccoursesmallcategory.EdgeOdAttachment:
		m.ClearOdAttachment()
		return nil
	}
	return fmt.Errorf("unknown KcCourseSmallCategory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *KcCourseSmallCategoryMutation) ResetEdge(name string) error {
	switch name {
	case kccoursesmallcategory.EdgeCourse:
		m.ResetCourse()
		return nil
	case kccoursesmallcategory.EdgeChapter:
		m.ResetChapter()
		return nil
	case kccoursesmallcategory.EdgeSection:
		m.ResetSection()
		return nil
	case kccoursesmallcategory.EdgeCourseSmallCategoryAttachments:
		m.ResetCourseSmallCategoryAttachments()
		return nil
	case kccoursesmallcategory.EdgeCourseSmallCategoryExampapers:
		m.ResetCourseSmallCategoryExampapers()
		return nil
	case kccoursesmallcategory.EdgeCourseSmallCategoryQuestions:
		m.ResetCourseSmallCategoryQuestions()
		return nil
	case kccoursesmallcategory.EdgeCourseAppraiseSmalls:
		m.ResetCourseAppraiseSmalls()
		return nil
	case kccoursesmallcategory.EdgeVideoRecordSmall:
		m.ResetVideoRecordSmall()
		return nil
	case kccoursesmallcategory.EdgeCsAttachment:
		m.ResetCsAttachment()
		return nil
	case kccoursesmallcategory.EdgeOdAttachment:
		m.ResetOdAttachment()
		return nil
	}
	return fmt.Errorf("unknown KcCourseSmallCategory edge %s", name)
}

// KcCourseTeacherMutation represents an operation that mutates the KcCourseTeacher nodes in the graph.
type KcCourseTeacherMutation struct {
	config
	op             Op
	typ            string
	id             *int
	show_status    *uint8
	addshow_status *uint8
	sort_order     *int
	addsort_order  *int
	clearedFields  map[string]struct{}
	teacher        *int
	clearedteacher bool
	course         *int
	clearedcourse  bool
	done           bool
	oldValue       func(context.Context) (*KcCourseTeacher, error)
	predicates     []predicate.KcCourseTeacher
}

var _ ent.Mutation = (*KcCourseTeacherMutation)(nil)

// kccourseteacherOption allows management of the mutation configuration using functional options.
type kccourseteacherOption func(*KcCourseTeacherMutation)

// newKcCourseTeacherMutation creates new mutation for the KcCourseTeacher entity.
func newKcCourseTeacherMutation(c config, op Op, opts ...kccourseteacherOption) *KcCourseTeacherMutation {
	m := &KcCourseTeacherMutation{
		config:        c,
		op:            op,
		typ:           TypeKcCourseTeacher,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withKcCourseTeacherID sets the ID field of the mutation.
func withKcCourseTeacherID(id int) kccourseteacherOption {
	return func(m *KcCourseTeacherMutation) {
		var (
			err   error
			once  sync.Once
			value *KcCourseTeacher
		)
		m.oldValue = func(ctx context.Context) (*KcCourseTeacher, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().KcCourseTeacher.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withKcCourseTeacher sets the old KcCourseTeacher of the mutation.
func withKcCourseTeacher(node *KcCourseTeacher) kccourseteacherOption {
	return func(m *KcCourseTeacherMutation) {
		m.oldValue = func(context.Context) (*KcCourseTeacher, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m KcCourseTeacherMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m KcCourseTeacherMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *KcCourseTeacherMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetShowStatus sets the "show_status" field.
func (m *KcCourseTeacherMutation) SetShowStatus(u uint8) {
	m.show_status = &u
	m.addshow_status = nil
}

// ShowStatus returns the value of the "show_status" field in the mutation.
func (m *KcCourseTeacherMutation) ShowStatus() (r uint8, exists bool) {
	v := m.show_status
	if v == nil {
		return
	}
	return *v, true
}

// OldShowStatus returns the old "show_status" field's value of the KcCourseTeacher entity.
// If the KcCourseTeacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcCourseTeacherMutation) OldShowStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShowStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShowStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShowStatus: %w", err)
	}
	return oldValue.ShowStatus, nil
}

// AddShowStatus adds u to the "show_status" field.
func (m *KcCourseTeacherMutation) AddShowStatus(u uint8) {
	if m.addshow_status != nil {
		*m.addshow_status += u
	} else {
		m.addshow_status = &u
	}
}

// AddedShowStatus returns the value that was added to the "show_status" field in this mutation.
func (m *KcCourseTeacherMutation) AddedShowStatus() (r uint8, exists bool) {
	v := m.addshow_status
	if v == nil {
		return
	}
	return *v, true
}

// ResetShowStatus resets all changes to the "show_status" field.
func (m *KcCourseTeacherMutation) ResetShowStatus() {
	m.show_status = nil
	m.addshow_status = nil
}

// SetSortOrder sets the "sort_order" field.
func (m *KcCourseTeacherMutation) SetSortOrder(i int) {
	m.sort_order = &i
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *KcCourseTeacherMutation) SortOrder() (r int, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the KcCourseTeacher entity.
// If the KcCourseTeacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcCourseTeacherMutation) OldSortOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds i to the "sort_order" field.
func (m *KcCourseTeacherMutation) AddSortOrder(i int) {
	if m.addsort_order != nil {
		*m.addsort_order += i
	} else {
		m.addsort_order = &i
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *KcCourseTeacherMutation) AddedSortOrder() (r int, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *KcCourseTeacherMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
}

// SetCourseID sets the "course_id" field.
func (m *KcCourseTeacherMutation) SetCourseID(i int) {
	m.course = &i
}

// CourseID returns the value of the "course_id" field in the mutation.
func (m *KcCourseTeacherMutation) CourseID() (r int, exists bool) {
	v := m.course
	if v == nil {
		return
	}
	return *v, true
}

// OldCourseID returns the old "course_id" field's value of the KcCourseTeacher entity.
// If the KcCourseTeacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcCourseTeacherMutation) OldCourseID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCourseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCourseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCourseID: %w", err)
	}
	return oldValue.CourseID, nil
}

// ClearCourseID clears the value of the "course_id" field.
func (m *KcCourseTeacherMutation) ClearCourseID() {
	m.course = nil
	m.clearedFields[kccourseteacher.FieldCourseID] = struct{}{}
}

// CourseIDCleared returns if the "course_id" field was cleared in this mutation.
func (m *KcCourseTeacherMutation) CourseIDCleared() bool {
	_, ok := m.clearedFields[kccourseteacher.FieldCourseID]
	return ok
}

// ResetCourseID resets all changes to the "course_id" field.
func (m *KcCourseTeacherMutation) ResetCourseID() {
	m.course = nil
	delete(m.clearedFields, kccourseteacher.FieldCourseID)
}

// SetTeacherID sets the "teacher_id" field.
func (m *KcCourseTeacherMutation) SetTeacherID(i int) {
	m.teacher = &i
}

// TeacherID returns the value of the "teacher_id" field in the mutation.
func (m *KcCourseTeacherMutation) TeacherID() (r int, exists bool) {
	v := m.teacher
	if v == nil {
		return
	}
	return *v, true
}

// OldTeacherID returns the old "teacher_id" field's value of the KcCourseTeacher entity.
// If the KcCourseTeacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcCourseTeacherMutation) OldTeacherID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTeacherID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTeacherID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeacherID: %w", err)
	}
	return oldValue.TeacherID, nil
}

// ClearTeacherID clears the value of the "teacher_id" field.
func (m *KcCourseTeacherMutation) ClearTeacherID() {
	m.teacher = nil
	m.clearedFields[kccourseteacher.FieldTeacherID] = struct{}{}
}

// TeacherIDCleared returns if the "teacher_id" field was cleared in this mutation.
func (m *KcCourseTeacherMutation) TeacherIDCleared() bool {
	_, ok := m.clearedFields[kccourseteacher.FieldTeacherID]
	return ok
}

// ResetTeacherID resets all changes to the "teacher_id" field.
func (m *KcCourseTeacherMutation) ResetTeacherID() {
	m.teacher = nil
	delete(m.clearedFields, kccourseteacher.FieldTeacherID)
}

// ClearTeacher clears the "teacher" edge to the Teacher entity.
func (m *KcCourseTeacherMutation) ClearTeacher() {
	m.clearedteacher = true
}

// TeacherCleared reports if the "teacher" edge to the Teacher entity was cleared.
func (m *KcCourseTeacherMutation) TeacherCleared() bool {
	return m.TeacherIDCleared() || m.clearedteacher
}

// TeacherIDs returns the "teacher" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeacherID instead. It exists only for internal usage by the builders.
func (m *KcCourseTeacherMutation) TeacherIDs() (ids []int) {
	if id := m.teacher; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeacher resets all changes to the "teacher" edge.
func (m *KcCourseTeacherMutation) ResetTeacher() {
	m.teacher = nil
	m.clearedteacher = false
}

// ClearCourse clears the "course" edge to the KcCourse entity.
func (m *KcCourseTeacherMutation) ClearCourse() {
	m.clearedcourse = true
}

// CourseCleared reports if the "course" edge to the KcCourse entity was cleared.
func (m *KcCourseTeacherMutation) CourseCleared() bool {
	return m.CourseIDCleared() || m.clearedcourse
}

// CourseIDs returns the "course" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CourseID instead. It exists only for internal usage by the builders.
func (m *KcCourseTeacherMutation) CourseIDs() (ids []int) {
	if id := m.course; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCourse resets all changes to the "course" edge.
func (m *KcCourseTeacherMutation) ResetCourse() {
	m.course = nil
	m.clearedcourse = false
}

// Op returns the operation name.
func (m *KcCourseTeacherMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (KcCourseTeacher).
func (m *KcCourseTeacherMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *KcCourseTeacherMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.show_status != nil {
		fields = append(fields, kccourseteacher.FieldShowStatus)
	}
	if m.sort_order != nil {
		fields = append(fields, kccourseteacher.FieldSortOrder)
	}
	if m.course != nil {
		fields = append(fields, kccourseteacher.FieldCourseID)
	}
	if m.teacher != nil {
		fields = append(fields, kccourseteacher.FieldTeacherID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *KcCourseTeacherMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case kccourseteacher.FieldShowStatus:
		return m.ShowStatus()
	case kccourseteacher.FieldSortOrder:
		return m.SortOrder()
	case kccourseteacher.FieldCourseID:
		return m.CourseID()
	case kccourseteacher.FieldTeacherID:
		return m.TeacherID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *KcCourseTeacherMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case kccourseteacher.FieldShowStatus:
		return m.OldShowStatus(ctx)
	case kccourseteacher.FieldSortOrder:
		return m.OldSortOrder(ctx)
	case kccourseteacher.FieldCourseID:
		return m.OldCourseID(ctx)
	case kccourseteacher.FieldTeacherID:
		return m.OldTeacherID(ctx)
	}
	return nil, fmt.Errorf("unknown KcCourseTeacher field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KcCourseTeacherMutation) SetField(name string, value ent.Value) error {
	switch name {
	case kccourseteacher.FieldShowStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShowStatus(v)
		return nil
	case kccourseteacher.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	case kccourseteacher.FieldCourseID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCourseID(v)
		return nil
	case kccourseteacher.FieldTeacherID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeacherID(v)
		return nil
	}
	return fmt.Errorf("unknown KcCourseTeacher field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *KcCourseTeacherMutation) AddedFields() []string {
	var fields []string
	if m.addshow_status != nil {
		fields = append(fields, kccourseteacher.FieldShowStatus)
	}
	if m.addsort_order != nil {
		fields = append(fields, kccourseteacher.FieldSortOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *KcCourseTeacherMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case kccourseteacher.FieldShowStatus:
		return m.AddedShowStatus()
	case kccourseteacher.FieldSortOrder:
		return m.AddedSortOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KcCourseTeacherMutation) AddField(name string, value ent.Value) error {
	switch name {
	case kccourseteacher.FieldShowStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShowStatus(v)
		return nil
	case kccourseteacher.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown KcCourseTeacher numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *KcCourseTeacherMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(kccourseteacher.FieldCourseID) {
		fields = append(fields, kccourseteacher.FieldCourseID)
	}
	if m.FieldCleared(kccourseteacher.FieldTeacherID) {
		fields = append(fields, kccourseteacher.FieldTeacherID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *KcCourseTeacherMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *KcCourseTeacherMutation) ClearField(name string) error {
	switch name {
	case kccourseteacher.FieldCourseID:
		m.ClearCourseID()
		return nil
	case kccourseteacher.FieldTeacherID:
		m.ClearTeacherID()
		return nil
	}
	return fmt.Errorf("unknown KcCourseTeacher nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *KcCourseTeacherMutation) ResetField(name string) error {
	switch name {
	case kccourseteacher.FieldShowStatus:
		m.ResetShowStatus()
		return nil
	case kccourseteacher.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	case kccourseteacher.FieldCourseID:
		m.ResetCourseID()
		return nil
	case kccourseteacher.FieldTeacherID:
		m.ResetTeacherID()
		return nil
	}
	return fmt.Errorf("unknown KcCourseTeacher field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *KcCourseTeacherMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.teacher != nil {
		edges = append(edges, kccourseteacher.EdgeTeacher)
	}
	if m.course != nil {
		edges = append(edges, kccourseteacher.EdgeCourse)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *KcCourseTeacherMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case kccourseteacher.EdgeTeacher:
		if id := m.teacher; id != nil {
			return []ent.Value{*id}
		}
	case kccourseteacher.EdgeCourse:
		if id := m.course; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *KcCourseTeacherMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *KcCourseTeacherMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *KcCourseTeacherMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedteacher {
		edges = append(edges, kccourseteacher.EdgeTeacher)
	}
	if m.clearedcourse {
		edges = append(edges, kccourseteacher.EdgeCourse)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *KcCourseTeacherMutation) EdgeCleared(name string) bool {
	switch name {
	case kccourseteacher.EdgeTeacher:
		return m.clearedteacher
	case kccourseteacher.EdgeCourse:
		return m.clearedcourse
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *KcCourseTeacherMutation) ClearEdge(name string) error {
	switch name {
	case kccourseteacher.EdgeTeacher:
		m.ClearTeacher()
		return nil
	case kccourseteacher.EdgeCourse:
		m.ClearCourse()
		return nil
	}
	return fmt.Errorf("unknown KcCourseTeacher unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *KcCourseTeacherMutation) ResetEdge(name string) error {
	switch name {
	case kccourseteacher.EdgeTeacher:
		m.ResetTeacher()
		return nil
	case kccourseteacher.EdgeCourse:
		m.ResetCourse()
		return nil
	}
	return fmt.Errorf("unknown KcCourseTeacher edge %s", name)
}

// KcCourseVideoMutation represents an operation that mutates the KcCourseVideo nodes in the graph.
type KcCourseVideoMutation struct {
	config
	op            Op
	typ           string
	id            *int
	video_title   *string
	file_type     *int8
	addfile_type  *int8
	file_path     *string
	subtitle_path *string
	video_time    *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*KcCourseVideo, error)
	predicates    []predicate.KcCourseVideo
}

var _ ent.Mutation = (*KcCourseVideoMutation)(nil)

// kccoursevideoOption allows management of the mutation configuration using functional options.
type kccoursevideoOption func(*KcCourseVideoMutation)

// newKcCourseVideoMutation creates new mutation for the KcCourseVideo entity.
func newKcCourseVideoMutation(c config, op Op, opts ...kccoursevideoOption) *KcCourseVideoMutation {
	m := &KcCourseVideoMutation{
		config:        c,
		op:            op,
		typ:           TypeKcCourseVideo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withKcCourseVideoID sets the ID field of the mutation.
func withKcCourseVideoID(id int) kccoursevideoOption {
	return func(m *KcCourseVideoMutation) {
		var (
			err   error
			once  sync.Once
			value *KcCourseVideo
		)
		m.oldValue = func(ctx context.Context) (*KcCourseVideo, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().KcCourseVideo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withKcCourseVideo sets the old KcCourseVideo of the mutation.
func withKcCourseVideo(node *KcCourseVideo) kccoursevideoOption {
	return func(m *KcCourseVideoMutation) {
		m.oldValue = func(context.Context) (*KcCourseVideo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m KcCourseVideoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m KcCourseVideoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *KcCourseVideoMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetVideoTitle sets the "video_title" field.
func (m *KcCourseVideoMutation) SetVideoTitle(s string) {
	m.video_title = &s
}

// VideoTitle returns the value of the "video_title" field in the mutation.
func (m *KcCourseVideoMutation) VideoTitle() (r string, exists bool) {
	v := m.video_title
	if v == nil {
		return
	}
	return *v, true
}

// OldVideoTitle returns the old "video_title" field's value of the KcCourseVideo entity.
// If the KcCourseVideo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcCourseVideoMutation) OldVideoTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVideoTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVideoTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVideoTitle: %w", err)
	}
	return oldValue.VideoTitle, nil
}

// ResetVideoTitle resets all changes to the "video_title" field.
func (m *KcCourseVideoMutation) ResetVideoTitle() {
	m.video_title = nil
}

// SetFileType sets the "file_type" field.
func (m *KcCourseVideoMutation) SetFileType(i int8) {
	m.file_type = &i
	m.addfile_type = nil
}

// FileType returns the value of the "file_type" field in the mutation.
func (m *KcCourseVideoMutation) FileType() (r int8, exists bool) {
	v := m.file_type
	if v == nil {
		return
	}
	return *v, true
}

// OldFileType returns the old "file_type" field's value of the KcCourseVideo entity.
// If the KcCourseVideo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcCourseVideoMutation) OldFileType(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFileType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFileType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileType: %w", err)
	}
	return oldValue.FileType, nil
}

// AddFileType adds i to the "file_type" field.
func (m *KcCourseVideoMutation) AddFileType(i int8) {
	if m.addfile_type != nil {
		*m.addfile_type += i
	} else {
		m.addfile_type = &i
	}
}

// AddedFileType returns the value that was added to the "file_type" field in this mutation.
func (m *KcCourseVideoMutation) AddedFileType() (r int8, exists bool) {
	v := m.addfile_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetFileType resets all changes to the "file_type" field.
func (m *KcCourseVideoMutation) ResetFileType() {
	m.file_type = nil
	m.addfile_type = nil
}

// SetFilePath sets the "file_path" field.
func (m *KcCourseVideoMutation) SetFilePath(s string) {
	m.file_path = &s
}

// FilePath returns the value of the "file_path" field in the mutation.
func (m *KcCourseVideoMutation) FilePath() (r string, exists bool) {
	v := m.file_path
	if v == nil {
		return
	}
	return *v, true
}

// OldFilePath returns the old "file_path" field's value of the KcCourseVideo entity.
// If the KcCourseVideo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcCourseVideoMutation) OldFilePath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFilePath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFilePath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilePath: %w", err)
	}
	return oldValue.FilePath, nil
}

// ResetFilePath resets all changes to the "file_path" field.
func (m *KcCourseVideoMutation) ResetFilePath() {
	m.file_path = nil
}

// SetSubtitlePath sets the "subtitle_path" field.
func (m *KcCourseVideoMutation) SetSubtitlePath(s string) {
	m.subtitle_path = &s
}

// SubtitlePath returns the value of the "subtitle_path" field in the mutation.
func (m *KcCourseVideoMutation) SubtitlePath() (r string, exists bool) {
	v := m.subtitle_path
	if v == nil {
		return
	}
	return *v, true
}

// OldSubtitlePath returns the old "subtitle_path" field's value of the KcCourseVideo entity.
// If the KcCourseVideo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcCourseVideoMutation) OldSubtitlePath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSubtitlePath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSubtitlePath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubtitlePath: %w", err)
	}
	return oldValue.SubtitlePath, nil
}

// ResetSubtitlePath resets all changes to the "subtitle_path" field.
func (m *KcCourseVideoMutation) ResetSubtitlePath() {
	m.subtitle_path = nil
}

// SetVideoTime sets the "video_time" field.
func (m *KcCourseVideoMutation) SetVideoTime(s string) {
	m.video_time = &s
}

// VideoTime returns the value of the "video_time" field in the mutation.
func (m *KcCourseVideoMutation) VideoTime() (r string, exists bool) {
	v := m.video_time
	if v == nil {
		return
	}
	return *v, true
}

// OldVideoTime returns the old "video_time" field's value of the KcCourseVideo entity.
// If the KcCourseVideo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcCourseVideoMutation) OldVideoTime(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVideoTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVideoTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVideoTime: %w", err)
	}
	return oldValue.VideoTime, nil
}

// ResetVideoTime resets all changes to the "video_time" field.
func (m *KcCourseVideoMutation) ResetVideoTime() {
	m.video_time = nil
}

// Op returns the operation name.
func (m *KcCourseVideoMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (KcCourseVideo).
func (m *KcCourseVideoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *KcCourseVideoMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.video_title != nil {
		fields = append(fields, kccoursevideo.FieldVideoTitle)
	}
	if m.file_type != nil {
		fields = append(fields, kccoursevideo.FieldFileType)
	}
	if m.file_path != nil {
		fields = append(fields, kccoursevideo.FieldFilePath)
	}
	if m.subtitle_path != nil {
		fields = append(fields, kccoursevideo.FieldSubtitlePath)
	}
	if m.video_time != nil {
		fields = append(fields, kccoursevideo.FieldVideoTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *KcCourseVideoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case kccoursevideo.FieldVideoTitle:
		return m.VideoTitle()
	case kccoursevideo.FieldFileType:
		return m.FileType()
	case kccoursevideo.FieldFilePath:
		return m.FilePath()
	case kccoursevideo.FieldSubtitlePath:
		return m.SubtitlePath()
	case kccoursevideo.FieldVideoTime:
		return m.VideoTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *KcCourseVideoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case kccoursevideo.FieldVideoTitle:
		return m.OldVideoTitle(ctx)
	case kccoursevideo.FieldFileType:
		return m.OldFileType(ctx)
	case kccoursevideo.FieldFilePath:
		return m.OldFilePath(ctx)
	case kccoursevideo.FieldSubtitlePath:
		return m.OldSubtitlePath(ctx)
	case kccoursevideo.FieldVideoTime:
		return m.OldVideoTime(ctx)
	}
	return nil, fmt.Errorf("unknown KcCourseVideo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KcCourseVideoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case kccoursevideo.FieldVideoTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVideoTitle(v)
		return nil
	case kccoursevideo.FieldFileType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileType(v)
		return nil
	case kccoursevideo.FieldFilePath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilePath(v)
		return nil
	case kccoursevideo.FieldSubtitlePath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubtitlePath(v)
		return nil
	case kccoursevideo.FieldVideoTime:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVideoTime(v)
		return nil
	}
	return fmt.Errorf("unknown KcCourseVideo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *KcCourseVideoMutation) AddedFields() []string {
	var fields []string
	if m.addfile_type != nil {
		fields = append(fields, kccoursevideo.FieldFileType)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *KcCourseVideoMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case kccoursevideo.FieldFileType:
		return m.AddedFileType()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KcCourseVideoMutation) AddField(name string, value ent.Value) error {
	switch name {
	case kccoursevideo.FieldFileType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFileType(v)
		return nil
	}
	return fmt.Errorf("unknown KcCourseVideo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *KcCourseVideoMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *KcCourseVideoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *KcCourseVideoMutation) ClearField(name string) error {
	return fmt.Errorf("unknown KcCourseVideo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *KcCourseVideoMutation) ResetField(name string) error {
	switch name {
	case kccoursevideo.FieldVideoTitle:
		m.ResetVideoTitle()
		return nil
	case kccoursevideo.FieldFileType:
		m.ResetFileType()
		return nil
	case kccoursevideo.FieldFilePath:
		m.ResetFilePath()
		return nil
	case kccoursevideo.FieldSubtitlePath:
		m.ResetSubtitlePath()
		return nil
	case kccoursevideo.FieldVideoTime:
		m.ResetVideoTime()
		return nil
	}
	return fmt.Errorf("unknown KcCourseVideo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *KcCourseVideoMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *KcCourseVideoMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *KcCourseVideoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *KcCourseVideoMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *KcCourseVideoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *KcCourseVideoMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *KcCourseVideoMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown KcCourseVideo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *KcCourseVideoMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown KcCourseVideo edge %s", name)
}

// KcSmallCategoryAttachmentMutation represents an operation that mutates the KcSmallCategoryAttachment nodes in the graph.
type KcSmallCategoryAttachmentMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	uuid                  *string
	created_at            *time.Time
	updated_at            *time.Time
	deleted_at            *time.Time
	attachment_name       *string
	clearedFields         map[string]struct{}
	attachment            *int
	clearedattachment     bool
	small_category        *int
	clearedsmall_category bool
	done                  bool
	oldValue              func(context.Context) (*KcSmallCategoryAttachment, error)
	predicates            []predicate.KcSmallCategoryAttachment
}

var _ ent.Mutation = (*KcSmallCategoryAttachmentMutation)(nil)

// kcsmallcategoryattachmentOption allows management of the mutation configuration using functional options.
type kcsmallcategoryattachmentOption func(*KcSmallCategoryAttachmentMutation)

// newKcSmallCategoryAttachmentMutation creates new mutation for the KcSmallCategoryAttachment entity.
func newKcSmallCategoryAttachmentMutation(c config, op Op, opts ...kcsmallcategoryattachmentOption) *KcSmallCategoryAttachmentMutation {
	m := &KcSmallCategoryAttachmentMutation{
		config:        c,
		op:            op,
		typ:           TypeKcSmallCategoryAttachment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withKcSmallCategoryAttachmentID sets the ID field of the mutation.
func withKcSmallCategoryAttachmentID(id int) kcsmallcategoryattachmentOption {
	return func(m *KcSmallCategoryAttachmentMutation) {
		var (
			err   error
			once  sync.Once
			value *KcSmallCategoryAttachment
		)
		m.oldValue = func(ctx context.Context) (*KcSmallCategoryAttachment, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().KcSmallCategoryAttachment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withKcSmallCategoryAttachment sets the old KcSmallCategoryAttachment of the mutation.
func withKcSmallCategoryAttachment(node *KcSmallCategoryAttachment) kcsmallcategoryattachmentOption {
	return func(m *KcSmallCategoryAttachmentMutation) {
		m.oldValue = func(context.Context) (*KcSmallCategoryAttachment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m KcSmallCategoryAttachmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m KcSmallCategoryAttachmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *KcSmallCategoryAttachmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *KcSmallCategoryAttachmentMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *KcSmallCategoryAttachmentMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the KcSmallCategoryAttachment entity.
// If the KcSmallCategoryAttachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcSmallCategoryAttachmentMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *KcSmallCategoryAttachmentMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *KcSmallCategoryAttachmentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *KcSmallCategoryAttachmentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the KcSmallCategoryAttachment entity.
// If the KcSmallCategoryAttachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcSmallCategoryAttachmentMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *KcSmallCategoryAttachmentMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[kcsmallcategoryattachment.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *KcSmallCategoryAttachmentMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[kcsmallcategoryattachment.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *KcSmallCategoryAttachmentMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, kcsmallcategoryattachment.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *KcSmallCategoryAttachmentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *KcSmallCategoryAttachmentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the KcSmallCategoryAttachment entity.
// If the KcSmallCategoryAttachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcSmallCategoryAttachmentMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *KcSmallCategoryAttachmentMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[kcsmallcategoryattachment.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *KcSmallCategoryAttachmentMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[kcsmallcategoryattachment.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *KcSmallCategoryAttachmentMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, kcsmallcategoryattachment.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *KcSmallCategoryAttachmentMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *KcSmallCategoryAttachmentMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the KcSmallCategoryAttachment entity.
// If the KcSmallCategoryAttachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcSmallCategoryAttachmentMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *KcSmallCategoryAttachmentMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[kcsmallcategoryattachment.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *KcSmallCategoryAttachmentMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[kcsmallcategoryattachment.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *KcSmallCategoryAttachmentMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, kcsmallcategoryattachment.FieldDeletedAt)
}

// SetAttachmentID sets the "attachment_id" field.
func (m *KcSmallCategoryAttachmentMutation) SetAttachmentID(i int) {
	m.attachment = &i
}

// AttachmentID returns the value of the "attachment_id" field in the mutation.
func (m *KcSmallCategoryAttachmentMutation) AttachmentID() (r int, exists bool) {
	v := m.attachment
	if v == nil {
		return
	}
	return *v, true
}

// OldAttachmentID returns the old "attachment_id" field's value of the KcSmallCategoryAttachment entity.
// If the KcSmallCategoryAttachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcSmallCategoryAttachmentMutation) OldAttachmentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAttachmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAttachmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttachmentID: %w", err)
	}
	return oldValue.AttachmentID, nil
}

// ClearAttachmentID clears the value of the "attachment_id" field.
func (m *KcSmallCategoryAttachmentMutation) ClearAttachmentID() {
	m.attachment = nil
	m.clearedFields[kcsmallcategoryattachment.FieldAttachmentID] = struct{}{}
}

// AttachmentIDCleared returns if the "attachment_id" field was cleared in this mutation.
func (m *KcSmallCategoryAttachmentMutation) AttachmentIDCleared() bool {
	_, ok := m.clearedFields[kcsmallcategoryattachment.FieldAttachmentID]
	return ok
}

// ResetAttachmentID resets all changes to the "attachment_id" field.
func (m *KcSmallCategoryAttachmentMutation) ResetAttachmentID() {
	m.attachment = nil
	delete(m.clearedFields, kcsmallcategoryattachment.FieldAttachmentID)
}

// SetAttachmentName sets the "attachment_name" field.
func (m *KcSmallCategoryAttachmentMutation) SetAttachmentName(s string) {
	m.attachment_name = &s
}

// AttachmentName returns the value of the "attachment_name" field in the mutation.
func (m *KcSmallCategoryAttachmentMutation) AttachmentName() (r string, exists bool) {
	v := m.attachment_name
	if v == nil {
		return
	}
	return *v, true
}

// OldAttachmentName returns the old "attachment_name" field's value of the KcSmallCategoryAttachment entity.
// If the KcSmallCategoryAttachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcSmallCategoryAttachmentMutation) OldAttachmentName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAttachmentName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAttachmentName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttachmentName: %w", err)
	}
	return oldValue.AttachmentName, nil
}

// ResetAttachmentName resets all changes to the "attachment_name" field.
func (m *KcSmallCategoryAttachmentMutation) ResetAttachmentName() {
	m.attachment_name = nil
}

// SetSmallCategoryID sets the "small_category_id" field.
func (m *KcSmallCategoryAttachmentMutation) SetSmallCategoryID(i int) {
	m.small_category = &i
}

// SmallCategoryID returns the value of the "small_category_id" field in the mutation.
func (m *KcSmallCategoryAttachmentMutation) SmallCategoryID() (r int, exists bool) {
	v := m.small_category
	if v == nil {
		return
	}
	return *v, true
}

// OldSmallCategoryID returns the old "small_category_id" field's value of the KcSmallCategoryAttachment entity.
// If the KcSmallCategoryAttachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcSmallCategoryAttachmentMutation) OldSmallCategoryID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSmallCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSmallCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSmallCategoryID: %w", err)
	}
	return oldValue.SmallCategoryID, nil
}

// ClearSmallCategoryID clears the value of the "small_category_id" field.
func (m *KcSmallCategoryAttachmentMutation) ClearSmallCategoryID() {
	m.small_category = nil
	m.clearedFields[kcsmallcategoryattachment.FieldSmallCategoryID] = struct{}{}
}

// SmallCategoryIDCleared returns if the "small_category_id" field was cleared in this mutation.
func (m *KcSmallCategoryAttachmentMutation) SmallCategoryIDCleared() bool {
	_, ok := m.clearedFields[kcsmallcategoryattachment.FieldSmallCategoryID]
	return ok
}

// ResetSmallCategoryID resets all changes to the "small_category_id" field.
func (m *KcSmallCategoryAttachmentMutation) ResetSmallCategoryID() {
	m.small_category = nil
	delete(m.clearedFields, kcsmallcategoryattachment.FieldSmallCategoryID)
}

// ClearAttachment clears the "attachment" edge to the Attachment entity.
func (m *KcSmallCategoryAttachmentMutation) ClearAttachment() {
	m.clearedattachment = true
}

// AttachmentCleared reports if the "attachment" edge to the Attachment entity was cleared.
func (m *KcSmallCategoryAttachmentMutation) AttachmentCleared() bool {
	return m.AttachmentIDCleared() || m.clearedattachment
}

// AttachmentIDs returns the "attachment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AttachmentID instead. It exists only for internal usage by the builders.
func (m *KcSmallCategoryAttachmentMutation) AttachmentIDs() (ids []int) {
	if id := m.attachment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAttachment resets all changes to the "attachment" edge.
func (m *KcSmallCategoryAttachmentMutation) ResetAttachment() {
	m.attachment = nil
	m.clearedattachment = false
}

// ClearSmallCategory clears the "small_category" edge to the KcCourseSmallCategory entity.
func (m *KcSmallCategoryAttachmentMutation) ClearSmallCategory() {
	m.clearedsmall_category = true
}

// SmallCategoryCleared reports if the "small_category" edge to the KcCourseSmallCategory entity was cleared.
func (m *KcSmallCategoryAttachmentMutation) SmallCategoryCleared() bool {
	return m.SmallCategoryIDCleared() || m.clearedsmall_category
}

// SmallCategoryIDs returns the "small_category" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SmallCategoryID instead. It exists only for internal usage by the builders.
func (m *KcSmallCategoryAttachmentMutation) SmallCategoryIDs() (ids []int) {
	if id := m.small_category; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSmallCategory resets all changes to the "small_category" edge.
func (m *KcSmallCategoryAttachmentMutation) ResetSmallCategory() {
	m.small_category = nil
	m.clearedsmall_category = false
}

// Op returns the operation name.
func (m *KcSmallCategoryAttachmentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (KcSmallCategoryAttachment).
func (m *KcSmallCategoryAttachmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *KcSmallCategoryAttachmentMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.uuid != nil {
		fields = append(fields, kcsmallcategoryattachment.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, kcsmallcategoryattachment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, kcsmallcategoryattachment.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, kcsmallcategoryattachment.FieldDeletedAt)
	}
	if m.attachment != nil {
		fields = append(fields, kcsmallcategoryattachment.FieldAttachmentID)
	}
	if m.attachment_name != nil {
		fields = append(fields, kcsmallcategoryattachment.FieldAttachmentName)
	}
	if m.small_category != nil {
		fields = append(fields, kcsmallcategoryattachment.FieldSmallCategoryID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *KcSmallCategoryAttachmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case kcsmallcategoryattachment.FieldUUID:
		return m.UUID()
	case kcsmallcategoryattachment.FieldCreatedAt:
		return m.CreatedAt()
	case kcsmallcategoryattachment.FieldUpdatedAt:
		return m.UpdatedAt()
	case kcsmallcategoryattachment.FieldDeletedAt:
		return m.DeletedAt()
	case kcsmallcategoryattachment.FieldAttachmentID:
		return m.AttachmentID()
	case kcsmallcategoryattachment.FieldAttachmentName:
		return m.AttachmentName()
	case kcsmallcategoryattachment.FieldSmallCategoryID:
		return m.SmallCategoryID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *KcSmallCategoryAttachmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case kcsmallcategoryattachment.FieldUUID:
		return m.OldUUID(ctx)
	case kcsmallcategoryattachment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case kcsmallcategoryattachment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case kcsmallcategoryattachment.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case kcsmallcategoryattachment.FieldAttachmentID:
		return m.OldAttachmentID(ctx)
	case kcsmallcategoryattachment.FieldAttachmentName:
		return m.OldAttachmentName(ctx)
	case kcsmallcategoryattachment.FieldSmallCategoryID:
		return m.OldSmallCategoryID(ctx)
	}
	return nil, fmt.Errorf("unknown KcSmallCategoryAttachment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KcSmallCategoryAttachmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case kcsmallcategoryattachment.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case kcsmallcategoryattachment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case kcsmallcategoryattachment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case kcsmallcategoryattachment.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case kcsmallcategoryattachment.FieldAttachmentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttachmentID(v)
		return nil
	case kcsmallcategoryattachment.FieldAttachmentName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttachmentName(v)
		return nil
	case kcsmallcategoryattachment.FieldSmallCategoryID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSmallCategoryID(v)
		return nil
	}
	return fmt.Errorf("unknown KcSmallCategoryAttachment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *KcSmallCategoryAttachmentMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *KcSmallCategoryAttachmentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KcSmallCategoryAttachmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown KcSmallCategoryAttachment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *KcSmallCategoryAttachmentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(kcsmallcategoryattachment.FieldCreatedAt) {
		fields = append(fields, kcsmallcategoryattachment.FieldCreatedAt)
	}
	if m.FieldCleared(kcsmallcategoryattachment.FieldUpdatedAt) {
		fields = append(fields, kcsmallcategoryattachment.FieldUpdatedAt)
	}
	if m.FieldCleared(kcsmallcategoryattachment.FieldDeletedAt) {
		fields = append(fields, kcsmallcategoryattachment.FieldDeletedAt)
	}
	if m.FieldCleared(kcsmallcategoryattachment.FieldAttachmentID) {
		fields = append(fields, kcsmallcategoryattachment.FieldAttachmentID)
	}
	if m.FieldCleared(kcsmallcategoryattachment.FieldSmallCategoryID) {
		fields = append(fields, kcsmallcategoryattachment.FieldSmallCategoryID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *KcSmallCategoryAttachmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *KcSmallCategoryAttachmentMutation) ClearField(name string) error {
	switch name {
	case kcsmallcategoryattachment.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case kcsmallcategoryattachment.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case kcsmallcategoryattachment.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case kcsmallcategoryattachment.FieldAttachmentID:
		m.ClearAttachmentID()
		return nil
	case kcsmallcategoryattachment.FieldSmallCategoryID:
		m.ClearSmallCategoryID()
		return nil
	}
	return fmt.Errorf("unknown KcSmallCategoryAttachment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *KcSmallCategoryAttachmentMutation) ResetField(name string) error {
	switch name {
	case kcsmallcategoryattachment.FieldUUID:
		m.ResetUUID()
		return nil
	case kcsmallcategoryattachment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case kcsmallcategoryattachment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case kcsmallcategoryattachment.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case kcsmallcategoryattachment.FieldAttachmentID:
		m.ResetAttachmentID()
		return nil
	case kcsmallcategoryattachment.FieldAttachmentName:
		m.ResetAttachmentName()
		return nil
	case kcsmallcategoryattachment.FieldSmallCategoryID:
		m.ResetSmallCategoryID()
		return nil
	}
	return fmt.Errorf("unknown KcSmallCategoryAttachment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *KcSmallCategoryAttachmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.attachment != nil {
		edges = append(edges, kcsmallcategoryattachment.EdgeAttachment)
	}
	if m.small_category != nil {
		edges = append(edges, kcsmallcategoryattachment.EdgeSmallCategory)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *KcSmallCategoryAttachmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case kcsmallcategoryattachment.EdgeAttachment:
		if id := m.attachment; id != nil {
			return []ent.Value{*id}
		}
	case kcsmallcategoryattachment.EdgeSmallCategory:
		if id := m.small_category; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *KcSmallCategoryAttachmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *KcSmallCategoryAttachmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *KcSmallCategoryAttachmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedattachment {
		edges = append(edges, kcsmallcategoryattachment.EdgeAttachment)
	}
	if m.clearedsmall_category {
		edges = append(edges, kcsmallcategoryattachment.EdgeSmallCategory)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *KcSmallCategoryAttachmentMutation) EdgeCleared(name string) bool {
	switch name {
	case kcsmallcategoryattachment.EdgeAttachment:
		return m.clearedattachment
	case kcsmallcategoryattachment.EdgeSmallCategory:
		return m.clearedsmall_category
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *KcSmallCategoryAttachmentMutation) ClearEdge(name string) error {
	switch name {
	case kcsmallcategoryattachment.EdgeAttachment:
		m.ClearAttachment()
		return nil
	case kcsmallcategoryattachment.EdgeSmallCategory:
		m.ClearSmallCategory()
		return nil
	}
	return fmt.Errorf("unknown KcSmallCategoryAttachment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *KcSmallCategoryAttachmentMutation) ResetEdge(name string) error {
	switch name {
	case kcsmallcategoryattachment.EdgeAttachment:
		m.ResetAttachment()
		return nil
	case kcsmallcategoryattachment.EdgeSmallCategory:
		m.ResetSmallCategory()
		return nil
	}
	return fmt.Errorf("unknown KcSmallCategoryAttachment edge %s", name)
}

// KcSmallCategoryExamPaperMutation represents an operation that mutates the KcSmallCategoryExamPaper nodes in the graph.
type KcSmallCategoryExamPaperMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	uuid                         *string
	created_at                   *time.Time
	updated_at                   *time.Time
	deleted_at                   *time.Time
	_type                        *uint8
	add_type                     *uint8
	clearedFields                map[string]struct{}
	exam_paper                   *int
	clearedexam_paper            bool
	course_small_category        *int
	clearedcourse_small_category bool
	done                         bool
	oldValue                     func(context.Context) (*KcSmallCategoryExamPaper, error)
	predicates                   []predicate.KcSmallCategoryExamPaper
}

var _ ent.Mutation = (*KcSmallCategoryExamPaperMutation)(nil)

// kcsmallcategoryexampaperOption allows management of the mutation configuration using functional options.
type kcsmallcategoryexampaperOption func(*KcSmallCategoryExamPaperMutation)

// newKcSmallCategoryExamPaperMutation creates new mutation for the KcSmallCategoryExamPaper entity.
func newKcSmallCategoryExamPaperMutation(c config, op Op, opts ...kcsmallcategoryexampaperOption) *KcSmallCategoryExamPaperMutation {
	m := &KcSmallCategoryExamPaperMutation{
		config:        c,
		op:            op,
		typ:           TypeKcSmallCategoryExamPaper,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withKcSmallCategoryExamPaperID sets the ID field of the mutation.
func withKcSmallCategoryExamPaperID(id int) kcsmallcategoryexampaperOption {
	return func(m *KcSmallCategoryExamPaperMutation) {
		var (
			err   error
			once  sync.Once
			value *KcSmallCategoryExamPaper
		)
		m.oldValue = func(ctx context.Context) (*KcSmallCategoryExamPaper, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().KcSmallCategoryExamPaper.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withKcSmallCategoryExamPaper sets the old KcSmallCategoryExamPaper of the mutation.
func withKcSmallCategoryExamPaper(node *KcSmallCategoryExamPaper) kcsmallcategoryexampaperOption {
	return func(m *KcSmallCategoryExamPaperMutation) {
		m.oldValue = func(context.Context) (*KcSmallCategoryExamPaper, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m KcSmallCategoryExamPaperMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m KcSmallCategoryExamPaperMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *KcSmallCategoryExamPaperMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *KcSmallCategoryExamPaperMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *KcSmallCategoryExamPaperMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the KcSmallCategoryExamPaper entity.
// If the KcSmallCategoryExamPaper object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcSmallCategoryExamPaperMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *KcSmallCategoryExamPaperMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *KcSmallCategoryExamPaperMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *KcSmallCategoryExamPaperMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the KcSmallCategoryExamPaper entity.
// If the KcSmallCategoryExamPaper object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcSmallCategoryExamPaperMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *KcSmallCategoryExamPaperMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[kcsmallcategoryexampaper.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *KcSmallCategoryExamPaperMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[kcsmallcategoryexampaper.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *KcSmallCategoryExamPaperMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, kcsmallcategoryexampaper.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *KcSmallCategoryExamPaperMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *KcSmallCategoryExamPaperMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the KcSmallCategoryExamPaper entity.
// If the KcSmallCategoryExamPaper object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcSmallCategoryExamPaperMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *KcSmallCategoryExamPaperMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[kcsmallcategoryexampaper.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *KcSmallCategoryExamPaperMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[kcsmallcategoryexampaper.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *KcSmallCategoryExamPaperMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, kcsmallcategoryexampaper.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *KcSmallCategoryExamPaperMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *KcSmallCategoryExamPaperMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the KcSmallCategoryExamPaper entity.
// If the KcSmallCategoryExamPaper object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcSmallCategoryExamPaperMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *KcSmallCategoryExamPaperMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[kcsmallcategoryexampaper.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *KcSmallCategoryExamPaperMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[kcsmallcategoryexampaper.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *KcSmallCategoryExamPaperMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, kcsmallcategoryexampaper.FieldDeletedAt)
}

// SetType sets the "type" field.
func (m *KcSmallCategoryExamPaperMutation) SetType(u uint8) {
	m._type = &u
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *KcSmallCategoryExamPaperMutation) GetType() (r uint8, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the KcSmallCategoryExamPaper entity.
// If the KcSmallCategoryExamPaper object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcSmallCategoryExamPaperMutation) OldType(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds u to the "type" field.
func (m *KcSmallCategoryExamPaperMutation) AddType(u uint8) {
	if m.add_type != nil {
		*m.add_type += u
	} else {
		m.add_type = &u
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *KcSmallCategoryExamPaperMutation) AddedType() (r uint8, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *KcSmallCategoryExamPaperMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetExamPaperID sets the "exam_paper_id" field.
func (m *KcSmallCategoryExamPaperMutation) SetExamPaperID(i int) {
	m.exam_paper = &i
}

// ExamPaperID returns the value of the "exam_paper_id" field in the mutation.
func (m *KcSmallCategoryExamPaperMutation) ExamPaperID() (r int, exists bool) {
	v := m.exam_paper
	if v == nil {
		return
	}
	return *v, true
}

// OldExamPaperID returns the old "exam_paper_id" field's value of the KcSmallCategoryExamPaper entity.
// If the KcSmallCategoryExamPaper object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcSmallCategoryExamPaperMutation) OldExamPaperID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExamPaperID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExamPaperID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamPaperID: %w", err)
	}
	return oldValue.ExamPaperID, nil
}

// ClearExamPaperID clears the value of the "exam_paper_id" field.
func (m *KcSmallCategoryExamPaperMutation) ClearExamPaperID() {
	m.exam_paper = nil
	m.clearedFields[kcsmallcategoryexampaper.FieldExamPaperID] = struct{}{}
}

// ExamPaperIDCleared returns if the "exam_paper_id" field was cleared in this mutation.
func (m *KcSmallCategoryExamPaperMutation) ExamPaperIDCleared() bool {
	_, ok := m.clearedFields[kcsmallcategoryexampaper.FieldExamPaperID]
	return ok
}

// ResetExamPaperID resets all changes to the "exam_paper_id" field.
func (m *KcSmallCategoryExamPaperMutation) ResetExamPaperID() {
	m.exam_paper = nil
	delete(m.clearedFields, kcsmallcategoryexampaper.FieldExamPaperID)
}

// SetSmallCategoryID sets the "small_category_id" field.
func (m *KcSmallCategoryExamPaperMutation) SetSmallCategoryID(i int) {
	m.course_small_category = &i
}

// SmallCategoryID returns the value of the "small_category_id" field in the mutation.
func (m *KcSmallCategoryExamPaperMutation) SmallCategoryID() (r int, exists bool) {
	v := m.course_small_category
	if v == nil {
		return
	}
	return *v, true
}

// OldSmallCategoryID returns the old "small_category_id" field's value of the KcSmallCategoryExamPaper entity.
// If the KcSmallCategoryExamPaper object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcSmallCategoryExamPaperMutation) OldSmallCategoryID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSmallCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSmallCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSmallCategoryID: %w", err)
	}
	return oldValue.SmallCategoryID, nil
}

// ClearSmallCategoryID clears the value of the "small_category_id" field.
func (m *KcSmallCategoryExamPaperMutation) ClearSmallCategoryID() {
	m.course_small_category = nil
	m.clearedFields[kcsmallcategoryexampaper.FieldSmallCategoryID] = struct{}{}
}

// SmallCategoryIDCleared returns if the "small_category_id" field was cleared in this mutation.
func (m *KcSmallCategoryExamPaperMutation) SmallCategoryIDCleared() bool {
	_, ok := m.clearedFields[kcsmallcategoryexampaper.FieldSmallCategoryID]
	return ok
}

// ResetSmallCategoryID resets all changes to the "small_category_id" field.
func (m *KcSmallCategoryExamPaperMutation) ResetSmallCategoryID() {
	m.course_small_category = nil
	delete(m.clearedFields, kcsmallcategoryexampaper.FieldSmallCategoryID)
}

// ClearExamPaper clears the "exam_paper" edge to the TkExamPaper entity.
func (m *KcSmallCategoryExamPaperMutation) ClearExamPaper() {
	m.clearedexam_paper = true
}

// ExamPaperCleared reports if the "exam_paper" edge to the TkExamPaper entity was cleared.
func (m *KcSmallCategoryExamPaperMutation) ExamPaperCleared() bool {
	return m.ExamPaperIDCleared() || m.clearedexam_paper
}

// ExamPaperIDs returns the "exam_paper" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ExamPaperID instead. It exists only for internal usage by the builders.
func (m *KcSmallCategoryExamPaperMutation) ExamPaperIDs() (ids []int) {
	if id := m.exam_paper; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExamPaper resets all changes to the "exam_paper" edge.
func (m *KcSmallCategoryExamPaperMutation) ResetExamPaper() {
	m.exam_paper = nil
	m.clearedexam_paper = false
}

// SetCourseSmallCategoryID sets the "course_small_category" edge to the KcCourseSmallCategory entity by id.
func (m *KcSmallCategoryExamPaperMutation) SetCourseSmallCategoryID(id int) {
	m.course_small_category = &id
}

// ClearCourseSmallCategory clears the "course_small_category" edge to the KcCourseSmallCategory entity.
func (m *KcSmallCategoryExamPaperMutation) ClearCourseSmallCategory() {
	m.clearedcourse_small_category = true
}

// CourseSmallCategoryCleared reports if the "course_small_category" edge to the KcCourseSmallCategory entity was cleared.
func (m *KcSmallCategoryExamPaperMutation) CourseSmallCategoryCleared() bool {
	return m.SmallCategoryIDCleared() || m.clearedcourse_small_category
}

// CourseSmallCategoryID returns the "course_small_category" edge ID in the mutation.
func (m *KcSmallCategoryExamPaperMutation) CourseSmallCategoryID() (id int, exists bool) {
	if m.course_small_category != nil {
		return *m.course_small_category, true
	}
	return
}

// CourseSmallCategoryIDs returns the "course_small_category" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CourseSmallCategoryID instead. It exists only for internal usage by the builders.
func (m *KcSmallCategoryExamPaperMutation) CourseSmallCategoryIDs() (ids []int) {
	if id := m.course_small_category; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCourseSmallCategory resets all changes to the "course_small_category" edge.
func (m *KcSmallCategoryExamPaperMutation) ResetCourseSmallCategory() {
	m.course_small_category = nil
	m.clearedcourse_small_category = false
}

// Op returns the operation name.
func (m *KcSmallCategoryExamPaperMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (KcSmallCategoryExamPaper).
func (m *KcSmallCategoryExamPaperMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *KcSmallCategoryExamPaperMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.uuid != nil {
		fields = append(fields, kcsmallcategoryexampaper.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, kcsmallcategoryexampaper.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, kcsmallcategoryexampaper.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, kcsmallcategoryexampaper.FieldDeletedAt)
	}
	if m._type != nil {
		fields = append(fields, kcsmallcategoryexampaper.FieldType)
	}
	if m.exam_paper != nil {
		fields = append(fields, kcsmallcategoryexampaper.FieldExamPaperID)
	}
	if m.course_small_category != nil {
		fields = append(fields, kcsmallcategoryexampaper.FieldSmallCategoryID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *KcSmallCategoryExamPaperMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case kcsmallcategoryexampaper.FieldUUID:
		return m.UUID()
	case kcsmallcategoryexampaper.FieldCreatedAt:
		return m.CreatedAt()
	case kcsmallcategoryexampaper.FieldUpdatedAt:
		return m.UpdatedAt()
	case kcsmallcategoryexampaper.FieldDeletedAt:
		return m.DeletedAt()
	case kcsmallcategoryexampaper.FieldType:
		return m.GetType()
	case kcsmallcategoryexampaper.FieldExamPaperID:
		return m.ExamPaperID()
	case kcsmallcategoryexampaper.FieldSmallCategoryID:
		return m.SmallCategoryID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *KcSmallCategoryExamPaperMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case kcsmallcategoryexampaper.FieldUUID:
		return m.OldUUID(ctx)
	case kcsmallcategoryexampaper.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case kcsmallcategoryexampaper.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case kcsmallcategoryexampaper.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case kcsmallcategoryexampaper.FieldType:
		return m.OldType(ctx)
	case kcsmallcategoryexampaper.FieldExamPaperID:
		return m.OldExamPaperID(ctx)
	case kcsmallcategoryexampaper.FieldSmallCategoryID:
		return m.OldSmallCategoryID(ctx)
	}
	return nil, fmt.Errorf("unknown KcSmallCategoryExamPaper field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KcSmallCategoryExamPaperMutation) SetField(name string, value ent.Value) error {
	switch name {
	case kcsmallcategoryexampaper.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case kcsmallcategoryexampaper.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case kcsmallcategoryexampaper.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case kcsmallcategoryexampaper.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case kcsmallcategoryexampaper.FieldType:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case kcsmallcategoryexampaper.FieldExamPaperID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamPaperID(v)
		return nil
	case kcsmallcategoryexampaper.FieldSmallCategoryID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSmallCategoryID(v)
		return nil
	}
	return fmt.Errorf("unknown KcSmallCategoryExamPaper field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *KcSmallCategoryExamPaperMutation) AddedFields() []string {
	var fields []string
	if m.add_type != nil {
		fields = append(fields, kcsmallcategoryexampaper.FieldType)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *KcSmallCategoryExamPaperMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case kcsmallcategoryexampaper.FieldType:
		return m.AddedType()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KcSmallCategoryExamPaperMutation) AddField(name string, value ent.Value) error {
	switch name {
	case kcsmallcategoryexampaper.FieldType:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	}
	return fmt.Errorf("unknown KcSmallCategoryExamPaper numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *KcSmallCategoryExamPaperMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(kcsmallcategoryexampaper.FieldCreatedAt) {
		fields = append(fields, kcsmallcategoryexampaper.FieldCreatedAt)
	}
	if m.FieldCleared(kcsmallcategoryexampaper.FieldUpdatedAt) {
		fields = append(fields, kcsmallcategoryexampaper.FieldUpdatedAt)
	}
	if m.FieldCleared(kcsmallcategoryexampaper.FieldDeletedAt) {
		fields = append(fields, kcsmallcategoryexampaper.FieldDeletedAt)
	}
	if m.FieldCleared(kcsmallcategoryexampaper.FieldExamPaperID) {
		fields = append(fields, kcsmallcategoryexampaper.FieldExamPaperID)
	}
	if m.FieldCleared(kcsmallcategoryexampaper.FieldSmallCategoryID) {
		fields = append(fields, kcsmallcategoryexampaper.FieldSmallCategoryID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *KcSmallCategoryExamPaperMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *KcSmallCategoryExamPaperMutation) ClearField(name string) error {
	switch name {
	case kcsmallcategoryexampaper.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case kcsmallcategoryexampaper.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case kcsmallcategoryexampaper.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case kcsmallcategoryexampaper.FieldExamPaperID:
		m.ClearExamPaperID()
		return nil
	case kcsmallcategoryexampaper.FieldSmallCategoryID:
		m.ClearSmallCategoryID()
		return nil
	}
	return fmt.Errorf("unknown KcSmallCategoryExamPaper nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *KcSmallCategoryExamPaperMutation) ResetField(name string) error {
	switch name {
	case kcsmallcategoryexampaper.FieldUUID:
		m.ResetUUID()
		return nil
	case kcsmallcategoryexampaper.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case kcsmallcategoryexampaper.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case kcsmallcategoryexampaper.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case kcsmallcategoryexampaper.FieldType:
		m.ResetType()
		return nil
	case kcsmallcategoryexampaper.FieldExamPaperID:
		m.ResetExamPaperID()
		return nil
	case kcsmallcategoryexampaper.FieldSmallCategoryID:
		m.ResetSmallCategoryID()
		return nil
	}
	return fmt.Errorf("unknown KcSmallCategoryExamPaper field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *KcSmallCategoryExamPaperMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.exam_paper != nil {
		edges = append(edges, kcsmallcategoryexampaper.EdgeExamPaper)
	}
	if m.course_small_category != nil {
		edges = append(edges, kcsmallcategoryexampaper.EdgeCourseSmallCategory)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *KcSmallCategoryExamPaperMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case kcsmallcategoryexampaper.EdgeExamPaper:
		if id := m.exam_paper; id != nil {
			return []ent.Value{*id}
		}
	case kcsmallcategoryexampaper.EdgeCourseSmallCategory:
		if id := m.course_small_category; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *KcSmallCategoryExamPaperMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *KcSmallCategoryExamPaperMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *KcSmallCategoryExamPaperMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedexam_paper {
		edges = append(edges, kcsmallcategoryexampaper.EdgeExamPaper)
	}
	if m.clearedcourse_small_category {
		edges = append(edges, kcsmallcategoryexampaper.EdgeCourseSmallCategory)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *KcSmallCategoryExamPaperMutation) EdgeCleared(name string) bool {
	switch name {
	case kcsmallcategoryexampaper.EdgeExamPaper:
		return m.clearedexam_paper
	case kcsmallcategoryexampaper.EdgeCourseSmallCategory:
		return m.clearedcourse_small_category
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *KcSmallCategoryExamPaperMutation) ClearEdge(name string) error {
	switch name {
	case kcsmallcategoryexampaper.EdgeExamPaper:
		m.ClearExamPaper()
		return nil
	case kcsmallcategoryexampaper.EdgeCourseSmallCategory:
		m.ClearCourseSmallCategory()
		return nil
	}
	return fmt.Errorf("unknown KcSmallCategoryExamPaper unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *KcSmallCategoryExamPaperMutation) ResetEdge(name string) error {
	switch name {
	case kcsmallcategoryexampaper.EdgeExamPaper:
		m.ResetExamPaper()
		return nil
	case kcsmallcategoryexampaper.EdgeCourseSmallCategory:
		m.ResetCourseSmallCategory()
		return nil
	}
	return fmt.Errorf("unknown KcSmallCategoryExamPaper edge %s", name)
}

// KcSmallCategoryQuestionMutation represents an operation that mutates the KcSmallCategoryQuestion nodes in the graph.
type KcSmallCategoryQuestionMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	uuid                         *string
	created_at                   *time.Time
	updated_at                   *time.Time
	deleted_at                   *time.Time
	clearedFields                map[string]struct{}
	question                     *int
	clearedquestion              bool
	course_small_category        *int
	clearedcourse_small_category bool
	done                         bool
	oldValue                     func(context.Context) (*KcSmallCategoryQuestion, error)
	predicates                   []predicate.KcSmallCategoryQuestion
}

var _ ent.Mutation = (*KcSmallCategoryQuestionMutation)(nil)

// kcsmallcategoryquestionOption allows management of the mutation configuration using functional options.
type kcsmallcategoryquestionOption func(*KcSmallCategoryQuestionMutation)

// newKcSmallCategoryQuestionMutation creates new mutation for the KcSmallCategoryQuestion entity.
func newKcSmallCategoryQuestionMutation(c config, op Op, opts ...kcsmallcategoryquestionOption) *KcSmallCategoryQuestionMutation {
	m := &KcSmallCategoryQuestionMutation{
		config:        c,
		op:            op,
		typ:           TypeKcSmallCategoryQuestion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withKcSmallCategoryQuestionID sets the ID field of the mutation.
func withKcSmallCategoryQuestionID(id int) kcsmallcategoryquestionOption {
	return func(m *KcSmallCategoryQuestionMutation) {
		var (
			err   error
			once  sync.Once
			value *KcSmallCategoryQuestion
		)
		m.oldValue = func(ctx context.Context) (*KcSmallCategoryQuestion, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().KcSmallCategoryQuestion.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withKcSmallCategoryQuestion sets the old KcSmallCategoryQuestion of the mutation.
func withKcSmallCategoryQuestion(node *KcSmallCategoryQuestion) kcsmallcategoryquestionOption {
	return func(m *KcSmallCategoryQuestionMutation) {
		m.oldValue = func(context.Context) (*KcSmallCategoryQuestion, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m KcSmallCategoryQuestionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m KcSmallCategoryQuestionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *KcSmallCategoryQuestionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *KcSmallCategoryQuestionMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *KcSmallCategoryQuestionMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the KcSmallCategoryQuestion entity.
// If the KcSmallCategoryQuestion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcSmallCategoryQuestionMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *KcSmallCategoryQuestionMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *KcSmallCategoryQuestionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *KcSmallCategoryQuestionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the KcSmallCategoryQuestion entity.
// If the KcSmallCategoryQuestion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcSmallCategoryQuestionMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *KcSmallCategoryQuestionMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[kcsmallcategoryquestion.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *KcSmallCategoryQuestionMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[kcsmallcategoryquestion.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *KcSmallCategoryQuestionMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, kcsmallcategoryquestion.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *KcSmallCategoryQuestionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *KcSmallCategoryQuestionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the KcSmallCategoryQuestion entity.
// If the KcSmallCategoryQuestion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcSmallCategoryQuestionMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *KcSmallCategoryQuestionMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[kcsmallcategoryquestion.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *KcSmallCategoryQuestionMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[kcsmallcategoryquestion.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *KcSmallCategoryQuestionMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, kcsmallcategoryquestion.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *KcSmallCategoryQuestionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *KcSmallCategoryQuestionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the KcSmallCategoryQuestion entity.
// If the KcSmallCategoryQuestion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcSmallCategoryQuestionMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *KcSmallCategoryQuestionMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[kcsmallcategoryquestion.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *KcSmallCategoryQuestionMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[kcsmallcategoryquestion.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *KcSmallCategoryQuestionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, kcsmallcategoryquestion.FieldDeletedAt)
}

// SetQuestionID sets the "question_id" field.
func (m *KcSmallCategoryQuestionMutation) SetQuestionID(i int) {
	m.question = &i
}

// QuestionID returns the value of the "question_id" field in the mutation.
func (m *KcSmallCategoryQuestionMutation) QuestionID() (r int, exists bool) {
	v := m.question
	if v == nil {
		return
	}
	return *v, true
}

// OldQuestionID returns the old "question_id" field's value of the KcSmallCategoryQuestion entity.
// If the KcSmallCategoryQuestion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcSmallCategoryQuestionMutation) OldQuestionID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldQuestionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldQuestionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuestionID: %w", err)
	}
	return oldValue.QuestionID, nil
}

// ClearQuestionID clears the value of the "question_id" field.
func (m *KcSmallCategoryQuestionMutation) ClearQuestionID() {
	m.question = nil
	m.clearedFields[kcsmallcategoryquestion.FieldQuestionID] = struct{}{}
}

// QuestionIDCleared returns if the "question_id" field was cleared in this mutation.
func (m *KcSmallCategoryQuestionMutation) QuestionIDCleared() bool {
	_, ok := m.clearedFields[kcsmallcategoryquestion.FieldQuestionID]
	return ok
}

// ResetQuestionID resets all changes to the "question_id" field.
func (m *KcSmallCategoryQuestionMutation) ResetQuestionID() {
	m.question = nil
	delete(m.clearedFields, kcsmallcategoryquestion.FieldQuestionID)
}

// SetSmallCategoryID sets the "small_category_id" field.
func (m *KcSmallCategoryQuestionMutation) SetSmallCategoryID(i int) {
	m.course_small_category = &i
}

// SmallCategoryID returns the value of the "small_category_id" field in the mutation.
func (m *KcSmallCategoryQuestionMutation) SmallCategoryID() (r int, exists bool) {
	v := m.course_small_category
	if v == nil {
		return
	}
	return *v, true
}

// OldSmallCategoryID returns the old "small_category_id" field's value of the KcSmallCategoryQuestion entity.
// If the KcSmallCategoryQuestion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcSmallCategoryQuestionMutation) OldSmallCategoryID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSmallCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSmallCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSmallCategoryID: %w", err)
	}
	return oldValue.SmallCategoryID, nil
}

// ClearSmallCategoryID clears the value of the "small_category_id" field.
func (m *KcSmallCategoryQuestionMutation) ClearSmallCategoryID() {
	m.course_small_category = nil
	m.clearedFields[kcsmallcategoryquestion.FieldSmallCategoryID] = struct{}{}
}

// SmallCategoryIDCleared returns if the "small_category_id" field was cleared in this mutation.
func (m *KcSmallCategoryQuestionMutation) SmallCategoryIDCleared() bool {
	_, ok := m.clearedFields[kcsmallcategoryquestion.FieldSmallCategoryID]
	return ok
}

// ResetSmallCategoryID resets all changes to the "small_category_id" field.
func (m *KcSmallCategoryQuestionMutation) ResetSmallCategoryID() {
	m.course_small_category = nil
	delete(m.clearedFields, kcsmallcategoryquestion.FieldSmallCategoryID)
}

// ClearQuestion clears the "question" edge to the TkQuestion entity.
func (m *KcSmallCategoryQuestionMutation) ClearQuestion() {
	m.clearedquestion = true
}

// QuestionCleared reports if the "question" edge to the TkQuestion entity was cleared.
func (m *KcSmallCategoryQuestionMutation) QuestionCleared() bool {
	return m.QuestionIDCleared() || m.clearedquestion
}

// QuestionIDs returns the "question" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// QuestionID instead. It exists only for internal usage by the builders.
func (m *KcSmallCategoryQuestionMutation) QuestionIDs() (ids []int) {
	if id := m.question; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetQuestion resets all changes to the "question" edge.
func (m *KcSmallCategoryQuestionMutation) ResetQuestion() {
	m.question = nil
	m.clearedquestion = false
}

// SetCourseSmallCategoryID sets the "course_small_category" edge to the KcCourseSmallCategory entity by id.
func (m *KcSmallCategoryQuestionMutation) SetCourseSmallCategoryID(id int) {
	m.course_small_category = &id
}

// ClearCourseSmallCategory clears the "course_small_category" edge to the KcCourseSmallCategory entity.
func (m *KcSmallCategoryQuestionMutation) ClearCourseSmallCategory() {
	m.clearedcourse_small_category = true
}

// CourseSmallCategoryCleared reports if the "course_small_category" edge to the KcCourseSmallCategory entity was cleared.
func (m *KcSmallCategoryQuestionMutation) CourseSmallCategoryCleared() bool {
	return m.SmallCategoryIDCleared() || m.clearedcourse_small_category
}

// CourseSmallCategoryID returns the "course_small_category" edge ID in the mutation.
func (m *KcSmallCategoryQuestionMutation) CourseSmallCategoryID() (id int, exists bool) {
	if m.course_small_category != nil {
		return *m.course_small_category, true
	}
	return
}

// CourseSmallCategoryIDs returns the "course_small_category" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CourseSmallCategoryID instead. It exists only for internal usage by the builders.
func (m *KcSmallCategoryQuestionMutation) CourseSmallCategoryIDs() (ids []int) {
	if id := m.course_small_category; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCourseSmallCategory resets all changes to the "course_small_category" edge.
func (m *KcSmallCategoryQuestionMutation) ResetCourseSmallCategory() {
	m.course_small_category = nil
	m.clearedcourse_small_category = false
}

// Op returns the operation name.
func (m *KcSmallCategoryQuestionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (KcSmallCategoryQuestion).
func (m *KcSmallCategoryQuestionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *KcSmallCategoryQuestionMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.uuid != nil {
		fields = append(fields, kcsmallcategoryquestion.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, kcsmallcategoryquestion.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, kcsmallcategoryquestion.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, kcsmallcategoryquestion.FieldDeletedAt)
	}
	if m.question != nil {
		fields = append(fields, kcsmallcategoryquestion.FieldQuestionID)
	}
	if m.course_small_category != nil {
		fields = append(fields, kcsmallcategoryquestion.FieldSmallCategoryID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *KcSmallCategoryQuestionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case kcsmallcategoryquestion.FieldUUID:
		return m.UUID()
	case kcsmallcategoryquestion.FieldCreatedAt:
		return m.CreatedAt()
	case kcsmallcategoryquestion.FieldUpdatedAt:
		return m.UpdatedAt()
	case kcsmallcategoryquestion.FieldDeletedAt:
		return m.DeletedAt()
	case kcsmallcategoryquestion.FieldQuestionID:
		return m.QuestionID()
	case kcsmallcategoryquestion.FieldSmallCategoryID:
		return m.SmallCategoryID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *KcSmallCategoryQuestionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case kcsmallcategoryquestion.FieldUUID:
		return m.OldUUID(ctx)
	case kcsmallcategoryquestion.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case kcsmallcategoryquestion.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case kcsmallcategoryquestion.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case kcsmallcategoryquestion.FieldQuestionID:
		return m.OldQuestionID(ctx)
	case kcsmallcategoryquestion.FieldSmallCategoryID:
		return m.OldSmallCategoryID(ctx)
	}
	return nil, fmt.Errorf("unknown KcSmallCategoryQuestion field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KcSmallCategoryQuestionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case kcsmallcategoryquestion.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case kcsmallcategoryquestion.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case kcsmallcategoryquestion.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case kcsmallcategoryquestion.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case kcsmallcategoryquestion.FieldQuestionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuestionID(v)
		return nil
	case kcsmallcategoryquestion.FieldSmallCategoryID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSmallCategoryID(v)
		return nil
	}
	return fmt.Errorf("unknown KcSmallCategoryQuestion field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *KcSmallCategoryQuestionMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *KcSmallCategoryQuestionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KcSmallCategoryQuestionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown KcSmallCategoryQuestion numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *KcSmallCategoryQuestionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(kcsmallcategoryquestion.FieldCreatedAt) {
		fields = append(fields, kcsmallcategoryquestion.FieldCreatedAt)
	}
	if m.FieldCleared(kcsmallcategoryquestion.FieldUpdatedAt) {
		fields = append(fields, kcsmallcategoryquestion.FieldUpdatedAt)
	}
	if m.FieldCleared(kcsmallcategoryquestion.FieldDeletedAt) {
		fields = append(fields, kcsmallcategoryquestion.FieldDeletedAt)
	}
	if m.FieldCleared(kcsmallcategoryquestion.FieldQuestionID) {
		fields = append(fields, kcsmallcategoryquestion.FieldQuestionID)
	}
	if m.FieldCleared(kcsmallcategoryquestion.FieldSmallCategoryID) {
		fields = append(fields, kcsmallcategoryquestion.FieldSmallCategoryID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *KcSmallCategoryQuestionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *KcSmallCategoryQuestionMutation) ClearField(name string) error {
	switch name {
	case kcsmallcategoryquestion.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case kcsmallcategoryquestion.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case kcsmallcategoryquestion.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case kcsmallcategoryquestion.FieldQuestionID:
		m.ClearQuestionID()
		return nil
	case kcsmallcategoryquestion.FieldSmallCategoryID:
		m.ClearSmallCategoryID()
		return nil
	}
	return fmt.Errorf("unknown KcSmallCategoryQuestion nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *KcSmallCategoryQuestionMutation) ResetField(name string) error {
	switch name {
	case kcsmallcategoryquestion.FieldUUID:
		m.ResetUUID()
		return nil
	case kcsmallcategoryquestion.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case kcsmallcategoryquestion.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case kcsmallcategoryquestion.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case kcsmallcategoryquestion.FieldQuestionID:
		m.ResetQuestionID()
		return nil
	case kcsmallcategoryquestion.FieldSmallCategoryID:
		m.ResetSmallCategoryID()
		return nil
	}
	return fmt.Errorf("unknown KcSmallCategoryQuestion field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *KcSmallCategoryQuestionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.question != nil {
		edges = append(edges, kcsmallcategoryquestion.EdgeQuestion)
	}
	if m.course_small_category != nil {
		edges = append(edges, kcsmallcategoryquestion.EdgeCourseSmallCategory)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *KcSmallCategoryQuestionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case kcsmallcategoryquestion.EdgeQuestion:
		if id := m.question; id != nil {
			return []ent.Value{*id}
		}
	case kcsmallcategoryquestion.EdgeCourseSmallCategory:
		if id := m.course_small_category; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *KcSmallCategoryQuestionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *KcSmallCategoryQuestionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *KcSmallCategoryQuestionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedquestion {
		edges = append(edges, kcsmallcategoryquestion.EdgeQuestion)
	}
	if m.clearedcourse_small_category {
		edges = append(edges, kcsmallcategoryquestion.EdgeCourseSmallCategory)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *KcSmallCategoryQuestionMutation) EdgeCleared(name string) bool {
	switch name {
	case kcsmallcategoryquestion.EdgeQuestion:
		return m.clearedquestion
	case kcsmallcategoryquestion.EdgeCourseSmallCategory:
		return m.clearedcourse_small_category
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *KcSmallCategoryQuestionMutation) ClearEdge(name string) error {
	switch name {
	case kcsmallcategoryquestion.EdgeQuestion:
		m.ClearQuestion()
		return nil
	case kcsmallcategoryquestion.EdgeCourseSmallCategory:
		m.ClearCourseSmallCategory()
		return nil
	}
	return fmt.Errorf("unknown KcSmallCategoryQuestion unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *KcSmallCategoryQuestionMutation) ResetEdge(name string) error {
	switch name {
	case kcsmallcategoryquestion.EdgeQuestion:
		m.ResetQuestion()
		return nil
	case kcsmallcategoryquestion.EdgeCourseSmallCategory:
		m.ResetCourseSmallCategory()
		return nil
	}
	return fmt.Errorf("unknown KcSmallCategoryQuestion edge %s", name)
}

// KcUserClassMutation represents an operation that mutates the KcUserClass nodes in the graph.
type KcUserClassMutation struct {
	config
	op             Op
	typ            string
	id             *int
	uuid           *string
	created_at     *time.Time
	updated_at     *time.Time
	deleted_at     *time.Time
	period_type    *uint8
	addperiod_type *uint8
	closing_date   *time.Time
	study_rate     *float64
	addstudy_rate  *float64
	remark         *string
	price          *float64
	addprice       *float64
	clearedFields  map[string]struct{}
	user           *int
	cleareduser    bool
	class          *int
	clearedclass   bool
	done           bool
	oldValue       func(context.Context) (*KcUserClass, error)
	predicates     []predicate.KcUserClass
}

var _ ent.Mutation = (*KcUserClassMutation)(nil)

// kcuserclassOption allows management of the mutation configuration using functional options.
type kcuserclassOption func(*KcUserClassMutation)

// newKcUserClassMutation creates new mutation for the KcUserClass entity.
func newKcUserClassMutation(c config, op Op, opts ...kcuserclassOption) *KcUserClassMutation {
	m := &KcUserClassMutation{
		config:        c,
		op:            op,
		typ:           TypeKcUserClass,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withKcUserClassID sets the ID field of the mutation.
func withKcUserClassID(id int) kcuserclassOption {
	return func(m *KcUserClassMutation) {
		var (
			err   error
			once  sync.Once
			value *KcUserClass
		)
		m.oldValue = func(ctx context.Context) (*KcUserClass, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().KcUserClass.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withKcUserClass sets the old KcUserClass of the mutation.
func withKcUserClass(node *KcUserClass) kcuserclassOption {
	return func(m *KcUserClassMutation) {
		m.oldValue = func(context.Context) (*KcUserClass, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m KcUserClassMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m KcUserClassMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *KcUserClassMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *KcUserClassMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *KcUserClassMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the KcUserClass entity.
// If the KcUserClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcUserClassMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *KcUserClassMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *KcUserClassMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *KcUserClassMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the KcUserClass entity.
// If the KcUserClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcUserClassMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *KcUserClassMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[kcuserclass.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *KcUserClassMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[kcuserclass.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *KcUserClassMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, kcuserclass.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *KcUserClassMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *KcUserClassMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the KcUserClass entity.
// If the KcUserClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcUserClassMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *KcUserClassMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[kcuserclass.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *KcUserClassMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[kcuserclass.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *KcUserClassMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, kcuserclass.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *KcUserClassMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *KcUserClassMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the KcUserClass entity.
// If the KcUserClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcUserClassMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *KcUserClassMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[kcuserclass.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *KcUserClassMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[kcuserclass.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *KcUserClassMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, kcuserclass.FieldDeletedAt)
}

// SetPeriodType sets the "period_type" field.
func (m *KcUserClassMutation) SetPeriodType(u uint8) {
	m.period_type = &u
	m.addperiod_type = nil
}

// PeriodType returns the value of the "period_type" field in the mutation.
func (m *KcUserClassMutation) PeriodType() (r uint8, exists bool) {
	v := m.period_type
	if v == nil {
		return
	}
	return *v, true
}

// OldPeriodType returns the old "period_type" field's value of the KcUserClass entity.
// If the KcUserClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcUserClassMutation) OldPeriodType(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPeriodType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPeriodType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPeriodType: %w", err)
	}
	return oldValue.PeriodType, nil
}

// AddPeriodType adds u to the "period_type" field.
func (m *KcUserClassMutation) AddPeriodType(u uint8) {
	if m.addperiod_type != nil {
		*m.addperiod_type += u
	} else {
		m.addperiod_type = &u
	}
}

// AddedPeriodType returns the value that was added to the "period_type" field in this mutation.
func (m *KcUserClassMutation) AddedPeriodType() (r uint8, exists bool) {
	v := m.addperiod_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetPeriodType resets all changes to the "period_type" field.
func (m *KcUserClassMutation) ResetPeriodType() {
	m.period_type = nil
	m.addperiod_type = nil
}

// SetClosingDate sets the "closing_date" field.
func (m *KcUserClassMutation) SetClosingDate(t time.Time) {
	m.closing_date = &t
}

// ClosingDate returns the value of the "closing_date" field in the mutation.
func (m *KcUserClassMutation) ClosingDate() (r time.Time, exists bool) {
	v := m.closing_date
	if v == nil {
		return
	}
	return *v, true
}

// OldClosingDate returns the old "closing_date" field's value of the KcUserClass entity.
// If the KcUserClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcUserClassMutation) OldClosingDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldClosingDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldClosingDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClosingDate: %w", err)
	}
	return oldValue.ClosingDate, nil
}

// ClearClosingDate clears the value of the "closing_date" field.
func (m *KcUserClassMutation) ClearClosingDate() {
	m.closing_date = nil
	m.clearedFields[kcuserclass.FieldClosingDate] = struct{}{}
}

// ClosingDateCleared returns if the "closing_date" field was cleared in this mutation.
func (m *KcUserClassMutation) ClosingDateCleared() bool {
	_, ok := m.clearedFields[kcuserclass.FieldClosingDate]
	return ok
}

// ResetClosingDate resets all changes to the "closing_date" field.
func (m *KcUserClassMutation) ResetClosingDate() {
	m.closing_date = nil
	delete(m.clearedFields, kcuserclass.FieldClosingDate)
}

// SetStudyRate sets the "study_rate" field.
func (m *KcUserClassMutation) SetStudyRate(f float64) {
	m.study_rate = &f
	m.addstudy_rate = nil
}

// StudyRate returns the value of the "study_rate" field in the mutation.
func (m *KcUserClassMutation) StudyRate() (r float64, exists bool) {
	v := m.study_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldStudyRate returns the old "study_rate" field's value of the KcUserClass entity.
// If the KcUserClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcUserClassMutation) OldStudyRate(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStudyRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStudyRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStudyRate: %w", err)
	}
	return oldValue.StudyRate, nil
}

// AddStudyRate adds f to the "study_rate" field.
func (m *KcUserClassMutation) AddStudyRate(f float64) {
	if m.addstudy_rate != nil {
		*m.addstudy_rate += f
	} else {
		m.addstudy_rate = &f
	}
}

// AddedStudyRate returns the value that was added to the "study_rate" field in this mutation.
func (m *KcUserClassMutation) AddedStudyRate() (r float64, exists bool) {
	v := m.addstudy_rate
	if v == nil {
		return
	}
	return *v, true
}

// ResetStudyRate resets all changes to the "study_rate" field.
func (m *KcUserClassMutation) ResetStudyRate() {
	m.study_rate = nil
	m.addstudy_rate = nil
}

// SetRemark sets the "remark" field.
func (m *KcUserClassMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *KcUserClassMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the KcUserClass entity.
// If the KcUserClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcUserClassMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ResetRemark resets all changes to the "remark" field.
func (m *KcUserClassMutation) ResetRemark() {
	m.remark = nil
}

// SetPrice sets the "price" field.
func (m *KcUserClassMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *KcUserClassMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the KcUserClass entity.
// If the KcUserClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcUserClassMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *KcUserClassMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *KcUserClassMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *KcUserClassMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetUserID sets the "user_id" field.
func (m *KcUserClassMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *KcUserClassMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the KcUserClass entity.
// If the KcUserClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcUserClassMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *KcUserClassMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[kcuserclass.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *KcUserClassMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[kcuserclass.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *KcUserClassMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, kcuserclass.FieldUserID)
}

// SetClassID sets the "class_id" field.
func (m *KcUserClassMutation) SetClassID(i int) {
	m.class = &i
}

// ClassID returns the value of the "class_id" field in the mutation.
func (m *KcUserClassMutation) ClassID() (r int, exists bool) {
	v := m.class
	if v == nil {
		return
	}
	return *v, true
}

// OldClassID returns the old "class_id" field's value of the KcUserClass entity.
// If the KcUserClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcUserClassMutation) OldClassID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldClassID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldClassID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClassID: %w", err)
	}
	return oldValue.ClassID, nil
}

// ClearClassID clears the value of the "class_id" field.
func (m *KcUserClassMutation) ClearClassID() {
	m.class = nil
	m.clearedFields[kcuserclass.FieldClassID] = struct{}{}
}

// ClassIDCleared returns if the "class_id" field was cleared in this mutation.
func (m *KcUserClassMutation) ClassIDCleared() bool {
	_, ok := m.clearedFields[kcuserclass.FieldClassID]
	return ok
}

// ResetClassID resets all changes to the "class_id" field.
func (m *KcUserClassMutation) ResetClassID() {
	m.class = nil
	delete(m.clearedFields, kcuserclass.FieldClassID)
}

// ClearUser clears the "user" edge to the User entity.
func (m *KcUserClassMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *KcUserClassMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *KcUserClassMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *KcUserClassMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearClass clears the "class" edge to the KcClass entity.
func (m *KcUserClassMutation) ClearClass() {
	m.clearedclass = true
}

// ClassCleared reports if the "class" edge to the KcClass entity was cleared.
func (m *KcUserClassMutation) ClassCleared() bool {
	return m.ClassIDCleared() || m.clearedclass
}

// ClassIDs returns the "class" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClassID instead. It exists only for internal usage by the builders.
func (m *KcUserClassMutation) ClassIDs() (ids []int) {
	if id := m.class; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClass resets all changes to the "class" edge.
func (m *KcUserClassMutation) ResetClass() {
	m.class = nil
	m.clearedclass = false
}

// Op returns the operation name.
func (m *KcUserClassMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (KcUserClass).
func (m *KcUserClassMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *KcUserClassMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.uuid != nil {
		fields = append(fields, kcuserclass.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, kcuserclass.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, kcuserclass.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, kcuserclass.FieldDeletedAt)
	}
	if m.period_type != nil {
		fields = append(fields, kcuserclass.FieldPeriodType)
	}
	if m.closing_date != nil {
		fields = append(fields, kcuserclass.FieldClosingDate)
	}
	if m.study_rate != nil {
		fields = append(fields, kcuserclass.FieldStudyRate)
	}
	if m.remark != nil {
		fields = append(fields, kcuserclass.FieldRemark)
	}
	if m.price != nil {
		fields = append(fields, kcuserclass.FieldPrice)
	}
	if m.user != nil {
		fields = append(fields, kcuserclass.FieldUserID)
	}
	if m.class != nil {
		fields = append(fields, kcuserclass.FieldClassID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *KcUserClassMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case kcuserclass.FieldUUID:
		return m.UUID()
	case kcuserclass.FieldCreatedAt:
		return m.CreatedAt()
	case kcuserclass.FieldUpdatedAt:
		return m.UpdatedAt()
	case kcuserclass.FieldDeletedAt:
		return m.DeletedAt()
	case kcuserclass.FieldPeriodType:
		return m.PeriodType()
	case kcuserclass.FieldClosingDate:
		return m.ClosingDate()
	case kcuserclass.FieldStudyRate:
		return m.StudyRate()
	case kcuserclass.FieldRemark:
		return m.Remark()
	case kcuserclass.FieldPrice:
		return m.Price()
	case kcuserclass.FieldUserID:
		return m.UserID()
	case kcuserclass.FieldClassID:
		return m.ClassID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *KcUserClassMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case kcuserclass.FieldUUID:
		return m.OldUUID(ctx)
	case kcuserclass.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case kcuserclass.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case kcuserclass.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case kcuserclass.FieldPeriodType:
		return m.OldPeriodType(ctx)
	case kcuserclass.FieldClosingDate:
		return m.OldClosingDate(ctx)
	case kcuserclass.FieldStudyRate:
		return m.OldStudyRate(ctx)
	case kcuserclass.FieldRemark:
		return m.OldRemark(ctx)
	case kcuserclass.FieldPrice:
		return m.OldPrice(ctx)
	case kcuserclass.FieldUserID:
		return m.OldUserID(ctx)
	case kcuserclass.FieldClassID:
		return m.OldClassID(ctx)
	}
	return nil, fmt.Errorf("unknown KcUserClass field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KcUserClassMutation) SetField(name string, value ent.Value) error {
	switch name {
	case kcuserclass.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case kcuserclass.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case kcuserclass.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case kcuserclass.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case kcuserclass.FieldPeriodType:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPeriodType(v)
		return nil
	case kcuserclass.FieldClosingDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClosingDate(v)
		return nil
	case kcuserclass.FieldStudyRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStudyRate(v)
		return nil
	case kcuserclass.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case kcuserclass.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case kcuserclass.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case kcuserclass.FieldClassID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClassID(v)
		return nil
	}
	return fmt.Errorf("unknown KcUserClass field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *KcUserClassMutation) AddedFields() []string {
	var fields []string
	if m.addperiod_type != nil {
		fields = append(fields, kcuserclass.FieldPeriodType)
	}
	if m.addstudy_rate != nil {
		fields = append(fields, kcuserclass.FieldStudyRate)
	}
	if m.addprice != nil {
		fields = append(fields, kcuserclass.FieldPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *KcUserClassMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case kcuserclass.FieldPeriodType:
		return m.AddedPeriodType()
	case kcuserclass.FieldStudyRate:
		return m.AddedStudyRate()
	case kcuserclass.FieldPrice:
		return m.AddedPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KcUserClassMutation) AddField(name string, value ent.Value) error {
	switch name {
	case kcuserclass.FieldPeriodType:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPeriodType(v)
		return nil
	case kcuserclass.FieldStudyRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStudyRate(v)
		return nil
	case kcuserclass.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	}
	return fmt.Errorf("unknown KcUserClass numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *KcUserClassMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(kcuserclass.FieldCreatedAt) {
		fields = append(fields, kcuserclass.FieldCreatedAt)
	}
	if m.FieldCleared(kcuserclass.FieldUpdatedAt) {
		fields = append(fields, kcuserclass.FieldUpdatedAt)
	}
	if m.FieldCleared(kcuserclass.FieldDeletedAt) {
		fields = append(fields, kcuserclass.FieldDeletedAt)
	}
	if m.FieldCleared(kcuserclass.FieldClosingDate) {
		fields = append(fields, kcuserclass.FieldClosingDate)
	}
	if m.FieldCleared(kcuserclass.FieldUserID) {
		fields = append(fields, kcuserclass.FieldUserID)
	}
	if m.FieldCleared(kcuserclass.FieldClassID) {
		fields = append(fields, kcuserclass.FieldClassID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *KcUserClassMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *KcUserClassMutation) ClearField(name string) error {
	switch name {
	case kcuserclass.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case kcuserclass.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case kcuserclass.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case kcuserclass.FieldClosingDate:
		m.ClearClosingDate()
		return nil
	case kcuserclass.FieldUserID:
		m.ClearUserID()
		return nil
	case kcuserclass.FieldClassID:
		m.ClearClassID()
		return nil
	}
	return fmt.Errorf("unknown KcUserClass nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *KcUserClassMutation) ResetField(name string) error {
	switch name {
	case kcuserclass.FieldUUID:
		m.ResetUUID()
		return nil
	case kcuserclass.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case kcuserclass.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case kcuserclass.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case kcuserclass.FieldPeriodType:
		m.ResetPeriodType()
		return nil
	case kcuserclass.FieldClosingDate:
		m.ResetClosingDate()
		return nil
	case kcuserclass.FieldStudyRate:
		m.ResetStudyRate()
		return nil
	case kcuserclass.FieldRemark:
		m.ResetRemark()
		return nil
	case kcuserclass.FieldPrice:
		m.ResetPrice()
		return nil
	case kcuserclass.FieldUserID:
		m.ResetUserID()
		return nil
	case kcuserclass.FieldClassID:
		m.ResetClassID()
		return nil
	}
	return fmt.Errorf("unknown KcUserClass field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *KcUserClassMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, kcuserclass.EdgeUser)
	}
	if m.class != nil {
		edges = append(edges, kcuserclass.EdgeClass)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *KcUserClassMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case kcuserclass.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case kcuserclass.EdgeClass:
		if id := m.class; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *KcUserClassMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *KcUserClassMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *KcUserClassMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, kcuserclass.EdgeUser)
	}
	if m.clearedclass {
		edges = append(edges, kcuserclass.EdgeClass)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *KcUserClassMutation) EdgeCleared(name string) bool {
	switch name {
	case kcuserclass.EdgeUser:
		return m.cleareduser
	case kcuserclass.EdgeClass:
		return m.clearedclass
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *KcUserClassMutation) ClearEdge(name string) error {
	switch name {
	case kcuserclass.EdgeUser:
		m.ClearUser()
		return nil
	case kcuserclass.EdgeClass:
		m.ClearClass()
		return nil
	}
	return fmt.Errorf("unknown KcUserClass unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *KcUserClassMutation) ResetEdge(name string) error {
	switch name {
	case kcuserclass.EdgeUser:
		m.ResetUser()
		return nil
	case kcuserclass.EdgeClass:
		m.ResetClass()
		return nil
	}
	return fmt.Errorf("unknown KcUserClass edge %s", name)
}

// KcUserCourseMutation represents an operation that mutates the KcUserCourse nodes in the graph.
type KcUserCourseMutation struct {
	config
	op             Op
	typ            string
	id             *int
	uuid           *string
	created_at     *time.Time
	updated_at     *time.Time
	deleted_at     *time.Time
	period_type    *uint8
	addperiod_type *uint8
	closing_date   *time.Time
	study_rate     *float64
	addstudy_rate  *float64
	remark         *string
	price          *float64
	addprice       *float64
	clearedFields  map[string]struct{}
	user           *int
	cleareduser    bool
	course         *int
	clearedcourse  bool
	done           bool
	oldValue       func(context.Context) (*KcUserCourse, error)
	predicates     []predicate.KcUserCourse
}

var _ ent.Mutation = (*KcUserCourseMutation)(nil)

// kcusercourseOption allows management of the mutation configuration using functional options.
type kcusercourseOption func(*KcUserCourseMutation)

// newKcUserCourseMutation creates new mutation for the KcUserCourse entity.
func newKcUserCourseMutation(c config, op Op, opts ...kcusercourseOption) *KcUserCourseMutation {
	m := &KcUserCourseMutation{
		config:        c,
		op:            op,
		typ:           TypeKcUserCourse,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withKcUserCourseID sets the ID field of the mutation.
func withKcUserCourseID(id int) kcusercourseOption {
	return func(m *KcUserCourseMutation) {
		var (
			err   error
			once  sync.Once
			value *KcUserCourse
		)
		m.oldValue = func(ctx context.Context) (*KcUserCourse, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().KcUserCourse.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withKcUserCourse sets the old KcUserCourse of the mutation.
func withKcUserCourse(node *KcUserCourse) kcusercourseOption {
	return func(m *KcUserCourseMutation) {
		m.oldValue = func(context.Context) (*KcUserCourse, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m KcUserCourseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m KcUserCourseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *KcUserCourseMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *KcUserCourseMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *KcUserCourseMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the KcUserCourse entity.
// If the KcUserCourse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcUserCourseMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *KcUserCourseMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *KcUserCourseMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *KcUserCourseMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the KcUserCourse entity.
// If the KcUserCourse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcUserCourseMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *KcUserCourseMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[kcusercourse.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *KcUserCourseMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[kcusercourse.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *KcUserCourseMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, kcusercourse.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *KcUserCourseMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *KcUserCourseMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the KcUserCourse entity.
// If the KcUserCourse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcUserCourseMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *KcUserCourseMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[kcusercourse.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *KcUserCourseMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[kcusercourse.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *KcUserCourseMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, kcusercourse.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *KcUserCourseMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *KcUserCourseMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the KcUserCourse entity.
// If the KcUserCourse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcUserCourseMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *KcUserCourseMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[kcusercourse.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *KcUserCourseMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[kcusercourse.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *KcUserCourseMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, kcusercourse.FieldDeletedAt)
}

// SetPeriodType sets the "period_type" field.
func (m *KcUserCourseMutation) SetPeriodType(u uint8) {
	m.period_type = &u
	m.addperiod_type = nil
}

// PeriodType returns the value of the "period_type" field in the mutation.
func (m *KcUserCourseMutation) PeriodType() (r uint8, exists bool) {
	v := m.period_type
	if v == nil {
		return
	}
	return *v, true
}

// OldPeriodType returns the old "period_type" field's value of the KcUserCourse entity.
// If the KcUserCourse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcUserCourseMutation) OldPeriodType(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPeriodType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPeriodType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPeriodType: %w", err)
	}
	return oldValue.PeriodType, nil
}

// AddPeriodType adds u to the "period_type" field.
func (m *KcUserCourseMutation) AddPeriodType(u uint8) {
	if m.addperiod_type != nil {
		*m.addperiod_type += u
	} else {
		m.addperiod_type = &u
	}
}

// AddedPeriodType returns the value that was added to the "period_type" field in this mutation.
func (m *KcUserCourseMutation) AddedPeriodType() (r uint8, exists bool) {
	v := m.addperiod_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetPeriodType resets all changes to the "period_type" field.
func (m *KcUserCourseMutation) ResetPeriodType() {
	m.period_type = nil
	m.addperiod_type = nil
}

// SetClosingDate sets the "closing_date" field.
func (m *KcUserCourseMutation) SetClosingDate(t time.Time) {
	m.closing_date = &t
}

// ClosingDate returns the value of the "closing_date" field in the mutation.
func (m *KcUserCourseMutation) ClosingDate() (r time.Time, exists bool) {
	v := m.closing_date
	if v == nil {
		return
	}
	return *v, true
}

// OldClosingDate returns the old "closing_date" field's value of the KcUserCourse entity.
// If the KcUserCourse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcUserCourseMutation) OldClosingDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldClosingDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldClosingDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClosingDate: %w", err)
	}
	return oldValue.ClosingDate, nil
}

// ClearClosingDate clears the value of the "closing_date" field.
func (m *KcUserCourseMutation) ClearClosingDate() {
	m.closing_date = nil
	m.clearedFields[kcusercourse.FieldClosingDate] = struct{}{}
}

// ClosingDateCleared returns if the "closing_date" field was cleared in this mutation.
func (m *KcUserCourseMutation) ClosingDateCleared() bool {
	_, ok := m.clearedFields[kcusercourse.FieldClosingDate]
	return ok
}

// ResetClosingDate resets all changes to the "closing_date" field.
func (m *KcUserCourseMutation) ResetClosingDate() {
	m.closing_date = nil
	delete(m.clearedFields, kcusercourse.FieldClosingDate)
}

// SetStudyRate sets the "study_rate" field.
func (m *KcUserCourseMutation) SetStudyRate(f float64) {
	m.study_rate = &f
	m.addstudy_rate = nil
}

// StudyRate returns the value of the "study_rate" field in the mutation.
func (m *KcUserCourseMutation) StudyRate() (r float64, exists bool) {
	v := m.study_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldStudyRate returns the old "study_rate" field's value of the KcUserCourse entity.
// If the KcUserCourse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcUserCourseMutation) OldStudyRate(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStudyRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStudyRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStudyRate: %w", err)
	}
	return oldValue.StudyRate, nil
}

// AddStudyRate adds f to the "study_rate" field.
func (m *KcUserCourseMutation) AddStudyRate(f float64) {
	if m.addstudy_rate != nil {
		*m.addstudy_rate += f
	} else {
		m.addstudy_rate = &f
	}
}

// AddedStudyRate returns the value that was added to the "study_rate" field in this mutation.
func (m *KcUserCourseMutation) AddedStudyRate() (r float64, exists bool) {
	v := m.addstudy_rate
	if v == nil {
		return
	}
	return *v, true
}

// ResetStudyRate resets all changes to the "study_rate" field.
func (m *KcUserCourseMutation) ResetStudyRate() {
	m.study_rate = nil
	m.addstudy_rate = nil
}

// SetRemark sets the "remark" field.
func (m *KcUserCourseMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *KcUserCourseMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the KcUserCourse entity.
// If the KcUserCourse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcUserCourseMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ResetRemark resets all changes to the "remark" field.
func (m *KcUserCourseMutation) ResetRemark() {
	m.remark = nil
}

// SetPrice sets the "price" field.
func (m *KcUserCourseMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *KcUserCourseMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the KcUserCourse entity.
// If the KcUserCourse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcUserCourseMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *KcUserCourseMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *KcUserCourseMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *KcUserCourseMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetUserID sets the "user_id" field.
func (m *KcUserCourseMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *KcUserCourseMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the KcUserCourse entity.
// If the KcUserCourse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcUserCourseMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *KcUserCourseMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[kcusercourse.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *KcUserCourseMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[kcusercourse.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *KcUserCourseMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, kcusercourse.FieldUserID)
}

// SetCourseID sets the "course_id" field.
func (m *KcUserCourseMutation) SetCourseID(i int) {
	m.course = &i
}

// CourseID returns the value of the "course_id" field in the mutation.
func (m *KcUserCourseMutation) CourseID() (r int, exists bool) {
	v := m.course
	if v == nil {
		return
	}
	return *v, true
}

// OldCourseID returns the old "course_id" field's value of the KcUserCourse entity.
// If the KcUserCourse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcUserCourseMutation) OldCourseID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCourseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCourseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCourseID: %w", err)
	}
	return oldValue.CourseID, nil
}

// ClearCourseID clears the value of the "course_id" field.
func (m *KcUserCourseMutation) ClearCourseID() {
	m.course = nil
	m.clearedFields[kcusercourse.FieldCourseID] = struct{}{}
}

// CourseIDCleared returns if the "course_id" field was cleared in this mutation.
func (m *KcUserCourseMutation) CourseIDCleared() bool {
	_, ok := m.clearedFields[kcusercourse.FieldCourseID]
	return ok
}

// ResetCourseID resets all changes to the "course_id" field.
func (m *KcUserCourseMutation) ResetCourseID() {
	m.course = nil
	delete(m.clearedFields, kcusercourse.FieldCourseID)
}

// ClearUser clears the "user" edge to the User entity.
func (m *KcUserCourseMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *KcUserCourseMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *KcUserCourseMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *KcUserCourseMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearCourse clears the "course" edge to the KcCourse entity.
func (m *KcUserCourseMutation) ClearCourse() {
	m.clearedcourse = true
}

// CourseCleared reports if the "course" edge to the KcCourse entity was cleared.
func (m *KcUserCourseMutation) CourseCleared() bool {
	return m.CourseIDCleared() || m.clearedcourse
}

// CourseIDs returns the "course" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CourseID instead. It exists only for internal usage by the builders.
func (m *KcUserCourseMutation) CourseIDs() (ids []int) {
	if id := m.course; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCourse resets all changes to the "course" edge.
func (m *KcUserCourseMutation) ResetCourse() {
	m.course = nil
	m.clearedcourse = false
}

// Op returns the operation name.
func (m *KcUserCourseMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (KcUserCourse).
func (m *KcUserCourseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *KcUserCourseMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.uuid != nil {
		fields = append(fields, kcusercourse.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, kcusercourse.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, kcusercourse.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, kcusercourse.FieldDeletedAt)
	}
	if m.period_type != nil {
		fields = append(fields, kcusercourse.FieldPeriodType)
	}
	if m.closing_date != nil {
		fields = append(fields, kcusercourse.FieldClosingDate)
	}
	if m.study_rate != nil {
		fields = append(fields, kcusercourse.FieldStudyRate)
	}
	if m.remark != nil {
		fields = append(fields, kcusercourse.FieldRemark)
	}
	if m.price != nil {
		fields = append(fields, kcusercourse.FieldPrice)
	}
	if m.user != nil {
		fields = append(fields, kcusercourse.FieldUserID)
	}
	if m.course != nil {
		fields = append(fields, kcusercourse.FieldCourseID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *KcUserCourseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case kcusercourse.FieldUUID:
		return m.UUID()
	case kcusercourse.FieldCreatedAt:
		return m.CreatedAt()
	case kcusercourse.FieldUpdatedAt:
		return m.UpdatedAt()
	case kcusercourse.FieldDeletedAt:
		return m.DeletedAt()
	case kcusercourse.FieldPeriodType:
		return m.PeriodType()
	case kcusercourse.FieldClosingDate:
		return m.ClosingDate()
	case kcusercourse.FieldStudyRate:
		return m.StudyRate()
	case kcusercourse.FieldRemark:
		return m.Remark()
	case kcusercourse.FieldPrice:
		return m.Price()
	case kcusercourse.FieldUserID:
		return m.UserID()
	case kcusercourse.FieldCourseID:
		return m.CourseID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *KcUserCourseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case kcusercourse.FieldUUID:
		return m.OldUUID(ctx)
	case kcusercourse.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case kcusercourse.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case kcusercourse.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case kcusercourse.FieldPeriodType:
		return m.OldPeriodType(ctx)
	case kcusercourse.FieldClosingDate:
		return m.OldClosingDate(ctx)
	case kcusercourse.FieldStudyRate:
		return m.OldStudyRate(ctx)
	case kcusercourse.FieldRemark:
		return m.OldRemark(ctx)
	case kcusercourse.FieldPrice:
		return m.OldPrice(ctx)
	case kcusercourse.FieldUserID:
		return m.OldUserID(ctx)
	case kcusercourse.FieldCourseID:
		return m.OldCourseID(ctx)
	}
	return nil, fmt.Errorf("unknown KcUserCourse field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KcUserCourseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case kcusercourse.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case kcusercourse.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case kcusercourse.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case kcusercourse.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case kcusercourse.FieldPeriodType:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPeriodType(v)
		return nil
	case kcusercourse.FieldClosingDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClosingDate(v)
		return nil
	case kcusercourse.FieldStudyRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStudyRate(v)
		return nil
	case kcusercourse.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case kcusercourse.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case kcusercourse.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case kcusercourse.FieldCourseID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCourseID(v)
		return nil
	}
	return fmt.Errorf("unknown KcUserCourse field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *KcUserCourseMutation) AddedFields() []string {
	var fields []string
	if m.addperiod_type != nil {
		fields = append(fields, kcusercourse.FieldPeriodType)
	}
	if m.addstudy_rate != nil {
		fields = append(fields, kcusercourse.FieldStudyRate)
	}
	if m.addprice != nil {
		fields = append(fields, kcusercourse.FieldPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *KcUserCourseMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case kcusercourse.FieldPeriodType:
		return m.AddedPeriodType()
	case kcusercourse.FieldStudyRate:
		return m.AddedStudyRate()
	case kcusercourse.FieldPrice:
		return m.AddedPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KcUserCourseMutation) AddField(name string, value ent.Value) error {
	switch name {
	case kcusercourse.FieldPeriodType:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPeriodType(v)
		return nil
	case kcusercourse.FieldStudyRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStudyRate(v)
		return nil
	case kcusercourse.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	}
	return fmt.Errorf("unknown KcUserCourse numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *KcUserCourseMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(kcusercourse.FieldCreatedAt) {
		fields = append(fields, kcusercourse.FieldCreatedAt)
	}
	if m.FieldCleared(kcusercourse.FieldUpdatedAt) {
		fields = append(fields, kcusercourse.FieldUpdatedAt)
	}
	if m.FieldCleared(kcusercourse.FieldDeletedAt) {
		fields = append(fields, kcusercourse.FieldDeletedAt)
	}
	if m.FieldCleared(kcusercourse.FieldClosingDate) {
		fields = append(fields, kcusercourse.FieldClosingDate)
	}
	if m.FieldCleared(kcusercourse.FieldUserID) {
		fields = append(fields, kcusercourse.FieldUserID)
	}
	if m.FieldCleared(kcusercourse.FieldCourseID) {
		fields = append(fields, kcusercourse.FieldCourseID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *KcUserCourseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *KcUserCourseMutation) ClearField(name string) error {
	switch name {
	case kcusercourse.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case kcusercourse.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case kcusercourse.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case kcusercourse.FieldClosingDate:
		m.ClearClosingDate()
		return nil
	case kcusercourse.FieldUserID:
		m.ClearUserID()
		return nil
	case kcusercourse.FieldCourseID:
		m.ClearCourseID()
		return nil
	}
	return fmt.Errorf("unknown KcUserCourse nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *KcUserCourseMutation) ResetField(name string) error {
	switch name {
	case kcusercourse.FieldUUID:
		m.ResetUUID()
		return nil
	case kcusercourse.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case kcusercourse.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case kcusercourse.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case kcusercourse.FieldPeriodType:
		m.ResetPeriodType()
		return nil
	case kcusercourse.FieldClosingDate:
		m.ResetClosingDate()
		return nil
	case kcusercourse.FieldStudyRate:
		m.ResetStudyRate()
		return nil
	case kcusercourse.FieldRemark:
		m.ResetRemark()
		return nil
	case kcusercourse.FieldPrice:
		m.ResetPrice()
		return nil
	case kcusercourse.FieldUserID:
		m.ResetUserID()
		return nil
	case kcusercourse.FieldCourseID:
		m.ResetCourseID()
		return nil
	}
	return fmt.Errorf("unknown KcUserCourse field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *KcUserCourseMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, kcusercourse.EdgeUser)
	}
	if m.course != nil {
		edges = append(edges, kcusercourse.EdgeCourse)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *KcUserCourseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case kcusercourse.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case kcusercourse.EdgeCourse:
		if id := m.course; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *KcUserCourseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *KcUserCourseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *KcUserCourseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, kcusercourse.EdgeUser)
	}
	if m.clearedcourse {
		edges = append(edges, kcusercourse.EdgeCourse)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *KcUserCourseMutation) EdgeCleared(name string) bool {
	switch name {
	case kcusercourse.EdgeUser:
		return m.cleareduser
	case kcusercourse.EdgeCourse:
		return m.clearedcourse
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *KcUserCourseMutation) ClearEdge(name string) error {
	switch name {
	case kcusercourse.EdgeUser:
		m.ClearUser()
		return nil
	case kcusercourse.EdgeCourse:
		m.ClearCourse()
		return nil
	}
	return fmt.Errorf("unknown KcUserCourse unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *KcUserCourseMutation) ResetEdge(name string) error {
	switch name {
	case kcusercourse.EdgeUser:
		m.ResetUser()
		return nil
	case kcusercourse.EdgeCourse:
		m.ResetCourse()
		return nil
	}
	return fmt.Errorf("unknown KcUserCourse edge %s", name)
}

// KcVideoUploadTaskMutation represents an operation that mutates the KcVideoUploadTask nodes in the graph.
type KcVideoUploadTaskMutation struct {
	config
	op                Op
	typ               string
	id                *int
	uuid              *string
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	video_id          *int
	addvideo_id       *int
	_type             *uint8
	add_type          *uint8
	course_id         *int
	addcourse_id      *int
	status            *int
	addstatus         *int
	remark            *string
	title             *string
	video_name        *string
	total_size        *int
	addtotal_size     *int
	length            *int
	addlength         *int
	clearedFields     map[string]struct{}
	attachment        *int
	clearedattachment bool
	done              bool
	oldValue          func(context.Context) (*KcVideoUploadTask, error)
	predicates        []predicate.KcVideoUploadTask
}

var _ ent.Mutation = (*KcVideoUploadTaskMutation)(nil)

// kcvideouploadtaskOption allows management of the mutation configuration using functional options.
type kcvideouploadtaskOption func(*KcVideoUploadTaskMutation)

// newKcVideoUploadTaskMutation creates new mutation for the KcVideoUploadTask entity.
func newKcVideoUploadTaskMutation(c config, op Op, opts ...kcvideouploadtaskOption) *KcVideoUploadTaskMutation {
	m := &KcVideoUploadTaskMutation{
		config:        c,
		op:            op,
		typ:           TypeKcVideoUploadTask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withKcVideoUploadTaskID sets the ID field of the mutation.
func withKcVideoUploadTaskID(id int) kcvideouploadtaskOption {
	return func(m *KcVideoUploadTaskMutation) {
		var (
			err   error
			once  sync.Once
			value *KcVideoUploadTask
		)
		m.oldValue = func(ctx context.Context) (*KcVideoUploadTask, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().KcVideoUploadTask.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withKcVideoUploadTask sets the old KcVideoUploadTask of the mutation.
func withKcVideoUploadTask(node *KcVideoUploadTask) kcvideouploadtaskOption {
	return func(m *KcVideoUploadTaskMutation) {
		m.oldValue = func(context.Context) (*KcVideoUploadTask, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m KcVideoUploadTaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m KcVideoUploadTaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *KcVideoUploadTaskMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *KcVideoUploadTaskMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *KcVideoUploadTaskMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the KcVideoUploadTask entity.
// If the KcVideoUploadTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcVideoUploadTaskMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *KcVideoUploadTaskMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *KcVideoUploadTaskMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *KcVideoUploadTaskMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the KcVideoUploadTask entity.
// If the KcVideoUploadTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcVideoUploadTaskMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *KcVideoUploadTaskMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[kcvideouploadtask.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *KcVideoUploadTaskMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[kcvideouploadtask.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *KcVideoUploadTaskMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, kcvideouploadtask.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *KcVideoUploadTaskMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *KcVideoUploadTaskMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the KcVideoUploadTask entity.
// If the KcVideoUploadTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcVideoUploadTaskMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *KcVideoUploadTaskMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[kcvideouploadtask.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *KcVideoUploadTaskMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[kcvideouploadtask.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *KcVideoUploadTaskMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, kcvideouploadtask.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *KcVideoUploadTaskMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *KcVideoUploadTaskMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the KcVideoUploadTask entity.
// If the KcVideoUploadTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcVideoUploadTaskMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *KcVideoUploadTaskMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[kcvideouploadtask.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *KcVideoUploadTaskMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[kcvideouploadtask.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *KcVideoUploadTaskMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, kcvideouploadtask.FieldDeletedAt)
}

// SetVideoID sets the "video_id" field.
func (m *KcVideoUploadTaskMutation) SetVideoID(i int) {
	m.video_id = &i
	m.addvideo_id = nil
}

// VideoID returns the value of the "video_id" field in the mutation.
func (m *KcVideoUploadTaskMutation) VideoID() (r int, exists bool) {
	v := m.video_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVideoID returns the old "video_id" field's value of the KcVideoUploadTask entity.
// If the KcVideoUploadTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcVideoUploadTaskMutation) OldVideoID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVideoID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVideoID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVideoID: %w", err)
	}
	return oldValue.VideoID, nil
}

// AddVideoID adds i to the "video_id" field.
func (m *KcVideoUploadTaskMutation) AddVideoID(i int) {
	if m.addvideo_id != nil {
		*m.addvideo_id += i
	} else {
		m.addvideo_id = &i
	}
}

// AddedVideoID returns the value that was added to the "video_id" field in this mutation.
func (m *KcVideoUploadTaskMutation) AddedVideoID() (r int, exists bool) {
	v := m.addvideo_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearVideoID clears the value of the "video_id" field.
func (m *KcVideoUploadTaskMutation) ClearVideoID() {
	m.video_id = nil
	m.addvideo_id = nil
	m.clearedFields[kcvideouploadtask.FieldVideoID] = struct{}{}
}

// VideoIDCleared returns if the "video_id" field was cleared in this mutation.
func (m *KcVideoUploadTaskMutation) VideoIDCleared() bool {
	_, ok := m.clearedFields[kcvideouploadtask.FieldVideoID]
	return ok
}

// ResetVideoID resets all changes to the "video_id" field.
func (m *KcVideoUploadTaskMutation) ResetVideoID() {
	m.video_id = nil
	m.addvideo_id = nil
	delete(m.clearedFields, kcvideouploadtask.FieldVideoID)
}

// SetAttachmentID sets the "attachment_id" field.
func (m *KcVideoUploadTaskMutation) SetAttachmentID(i int) {
	m.attachment = &i
}

// AttachmentID returns the value of the "attachment_id" field in the mutation.
func (m *KcVideoUploadTaskMutation) AttachmentID() (r int, exists bool) {
	v := m.attachment
	if v == nil {
		return
	}
	return *v, true
}

// OldAttachmentID returns the old "attachment_id" field's value of the KcVideoUploadTask entity.
// If the KcVideoUploadTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcVideoUploadTaskMutation) OldAttachmentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAttachmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAttachmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttachmentID: %w", err)
	}
	return oldValue.AttachmentID, nil
}

// ClearAttachmentID clears the value of the "attachment_id" field.
func (m *KcVideoUploadTaskMutation) ClearAttachmentID() {
	m.attachment = nil
	m.clearedFields[kcvideouploadtask.FieldAttachmentID] = struct{}{}
}

// AttachmentIDCleared returns if the "attachment_id" field was cleared in this mutation.
func (m *KcVideoUploadTaskMutation) AttachmentIDCleared() bool {
	_, ok := m.clearedFields[kcvideouploadtask.FieldAttachmentID]
	return ok
}

// ResetAttachmentID resets all changes to the "attachment_id" field.
func (m *KcVideoUploadTaskMutation) ResetAttachmentID() {
	m.attachment = nil
	delete(m.clearedFields, kcvideouploadtask.FieldAttachmentID)
}

// SetType sets the "type" field.
func (m *KcVideoUploadTaskMutation) SetType(u uint8) {
	m._type = &u
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *KcVideoUploadTaskMutation) GetType() (r uint8, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the KcVideoUploadTask entity.
// If the KcVideoUploadTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcVideoUploadTaskMutation) OldType(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds u to the "type" field.
func (m *KcVideoUploadTaskMutation) AddType(u uint8) {
	if m.add_type != nil {
		*m.add_type += u
	} else {
		m.add_type = &u
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *KcVideoUploadTaskMutation) AddedType() (r uint8, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *KcVideoUploadTaskMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetCourseID sets the "course_id" field.
func (m *KcVideoUploadTaskMutation) SetCourseID(i int) {
	m.course_id = &i
	m.addcourse_id = nil
}

// CourseID returns the value of the "course_id" field in the mutation.
func (m *KcVideoUploadTaskMutation) CourseID() (r int, exists bool) {
	v := m.course_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCourseID returns the old "course_id" field's value of the KcVideoUploadTask entity.
// If the KcVideoUploadTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcVideoUploadTaskMutation) OldCourseID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCourseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCourseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCourseID: %w", err)
	}
	return oldValue.CourseID, nil
}

// AddCourseID adds i to the "course_id" field.
func (m *KcVideoUploadTaskMutation) AddCourseID(i int) {
	if m.addcourse_id != nil {
		*m.addcourse_id += i
	} else {
		m.addcourse_id = &i
	}
}

// AddedCourseID returns the value that was added to the "course_id" field in this mutation.
func (m *KcVideoUploadTaskMutation) AddedCourseID() (r int, exists bool) {
	v := m.addcourse_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCourseID resets all changes to the "course_id" field.
func (m *KcVideoUploadTaskMutation) ResetCourseID() {
	m.course_id = nil
	m.addcourse_id = nil
}

// SetStatus sets the "status" field.
func (m *KcVideoUploadTaskMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *KcVideoUploadTaskMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the KcVideoUploadTask entity.
// If the KcVideoUploadTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcVideoUploadTaskMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *KcVideoUploadTaskMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *KcVideoUploadTaskMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *KcVideoUploadTaskMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetRemark sets the "remark" field.
func (m *KcVideoUploadTaskMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *KcVideoUploadTaskMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the KcVideoUploadTask entity.
// If the KcVideoUploadTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcVideoUploadTaskMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *KcVideoUploadTaskMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[kcvideouploadtask.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *KcVideoUploadTaskMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[kcvideouploadtask.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *KcVideoUploadTaskMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, kcvideouploadtask.FieldRemark)
}

// SetTitle sets the "title" field.
func (m *KcVideoUploadTaskMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *KcVideoUploadTaskMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the KcVideoUploadTask entity.
// If the KcVideoUploadTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcVideoUploadTaskMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *KcVideoUploadTaskMutation) ResetTitle() {
	m.title = nil
}

// SetVideoName sets the "video_name" field.
func (m *KcVideoUploadTaskMutation) SetVideoName(s string) {
	m.video_name = &s
}

// VideoName returns the value of the "video_name" field in the mutation.
func (m *KcVideoUploadTaskMutation) VideoName() (r string, exists bool) {
	v := m.video_name
	if v == nil {
		return
	}
	return *v, true
}

// OldVideoName returns the old "video_name" field's value of the KcVideoUploadTask entity.
// If the KcVideoUploadTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcVideoUploadTaskMutation) OldVideoName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVideoName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVideoName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVideoName: %w", err)
	}
	return oldValue.VideoName, nil
}

// ResetVideoName resets all changes to the "video_name" field.
func (m *KcVideoUploadTaskMutation) ResetVideoName() {
	m.video_name = nil
}

// SetTotalSize sets the "total_size" field.
func (m *KcVideoUploadTaskMutation) SetTotalSize(i int) {
	m.total_size = &i
	m.addtotal_size = nil
}

// TotalSize returns the value of the "total_size" field in the mutation.
func (m *KcVideoUploadTaskMutation) TotalSize() (r int, exists bool) {
	v := m.total_size
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalSize returns the old "total_size" field's value of the KcVideoUploadTask entity.
// If the KcVideoUploadTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcVideoUploadTaskMutation) OldTotalSize(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTotalSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTotalSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalSize: %w", err)
	}
	return oldValue.TotalSize, nil
}

// AddTotalSize adds i to the "total_size" field.
func (m *KcVideoUploadTaskMutation) AddTotalSize(i int) {
	if m.addtotal_size != nil {
		*m.addtotal_size += i
	} else {
		m.addtotal_size = &i
	}
}

// AddedTotalSize returns the value that was added to the "total_size" field in this mutation.
func (m *KcVideoUploadTaskMutation) AddedTotalSize() (r int, exists bool) {
	v := m.addtotal_size
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalSize resets all changes to the "total_size" field.
func (m *KcVideoUploadTaskMutation) ResetTotalSize() {
	m.total_size = nil
	m.addtotal_size = nil
}

// SetLength sets the "length" field.
func (m *KcVideoUploadTaskMutation) SetLength(i int) {
	m.length = &i
	m.addlength = nil
}

// Length returns the value of the "length" field in the mutation.
func (m *KcVideoUploadTaskMutation) Length() (r int, exists bool) {
	v := m.length
	if v == nil {
		return
	}
	return *v, true
}

// OldLength returns the old "length" field's value of the KcVideoUploadTask entity.
// If the KcVideoUploadTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KcVideoUploadTaskMutation) OldLength(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLength is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLength requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLength: %w", err)
	}
	return oldValue.Length, nil
}

// AddLength adds i to the "length" field.
func (m *KcVideoUploadTaskMutation) AddLength(i int) {
	if m.addlength != nil {
		*m.addlength += i
	} else {
		m.addlength = &i
	}
}

// AddedLength returns the value that was added to the "length" field in this mutation.
func (m *KcVideoUploadTaskMutation) AddedLength() (r int, exists bool) {
	v := m.addlength
	if v == nil {
		return
	}
	return *v, true
}

// ResetLength resets all changes to the "length" field.
func (m *KcVideoUploadTaskMutation) ResetLength() {
	m.length = nil
	m.addlength = nil
}

// ClearAttachment clears the "attachment" edge to the Attachment entity.
func (m *KcVideoUploadTaskMutation) ClearAttachment() {
	m.clearedattachment = true
}

// AttachmentCleared reports if the "attachment" edge to the Attachment entity was cleared.
func (m *KcVideoUploadTaskMutation) AttachmentCleared() bool {
	return m.AttachmentIDCleared() || m.clearedattachment
}

// AttachmentIDs returns the "attachment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AttachmentID instead. It exists only for internal usage by the builders.
func (m *KcVideoUploadTaskMutation) AttachmentIDs() (ids []int) {
	if id := m.attachment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAttachment resets all changes to the "attachment" edge.
func (m *KcVideoUploadTaskMutation) ResetAttachment() {
	m.attachment = nil
	m.clearedattachment = false
}

// Op returns the operation name.
func (m *KcVideoUploadTaskMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (KcVideoUploadTask).
func (m *KcVideoUploadTaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *KcVideoUploadTaskMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.uuid != nil {
		fields = append(fields, kcvideouploadtask.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, kcvideouploadtask.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, kcvideouploadtask.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, kcvideouploadtask.FieldDeletedAt)
	}
	if m.video_id != nil {
		fields = append(fields, kcvideouploadtask.FieldVideoID)
	}
	if m.attachment != nil {
		fields = append(fields, kcvideouploadtask.FieldAttachmentID)
	}
	if m._type != nil {
		fields = append(fields, kcvideouploadtask.FieldType)
	}
	if m.course_id != nil {
		fields = append(fields, kcvideouploadtask.FieldCourseID)
	}
	if m.status != nil {
		fields = append(fields, kcvideouploadtask.FieldStatus)
	}
	if m.remark != nil {
		fields = append(fields, kcvideouploadtask.FieldRemark)
	}
	if m.title != nil {
		fields = append(fields, kcvideouploadtask.FieldTitle)
	}
	if m.video_name != nil {
		fields = append(fields, kcvideouploadtask.FieldVideoName)
	}
	if m.total_size != nil {
		fields = append(fields, kcvideouploadtask.FieldTotalSize)
	}
	if m.length != nil {
		fields = append(fields, kcvideouploadtask.FieldLength)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *KcVideoUploadTaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case kcvideouploadtask.FieldUUID:
		return m.UUID()
	case kcvideouploadtask.FieldCreatedAt:
		return m.CreatedAt()
	case kcvideouploadtask.FieldUpdatedAt:
		return m.UpdatedAt()
	case kcvideouploadtask.FieldDeletedAt:
		return m.DeletedAt()
	case kcvideouploadtask.FieldVideoID:
		return m.VideoID()
	case kcvideouploadtask.FieldAttachmentID:
		return m.AttachmentID()
	case kcvideouploadtask.FieldType:
		return m.GetType()
	case kcvideouploadtask.FieldCourseID:
		return m.CourseID()
	case kcvideouploadtask.FieldStatus:
		return m.Status()
	case kcvideouploadtask.FieldRemark:
		return m.Remark()
	case kcvideouploadtask.FieldTitle:
		return m.Title()
	case kcvideouploadtask.FieldVideoName:
		return m.VideoName()
	case kcvideouploadtask.FieldTotalSize:
		return m.TotalSize()
	case kcvideouploadtask.FieldLength:
		return m.Length()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *KcVideoUploadTaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case kcvideouploadtask.FieldUUID:
		return m.OldUUID(ctx)
	case kcvideouploadtask.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case kcvideouploadtask.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case kcvideouploadtask.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case kcvideouploadtask.FieldVideoID:
		return m.OldVideoID(ctx)
	case kcvideouploadtask.FieldAttachmentID:
		return m.OldAttachmentID(ctx)
	case kcvideouploadtask.FieldType:
		return m.OldType(ctx)
	case kcvideouploadtask.FieldCourseID:
		return m.OldCourseID(ctx)
	case kcvideouploadtask.FieldStatus:
		return m.OldStatus(ctx)
	case kcvideouploadtask.FieldRemark:
		return m.OldRemark(ctx)
	case kcvideouploadtask.FieldTitle:
		return m.OldTitle(ctx)
	case kcvideouploadtask.FieldVideoName:
		return m.OldVideoName(ctx)
	case kcvideouploadtask.FieldTotalSize:
		return m.OldTotalSize(ctx)
	case kcvideouploadtask.FieldLength:
		return m.OldLength(ctx)
	}
	return nil, fmt.Errorf("unknown KcVideoUploadTask field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KcVideoUploadTaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case kcvideouploadtask.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case kcvideouploadtask.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case kcvideouploadtask.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case kcvideouploadtask.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case kcvideouploadtask.FieldVideoID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVideoID(v)
		return nil
	case kcvideouploadtask.FieldAttachmentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttachmentID(v)
		return nil
	case kcvideouploadtask.FieldType:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case kcvideouploadtask.FieldCourseID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCourseID(v)
		return nil
	case kcvideouploadtask.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case kcvideouploadtask.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case kcvideouploadtask.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case kcvideouploadtask.FieldVideoName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVideoName(v)
		return nil
	case kcvideouploadtask.FieldTotalSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalSize(v)
		return nil
	case kcvideouploadtask.FieldLength:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLength(v)
		return nil
	}
	return fmt.Errorf("unknown KcVideoUploadTask field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *KcVideoUploadTaskMutation) AddedFields() []string {
	var fields []string
	if m.addvideo_id != nil {
		fields = append(fields, kcvideouploadtask.FieldVideoID)
	}
	if m.add_type != nil {
		fields = append(fields, kcvideouploadtask.FieldType)
	}
	if m.addcourse_id != nil {
		fields = append(fields, kcvideouploadtask.FieldCourseID)
	}
	if m.addstatus != nil {
		fields = append(fields, kcvideouploadtask.FieldStatus)
	}
	if m.addtotal_size != nil {
		fields = append(fields, kcvideouploadtask.FieldTotalSize)
	}
	if m.addlength != nil {
		fields = append(fields, kcvideouploadtask.FieldLength)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *KcVideoUploadTaskMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case kcvideouploadtask.FieldVideoID:
		return m.AddedVideoID()
	case kcvideouploadtask.FieldType:
		return m.AddedType()
	case kcvideouploadtask.FieldCourseID:
		return m.AddedCourseID()
	case kcvideouploadtask.FieldStatus:
		return m.AddedStatus()
	case kcvideouploadtask.FieldTotalSize:
		return m.AddedTotalSize()
	case kcvideouploadtask.FieldLength:
		return m.AddedLength()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KcVideoUploadTaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	case kcvideouploadtask.FieldVideoID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVideoID(v)
		return nil
	case kcvideouploadtask.FieldType:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case kcvideouploadtask.FieldCourseID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCourseID(v)
		return nil
	case kcvideouploadtask.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case kcvideouploadtask.FieldTotalSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalSize(v)
		return nil
	case kcvideouploadtask.FieldLength:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLength(v)
		return nil
	}
	return fmt.Errorf("unknown KcVideoUploadTask numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *KcVideoUploadTaskMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(kcvideouploadtask.FieldCreatedAt) {
		fields = append(fields, kcvideouploadtask.FieldCreatedAt)
	}
	if m.FieldCleared(kcvideouploadtask.FieldUpdatedAt) {
		fields = append(fields, kcvideouploadtask.FieldUpdatedAt)
	}
	if m.FieldCleared(kcvideouploadtask.FieldDeletedAt) {
		fields = append(fields, kcvideouploadtask.FieldDeletedAt)
	}
	if m.FieldCleared(kcvideouploadtask.FieldVideoID) {
		fields = append(fields, kcvideouploadtask.FieldVideoID)
	}
	if m.FieldCleared(kcvideouploadtask.FieldAttachmentID) {
		fields = append(fields, kcvideouploadtask.FieldAttachmentID)
	}
	if m.FieldCleared(kcvideouploadtask.FieldRemark) {
		fields = append(fields, kcvideouploadtask.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *KcVideoUploadTaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *KcVideoUploadTaskMutation) ClearField(name string) error {
	switch name {
	case kcvideouploadtask.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case kcvideouploadtask.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case kcvideouploadtask.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case kcvideouploadtask.FieldVideoID:
		m.ClearVideoID()
		return nil
	case kcvideouploadtask.FieldAttachmentID:
		m.ClearAttachmentID()
		return nil
	case kcvideouploadtask.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown KcVideoUploadTask nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *KcVideoUploadTaskMutation) ResetField(name string) error {
	switch name {
	case kcvideouploadtask.FieldUUID:
		m.ResetUUID()
		return nil
	case kcvideouploadtask.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case kcvideouploadtask.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case kcvideouploadtask.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case kcvideouploadtask.FieldVideoID:
		m.ResetVideoID()
		return nil
	case kcvideouploadtask.FieldAttachmentID:
		m.ResetAttachmentID()
		return nil
	case kcvideouploadtask.FieldType:
		m.ResetType()
		return nil
	case kcvideouploadtask.FieldCourseID:
		m.ResetCourseID()
		return nil
	case kcvideouploadtask.FieldStatus:
		m.ResetStatus()
		return nil
	case kcvideouploadtask.FieldRemark:
		m.ResetRemark()
		return nil
	case kcvideouploadtask.FieldTitle:
		m.ResetTitle()
		return nil
	case kcvideouploadtask.FieldVideoName:
		m.ResetVideoName()
		return nil
	case kcvideouploadtask.FieldTotalSize:
		m.ResetTotalSize()
		return nil
	case kcvideouploadtask.FieldLength:
		m.ResetLength()
		return nil
	}
	return fmt.Errorf("unknown KcVideoUploadTask field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *KcVideoUploadTaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.attachment != nil {
		edges = append(edges, kcvideouploadtask.EdgeAttachment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *KcVideoUploadTaskMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case kcvideouploadtask.EdgeAttachment:
		if id := m.attachment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *KcVideoUploadTaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *KcVideoUploadTaskMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *KcVideoUploadTaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedattachment {
		edges = append(edges, kcvideouploadtask.EdgeAttachment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *KcVideoUploadTaskMutation) EdgeCleared(name string) bool {
	switch name {
	case kcvideouploadtask.EdgeAttachment:
		return m.clearedattachment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *KcVideoUploadTaskMutation) ClearEdge(name string) error {
	switch name {
	case kcvideouploadtask.EdgeAttachment:
		m.ClearAttachment()
		return nil
	}
	return fmt.Errorf("unknown KcVideoUploadTask unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *KcVideoUploadTaskMutation) ResetEdge(name string) error {
	switch name {
	case kcvideouploadtask.EdgeAttachment:
		m.ResetAttachment()
		return nil
	}
	return fmt.Errorf("unknown KcVideoUploadTask edge %s", name)
}

// MajorMutation represents an operation that mutates the Major nodes in the graph.
type MajorMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	uuid                *string
	created_at          *time.Time
	updated_at          *time.Time
	deleted_at          *time.Time
	name                *string
	status              *uint8
	addstatus           *uint8
	code                *string
	desc                *string
	sort_order          *int
	addsort_order       *int
	clearedFields       map[string]struct{}
	teachers            map[int]struct{}
	removedteachers     map[int]struct{}
	clearedteachers     bool
	major_detail        *int
	clearedmajor_detail bool
	kc_classes          map[int]struct{}
	removedkc_classes   map[int]struct{}
	clearedkc_classes   bool
	courses             map[int]struct{}
	removedcourses      map[int]struct{}
	clearedcourses      bool
	done                bool
	oldValue            func(context.Context) (*Major, error)
	predicates          []predicate.Major
}

var _ ent.Mutation = (*MajorMutation)(nil)

// majorOption allows management of the mutation configuration using functional options.
type majorOption func(*MajorMutation)

// newMajorMutation creates new mutation for the Major entity.
func newMajorMutation(c config, op Op, opts ...majorOption) *MajorMutation {
	m := &MajorMutation{
		config:        c,
		op:            op,
		typ:           TypeMajor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMajorID sets the ID field of the mutation.
func withMajorID(id int) majorOption {
	return func(m *MajorMutation) {
		var (
			err   error
			once  sync.Once
			value *Major
		)
		m.oldValue = func(ctx context.Context) (*Major, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Major.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMajor sets the old Major of the mutation.
func withMajor(node *Major) majorOption {
	return func(m *MajorMutation) {
		m.oldValue = func(context.Context) (*Major, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MajorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MajorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *MajorMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *MajorMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *MajorMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the Major entity.
// If the Major object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MajorMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *MajorMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MajorMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MajorMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Major entity.
// If the Major object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MajorMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *MajorMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[major.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *MajorMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[major.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MajorMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, major.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MajorMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MajorMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Major entity.
// If the Major object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MajorMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *MajorMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[major.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *MajorMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[major.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MajorMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, major.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MajorMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MajorMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Major entity.
// If the Major object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MajorMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *MajorMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[major.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *MajorMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[major.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MajorMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, major.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *MajorMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MajorMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Major entity.
// If the Major object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MajorMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MajorMutation) ResetName() {
	m.name = nil
}

// SetStatus sets the "status" field.
func (m *MajorMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *MajorMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Major entity.
// If the Major object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MajorMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *MajorMutation) AddStatus(u uint8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *MajorMutation) AddedStatus() (r uint8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *MajorMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetCode sets the "code" field.
func (m *MajorMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *MajorMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Major entity.
// If the Major object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MajorMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *MajorMutation) ResetCode() {
	m.code = nil
}

// SetDesc sets the "desc" field.
func (m *MajorMutation) SetDesc(s string) {
	m.desc = &s
}

// Desc returns the value of the "desc" field in the mutation.
func (m *MajorMutation) Desc() (r string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the Major entity.
// If the Major object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MajorMutation) OldDesc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// ResetDesc resets all changes to the "desc" field.
func (m *MajorMutation) ResetDesc() {
	m.desc = nil
}

// SetSortOrder sets the "sort_order" field.
func (m *MajorMutation) SetSortOrder(i int) {
	m.sort_order = &i
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *MajorMutation) SortOrder() (r int, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the Major entity.
// If the Major object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MajorMutation) OldSortOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds i to the "sort_order" field.
func (m *MajorMutation) AddSortOrder(i int) {
	if m.addsort_order != nil {
		*m.addsort_order += i
	} else {
		m.addsort_order = &i
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *MajorMutation) AddedSortOrder() (r int, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *MajorMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
}

// AddTeacherIDs adds the "teachers" edge to the Teacher entity by ids.
func (m *MajorMutation) AddTeacherIDs(ids ...int) {
	if m.teachers == nil {
		m.teachers = make(map[int]struct{})
	}
	for i := range ids {
		m.teachers[ids[i]] = struct{}{}
	}
}

// ClearTeachers clears the "teachers" edge to the Teacher entity.
func (m *MajorMutation) ClearTeachers() {
	m.clearedteachers = true
}

// TeachersCleared reports if the "teachers" edge to the Teacher entity was cleared.
func (m *MajorMutation) TeachersCleared() bool {
	return m.clearedteachers
}

// RemoveTeacherIDs removes the "teachers" edge to the Teacher entity by IDs.
func (m *MajorMutation) RemoveTeacherIDs(ids ...int) {
	if m.removedteachers == nil {
		m.removedteachers = make(map[int]struct{})
	}
	for i := range ids {
		m.removedteachers[ids[i]] = struct{}{}
	}
}

// RemovedTeachers returns the removed IDs of the "teachers" edge to the Teacher entity.
func (m *MajorMutation) RemovedTeachersIDs() (ids []int) {
	for id := range m.removedteachers {
		ids = append(ids, id)
	}
	return
}

// TeachersIDs returns the "teachers" edge IDs in the mutation.
func (m *MajorMutation) TeachersIDs() (ids []int) {
	for id := range m.teachers {
		ids = append(ids, id)
	}
	return
}

// ResetTeachers resets all changes to the "teachers" edge.
func (m *MajorMutation) ResetTeachers() {
	m.teachers = nil
	m.clearedteachers = false
	m.removedteachers = nil
}

// SetMajorDetailID sets the "major_detail" edge to the MajorDetail entity by id.
func (m *MajorMutation) SetMajorDetailID(id int) {
	m.major_detail = &id
}

// ClearMajorDetail clears the "major_detail" edge to the MajorDetail entity.
func (m *MajorMutation) ClearMajorDetail() {
	m.clearedmajor_detail = true
}

// MajorDetailCleared reports if the "major_detail" edge to the MajorDetail entity was cleared.
func (m *MajorMutation) MajorDetailCleared() bool {
	return m.clearedmajor_detail
}

// MajorDetailID returns the "major_detail" edge ID in the mutation.
func (m *MajorMutation) MajorDetailID() (id int, exists bool) {
	if m.major_detail != nil {
		return *m.major_detail, true
	}
	return
}

// MajorDetailIDs returns the "major_detail" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MajorDetailID instead. It exists only for internal usage by the builders.
func (m *MajorMutation) MajorDetailIDs() (ids []int) {
	if id := m.major_detail; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMajorDetail resets all changes to the "major_detail" edge.
func (m *MajorMutation) ResetMajorDetail() {
	m.major_detail = nil
	m.clearedmajor_detail = false
}

// AddKcClassIDs adds the "kc_classes" edge to the KcClass entity by ids.
func (m *MajorMutation) AddKcClassIDs(ids ...int) {
	if m.kc_classes == nil {
		m.kc_classes = make(map[int]struct{})
	}
	for i := range ids {
		m.kc_classes[ids[i]] = struct{}{}
	}
}

// ClearKcClasses clears the "kc_classes" edge to the KcClass entity.
func (m *MajorMutation) ClearKcClasses() {
	m.clearedkc_classes = true
}

// KcClassesCleared reports if the "kc_classes" edge to the KcClass entity was cleared.
func (m *MajorMutation) KcClassesCleared() bool {
	return m.clearedkc_classes
}

// RemoveKcClassIDs removes the "kc_classes" edge to the KcClass entity by IDs.
func (m *MajorMutation) RemoveKcClassIDs(ids ...int) {
	if m.removedkc_classes == nil {
		m.removedkc_classes = make(map[int]struct{})
	}
	for i := range ids {
		m.removedkc_classes[ids[i]] = struct{}{}
	}
}

// RemovedKcClasses returns the removed IDs of the "kc_classes" edge to the KcClass entity.
func (m *MajorMutation) RemovedKcClassesIDs() (ids []int) {
	for id := range m.removedkc_classes {
		ids = append(ids, id)
	}
	return
}

// KcClassesIDs returns the "kc_classes" edge IDs in the mutation.
func (m *MajorMutation) KcClassesIDs() (ids []int) {
	for id := range m.kc_classes {
		ids = append(ids, id)
	}
	return
}

// ResetKcClasses resets all changes to the "kc_classes" edge.
func (m *MajorMutation) ResetKcClasses() {
	m.kc_classes = nil
	m.clearedkc_classes = false
	m.removedkc_classes = nil
}

// AddCourseIDs adds the "courses" edge to the KcCourse entity by ids.
func (m *MajorMutation) AddCourseIDs(ids ...int) {
	if m.courses == nil {
		m.courses = make(map[int]struct{})
	}
	for i := range ids {
		m.courses[ids[i]] = struct{}{}
	}
}

// ClearCourses clears the "courses" edge to the KcCourse entity.
func (m *MajorMutation) ClearCourses() {
	m.clearedcourses = true
}

// CoursesCleared reports if the "courses" edge to the KcCourse entity was cleared.
func (m *MajorMutation) CoursesCleared() bool {
	return m.clearedcourses
}

// RemoveCourseIDs removes the "courses" edge to the KcCourse entity by IDs.
func (m *MajorMutation) RemoveCourseIDs(ids ...int) {
	if m.removedcourses == nil {
		m.removedcourses = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcourses[ids[i]] = struct{}{}
	}
}

// RemovedCourses returns the removed IDs of the "courses" edge to the KcCourse entity.
func (m *MajorMutation) RemovedCoursesIDs() (ids []int) {
	for id := range m.removedcourses {
		ids = append(ids, id)
	}
	return
}

// CoursesIDs returns the "courses" edge IDs in the mutation.
func (m *MajorMutation) CoursesIDs() (ids []int) {
	for id := range m.courses {
		ids = append(ids, id)
	}
	return
}

// ResetCourses resets all changes to the "courses" edge.
func (m *MajorMutation) ResetCourses() {
	m.courses = nil
	m.clearedcourses = false
	m.removedcourses = nil
}

// Op returns the operation name.
func (m *MajorMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Major).
func (m *MajorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MajorMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.uuid != nil {
		fields = append(fields, major.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, major.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, major.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, major.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, major.FieldName)
	}
	if m.status != nil {
		fields = append(fields, major.FieldStatus)
	}
	if m.code != nil {
		fields = append(fields, major.FieldCode)
	}
	if m.desc != nil {
		fields = append(fields, major.FieldDesc)
	}
	if m.sort_order != nil {
		fields = append(fields, major.FieldSortOrder)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MajorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case major.FieldUUID:
		return m.UUID()
	case major.FieldCreatedAt:
		return m.CreatedAt()
	case major.FieldUpdatedAt:
		return m.UpdatedAt()
	case major.FieldDeletedAt:
		return m.DeletedAt()
	case major.FieldName:
		return m.Name()
	case major.FieldStatus:
		return m.Status()
	case major.FieldCode:
		return m.Code()
	case major.FieldDesc:
		return m.Desc()
	case major.FieldSortOrder:
		return m.SortOrder()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MajorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case major.FieldUUID:
		return m.OldUUID(ctx)
	case major.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case major.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case major.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case major.FieldName:
		return m.OldName(ctx)
	case major.FieldStatus:
		return m.OldStatus(ctx)
	case major.FieldCode:
		return m.OldCode(ctx)
	case major.FieldDesc:
		return m.OldDesc(ctx)
	case major.FieldSortOrder:
		return m.OldSortOrder(ctx)
	}
	return nil, fmt.Errorf("unknown Major field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MajorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case major.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case major.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case major.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case major.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case major.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case major.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case major.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case major.FieldDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	case major.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Major field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MajorMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, major.FieldStatus)
	}
	if m.addsort_order != nil {
		fields = append(fields, major.FieldSortOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MajorMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case major.FieldStatus:
		return m.AddedStatus()
	case major.FieldSortOrder:
		return m.AddedSortOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MajorMutation) AddField(name string, value ent.Value) error {
	switch name {
	case major.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case major.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Major numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MajorMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(major.FieldCreatedAt) {
		fields = append(fields, major.FieldCreatedAt)
	}
	if m.FieldCleared(major.FieldUpdatedAt) {
		fields = append(fields, major.FieldUpdatedAt)
	}
	if m.FieldCleared(major.FieldDeletedAt) {
		fields = append(fields, major.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MajorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MajorMutation) ClearField(name string) error {
	switch name {
	case major.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case major.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case major.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Major nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MajorMutation) ResetField(name string) error {
	switch name {
	case major.FieldUUID:
		m.ResetUUID()
		return nil
	case major.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case major.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case major.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case major.FieldName:
		m.ResetName()
		return nil
	case major.FieldStatus:
		m.ResetStatus()
		return nil
	case major.FieldCode:
		m.ResetCode()
		return nil
	case major.FieldDesc:
		m.ResetDesc()
		return nil
	case major.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	}
	return fmt.Errorf("unknown Major field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MajorMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.teachers != nil {
		edges = append(edges, major.EdgeTeachers)
	}
	if m.major_detail != nil {
		edges = append(edges, major.EdgeMajorDetail)
	}
	if m.kc_classes != nil {
		edges = append(edges, major.EdgeKcClasses)
	}
	if m.courses != nil {
		edges = append(edges, major.EdgeCourses)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MajorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case major.EdgeTeachers:
		ids := make([]ent.Value, 0, len(m.teachers))
		for id := range m.teachers {
			ids = append(ids, id)
		}
		return ids
	case major.EdgeMajorDetail:
		if id := m.major_detail; id != nil {
			return []ent.Value{*id}
		}
	case major.EdgeKcClasses:
		ids := make([]ent.Value, 0, len(m.kc_classes))
		for id := range m.kc_classes {
			ids = append(ids, id)
		}
		return ids
	case major.EdgeCourses:
		ids := make([]ent.Value, 0, len(m.courses))
		for id := range m.courses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MajorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedteachers != nil {
		edges = append(edges, major.EdgeTeachers)
	}
	if m.removedkc_classes != nil {
		edges = append(edges, major.EdgeKcClasses)
	}
	if m.removedcourses != nil {
		edges = append(edges, major.EdgeCourses)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MajorMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case major.EdgeTeachers:
		ids := make([]ent.Value, 0, len(m.removedteachers))
		for id := range m.removedteachers {
			ids = append(ids, id)
		}
		return ids
	case major.EdgeKcClasses:
		ids := make([]ent.Value, 0, len(m.removedkc_classes))
		for id := range m.removedkc_classes {
			ids = append(ids, id)
		}
		return ids
	case major.EdgeCourses:
		ids := make([]ent.Value, 0, len(m.removedcourses))
		for id := range m.removedcourses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MajorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedteachers {
		edges = append(edges, major.EdgeTeachers)
	}
	if m.clearedmajor_detail {
		edges = append(edges, major.EdgeMajorDetail)
	}
	if m.clearedkc_classes {
		edges = append(edges, major.EdgeKcClasses)
	}
	if m.clearedcourses {
		edges = append(edges, major.EdgeCourses)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MajorMutation) EdgeCleared(name string) bool {
	switch name {
	case major.EdgeTeachers:
		return m.clearedteachers
	case major.EdgeMajorDetail:
		return m.clearedmajor_detail
	case major.EdgeKcClasses:
		return m.clearedkc_classes
	case major.EdgeCourses:
		return m.clearedcourses
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MajorMutation) ClearEdge(name string) error {
	switch name {
	case major.EdgeMajorDetail:
		m.ClearMajorDetail()
		return nil
	}
	return fmt.Errorf("unknown Major unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MajorMutation) ResetEdge(name string) error {
	switch name {
	case major.EdgeTeachers:
		m.ResetTeachers()
		return nil
	case major.EdgeMajorDetail:
		m.ResetMajorDetail()
		return nil
	case major.EdgeKcClasses:
		m.ResetKcClasses()
		return nil
	case major.EdgeCourses:
		m.ResetCourses()
		return nil
	}
	return fmt.Errorf("unknown Major edge %s", name)
}

// MajorDetailMutation represents an operation that mutates the MajorDetail nodes in the graph.
type MajorDetailMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	uuid                       *string
	created_at                 *time.Time
	updated_at                 *time.Time
	deleted_at                 *time.Time
	name                       *string
	desc                       *string
	subject_count              *uint8
	addsubject_count           *uint8
	star                       *string
	pass_rate                  *uint8
	addpass_rate               *uint8
	student_count              *uint32
	addstudent_count           *uint32
	study_duration             *uint8
	addstudy_duration          *uint8
	clearedFields              map[string]struct{}
	major_detail_tags          map[int]struct{}
	removedmajor_detail_tags   map[int]struct{}
	clearedmajor_detail_tags   bool
	cover_attachment           *int
	clearedcover_attachment    bool
	subject_attachment         *int
	clearedsubject_attachment  bool
	teacher_attachments        map[int]struct{}
	removedteacher_attachments map[int]struct{}
	clearedteacher_attachments bool
	service_attachments        map[int]struct{}
	removedservice_attachments map[int]struct{}
	clearedservice_attachments bool
	major                      *int
	clearedmajor               bool
	done                       bool
	oldValue                   func(context.Context) (*MajorDetail, error)
	predicates                 []predicate.MajorDetail
}

var _ ent.Mutation = (*MajorDetailMutation)(nil)

// majordetailOption allows management of the mutation configuration using functional options.
type majordetailOption func(*MajorDetailMutation)

// newMajorDetailMutation creates new mutation for the MajorDetail entity.
func newMajorDetailMutation(c config, op Op, opts ...majordetailOption) *MajorDetailMutation {
	m := &MajorDetailMutation{
		config:        c,
		op:            op,
		typ:           TypeMajorDetail,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMajorDetailID sets the ID field of the mutation.
func withMajorDetailID(id int) majordetailOption {
	return func(m *MajorDetailMutation) {
		var (
			err   error
			once  sync.Once
			value *MajorDetail
		)
		m.oldValue = func(ctx context.Context) (*MajorDetail, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MajorDetail.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMajorDetail sets the old MajorDetail of the mutation.
func withMajorDetail(node *MajorDetail) majordetailOption {
	return func(m *MajorDetailMutation) {
		m.oldValue = func(context.Context) (*MajorDetail, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MajorDetailMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MajorDetailMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *MajorDetailMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *MajorDetailMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *MajorDetailMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the MajorDetail entity.
// If the MajorDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MajorDetailMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *MajorDetailMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MajorDetailMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MajorDetailMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MajorDetail entity.
// If the MajorDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MajorDetailMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *MajorDetailMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[majordetail.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *MajorDetailMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[majordetail.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MajorDetailMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, majordetail.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MajorDetailMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MajorDetailMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MajorDetail entity.
// If the MajorDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MajorDetailMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *MajorDetailMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[majordetail.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *MajorDetailMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[majordetail.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MajorDetailMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, majordetail.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MajorDetailMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MajorDetailMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the MajorDetail entity.
// If the MajorDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MajorDetailMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *MajorDetailMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[majordetail.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *MajorDetailMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[majordetail.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MajorDetailMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, majordetail.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *MajorDetailMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MajorDetailMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the MajorDetail entity.
// If the MajorDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MajorDetailMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MajorDetailMutation) ResetName() {
	m.name = nil
}

// SetDesc sets the "desc" field.
func (m *MajorDetailMutation) SetDesc(s string) {
	m.desc = &s
}

// Desc returns the value of the "desc" field in the mutation.
func (m *MajorDetailMutation) Desc() (r string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the MajorDetail entity.
// If the MajorDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MajorDetailMutation) OldDesc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// ClearDesc clears the value of the "desc" field.
func (m *MajorDetailMutation) ClearDesc() {
	m.desc = nil
	m.clearedFields[majordetail.FieldDesc] = struct{}{}
}

// DescCleared returns if the "desc" field was cleared in this mutation.
func (m *MajorDetailMutation) DescCleared() bool {
	_, ok := m.clearedFields[majordetail.FieldDesc]
	return ok
}

// ResetDesc resets all changes to the "desc" field.
func (m *MajorDetailMutation) ResetDesc() {
	m.desc = nil
	delete(m.clearedFields, majordetail.FieldDesc)
}

// SetSubjectCount sets the "subject_count" field.
func (m *MajorDetailMutation) SetSubjectCount(u uint8) {
	m.subject_count = &u
	m.addsubject_count = nil
}

// SubjectCount returns the value of the "subject_count" field in the mutation.
func (m *MajorDetailMutation) SubjectCount() (r uint8, exists bool) {
	v := m.subject_count
	if v == nil {
		return
	}
	return *v, true
}

// OldSubjectCount returns the old "subject_count" field's value of the MajorDetail entity.
// If the MajorDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MajorDetailMutation) OldSubjectCount(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSubjectCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSubjectCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubjectCount: %w", err)
	}
	return oldValue.SubjectCount, nil
}

// AddSubjectCount adds u to the "subject_count" field.
func (m *MajorDetailMutation) AddSubjectCount(u uint8) {
	if m.addsubject_count != nil {
		*m.addsubject_count += u
	} else {
		m.addsubject_count = &u
	}
}

// AddedSubjectCount returns the value that was added to the "subject_count" field in this mutation.
func (m *MajorDetailMutation) AddedSubjectCount() (r uint8, exists bool) {
	v := m.addsubject_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetSubjectCount resets all changes to the "subject_count" field.
func (m *MajorDetailMutation) ResetSubjectCount() {
	m.subject_count = nil
	m.addsubject_count = nil
}

// SetStar sets the "star" field.
func (m *MajorDetailMutation) SetStar(s string) {
	m.star = &s
}

// Star returns the value of the "star" field in the mutation.
func (m *MajorDetailMutation) Star() (r string, exists bool) {
	v := m.star
	if v == nil {
		return
	}
	return *v, true
}

// OldStar returns the old "star" field's value of the MajorDetail entity.
// If the MajorDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MajorDetailMutation) OldStar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStar: %w", err)
	}
	return oldValue.Star, nil
}

// ResetStar resets all changes to the "star" field.
func (m *MajorDetailMutation) ResetStar() {
	m.star = nil
}

// SetPassRate sets the "pass_rate" field.
func (m *MajorDetailMutation) SetPassRate(u uint8) {
	m.pass_rate = &u
	m.addpass_rate = nil
}

// PassRate returns the value of the "pass_rate" field in the mutation.
func (m *MajorDetailMutation) PassRate() (r uint8, exists bool) {
	v := m.pass_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldPassRate returns the old "pass_rate" field's value of the MajorDetail entity.
// If the MajorDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MajorDetailMutation) OldPassRate(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPassRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPassRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassRate: %w", err)
	}
	return oldValue.PassRate, nil
}

// AddPassRate adds u to the "pass_rate" field.
func (m *MajorDetailMutation) AddPassRate(u uint8) {
	if m.addpass_rate != nil {
		*m.addpass_rate += u
	} else {
		m.addpass_rate = &u
	}
}

// AddedPassRate returns the value that was added to the "pass_rate" field in this mutation.
func (m *MajorDetailMutation) AddedPassRate() (r uint8, exists bool) {
	v := m.addpass_rate
	if v == nil {
		return
	}
	return *v, true
}

// ResetPassRate resets all changes to the "pass_rate" field.
func (m *MajorDetailMutation) ResetPassRate() {
	m.pass_rate = nil
	m.addpass_rate = nil
}

// SetStudentCount sets the "student_count" field.
func (m *MajorDetailMutation) SetStudentCount(u uint32) {
	m.student_count = &u
	m.addstudent_count = nil
}

// StudentCount returns the value of the "student_count" field in the mutation.
func (m *MajorDetailMutation) StudentCount() (r uint32, exists bool) {
	v := m.student_count
	if v == nil {
		return
	}
	return *v, true
}

// OldStudentCount returns the old "student_count" field's value of the MajorDetail entity.
// If the MajorDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MajorDetailMutation) OldStudentCount(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStudentCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStudentCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStudentCount: %w", err)
	}
	return oldValue.StudentCount, nil
}

// AddStudentCount adds u to the "student_count" field.
func (m *MajorDetailMutation) AddStudentCount(u uint32) {
	if m.addstudent_count != nil {
		*m.addstudent_count += u
	} else {
		m.addstudent_count = &u
	}
}

// AddedStudentCount returns the value that was added to the "student_count" field in this mutation.
func (m *MajorDetailMutation) AddedStudentCount() (r uint32, exists bool) {
	v := m.addstudent_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetStudentCount resets all changes to the "student_count" field.
func (m *MajorDetailMutation) ResetStudentCount() {
	m.student_count = nil
	m.addstudent_count = nil
}

// SetStudyDuration sets the "study_duration" field.
func (m *MajorDetailMutation) SetStudyDuration(u uint8) {
	m.study_duration = &u
	m.addstudy_duration = nil
}

// StudyDuration returns the value of the "study_duration" field in the mutation.
func (m *MajorDetailMutation) StudyDuration() (r uint8, exists bool) {
	v := m.study_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldStudyDuration returns the old "study_duration" field's value of the MajorDetail entity.
// If the MajorDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MajorDetailMutation) OldStudyDuration(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStudyDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStudyDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStudyDuration: %w", err)
	}
	return oldValue.StudyDuration, nil
}

// AddStudyDuration adds u to the "study_duration" field.
func (m *MajorDetailMutation) AddStudyDuration(u uint8) {
	if m.addstudy_duration != nil {
		*m.addstudy_duration += u
	} else {
		m.addstudy_duration = &u
	}
}

// AddedStudyDuration returns the value that was added to the "study_duration" field in this mutation.
func (m *MajorDetailMutation) AddedStudyDuration() (r uint8, exists bool) {
	v := m.addstudy_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetStudyDuration resets all changes to the "study_duration" field.
func (m *MajorDetailMutation) ResetStudyDuration() {
	m.study_duration = nil
	m.addstudy_duration = nil
}

// SetMajorID sets the "major_id" field.
func (m *MajorDetailMutation) SetMajorID(i int) {
	m.major = &i
}

// MajorID returns the value of the "major_id" field in the mutation.
func (m *MajorDetailMutation) MajorID() (r int, exists bool) {
	v := m.major
	if v == nil {
		return
	}
	return *v, true
}

// OldMajorID returns the old "major_id" field's value of the MajorDetail entity.
// If the MajorDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MajorDetailMutation) OldMajorID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMajorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMajorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMajorID: %w", err)
	}
	return oldValue.MajorID, nil
}

// ClearMajorID clears the value of the "major_id" field.
func (m *MajorDetailMutation) ClearMajorID() {
	m.major = nil
	m.clearedFields[majordetail.FieldMajorID] = struct{}{}
}

// MajorIDCleared returns if the "major_id" field was cleared in this mutation.
func (m *MajorDetailMutation) MajorIDCleared() bool {
	_, ok := m.clearedFields[majordetail.FieldMajorID]
	return ok
}

// ResetMajorID resets all changes to the "major_id" field.
func (m *MajorDetailMutation) ResetMajorID() {
	m.major = nil
	delete(m.clearedFields, majordetail.FieldMajorID)
}

// SetCoverImgID sets the "cover_img_id" field.
func (m *MajorDetailMutation) SetCoverImgID(i int) {
	m.cover_attachment = &i
}

// CoverImgID returns the value of the "cover_img_id" field in the mutation.
func (m *MajorDetailMutation) CoverImgID() (r int, exists bool) {
	v := m.cover_attachment
	if v == nil {
		return
	}
	return *v, true
}

// OldCoverImgID returns the old "cover_img_id" field's value of the MajorDetail entity.
// If the MajorDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MajorDetailMutation) OldCoverImgID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCoverImgID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCoverImgID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoverImgID: %w", err)
	}
	return oldValue.CoverImgID, nil
}

// ClearCoverImgID clears the value of the "cover_img_id" field.
func (m *MajorDetailMutation) ClearCoverImgID() {
	m.cover_attachment = nil
	m.clearedFields[majordetail.FieldCoverImgID] = struct{}{}
}

// CoverImgIDCleared returns if the "cover_img_id" field was cleared in this mutation.
func (m *MajorDetailMutation) CoverImgIDCleared() bool {
	_, ok := m.clearedFields[majordetail.FieldCoverImgID]
	return ok
}

// ResetCoverImgID resets all changes to the "cover_img_id" field.
func (m *MajorDetailMutation) ResetCoverImgID() {
	m.cover_attachment = nil
	delete(m.clearedFields, majordetail.FieldCoverImgID)
}

// SetSubjectImgID sets the "subject_img_id" field.
func (m *MajorDetailMutation) SetSubjectImgID(i int) {
	m.subject_attachment = &i
}

// SubjectImgID returns the value of the "subject_img_id" field in the mutation.
func (m *MajorDetailMutation) SubjectImgID() (r int, exists bool) {
	v := m.subject_attachment
	if v == nil {
		return
	}
	return *v, true
}

// OldSubjectImgID returns the old "subject_img_id" field's value of the MajorDetail entity.
// If the MajorDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MajorDetailMutation) OldSubjectImgID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSubjectImgID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSubjectImgID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubjectImgID: %w", err)
	}
	return oldValue.SubjectImgID, nil
}

// ClearSubjectImgID clears the value of the "subject_img_id" field.
func (m *MajorDetailMutation) ClearSubjectImgID() {
	m.subject_attachment = nil
	m.clearedFields[majordetail.FieldSubjectImgID] = struct{}{}
}

// SubjectImgIDCleared returns if the "subject_img_id" field was cleared in this mutation.
func (m *MajorDetailMutation) SubjectImgIDCleared() bool {
	_, ok := m.clearedFields[majordetail.FieldSubjectImgID]
	return ok
}

// ResetSubjectImgID resets all changes to the "subject_img_id" field.
func (m *MajorDetailMutation) ResetSubjectImgID() {
	m.subject_attachment = nil
	delete(m.clearedFields, majordetail.FieldSubjectImgID)
}

// AddMajorDetailTagIDs adds the "major_detail_tags" edge to the MajorDetailTag entity by ids.
func (m *MajorDetailMutation) AddMajorDetailTagIDs(ids ...int) {
	if m.major_detail_tags == nil {
		m.major_detail_tags = make(map[int]struct{})
	}
	for i := range ids {
		m.major_detail_tags[ids[i]] = struct{}{}
	}
}

// ClearMajorDetailTags clears the "major_detail_tags" edge to the MajorDetailTag entity.
func (m *MajorDetailMutation) ClearMajorDetailTags() {
	m.clearedmajor_detail_tags = true
}

// MajorDetailTagsCleared reports if the "major_detail_tags" edge to the MajorDetailTag entity was cleared.
func (m *MajorDetailMutation) MajorDetailTagsCleared() bool {
	return m.clearedmajor_detail_tags
}

// RemoveMajorDetailTagIDs removes the "major_detail_tags" edge to the MajorDetailTag entity by IDs.
func (m *MajorDetailMutation) RemoveMajorDetailTagIDs(ids ...int) {
	if m.removedmajor_detail_tags == nil {
		m.removedmajor_detail_tags = make(map[int]struct{})
	}
	for i := range ids {
		m.removedmajor_detail_tags[ids[i]] = struct{}{}
	}
}

// RemovedMajorDetailTags returns the removed IDs of the "major_detail_tags" edge to the MajorDetailTag entity.
func (m *MajorDetailMutation) RemovedMajorDetailTagsIDs() (ids []int) {
	for id := range m.removedmajor_detail_tags {
		ids = append(ids, id)
	}
	return
}

// MajorDetailTagsIDs returns the "major_detail_tags" edge IDs in the mutation.
func (m *MajorDetailMutation) MajorDetailTagsIDs() (ids []int) {
	for id := range m.major_detail_tags {
		ids = append(ids, id)
	}
	return
}

// ResetMajorDetailTags resets all changes to the "major_detail_tags" edge.
func (m *MajorDetailMutation) ResetMajorDetailTags() {
	m.major_detail_tags = nil
	m.clearedmajor_detail_tags = false
	m.removedmajor_detail_tags = nil
}

// SetCoverAttachmentID sets the "cover_attachment" edge to the Attachment entity by id.
func (m *MajorDetailMutation) SetCoverAttachmentID(id int) {
	m.cover_attachment = &id
}

// ClearCoverAttachment clears the "cover_attachment" edge to the Attachment entity.
func (m *MajorDetailMutation) ClearCoverAttachment() {
	m.clearedcover_attachment = true
}

// CoverAttachmentCleared reports if the "cover_attachment" edge to the Attachment entity was cleared.
func (m *MajorDetailMutation) CoverAttachmentCleared() bool {
	return m.CoverImgIDCleared() || m.clearedcover_attachment
}

// CoverAttachmentID returns the "cover_attachment" edge ID in the mutation.
func (m *MajorDetailMutation) CoverAttachmentID() (id int, exists bool) {
	if m.cover_attachment != nil {
		return *m.cover_attachment, true
	}
	return
}

// CoverAttachmentIDs returns the "cover_attachment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CoverAttachmentID instead. It exists only for internal usage by the builders.
func (m *MajorDetailMutation) CoverAttachmentIDs() (ids []int) {
	if id := m.cover_attachment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCoverAttachment resets all changes to the "cover_attachment" edge.
func (m *MajorDetailMutation) ResetCoverAttachment() {
	m.cover_attachment = nil
	m.clearedcover_attachment = false
}

// SetSubjectAttachmentID sets the "subject_attachment" edge to the Attachment entity by id.
func (m *MajorDetailMutation) SetSubjectAttachmentID(id int) {
	m.subject_attachment = &id
}

// ClearSubjectAttachment clears the "subject_attachment" edge to the Attachment entity.
func (m *MajorDetailMutation) ClearSubjectAttachment() {
	m.clearedsubject_attachment = true
}

// SubjectAttachmentCleared reports if the "subject_attachment" edge to the Attachment entity was cleared.
func (m *MajorDetailMutation) SubjectAttachmentCleared() bool {
	return m.SubjectImgIDCleared() || m.clearedsubject_attachment
}

// SubjectAttachmentID returns the "subject_attachment" edge ID in the mutation.
func (m *MajorDetailMutation) SubjectAttachmentID() (id int, exists bool) {
	if m.subject_attachment != nil {
		return *m.subject_attachment, true
	}
	return
}

// SubjectAttachmentIDs returns the "subject_attachment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SubjectAttachmentID instead. It exists only for internal usage by the builders.
func (m *MajorDetailMutation) SubjectAttachmentIDs() (ids []int) {
	if id := m.subject_attachment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubjectAttachment resets all changes to the "subject_attachment" edge.
func (m *MajorDetailMutation) ResetSubjectAttachment() {
	m.subject_attachment = nil
	m.clearedsubject_attachment = false
}

// AddTeacherAttachmentIDs adds the "teacher_attachments" edge to the Attachment entity by ids.
func (m *MajorDetailMutation) AddTeacherAttachmentIDs(ids ...int) {
	if m.teacher_attachments == nil {
		m.teacher_attachments = make(map[int]struct{})
	}
	for i := range ids {
		m.teacher_attachments[ids[i]] = struct{}{}
	}
}

// ClearTeacherAttachments clears the "teacher_attachments" edge to the Attachment entity.
func (m *MajorDetailMutation) ClearTeacherAttachments() {
	m.clearedteacher_attachments = true
}

// TeacherAttachmentsCleared reports if the "teacher_attachments" edge to the Attachment entity was cleared.
func (m *MajorDetailMutation) TeacherAttachmentsCleared() bool {
	return m.clearedteacher_attachments
}

// RemoveTeacherAttachmentIDs removes the "teacher_attachments" edge to the Attachment entity by IDs.
func (m *MajorDetailMutation) RemoveTeacherAttachmentIDs(ids ...int) {
	if m.removedteacher_attachments == nil {
		m.removedteacher_attachments = make(map[int]struct{})
	}
	for i := range ids {
		m.removedteacher_attachments[ids[i]] = struct{}{}
	}
}

// RemovedTeacherAttachments returns the removed IDs of the "teacher_attachments" edge to the Attachment entity.
func (m *MajorDetailMutation) RemovedTeacherAttachmentsIDs() (ids []int) {
	for id := range m.removedteacher_attachments {
		ids = append(ids, id)
	}
	return
}

// TeacherAttachmentsIDs returns the "teacher_attachments" edge IDs in the mutation.
func (m *MajorDetailMutation) TeacherAttachmentsIDs() (ids []int) {
	for id := range m.teacher_attachments {
		ids = append(ids, id)
	}
	return
}

// ResetTeacherAttachments resets all changes to the "teacher_attachments" edge.
func (m *MajorDetailMutation) ResetTeacherAttachments() {
	m.teacher_attachments = nil
	m.clearedteacher_attachments = false
	m.removedteacher_attachments = nil
}

// AddServiceAttachmentIDs adds the "service_attachments" edge to the Attachment entity by ids.
func (m *MajorDetailMutation) AddServiceAttachmentIDs(ids ...int) {
	if m.service_attachments == nil {
		m.service_attachments = make(map[int]struct{})
	}
	for i := range ids {
		m.service_attachments[ids[i]] = struct{}{}
	}
}

// ClearServiceAttachments clears the "service_attachments" edge to the Attachment entity.
func (m *MajorDetailMutation) ClearServiceAttachments() {
	m.clearedservice_attachments = true
}

// ServiceAttachmentsCleared reports if the "service_attachments" edge to the Attachment entity was cleared.
func (m *MajorDetailMutation) ServiceAttachmentsCleared() bool {
	return m.clearedservice_attachments
}

// RemoveServiceAttachmentIDs removes the "service_attachments" edge to the Attachment entity by IDs.
func (m *MajorDetailMutation) RemoveServiceAttachmentIDs(ids ...int) {
	if m.removedservice_attachments == nil {
		m.removedservice_attachments = make(map[int]struct{})
	}
	for i := range ids {
		m.removedservice_attachments[ids[i]] = struct{}{}
	}
}

// RemovedServiceAttachments returns the removed IDs of the "service_attachments" edge to the Attachment entity.
func (m *MajorDetailMutation) RemovedServiceAttachmentsIDs() (ids []int) {
	for id := range m.removedservice_attachments {
		ids = append(ids, id)
	}
	return
}

// ServiceAttachmentsIDs returns the "service_attachments" edge IDs in the mutation.
func (m *MajorDetailMutation) ServiceAttachmentsIDs() (ids []int) {
	for id := range m.service_attachments {
		ids = append(ids, id)
	}
	return
}

// ResetServiceAttachments resets all changes to the "service_attachments" edge.
func (m *MajorDetailMutation) ResetServiceAttachments() {
	m.service_attachments = nil
	m.clearedservice_attachments = false
	m.removedservice_attachments = nil
}

// ClearMajor clears the "major" edge to the Major entity.
func (m *MajorDetailMutation) ClearMajor() {
	m.clearedmajor = true
}

// MajorCleared reports if the "major" edge to the Major entity was cleared.
func (m *MajorDetailMutation) MajorCleared() bool {
	return m.MajorIDCleared() || m.clearedmajor
}

// MajorIDs returns the "major" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MajorID instead. It exists only for internal usage by the builders.
func (m *MajorDetailMutation) MajorIDs() (ids []int) {
	if id := m.major; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMajor resets all changes to the "major" edge.
func (m *MajorDetailMutation) ResetMajor() {
	m.major = nil
	m.clearedmajor = false
}

// Op returns the operation name.
func (m *MajorDetailMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (MajorDetail).
func (m *MajorDetailMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MajorDetailMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.uuid != nil {
		fields = append(fields, majordetail.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, majordetail.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, majordetail.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, majordetail.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, majordetail.FieldName)
	}
	if m.desc != nil {
		fields = append(fields, majordetail.FieldDesc)
	}
	if m.subject_count != nil {
		fields = append(fields, majordetail.FieldSubjectCount)
	}
	if m.star != nil {
		fields = append(fields, majordetail.FieldStar)
	}
	if m.pass_rate != nil {
		fields = append(fields, majordetail.FieldPassRate)
	}
	if m.student_count != nil {
		fields = append(fields, majordetail.FieldStudentCount)
	}
	if m.study_duration != nil {
		fields = append(fields, majordetail.FieldStudyDuration)
	}
	if m.major != nil {
		fields = append(fields, majordetail.FieldMajorID)
	}
	if m.cover_attachment != nil {
		fields = append(fields, majordetail.FieldCoverImgID)
	}
	if m.subject_attachment != nil {
		fields = append(fields, majordetail.FieldSubjectImgID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MajorDetailMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case majordetail.FieldUUID:
		return m.UUID()
	case majordetail.FieldCreatedAt:
		return m.CreatedAt()
	case majordetail.FieldUpdatedAt:
		return m.UpdatedAt()
	case majordetail.FieldDeletedAt:
		return m.DeletedAt()
	case majordetail.FieldName:
		return m.Name()
	case majordetail.FieldDesc:
		return m.Desc()
	case majordetail.FieldSubjectCount:
		return m.SubjectCount()
	case majordetail.FieldStar:
		return m.Star()
	case majordetail.FieldPassRate:
		return m.PassRate()
	case majordetail.FieldStudentCount:
		return m.StudentCount()
	case majordetail.FieldStudyDuration:
		return m.StudyDuration()
	case majordetail.FieldMajorID:
		return m.MajorID()
	case majordetail.FieldCoverImgID:
		return m.CoverImgID()
	case majordetail.FieldSubjectImgID:
		return m.SubjectImgID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MajorDetailMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case majordetail.FieldUUID:
		return m.OldUUID(ctx)
	case majordetail.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case majordetail.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case majordetail.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case majordetail.FieldName:
		return m.OldName(ctx)
	case majordetail.FieldDesc:
		return m.OldDesc(ctx)
	case majordetail.FieldSubjectCount:
		return m.OldSubjectCount(ctx)
	case majordetail.FieldStar:
		return m.OldStar(ctx)
	case majordetail.FieldPassRate:
		return m.OldPassRate(ctx)
	case majordetail.FieldStudentCount:
		return m.OldStudentCount(ctx)
	case majordetail.FieldStudyDuration:
		return m.OldStudyDuration(ctx)
	case majordetail.FieldMajorID:
		return m.OldMajorID(ctx)
	case majordetail.FieldCoverImgID:
		return m.OldCoverImgID(ctx)
	case majordetail.FieldSubjectImgID:
		return m.OldSubjectImgID(ctx)
	}
	return nil, fmt.Errorf("unknown MajorDetail field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MajorDetailMutation) SetField(name string, value ent.Value) error {
	switch name {
	case majordetail.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case majordetail.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case majordetail.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case majordetail.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case majordetail.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case majordetail.FieldDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	case majordetail.FieldSubjectCount:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubjectCount(v)
		return nil
	case majordetail.FieldStar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStar(v)
		return nil
	case majordetail.FieldPassRate:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassRate(v)
		return nil
	case majordetail.FieldStudentCount:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStudentCount(v)
		return nil
	case majordetail.FieldStudyDuration:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStudyDuration(v)
		return nil
	case majordetail.FieldMajorID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMajorID(v)
		return nil
	case majordetail.FieldCoverImgID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoverImgID(v)
		return nil
	case majordetail.FieldSubjectImgID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubjectImgID(v)
		return nil
	}
	return fmt.Errorf("unknown MajorDetail field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MajorDetailMutation) AddedFields() []string {
	var fields []string
	if m.addsubject_count != nil {
		fields = append(fields, majordetail.FieldSubjectCount)
	}
	if m.addpass_rate != nil {
		fields = append(fields, majordetail.FieldPassRate)
	}
	if m.addstudent_count != nil {
		fields = append(fields, majordetail.FieldStudentCount)
	}
	if m.addstudy_duration != nil {
		fields = append(fields, majordetail.FieldStudyDuration)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MajorDetailMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case majordetail.FieldSubjectCount:
		return m.AddedSubjectCount()
	case majordetail.FieldPassRate:
		return m.AddedPassRate()
	case majordetail.FieldStudentCount:
		return m.AddedStudentCount()
	case majordetail.FieldStudyDuration:
		return m.AddedStudyDuration()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MajorDetailMutation) AddField(name string, value ent.Value) error {
	switch name {
	case majordetail.FieldSubjectCount:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSubjectCount(v)
		return nil
	case majordetail.FieldPassRate:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPassRate(v)
		return nil
	case majordetail.FieldStudentCount:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStudentCount(v)
		return nil
	case majordetail.FieldStudyDuration:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStudyDuration(v)
		return nil
	}
	return fmt.Errorf("unknown MajorDetail numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MajorDetailMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(majordetail.FieldCreatedAt) {
		fields = append(fields, majordetail.FieldCreatedAt)
	}
	if m.FieldCleared(majordetail.FieldUpdatedAt) {
		fields = append(fields, majordetail.FieldUpdatedAt)
	}
	if m.FieldCleared(majordetail.FieldDeletedAt) {
		fields = append(fields, majordetail.FieldDeletedAt)
	}
	if m.FieldCleared(majordetail.FieldDesc) {
		fields = append(fields, majordetail.FieldDesc)
	}
	if m.FieldCleared(majordetail.FieldMajorID) {
		fields = append(fields, majordetail.FieldMajorID)
	}
	if m.FieldCleared(majordetail.FieldCoverImgID) {
		fields = append(fields, majordetail.FieldCoverImgID)
	}
	if m.FieldCleared(majordetail.FieldSubjectImgID) {
		fields = append(fields, majordetail.FieldSubjectImgID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MajorDetailMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MajorDetailMutation) ClearField(name string) error {
	switch name {
	case majordetail.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case majordetail.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case majordetail.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case majordetail.FieldDesc:
		m.ClearDesc()
		return nil
	case majordetail.FieldMajorID:
		m.ClearMajorID()
		return nil
	case majordetail.FieldCoverImgID:
		m.ClearCoverImgID()
		return nil
	case majordetail.FieldSubjectImgID:
		m.ClearSubjectImgID()
		return nil
	}
	return fmt.Errorf("unknown MajorDetail nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MajorDetailMutation) ResetField(name string) error {
	switch name {
	case majordetail.FieldUUID:
		m.ResetUUID()
		return nil
	case majordetail.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case majordetail.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case majordetail.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case majordetail.FieldName:
		m.ResetName()
		return nil
	case majordetail.FieldDesc:
		m.ResetDesc()
		return nil
	case majordetail.FieldSubjectCount:
		m.ResetSubjectCount()
		return nil
	case majordetail.FieldStar:
		m.ResetStar()
		return nil
	case majordetail.FieldPassRate:
		m.ResetPassRate()
		return nil
	case majordetail.FieldStudentCount:
		m.ResetStudentCount()
		return nil
	case majordetail.FieldStudyDuration:
		m.ResetStudyDuration()
		return nil
	case majordetail.FieldMajorID:
		m.ResetMajorID()
		return nil
	case majordetail.FieldCoverImgID:
		m.ResetCoverImgID()
		return nil
	case majordetail.FieldSubjectImgID:
		m.ResetSubjectImgID()
		return nil
	}
	return fmt.Errorf("unknown MajorDetail field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MajorDetailMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.major_detail_tags != nil {
		edges = append(edges, majordetail.EdgeMajorDetailTags)
	}
	if m.cover_attachment != nil {
		edges = append(edges, majordetail.EdgeCoverAttachment)
	}
	if m.subject_attachment != nil {
		edges = append(edges, majordetail.EdgeSubjectAttachment)
	}
	if m.teacher_attachments != nil {
		edges = append(edges, majordetail.EdgeTeacherAttachments)
	}
	if m.service_attachments != nil {
		edges = append(edges, majordetail.EdgeServiceAttachments)
	}
	if m.major != nil {
		edges = append(edges, majordetail.EdgeMajor)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MajorDetailMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case majordetail.EdgeMajorDetailTags:
		ids := make([]ent.Value, 0, len(m.major_detail_tags))
		for id := range m.major_detail_tags {
			ids = append(ids, id)
		}
		return ids
	case majordetail.EdgeCoverAttachment:
		if id := m.cover_attachment; id != nil {
			return []ent.Value{*id}
		}
	case majordetail.EdgeSubjectAttachment:
		if id := m.subject_attachment; id != nil {
			return []ent.Value{*id}
		}
	case majordetail.EdgeTeacherAttachments:
		ids := make([]ent.Value, 0, len(m.teacher_attachments))
		for id := range m.teacher_attachments {
			ids = append(ids, id)
		}
		return ids
	case majordetail.EdgeServiceAttachments:
		ids := make([]ent.Value, 0, len(m.service_attachments))
		for id := range m.service_attachments {
			ids = append(ids, id)
		}
		return ids
	case majordetail.EdgeMajor:
		if id := m.major; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MajorDetailMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedmajor_detail_tags != nil {
		edges = append(edges, majordetail.EdgeMajorDetailTags)
	}
	if m.removedteacher_attachments != nil {
		edges = append(edges, majordetail.EdgeTeacherAttachments)
	}
	if m.removedservice_attachments != nil {
		edges = append(edges, majordetail.EdgeServiceAttachments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MajorDetailMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case majordetail.EdgeMajorDetailTags:
		ids := make([]ent.Value, 0, len(m.removedmajor_detail_tags))
		for id := range m.removedmajor_detail_tags {
			ids = append(ids, id)
		}
		return ids
	case majordetail.EdgeTeacherAttachments:
		ids := make([]ent.Value, 0, len(m.removedteacher_attachments))
		for id := range m.removedteacher_attachments {
			ids = append(ids, id)
		}
		return ids
	case majordetail.EdgeServiceAttachments:
		ids := make([]ent.Value, 0, len(m.removedservice_attachments))
		for id := range m.removedservice_attachments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MajorDetailMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedmajor_detail_tags {
		edges = append(edges, majordetail.EdgeMajorDetailTags)
	}
	if m.clearedcover_attachment {
		edges = append(edges, majordetail.EdgeCoverAttachment)
	}
	if m.clearedsubject_attachment {
		edges = append(edges, majordetail.EdgeSubjectAttachment)
	}
	if m.clearedteacher_attachments {
		edges = append(edges, majordetail.EdgeTeacherAttachments)
	}
	if m.clearedservice_attachments {
		edges = append(edges, majordetail.EdgeServiceAttachments)
	}
	if m.clearedmajor {
		edges = append(edges, majordetail.EdgeMajor)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MajorDetailMutation) EdgeCleared(name string) bool {
	switch name {
	case majordetail.EdgeMajorDetailTags:
		return m.clearedmajor_detail_tags
	case majordetail.EdgeCoverAttachment:
		return m.clearedcover_attachment
	case majordetail.EdgeSubjectAttachment:
		return m.clearedsubject_attachment
	case majordetail.EdgeTeacherAttachments:
		return m.clearedteacher_attachments
	case majordetail.EdgeServiceAttachments:
		return m.clearedservice_attachments
	case majordetail.EdgeMajor:
		return m.clearedmajor
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MajorDetailMutation) ClearEdge(name string) error {
	switch name {
	case majordetail.EdgeCoverAttachment:
		m.ClearCoverAttachment()
		return nil
	case majordetail.EdgeSubjectAttachment:
		m.ClearSubjectAttachment()
		return nil
	case majordetail.EdgeMajor:
		m.ClearMajor()
		return nil
	}
	return fmt.Errorf("unknown MajorDetail unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MajorDetailMutation) ResetEdge(name string) error {
	switch name {
	case majordetail.EdgeMajorDetailTags:
		m.ResetMajorDetailTags()
		return nil
	case majordetail.EdgeCoverAttachment:
		m.ResetCoverAttachment()
		return nil
	case majordetail.EdgeSubjectAttachment:
		m.ResetSubjectAttachment()
		return nil
	case majordetail.EdgeTeacherAttachments:
		m.ResetTeacherAttachments()
		return nil
	case majordetail.EdgeServiceAttachments:
		m.ResetServiceAttachments()
		return nil
	case majordetail.EdgeMajor:
		m.ResetMajor()
		return nil
	}
	return fmt.Errorf("unknown MajorDetail edge %s", name)
}

// MajorDetailTagMutation represents an operation that mutates the MajorDetailTag nodes in the graph.
type MajorDetailTagMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	uuid                *string
	created_at          *time.Time
	updated_at          *time.Time
	deleted_at          *time.Time
	name                *string
	clearedFields       map[string]struct{}
	major_detail        *int
	clearedmajor_detail bool
	done                bool
	oldValue            func(context.Context) (*MajorDetailTag, error)
	predicates          []predicate.MajorDetailTag
}

var _ ent.Mutation = (*MajorDetailTagMutation)(nil)

// majordetailtagOption allows management of the mutation configuration using functional options.
type majordetailtagOption func(*MajorDetailTagMutation)

// newMajorDetailTagMutation creates new mutation for the MajorDetailTag entity.
func newMajorDetailTagMutation(c config, op Op, opts ...majordetailtagOption) *MajorDetailTagMutation {
	m := &MajorDetailTagMutation{
		config:        c,
		op:            op,
		typ:           TypeMajorDetailTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMajorDetailTagID sets the ID field of the mutation.
func withMajorDetailTagID(id int) majordetailtagOption {
	return func(m *MajorDetailTagMutation) {
		var (
			err   error
			once  sync.Once
			value *MajorDetailTag
		)
		m.oldValue = func(ctx context.Context) (*MajorDetailTag, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MajorDetailTag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMajorDetailTag sets the old MajorDetailTag of the mutation.
func withMajorDetailTag(node *MajorDetailTag) majordetailtagOption {
	return func(m *MajorDetailTagMutation) {
		m.oldValue = func(context.Context) (*MajorDetailTag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MajorDetailTagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MajorDetailTagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *MajorDetailTagMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *MajorDetailTagMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *MajorDetailTagMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the MajorDetailTag entity.
// If the MajorDetailTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MajorDetailTagMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *MajorDetailTagMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MajorDetailTagMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MajorDetailTagMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MajorDetailTag entity.
// If the MajorDetailTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MajorDetailTagMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *MajorDetailTagMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[majordetailtag.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *MajorDetailTagMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[majordetailtag.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MajorDetailTagMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, majordetailtag.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MajorDetailTagMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MajorDetailTagMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MajorDetailTag entity.
// If the MajorDetailTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MajorDetailTagMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *MajorDetailTagMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[majordetailtag.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *MajorDetailTagMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[majordetailtag.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MajorDetailTagMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, majordetailtag.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MajorDetailTagMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MajorDetailTagMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the MajorDetailTag entity.
// If the MajorDetailTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MajorDetailTagMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *MajorDetailTagMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[majordetailtag.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *MajorDetailTagMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[majordetailtag.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MajorDetailTagMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, majordetailtag.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *MajorDetailTagMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MajorDetailTagMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the MajorDetailTag entity.
// If the MajorDetailTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MajorDetailTagMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MajorDetailTagMutation) ResetName() {
	m.name = nil
}

// SetMajorDetailID sets the "major_detail_id" field.
func (m *MajorDetailTagMutation) SetMajorDetailID(i int) {
	m.major_detail = &i
}

// MajorDetailID returns the value of the "major_detail_id" field in the mutation.
func (m *MajorDetailTagMutation) MajorDetailID() (r int, exists bool) {
	v := m.major_detail
	if v == nil {
		return
	}
	return *v, true
}

// OldMajorDetailID returns the old "major_detail_id" field's value of the MajorDetailTag entity.
// If the MajorDetailTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MajorDetailTagMutation) OldMajorDetailID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMajorDetailID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMajorDetailID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMajorDetailID: %w", err)
	}
	return oldValue.MajorDetailID, nil
}

// ClearMajorDetailID clears the value of the "major_detail_id" field.
func (m *MajorDetailTagMutation) ClearMajorDetailID() {
	m.major_detail = nil
	m.clearedFields[majordetailtag.FieldMajorDetailID] = struct{}{}
}

// MajorDetailIDCleared returns if the "major_detail_id" field was cleared in this mutation.
func (m *MajorDetailTagMutation) MajorDetailIDCleared() bool {
	_, ok := m.clearedFields[majordetailtag.FieldMajorDetailID]
	return ok
}

// ResetMajorDetailID resets all changes to the "major_detail_id" field.
func (m *MajorDetailTagMutation) ResetMajorDetailID() {
	m.major_detail = nil
	delete(m.clearedFields, majordetailtag.FieldMajorDetailID)
}

// ClearMajorDetail clears the "major_detail" edge to the MajorDetail entity.
func (m *MajorDetailTagMutation) ClearMajorDetail() {
	m.clearedmajor_detail = true
}

// MajorDetailCleared reports if the "major_detail" edge to the MajorDetail entity was cleared.
func (m *MajorDetailTagMutation) MajorDetailCleared() bool {
	return m.MajorDetailIDCleared() || m.clearedmajor_detail
}

// MajorDetailIDs returns the "major_detail" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MajorDetailID instead. It exists only for internal usage by the builders.
func (m *MajorDetailTagMutation) MajorDetailIDs() (ids []int) {
	if id := m.major_detail; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMajorDetail resets all changes to the "major_detail" edge.
func (m *MajorDetailTagMutation) ResetMajorDetail() {
	m.major_detail = nil
	m.clearedmajor_detail = false
}

// Op returns the operation name.
func (m *MajorDetailTagMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (MajorDetailTag).
func (m *MajorDetailTagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MajorDetailTagMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.uuid != nil {
		fields = append(fields, majordetailtag.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, majordetailtag.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, majordetailtag.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, majordetailtag.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, majordetailtag.FieldName)
	}
	if m.major_detail != nil {
		fields = append(fields, majordetailtag.FieldMajorDetailID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MajorDetailTagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case majordetailtag.FieldUUID:
		return m.UUID()
	case majordetailtag.FieldCreatedAt:
		return m.CreatedAt()
	case majordetailtag.FieldUpdatedAt:
		return m.UpdatedAt()
	case majordetailtag.FieldDeletedAt:
		return m.DeletedAt()
	case majordetailtag.FieldName:
		return m.Name()
	case majordetailtag.FieldMajorDetailID:
		return m.MajorDetailID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MajorDetailTagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case majordetailtag.FieldUUID:
		return m.OldUUID(ctx)
	case majordetailtag.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case majordetailtag.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case majordetailtag.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case majordetailtag.FieldName:
		return m.OldName(ctx)
	case majordetailtag.FieldMajorDetailID:
		return m.OldMajorDetailID(ctx)
	}
	return nil, fmt.Errorf("unknown MajorDetailTag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MajorDetailTagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case majordetailtag.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case majordetailtag.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case majordetailtag.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case majordetailtag.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case majordetailtag.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case majordetailtag.FieldMajorDetailID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMajorDetailID(v)
		return nil
	}
	return fmt.Errorf("unknown MajorDetailTag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MajorDetailTagMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MajorDetailTagMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MajorDetailTagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown MajorDetailTag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MajorDetailTagMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(majordetailtag.FieldCreatedAt) {
		fields = append(fields, majordetailtag.FieldCreatedAt)
	}
	if m.FieldCleared(majordetailtag.FieldUpdatedAt) {
		fields = append(fields, majordetailtag.FieldUpdatedAt)
	}
	if m.FieldCleared(majordetailtag.FieldDeletedAt) {
		fields = append(fields, majordetailtag.FieldDeletedAt)
	}
	if m.FieldCleared(majordetailtag.FieldMajorDetailID) {
		fields = append(fields, majordetailtag.FieldMajorDetailID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MajorDetailTagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MajorDetailTagMutation) ClearField(name string) error {
	switch name {
	case majordetailtag.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case majordetailtag.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case majordetailtag.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case majordetailtag.FieldMajorDetailID:
		m.ClearMajorDetailID()
		return nil
	}
	return fmt.Errorf("unknown MajorDetailTag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MajorDetailTagMutation) ResetField(name string) error {
	switch name {
	case majordetailtag.FieldUUID:
		m.ResetUUID()
		return nil
	case majordetailtag.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case majordetailtag.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case majordetailtag.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case majordetailtag.FieldName:
		m.ResetName()
		return nil
	case majordetailtag.FieldMajorDetailID:
		m.ResetMajorDetailID()
		return nil
	}
	return fmt.Errorf("unknown MajorDetailTag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MajorDetailTagMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.major_detail != nil {
		edges = append(edges, majordetailtag.EdgeMajorDetail)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MajorDetailTagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case majordetailtag.EdgeMajorDetail:
		if id := m.major_detail; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MajorDetailTagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MajorDetailTagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MajorDetailTagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmajor_detail {
		edges = append(edges, majordetailtag.EdgeMajorDetail)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MajorDetailTagMutation) EdgeCleared(name string) bool {
	switch name {
	case majordetailtag.EdgeMajorDetail:
		return m.clearedmajor_detail
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MajorDetailTagMutation) ClearEdge(name string) error {
	switch name {
	case majordetailtag.EdgeMajorDetail:
		m.ClearMajorDetail()
		return nil
	}
	return fmt.Errorf("unknown MajorDetailTag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MajorDetailTagMutation) ResetEdge(name string) error {
	switch name {
	case majordetailtag.EdgeMajorDetail:
		m.ResetMajorDetail()
		return nil
	}
	return fmt.Errorf("unknown MajorDetailTag edge %s", name)
}

// MakeUserQuestionRecordMutation represents an operation that mutates the MakeUserQuestionRecord nodes in the graph.
type MakeUserQuestionRecordMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	uuid                  *string
	created_at            *time.Time
	updated_at            *time.Time
	deleted_at            *time.Time
	user_id               *int
	adduser_id            *int
	question_bank_id      *int
	addquestion_bank_id   *int
	exam_question_type    *int
	addexam_question_type *int
	clearedFields         map[string]struct{}
	section               *int
	clearedsection        bool
	exam_paper            *int
	clearedexam_paper     bool
	done                  bool
	oldValue              func(context.Context) (*MakeUserQuestionRecord, error)
	predicates            []predicate.MakeUserQuestionRecord
}

var _ ent.Mutation = (*MakeUserQuestionRecordMutation)(nil)

// makeuserquestionrecordOption allows management of the mutation configuration using functional options.
type makeuserquestionrecordOption func(*MakeUserQuestionRecordMutation)

// newMakeUserQuestionRecordMutation creates new mutation for the MakeUserQuestionRecord entity.
func newMakeUserQuestionRecordMutation(c config, op Op, opts ...makeuserquestionrecordOption) *MakeUserQuestionRecordMutation {
	m := &MakeUserQuestionRecordMutation{
		config:        c,
		op:            op,
		typ:           TypeMakeUserQuestionRecord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMakeUserQuestionRecordID sets the ID field of the mutation.
func withMakeUserQuestionRecordID(id int) makeuserquestionrecordOption {
	return func(m *MakeUserQuestionRecordMutation) {
		var (
			err   error
			once  sync.Once
			value *MakeUserQuestionRecord
		)
		m.oldValue = func(ctx context.Context) (*MakeUserQuestionRecord, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MakeUserQuestionRecord.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMakeUserQuestionRecord sets the old MakeUserQuestionRecord of the mutation.
func withMakeUserQuestionRecord(node *MakeUserQuestionRecord) makeuserquestionrecordOption {
	return func(m *MakeUserQuestionRecordMutation) {
		m.oldValue = func(context.Context) (*MakeUserQuestionRecord, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MakeUserQuestionRecordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MakeUserQuestionRecordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *MakeUserQuestionRecordMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *MakeUserQuestionRecordMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *MakeUserQuestionRecordMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the MakeUserQuestionRecord entity.
// If the MakeUserQuestionRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MakeUserQuestionRecordMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *MakeUserQuestionRecordMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MakeUserQuestionRecordMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MakeUserQuestionRecordMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MakeUserQuestionRecord entity.
// If the MakeUserQuestionRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MakeUserQuestionRecordMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *MakeUserQuestionRecordMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[makeuserquestionrecord.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *MakeUserQuestionRecordMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[makeuserquestionrecord.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MakeUserQuestionRecordMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, makeuserquestionrecord.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MakeUserQuestionRecordMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MakeUserQuestionRecordMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MakeUserQuestionRecord entity.
// If the MakeUserQuestionRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MakeUserQuestionRecordMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *MakeUserQuestionRecordMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[makeuserquestionrecord.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *MakeUserQuestionRecordMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[makeuserquestionrecord.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MakeUserQuestionRecordMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, makeuserquestionrecord.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MakeUserQuestionRecordMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MakeUserQuestionRecordMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the MakeUserQuestionRecord entity.
// If the MakeUserQuestionRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MakeUserQuestionRecordMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *MakeUserQuestionRecordMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[makeuserquestionrecord.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *MakeUserQuestionRecordMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[makeuserquestionrecord.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MakeUserQuestionRecordMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, makeuserquestionrecord.FieldDeletedAt)
}

// SetUserID sets the "user_id" field.
func (m *MakeUserQuestionRecordMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *MakeUserQuestionRecordMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the MakeUserQuestionRecord entity.
// If the MakeUserQuestionRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MakeUserQuestionRecordMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *MakeUserQuestionRecordMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *MakeUserQuestionRecordMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearUserID clears the value of the "user_id" field.
func (m *MakeUserQuestionRecordMutation) ClearUserID() {
	m.user_id = nil
	m.adduser_id = nil
	m.clearedFields[makeuserquestionrecord.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *MakeUserQuestionRecordMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[makeuserquestionrecord.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *MakeUserQuestionRecordMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
	delete(m.clearedFields, makeuserquestionrecord.FieldUserID)
}

// SetExamID sets the "exam_id" field.
func (m *MakeUserQuestionRecordMutation) SetExamID(i int) {
	m.exam_paper = &i
}

// ExamID returns the value of the "exam_id" field in the mutation.
func (m *MakeUserQuestionRecordMutation) ExamID() (r int, exists bool) {
	v := m.exam_paper
	if v == nil {
		return
	}
	return *v, true
}

// OldExamID returns the old "exam_id" field's value of the MakeUserQuestionRecord entity.
// If the MakeUserQuestionRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MakeUserQuestionRecordMutation) OldExamID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExamID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExamID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamID: %w", err)
	}
	return oldValue.ExamID, nil
}

// ClearExamID clears the value of the "exam_id" field.
func (m *MakeUserQuestionRecordMutation) ClearExamID() {
	m.exam_paper = nil
	m.clearedFields[makeuserquestionrecord.FieldExamID] = struct{}{}
}

// ExamIDCleared returns if the "exam_id" field was cleared in this mutation.
func (m *MakeUserQuestionRecordMutation) ExamIDCleared() bool {
	_, ok := m.clearedFields[makeuserquestionrecord.FieldExamID]
	return ok
}

// ResetExamID resets all changes to the "exam_id" field.
func (m *MakeUserQuestionRecordMutation) ResetExamID() {
	m.exam_paper = nil
	delete(m.clearedFields, makeuserquestionrecord.FieldExamID)
}

// SetSecID sets the "sec_id" field.
func (m *MakeUserQuestionRecordMutation) SetSecID(i int) {
	m.section = &i
}

// SecID returns the value of the "sec_id" field in the mutation.
func (m *MakeUserQuestionRecordMutation) SecID() (r int, exists bool) {
	v := m.section
	if v == nil {
		return
	}
	return *v, true
}

// OldSecID returns the old "sec_id" field's value of the MakeUserQuestionRecord entity.
// If the MakeUserQuestionRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MakeUserQuestionRecordMutation) OldSecID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSecID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSecID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecID: %w", err)
	}
	return oldValue.SecID, nil
}

// ClearSecID clears the value of the "sec_id" field.
func (m *MakeUserQuestionRecordMutation) ClearSecID() {
	m.section = nil
	m.clearedFields[makeuserquestionrecord.FieldSecID] = struct{}{}
}

// SecIDCleared returns if the "sec_id" field was cleared in this mutation.
func (m *MakeUserQuestionRecordMutation) SecIDCleared() bool {
	_, ok := m.clearedFields[makeuserquestionrecord.FieldSecID]
	return ok
}

// ResetSecID resets all changes to the "sec_id" field.
func (m *MakeUserQuestionRecordMutation) ResetSecID() {
	m.section = nil
	delete(m.clearedFields, makeuserquestionrecord.FieldSecID)
}

// SetQuestionBankID sets the "question_bank_id" field.
func (m *MakeUserQuestionRecordMutation) SetQuestionBankID(i int) {
	m.question_bank_id = &i
	m.addquestion_bank_id = nil
}

// QuestionBankID returns the value of the "question_bank_id" field in the mutation.
func (m *MakeUserQuestionRecordMutation) QuestionBankID() (r int, exists bool) {
	v := m.question_bank_id
	if v == nil {
		return
	}
	return *v, true
}

// OldQuestionBankID returns the old "question_bank_id" field's value of the MakeUserQuestionRecord entity.
// If the MakeUserQuestionRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MakeUserQuestionRecordMutation) OldQuestionBankID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldQuestionBankID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldQuestionBankID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuestionBankID: %w", err)
	}
	return oldValue.QuestionBankID, nil
}

// AddQuestionBankID adds i to the "question_bank_id" field.
func (m *MakeUserQuestionRecordMutation) AddQuestionBankID(i int) {
	if m.addquestion_bank_id != nil {
		*m.addquestion_bank_id += i
	} else {
		m.addquestion_bank_id = &i
	}
}

// AddedQuestionBankID returns the value that was added to the "question_bank_id" field in this mutation.
func (m *MakeUserQuestionRecordMutation) AddedQuestionBankID() (r int, exists bool) {
	v := m.addquestion_bank_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearQuestionBankID clears the value of the "question_bank_id" field.
func (m *MakeUserQuestionRecordMutation) ClearQuestionBankID() {
	m.question_bank_id = nil
	m.addquestion_bank_id = nil
	m.clearedFields[makeuserquestionrecord.FieldQuestionBankID] = struct{}{}
}

// QuestionBankIDCleared returns if the "question_bank_id" field was cleared in this mutation.
func (m *MakeUserQuestionRecordMutation) QuestionBankIDCleared() bool {
	_, ok := m.clearedFields[makeuserquestionrecord.FieldQuestionBankID]
	return ok
}

// ResetQuestionBankID resets all changes to the "question_bank_id" field.
func (m *MakeUserQuestionRecordMutation) ResetQuestionBankID() {
	m.question_bank_id = nil
	m.addquestion_bank_id = nil
	delete(m.clearedFields, makeuserquestionrecord.FieldQuestionBankID)
}

// SetExamQuestionType sets the "exam_question_type" field.
func (m *MakeUserQuestionRecordMutation) SetExamQuestionType(i int) {
	m.exam_question_type = &i
	m.addexam_question_type = nil
}

// ExamQuestionType returns the value of the "exam_question_type" field in the mutation.
func (m *MakeUserQuestionRecordMutation) ExamQuestionType() (r int, exists bool) {
	v := m.exam_question_type
	if v == nil {
		return
	}
	return *v, true
}

// OldExamQuestionType returns the old "exam_question_type" field's value of the MakeUserQuestionRecord entity.
// If the MakeUserQuestionRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MakeUserQuestionRecordMutation) OldExamQuestionType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExamQuestionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExamQuestionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamQuestionType: %w", err)
	}
	return oldValue.ExamQuestionType, nil
}

// AddExamQuestionType adds i to the "exam_question_type" field.
func (m *MakeUserQuestionRecordMutation) AddExamQuestionType(i int) {
	if m.addexam_question_type != nil {
		*m.addexam_question_type += i
	} else {
		m.addexam_question_type = &i
	}
}

// AddedExamQuestionType returns the value that was added to the "exam_question_type" field in this mutation.
func (m *MakeUserQuestionRecordMutation) AddedExamQuestionType() (r int, exists bool) {
	v := m.addexam_question_type
	if v == nil {
		return
	}
	return *v, true
}

// ClearExamQuestionType clears the value of the "exam_question_type" field.
func (m *MakeUserQuestionRecordMutation) ClearExamQuestionType() {
	m.exam_question_type = nil
	m.addexam_question_type = nil
	m.clearedFields[makeuserquestionrecord.FieldExamQuestionType] = struct{}{}
}

// ExamQuestionTypeCleared returns if the "exam_question_type" field was cleared in this mutation.
func (m *MakeUserQuestionRecordMutation) ExamQuestionTypeCleared() bool {
	_, ok := m.clearedFields[makeuserquestionrecord.FieldExamQuestionType]
	return ok
}

// ResetExamQuestionType resets all changes to the "exam_question_type" field.
func (m *MakeUserQuestionRecordMutation) ResetExamQuestionType() {
	m.exam_question_type = nil
	m.addexam_question_type = nil
	delete(m.clearedFields, makeuserquestionrecord.FieldExamQuestionType)
}

// SetSectionID sets the "section" edge to the TkSection entity by id.
func (m *MakeUserQuestionRecordMutation) SetSectionID(id int) {
	m.section = &id
}

// ClearSection clears the "section" edge to the TkSection entity.
func (m *MakeUserQuestionRecordMutation) ClearSection() {
	m.clearedsection = true
}

// SectionCleared reports if the "section" edge to the TkSection entity was cleared.
func (m *MakeUserQuestionRecordMutation) SectionCleared() bool {
	return m.SecIDCleared() || m.clearedsection
}

// SectionID returns the "section" edge ID in the mutation.
func (m *MakeUserQuestionRecordMutation) SectionID() (id int, exists bool) {
	if m.section != nil {
		return *m.section, true
	}
	return
}

// SectionIDs returns the "section" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SectionID instead. It exists only for internal usage by the builders.
func (m *MakeUserQuestionRecordMutation) SectionIDs() (ids []int) {
	if id := m.section; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSection resets all changes to the "section" edge.
func (m *MakeUserQuestionRecordMutation) ResetSection() {
	m.section = nil
	m.clearedsection = false
}

// SetExamPaperID sets the "exam_paper" edge to the TkExamPaper entity by id.
func (m *MakeUserQuestionRecordMutation) SetExamPaperID(id int) {
	m.exam_paper = &id
}

// ClearExamPaper clears the "exam_paper" edge to the TkExamPaper entity.
func (m *MakeUserQuestionRecordMutation) ClearExamPaper() {
	m.clearedexam_paper = true
}

// ExamPaperCleared reports if the "exam_paper" edge to the TkExamPaper entity was cleared.
func (m *MakeUserQuestionRecordMutation) ExamPaperCleared() bool {
	return m.ExamIDCleared() || m.clearedexam_paper
}

// ExamPaperID returns the "exam_paper" edge ID in the mutation.
func (m *MakeUserQuestionRecordMutation) ExamPaperID() (id int, exists bool) {
	if m.exam_paper != nil {
		return *m.exam_paper, true
	}
	return
}

// ExamPaperIDs returns the "exam_paper" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ExamPaperID instead. It exists only for internal usage by the builders.
func (m *MakeUserQuestionRecordMutation) ExamPaperIDs() (ids []int) {
	if id := m.exam_paper; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExamPaper resets all changes to the "exam_paper" edge.
func (m *MakeUserQuestionRecordMutation) ResetExamPaper() {
	m.exam_paper = nil
	m.clearedexam_paper = false
}

// Op returns the operation name.
func (m *MakeUserQuestionRecordMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (MakeUserQuestionRecord).
func (m *MakeUserQuestionRecordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MakeUserQuestionRecordMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.uuid != nil {
		fields = append(fields, makeuserquestionrecord.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, makeuserquestionrecord.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, makeuserquestionrecord.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, makeuserquestionrecord.FieldDeletedAt)
	}
	if m.user_id != nil {
		fields = append(fields, makeuserquestionrecord.FieldUserID)
	}
	if m.exam_paper != nil {
		fields = append(fields, makeuserquestionrecord.FieldExamID)
	}
	if m.section != nil {
		fields = append(fields, makeuserquestionrecord.FieldSecID)
	}
	if m.question_bank_id != nil {
		fields = append(fields, makeuserquestionrecord.FieldQuestionBankID)
	}
	if m.exam_question_type != nil {
		fields = append(fields, makeuserquestionrecord.FieldExamQuestionType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MakeUserQuestionRecordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case makeuserquestionrecord.FieldUUID:
		return m.UUID()
	case makeuserquestionrecord.FieldCreatedAt:
		return m.CreatedAt()
	case makeuserquestionrecord.FieldUpdatedAt:
		return m.UpdatedAt()
	case makeuserquestionrecord.FieldDeletedAt:
		return m.DeletedAt()
	case makeuserquestionrecord.FieldUserID:
		return m.UserID()
	case makeuserquestionrecord.FieldExamID:
		return m.ExamID()
	case makeuserquestionrecord.FieldSecID:
		return m.SecID()
	case makeuserquestionrecord.FieldQuestionBankID:
		return m.QuestionBankID()
	case makeuserquestionrecord.FieldExamQuestionType:
		return m.ExamQuestionType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MakeUserQuestionRecordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case makeuserquestionrecord.FieldUUID:
		return m.OldUUID(ctx)
	case makeuserquestionrecord.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case makeuserquestionrecord.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case makeuserquestionrecord.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case makeuserquestionrecord.FieldUserID:
		return m.OldUserID(ctx)
	case makeuserquestionrecord.FieldExamID:
		return m.OldExamID(ctx)
	case makeuserquestionrecord.FieldSecID:
		return m.OldSecID(ctx)
	case makeuserquestionrecord.FieldQuestionBankID:
		return m.OldQuestionBankID(ctx)
	case makeuserquestionrecord.FieldExamQuestionType:
		return m.OldExamQuestionType(ctx)
	}
	return nil, fmt.Errorf("unknown MakeUserQuestionRecord field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MakeUserQuestionRecordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case makeuserquestionrecord.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case makeuserquestionrecord.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case makeuserquestionrecord.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case makeuserquestionrecord.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case makeuserquestionrecord.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case makeuserquestionrecord.FieldExamID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamID(v)
		return nil
	case makeuserquestionrecord.FieldSecID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecID(v)
		return nil
	case makeuserquestionrecord.FieldQuestionBankID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuestionBankID(v)
		return nil
	case makeuserquestionrecord.FieldExamQuestionType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamQuestionType(v)
		return nil
	}
	return fmt.Errorf("unknown MakeUserQuestionRecord field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MakeUserQuestionRecordMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, makeuserquestionrecord.FieldUserID)
	}
	if m.addquestion_bank_id != nil {
		fields = append(fields, makeuserquestionrecord.FieldQuestionBankID)
	}
	if m.addexam_question_type != nil {
		fields = append(fields, makeuserquestionrecord.FieldExamQuestionType)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MakeUserQuestionRecordMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case makeuserquestionrecord.FieldUserID:
		return m.AddedUserID()
	case makeuserquestionrecord.FieldQuestionBankID:
		return m.AddedQuestionBankID()
	case makeuserquestionrecord.FieldExamQuestionType:
		return m.AddedExamQuestionType()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MakeUserQuestionRecordMutation) AddField(name string, value ent.Value) error {
	switch name {
	case makeuserquestionrecord.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case makeuserquestionrecord.FieldQuestionBankID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuestionBankID(v)
		return nil
	case makeuserquestionrecord.FieldExamQuestionType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExamQuestionType(v)
		return nil
	}
	return fmt.Errorf("unknown MakeUserQuestionRecord numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MakeUserQuestionRecordMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(makeuserquestionrecord.FieldCreatedAt) {
		fields = append(fields, makeuserquestionrecord.FieldCreatedAt)
	}
	if m.FieldCleared(makeuserquestionrecord.FieldUpdatedAt) {
		fields = append(fields, makeuserquestionrecord.FieldUpdatedAt)
	}
	if m.FieldCleared(makeuserquestionrecord.FieldDeletedAt) {
		fields = append(fields, makeuserquestionrecord.FieldDeletedAt)
	}
	if m.FieldCleared(makeuserquestionrecord.FieldUserID) {
		fields = append(fields, makeuserquestionrecord.FieldUserID)
	}
	if m.FieldCleared(makeuserquestionrecord.FieldExamID) {
		fields = append(fields, makeuserquestionrecord.FieldExamID)
	}
	if m.FieldCleared(makeuserquestionrecord.FieldSecID) {
		fields = append(fields, makeuserquestionrecord.FieldSecID)
	}
	if m.FieldCleared(makeuserquestionrecord.FieldQuestionBankID) {
		fields = append(fields, makeuserquestionrecord.FieldQuestionBankID)
	}
	if m.FieldCleared(makeuserquestionrecord.FieldExamQuestionType) {
		fields = append(fields, makeuserquestionrecord.FieldExamQuestionType)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MakeUserQuestionRecordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MakeUserQuestionRecordMutation) ClearField(name string) error {
	switch name {
	case makeuserquestionrecord.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case makeuserquestionrecord.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case makeuserquestionrecord.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case makeuserquestionrecord.FieldUserID:
		m.ClearUserID()
		return nil
	case makeuserquestionrecord.FieldExamID:
		m.ClearExamID()
		return nil
	case makeuserquestionrecord.FieldSecID:
		m.ClearSecID()
		return nil
	case makeuserquestionrecord.FieldQuestionBankID:
		m.ClearQuestionBankID()
		return nil
	case makeuserquestionrecord.FieldExamQuestionType:
		m.ClearExamQuestionType()
		return nil
	}
	return fmt.Errorf("unknown MakeUserQuestionRecord nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MakeUserQuestionRecordMutation) ResetField(name string) error {
	switch name {
	case makeuserquestionrecord.FieldUUID:
		m.ResetUUID()
		return nil
	case makeuserquestionrecord.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case makeuserquestionrecord.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case makeuserquestionrecord.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case makeuserquestionrecord.FieldUserID:
		m.ResetUserID()
		return nil
	case makeuserquestionrecord.FieldExamID:
		m.ResetExamID()
		return nil
	case makeuserquestionrecord.FieldSecID:
		m.ResetSecID()
		return nil
	case makeuserquestionrecord.FieldQuestionBankID:
		m.ResetQuestionBankID()
		return nil
	case makeuserquestionrecord.FieldExamQuestionType:
		m.ResetExamQuestionType()
		return nil
	}
	return fmt.Errorf("unknown MakeUserQuestionRecord field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MakeUserQuestionRecordMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.section != nil {
		edges = append(edges, makeuserquestionrecord.EdgeSection)
	}
	if m.exam_paper != nil {
		edges = append(edges, makeuserquestionrecord.EdgeExamPaper)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MakeUserQuestionRecordMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case makeuserquestionrecord.EdgeSection:
		if id := m.section; id != nil {
			return []ent.Value{*id}
		}
	case makeuserquestionrecord.EdgeExamPaper:
		if id := m.exam_paper; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MakeUserQuestionRecordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MakeUserQuestionRecordMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MakeUserQuestionRecordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedsection {
		edges = append(edges, makeuserquestionrecord.EdgeSection)
	}
	if m.clearedexam_paper {
		edges = append(edges, makeuserquestionrecord.EdgeExamPaper)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MakeUserQuestionRecordMutation) EdgeCleared(name string) bool {
	switch name {
	case makeuserquestionrecord.EdgeSection:
		return m.clearedsection
	case makeuserquestionrecord.EdgeExamPaper:
		return m.clearedexam_paper
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MakeUserQuestionRecordMutation) ClearEdge(name string) error {
	switch name {
	case makeuserquestionrecord.EdgeSection:
		m.ClearSection()
		return nil
	case makeuserquestionrecord.EdgeExamPaper:
		m.ClearExamPaper()
		return nil
	}
	return fmt.Errorf("unknown MakeUserQuestionRecord unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MakeUserQuestionRecordMutation) ResetEdge(name string) error {
	switch name {
	case makeuserquestionrecord.EdgeSection:
		m.ResetSection()
		return nil
	case makeuserquestionrecord.EdgeExamPaper:
		m.ResetExamPaper()
		return nil
	}
	return fmt.Errorf("unknown MakeUserQuestionRecord edge %s", name)
}

// MessageMutation represents an operation that mutates the Message nodes in the graph.
type MessageMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	uuid                 *string
	created_at           *time.Time
	updated_at           *time.Time
	deleted_at           *time.Time
	name                 *string
	detail               *string
	publish_type         *uint8
	addpublish_type      *uint8
	status               *uint8
	addstatus            *uint8
	publish_status       *uint8
	addpublish_status    *uint8
	auto_publish_at      *time.Time
	clearedFields        map[string]struct{}
	_Message_type        *int
	cleared_Message_type bool
	admin                *int
	clearedadmin         bool
	attachment           *int
	clearedattachment    bool
	course               *int
	clearedcourse        bool
	class                *int
	clearedclass         bool
	users                map[int]struct{}
	removedusers         map[int]struct{}
	clearedusers         bool
	done                 bool
	oldValue             func(context.Context) (*Message, error)
	predicates           []predicate.Message
}

var _ ent.Mutation = (*MessageMutation)(nil)

// messageOption allows management of the mutation configuration using functional options.
type messageOption func(*MessageMutation)

// newMessageMutation creates new mutation for the Message entity.
func newMessageMutation(c config, op Op, opts ...messageOption) *MessageMutation {
	m := &MessageMutation{
		config:        c,
		op:            op,
		typ:           TypeMessage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMessageID sets the ID field of the mutation.
func withMessageID(id int) messageOption {
	return func(m *MessageMutation) {
		var (
			err   error
			once  sync.Once
			value *Message
		)
		m.oldValue = func(ctx context.Context) (*Message, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Message.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMessage sets the old Message of the mutation.
func withMessage(node *Message) messageOption {
	return func(m *MessageMutation) {
		m.oldValue = func(context.Context) (*Message, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MessageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MessageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *MessageMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *MessageMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *MessageMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *MessageMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MessageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MessageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *MessageMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[message.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *MessageMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[message.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MessageMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, message.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MessageMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MessageMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *MessageMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[message.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *MessageMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[message.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MessageMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, message.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MessageMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MessageMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *MessageMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[message.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *MessageMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[message.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MessageMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, message.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *MessageMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MessageMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MessageMutation) ResetName() {
	m.name = nil
}

// SetDetail sets the "detail" field.
func (m *MessageMutation) SetDetail(s string) {
	m.detail = &s
}

// Detail returns the value of the "detail" field in the mutation.
func (m *MessageMutation) Detail() (r string, exists bool) {
	v := m.detail
	if v == nil {
		return
	}
	return *v, true
}

// OldDetail returns the old "detail" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldDetail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDetail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDetail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetail: %w", err)
	}
	return oldValue.Detail, nil
}

// ResetDetail resets all changes to the "detail" field.
func (m *MessageMutation) ResetDetail() {
	m.detail = nil
}

// SetPublishType sets the "publish_type" field.
func (m *MessageMutation) SetPublishType(u uint8) {
	m.publish_type = &u
	m.addpublish_type = nil
}

// PublishType returns the value of the "publish_type" field in the mutation.
func (m *MessageMutation) PublishType() (r uint8, exists bool) {
	v := m.publish_type
	if v == nil {
		return
	}
	return *v, true
}

// OldPublishType returns the old "publish_type" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldPublishType(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPublishType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPublishType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublishType: %w", err)
	}
	return oldValue.PublishType, nil
}

// AddPublishType adds u to the "publish_type" field.
func (m *MessageMutation) AddPublishType(u uint8) {
	if m.addpublish_type != nil {
		*m.addpublish_type += u
	} else {
		m.addpublish_type = &u
	}
}

// AddedPublishType returns the value that was added to the "publish_type" field in this mutation.
func (m *MessageMutation) AddedPublishType() (r uint8, exists bool) {
	v := m.addpublish_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetPublishType resets all changes to the "publish_type" field.
func (m *MessageMutation) ResetPublishType() {
	m.publish_type = nil
	m.addpublish_type = nil
}

// SetStatus sets the "status" field.
func (m *MessageMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *MessageMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *MessageMutation) AddStatus(u uint8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *MessageMutation) AddedStatus() (r uint8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *MessageMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetPublishStatus sets the "publish_status" field.
func (m *MessageMutation) SetPublishStatus(u uint8) {
	m.publish_status = &u
	m.addpublish_status = nil
}

// PublishStatus returns the value of the "publish_status" field in the mutation.
func (m *MessageMutation) PublishStatus() (r uint8, exists bool) {
	v := m.publish_status
	if v == nil {
		return
	}
	return *v, true
}

// OldPublishStatus returns the old "publish_status" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldPublishStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPublishStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPublishStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublishStatus: %w", err)
	}
	return oldValue.PublishStatus, nil
}

// AddPublishStatus adds u to the "publish_status" field.
func (m *MessageMutation) AddPublishStatus(u uint8) {
	if m.addpublish_status != nil {
		*m.addpublish_status += u
	} else {
		m.addpublish_status = &u
	}
}

// AddedPublishStatus returns the value that was added to the "publish_status" field in this mutation.
func (m *MessageMutation) AddedPublishStatus() (r uint8, exists bool) {
	v := m.addpublish_status
	if v == nil {
		return
	}
	return *v, true
}

// ResetPublishStatus resets all changes to the "publish_status" field.
func (m *MessageMutation) ResetPublishStatus() {
	m.publish_status = nil
	m.addpublish_status = nil
}

// SetAutoPublishAt sets the "auto_publish_at" field.
func (m *MessageMutation) SetAutoPublishAt(t time.Time) {
	m.auto_publish_at = &t
}

// AutoPublishAt returns the value of the "auto_publish_at" field in the mutation.
func (m *MessageMutation) AutoPublishAt() (r time.Time, exists bool) {
	v := m.auto_publish_at
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoPublishAt returns the old "auto_publish_at" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldAutoPublishAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAutoPublishAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAutoPublishAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoPublishAt: %w", err)
	}
	return oldValue.AutoPublishAt, nil
}

// ClearAutoPublishAt clears the value of the "auto_publish_at" field.
func (m *MessageMutation) ClearAutoPublishAt() {
	m.auto_publish_at = nil
	m.clearedFields[message.FieldAutoPublishAt] = struct{}{}
}

// AutoPublishAtCleared returns if the "auto_publish_at" field was cleared in this mutation.
func (m *MessageMutation) AutoPublishAtCleared() bool {
	_, ok := m.clearedFields[message.FieldAutoPublishAt]
	return ok
}

// ResetAutoPublishAt resets all changes to the "auto_publish_at" field.
func (m *MessageMutation) ResetAutoPublishAt() {
	m.auto_publish_at = nil
	delete(m.clearedFields, message.FieldAutoPublishAt)
}

// SetMessageTypeID sets the "message_type_id" field.
func (m *MessageMutation) SetMessageTypeID(i int) {
	m._Message_type = &i
}

// MessageTypeID returns the value of the "message_type_id" field in the mutation.
func (m *MessageMutation) MessageTypeID() (r int, exists bool) {
	v := m._Message_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMessageTypeID returns the old "message_type_id" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldMessageTypeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMessageTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMessageTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessageTypeID: %w", err)
	}
	return oldValue.MessageTypeID, nil
}

// ClearMessageTypeID clears the value of the "message_type_id" field.
func (m *MessageMutation) ClearMessageTypeID() {
	m._Message_type = nil
	m.clearedFields[message.FieldMessageTypeID] = struct{}{}
}

// MessageTypeIDCleared returns if the "message_type_id" field was cleared in this mutation.
func (m *MessageMutation) MessageTypeIDCleared() bool {
	_, ok := m.clearedFields[message.FieldMessageTypeID]
	return ok
}

// ResetMessageTypeID resets all changes to the "message_type_id" field.
func (m *MessageMutation) ResetMessageTypeID() {
	m._Message_type = nil
	delete(m.clearedFields, message.FieldMessageTypeID)
}

// SetCreatedAdminID sets the "created_admin_id" field.
func (m *MessageMutation) SetCreatedAdminID(i int) {
	m.admin = &i
}

// CreatedAdminID returns the value of the "created_admin_id" field in the mutation.
func (m *MessageMutation) CreatedAdminID() (r int, exists bool) {
	v := m.admin
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAdminID returns the old "created_admin_id" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldCreatedAdminID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAdminID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAdminID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAdminID: %w", err)
	}
	return oldValue.CreatedAdminID, nil
}

// ClearCreatedAdminID clears the value of the "created_admin_id" field.
func (m *MessageMutation) ClearCreatedAdminID() {
	m.admin = nil
	m.clearedFields[message.FieldCreatedAdminID] = struct{}{}
}

// CreatedAdminIDCleared returns if the "created_admin_id" field was cleared in this mutation.
func (m *MessageMutation) CreatedAdminIDCleared() bool {
	_, ok := m.clearedFields[message.FieldCreatedAdminID]
	return ok
}

// ResetCreatedAdminID resets all changes to the "created_admin_id" field.
func (m *MessageMutation) ResetCreatedAdminID() {
	m.admin = nil
	delete(m.clearedFields, message.FieldCreatedAdminID)
}

// SetAttachmentID sets the "attachment_id" field.
func (m *MessageMutation) SetAttachmentID(i int) {
	m.attachment = &i
}

// AttachmentID returns the value of the "attachment_id" field in the mutation.
func (m *MessageMutation) AttachmentID() (r int, exists bool) {
	v := m.attachment
	if v == nil {
		return
	}
	return *v, true
}

// OldAttachmentID returns the old "attachment_id" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldAttachmentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAttachmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAttachmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttachmentID: %w", err)
	}
	return oldValue.AttachmentID, nil
}

// ClearAttachmentID clears the value of the "attachment_id" field.
func (m *MessageMutation) ClearAttachmentID() {
	m.attachment = nil
	m.clearedFields[message.FieldAttachmentID] = struct{}{}
}

// AttachmentIDCleared returns if the "attachment_id" field was cleared in this mutation.
func (m *MessageMutation) AttachmentIDCleared() bool {
	_, ok := m.clearedFields[message.FieldAttachmentID]
	return ok
}

// ResetAttachmentID resets all changes to the "attachment_id" field.
func (m *MessageMutation) ResetAttachmentID() {
	m.attachment = nil
	delete(m.clearedFields, message.FieldAttachmentID)
}

// SetCourseID sets the "course_id" field.
func (m *MessageMutation) SetCourseID(i int) {
	m.course = &i
}

// CourseID returns the value of the "course_id" field in the mutation.
func (m *MessageMutation) CourseID() (r int, exists bool) {
	v := m.course
	if v == nil {
		return
	}
	return *v, true
}

// OldCourseID returns the old "course_id" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldCourseID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCourseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCourseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCourseID: %w", err)
	}
	return oldValue.CourseID, nil
}

// ClearCourseID clears the value of the "course_id" field.
func (m *MessageMutation) ClearCourseID() {
	m.course = nil
	m.clearedFields[message.FieldCourseID] = struct{}{}
}

// CourseIDCleared returns if the "course_id" field was cleared in this mutation.
func (m *MessageMutation) CourseIDCleared() bool {
	_, ok := m.clearedFields[message.FieldCourseID]
	return ok
}

// ResetCourseID resets all changes to the "course_id" field.
func (m *MessageMutation) ResetCourseID() {
	m.course = nil
	delete(m.clearedFields, message.FieldCourseID)
}

// SetClassID sets the "class_id" field.
func (m *MessageMutation) SetClassID(i int) {
	m.class = &i
}

// ClassID returns the value of the "class_id" field in the mutation.
func (m *MessageMutation) ClassID() (r int, exists bool) {
	v := m.class
	if v == nil {
		return
	}
	return *v, true
}

// OldClassID returns the old "class_id" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldClassID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldClassID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldClassID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClassID: %w", err)
	}
	return oldValue.ClassID, nil
}

// ClearClassID clears the value of the "class_id" field.
func (m *MessageMutation) ClearClassID() {
	m.class = nil
	m.clearedFields[message.FieldClassID] = struct{}{}
}

// ClassIDCleared returns if the "class_id" field was cleared in this mutation.
func (m *MessageMutation) ClassIDCleared() bool {
	_, ok := m.clearedFields[message.FieldClassID]
	return ok
}

// ResetClassID resets all changes to the "class_id" field.
func (m *MessageMutation) ResetClassID() {
	m.class = nil
	delete(m.clearedFields, message.FieldClassID)
}

// ClearMessageType clears the "Message_type" edge to the MessageType entity.
func (m *MessageMutation) ClearMessageType() {
	m.cleared_Message_type = true
}

// MessageTypeCleared reports if the "Message_type" edge to the MessageType entity was cleared.
func (m *MessageMutation) MessageTypeCleared() bool {
	return m.MessageTypeIDCleared() || m.cleared_Message_type
}

// MessageTypeIDs returns the "Message_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MessageTypeID instead. It exists only for internal usage by the builders.
func (m *MessageMutation) MessageTypeIDs() (ids []int) {
	if id := m._Message_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMessageType resets all changes to the "Message_type" edge.
func (m *MessageMutation) ResetMessageType() {
	m._Message_type = nil
	m.cleared_Message_type = false
}

// SetAdminID sets the "admin" edge to the Admin entity by id.
func (m *MessageMutation) SetAdminID(id int) {
	m.admin = &id
}

// ClearAdmin clears the "admin" edge to the Admin entity.
func (m *MessageMutation) ClearAdmin() {
	m.clearedadmin = true
}

// AdminCleared reports if the "admin" edge to the Admin entity was cleared.
func (m *MessageMutation) AdminCleared() bool {
	return m.CreatedAdminIDCleared() || m.clearedadmin
}

// AdminID returns the "admin" edge ID in the mutation.
func (m *MessageMutation) AdminID() (id int, exists bool) {
	if m.admin != nil {
		return *m.admin, true
	}
	return
}

// AdminIDs returns the "admin" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AdminID instead. It exists only for internal usage by the builders.
func (m *MessageMutation) AdminIDs() (ids []int) {
	if id := m.admin; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAdmin resets all changes to the "admin" edge.
func (m *MessageMutation) ResetAdmin() {
	m.admin = nil
	m.clearedadmin = false
}

// ClearAttachment clears the "attachment" edge to the Attachment entity.
func (m *MessageMutation) ClearAttachment() {
	m.clearedattachment = true
}

// AttachmentCleared reports if the "attachment" edge to the Attachment entity was cleared.
func (m *MessageMutation) AttachmentCleared() bool {
	return m.AttachmentIDCleared() || m.clearedattachment
}

// AttachmentIDs returns the "attachment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AttachmentID instead. It exists only for internal usage by the builders.
func (m *MessageMutation) AttachmentIDs() (ids []int) {
	if id := m.attachment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAttachment resets all changes to the "attachment" edge.
func (m *MessageMutation) ResetAttachment() {
	m.attachment = nil
	m.clearedattachment = false
}

// ClearCourse clears the "course" edge to the KcCourse entity.
func (m *MessageMutation) ClearCourse() {
	m.clearedcourse = true
}

// CourseCleared reports if the "course" edge to the KcCourse entity was cleared.
func (m *MessageMutation) CourseCleared() bool {
	return m.CourseIDCleared() || m.clearedcourse
}

// CourseIDs returns the "course" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CourseID instead. It exists only for internal usage by the builders.
func (m *MessageMutation) CourseIDs() (ids []int) {
	if id := m.course; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCourse resets all changes to the "course" edge.
func (m *MessageMutation) ResetCourse() {
	m.course = nil
	m.clearedcourse = false
}

// ClearClass clears the "class" edge to the KcClass entity.
func (m *MessageMutation) ClearClass() {
	m.clearedclass = true
}

// ClassCleared reports if the "class" edge to the KcClass entity was cleared.
func (m *MessageMutation) ClassCleared() bool {
	return m.ClassIDCleared() || m.clearedclass
}

// ClassIDs returns the "class" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClassID instead. It exists only for internal usage by the builders.
func (m *MessageMutation) ClassIDs() (ids []int) {
	if id := m.class; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClass resets all changes to the "class" edge.
func (m *MessageMutation) ResetClass() {
	m.class = nil
	m.clearedclass = false
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *MessageMutation) AddUserIDs(ids ...int) {
	if m.users == nil {
		m.users = make(map[int]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *MessageMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *MessageMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *MessageMutation) RemoveUserIDs(ids ...int) {
	if m.removedusers == nil {
		m.removedusers = make(map[int]struct{})
	}
	for i := range ids {
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *MessageMutation) RemovedUsersIDs() (ids []int) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *MessageMutation) UsersIDs() (ids []int) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *MessageMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// Op returns the operation name.
func (m *MessageMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Message).
func (m *MessageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MessageMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.uuid != nil {
		fields = append(fields, message.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, message.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, message.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, message.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, message.FieldName)
	}
	if m.detail != nil {
		fields = append(fields, message.FieldDetail)
	}
	if m.publish_type != nil {
		fields = append(fields, message.FieldPublishType)
	}
	if m.status != nil {
		fields = append(fields, message.FieldStatus)
	}
	if m.publish_status != nil {
		fields = append(fields, message.FieldPublishStatus)
	}
	if m.auto_publish_at != nil {
		fields = append(fields, message.FieldAutoPublishAt)
	}
	if m._Message_type != nil {
		fields = append(fields, message.FieldMessageTypeID)
	}
	if m.admin != nil {
		fields = append(fields, message.FieldCreatedAdminID)
	}
	if m.attachment != nil {
		fields = append(fields, message.FieldAttachmentID)
	}
	if m.course != nil {
		fields = append(fields, message.FieldCourseID)
	}
	if m.class != nil {
		fields = append(fields, message.FieldClassID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MessageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case message.FieldUUID:
		return m.UUID()
	case message.FieldCreatedAt:
		return m.CreatedAt()
	case message.FieldUpdatedAt:
		return m.UpdatedAt()
	case message.FieldDeletedAt:
		return m.DeletedAt()
	case message.FieldName:
		return m.Name()
	case message.FieldDetail:
		return m.Detail()
	case message.FieldPublishType:
		return m.PublishType()
	case message.FieldStatus:
		return m.Status()
	case message.FieldPublishStatus:
		return m.PublishStatus()
	case message.FieldAutoPublishAt:
		return m.AutoPublishAt()
	case message.FieldMessageTypeID:
		return m.MessageTypeID()
	case message.FieldCreatedAdminID:
		return m.CreatedAdminID()
	case message.FieldAttachmentID:
		return m.AttachmentID()
	case message.FieldCourseID:
		return m.CourseID()
	case message.FieldClassID:
		return m.ClassID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MessageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case message.FieldUUID:
		return m.OldUUID(ctx)
	case message.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case message.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case message.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case message.FieldName:
		return m.OldName(ctx)
	case message.FieldDetail:
		return m.OldDetail(ctx)
	case message.FieldPublishType:
		return m.OldPublishType(ctx)
	case message.FieldStatus:
		return m.OldStatus(ctx)
	case message.FieldPublishStatus:
		return m.OldPublishStatus(ctx)
	case message.FieldAutoPublishAt:
		return m.OldAutoPublishAt(ctx)
	case message.FieldMessageTypeID:
		return m.OldMessageTypeID(ctx)
	case message.FieldCreatedAdminID:
		return m.OldCreatedAdminID(ctx)
	case message.FieldAttachmentID:
		return m.OldAttachmentID(ctx)
	case message.FieldCourseID:
		return m.OldCourseID(ctx)
	case message.FieldClassID:
		return m.OldClassID(ctx)
	}
	return nil, fmt.Errorf("unknown Message field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case message.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case message.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case message.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case message.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case message.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case message.FieldDetail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetail(v)
		return nil
	case message.FieldPublishType:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublishType(v)
		return nil
	case message.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case message.FieldPublishStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublishStatus(v)
		return nil
	case message.FieldAutoPublishAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoPublishAt(v)
		return nil
	case message.FieldMessageTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessageTypeID(v)
		return nil
	case message.FieldCreatedAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAdminID(v)
		return nil
	case message.FieldAttachmentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttachmentID(v)
		return nil
	case message.FieldCourseID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCourseID(v)
		return nil
	case message.FieldClassID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClassID(v)
		return nil
	}
	return fmt.Errorf("unknown Message field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MessageMutation) AddedFields() []string {
	var fields []string
	if m.addpublish_type != nil {
		fields = append(fields, message.FieldPublishType)
	}
	if m.addstatus != nil {
		fields = append(fields, message.FieldStatus)
	}
	if m.addpublish_status != nil {
		fields = append(fields, message.FieldPublishStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MessageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case message.FieldPublishType:
		return m.AddedPublishType()
	case message.FieldStatus:
		return m.AddedStatus()
	case message.FieldPublishStatus:
		return m.AddedPublishStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessageMutation) AddField(name string, value ent.Value) error {
	switch name {
	case message.FieldPublishType:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPublishType(v)
		return nil
	case message.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case message.FieldPublishStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPublishStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Message numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MessageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(message.FieldCreatedAt) {
		fields = append(fields, message.FieldCreatedAt)
	}
	if m.FieldCleared(message.FieldUpdatedAt) {
		fields = append(fields, message.FieldUpdatedAt)
	}
	if m.FieldCleared(message.FieldDeletedAt) {
		fields = append(fields, message.FieldDeletedAt)
	}
	if m.FieldCleared(message.FieldAutoPublishAt) {
		fields = append(fields, message.FieldAutoPublishAt)
	}
	if m.FieldCleared(message.FieldMessageTypeID) {
		fields = append(fields, message.FieldMessageTypeID)
	}
	if m.FieldCleared(message.FieldCreatedAdminID) {
		fields = append(fields, message.FieldCreatedAdminID)
	}
	if m.FieldCleared(message.FieldAttachmentID) {
		fields = append(fields, message.FieldAttachmentID)
	}
	if m.FieldCleared(message.FieldCourseID) {
		fields = append(fields, message.FieldCourseID)
	}
	if m.FieldCleared(message.FieldClassID) {
		fields = append(fields, message.FieldClassID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MessageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MessageMutation) ClearField(name string) error {
	switch name {
	case message.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case message.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case message.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case message.FieldAutoPublishAt:
		m.ClearAutoPublishAt()
		return nil
	case message.FieldMessageTypeID:
		m.ClearMessageTypeID()
		return nil
	case message.FieldCreatedAdminID:
		m.ClearCreatedAdminID()
		return nil
	case message.FieldAttachmentID:
		m.ClearAttachmentID()
		return nil
	case message.FieldCourseID:
		m.ClearCourseID()
		return nil
	case message.FieldClassID:
		m.ClearClassID()
		return nil
	}
	return fmt.Errorf("unknown Message nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MessageMutation) ResetField(name string) error {
	switch name {
	case message.FieldUUID:
		m.ResetUUID()
		return nil
	case message.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case message.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case message.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case message.FieldName:
		m.ResetName()
		return nil
	case message.FieldDetail:
		m.ResetDetail()
		return nil
	case message.FieldPublishType:
		m.ResetPublishType()
		return nil
	case message.FieldStatus:
		m.ResetStatus()
		return nil
	case message.FieldPublishStatus:
		m.ResetPublishStatus()
		return nil
	case message.FieldAutoPublishAt:
		m.ResetAutoPublishAt()
		return nil
	case message.FieldMessageTypeID:
		m.ResetMessageTypeID()
		return nil
	case message.FieldCreatedAdminID:
		m.ResetCreatedAdminID()
		return nil
	case message.FieldAttachmentID:
		m.ResetAttachmentID()
		return nil
	case message.FieldCourseID:
		m.ResetCourseID()
		return nil
	case message.FieldClassID:
		m.ResetClassID()
		return nil
	}
	return fmt.Errorf("unknown Message field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MessageMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m._Message_type != nil {
		edges = append(edges, message.EdgeMessageType)
	}
	if m.admin != nil {
		edges = append(edges, message.EdgeAdmin)
	}
	if m.attachment != nil {
		edges = append(edges, message.EdgeAttachment)
	}
	if m.course != nil {
		edges = append(edges, message.EdgeCourse)
	}
	if m.class != nil {
		edges = append(edges, message.EdgeClass)
	}
	if m.users != nil {
		edges = append(edges, message.EdgeUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MessageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case message.EdgeMessageType:
		if id := m._Message_type; id != nil {
			return []ent.Value{*id}
		}
	case message.EdgeAdmin:
		if id := m.admin; id != nil {
			return []ent.Value{*id}
		}
	case message.EdgeAttachment:
		if id := m.attachment; id != nil {
			return []ent.Value{*id}
		}
	case message.EdgeCourse:
		if id := m.course; id != nil {
			return []ent.Value{*id}
		}
	case message.EdgeClass:
		if id := m.class; id != nil {
			return []ent.Value{*id}
		}
	case message.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MessageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedusers != nil {
		edges = append(edges, message.EdgeUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MessageMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case message.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MessageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.cleared_Message_type {
		edges = append(edges, message.EdgeMessageType)
	}
	if m.clearedadmin {
		edges = append(edges, message.EdgeAdmin)
	}
	if m.clearedattachment {
		edges = append(edges, message.EdgeAttachment)
	}
	if m.clearedcourse {
		edges = append(edges, message.EdgeCourse)
	}
	if m.clearedclass {
		edges = append(edges, message.EdgeClass)
	}
	if m.clearedusers {
		edges = append(edges, message.EdgeUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MessageMutation) EdgeCleared(name string) bool {
	switch name {
	case message.EdgeMessageType:
		return m.cleared_Message_type
	case message.EdgeAdmin:
		return m.clearedadmin
	case message.EdgeAttachment:
		return m.clearedattachment
	case message.EdgeCourse:
		return m.clearedcourse
	case message.EdgeClass:
		return m.clearedclass
	case message.EdgeUsers:
		return m.clearedusers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MessageMutation) ClearEdge(name string) error {
	switch name {
	case message.EdgeMessageType:
		m.ClearMessageType()
		return nil
	case message.EdgeAdmin:
		m.ClearAdmin()
		return nil
	case message.EdgeAttachment:
		m.ClearAttachment()
		return nil
	case message.EdgeCourse:
		m.ClearCourse()
		return nil
	case message.EdgeClass:
		m.ClearClass()
		return nil
	}
	return fmt.Errorf("unknown Message unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MessageMutation) ResetEdge(name string) error {
	switch name {
	case message.EdgeMessageType:
		m.ResetMessageType()
		return nil
	case message.EdgeAdmin:
		m.ResetAdmin()
		return nil
	case message.EdgeAttachment:
		m.ResetAttachment()
		return nil
	case message.EdgeCourse:
		m.ResetCourse()
		return nil
	case message.EdgeClass:
		m.ResetClass()
		return nil
	case message.EdgeUsers:
		m.ResetUsers()
		return nil
	}
	return fmt.Errorf("unknown Message edge %s", name)
}

// MessageTypeMutation represents an operation that mutates the MessageType nodes in the graph.
type MessageTypeMutation struct {
	config
	op              Op
	typ             string
	id              *int
	uuid            *string
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *time.Time
	name            *string
	status          *uint8
	addstatus       *uint8
	clearedFields   map[string]struct{}
	messages        map[int]struct{}
	removedmessages map[int]struct{}
	clearedmessages bool
	done            bool
	oldValue        func(context.Context) (*MessageType, error)
	predicates      []predicate.MessageType
}

var _ ent.Mutation = (*MessageTypeMutation)(nil)

// messagetypeOption allows management of the mutation configuration using functional options.
type messagetypeOption func(*MessageTypeMutation)

// newMessageTypeMutation creates new mutation for the MessageType entity.
func newMessageTypeMutation(c config, op Op, opts ...messagetypeOption) *MessageTypeMutation {
	m := &MessageTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeMessageType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMessageTypeID sets the ID field of the mutation.
func withMessageTypeID(id int) messagetypeOption {
	return func(m *MessageTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *MessageType
		)
		m.oldValue = func(ctx context.Context) (*MessageType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MessageType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMessageType sets the old MessageType of the mutation.
func withMessageType(node *MessageType) messagetypeOption {
	return func(m *MessageTypeMutation) {
		m.oldValue = func(context.Context) (*MessageType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MessageTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MessageTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *MessageTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *MessageTypeMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *MessageTypeMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the MessageType entity.
// If the MessageType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageTypeMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *MessageTypeMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MessageTypeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MessageTypeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MessageType entity.
// If the MessageType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageTypeMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *MessageTypeMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[messagetype.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *MessageTypeMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[messagetype.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MessageTypeMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, messagetype.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MessageTypeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MessageTypeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MessageType entity.
// If the MessageType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageTypeMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *MessageTypeMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[messagetype.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *MessageTypeMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[messagetype.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MessageTypeMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, messagetype.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MessageTypeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MessageTypeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the MessageType entity.
// If the MessageType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageTypeMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *MessageTypeMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[messagetype.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *MessageTypeMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[messagetype.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MessageTypeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, messagetype.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *MessageTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MessageTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the MessageType entity.
// If the MessageType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MessageTypeMutation) ResetName() {
	m.name = nil
}

// SetStatus sets the "status" field.
func (m *MessageTypeMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *MessageTypeMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the MessageType entity.
// If the MessageType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageTypeMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *MessageTypeMutation) AddStatus(u uint8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *MessageTypeMutation) AddedStatus() (r uint8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *MessageTypeMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// AddMessageIDs adds the "messages" edge to the Message entity by ids.
func (m *MessageTypeMutation) AddMessageIDs(ids ...int) {
	if m.messages == nil {
		m.messages = make(map[int]struct{})
	}
	for i := range ids {
		m.messages[ids[i]] = struct{}{}
	}
}

// ClearMessages clears the "messages" edge to the Message entity.
func (m *MessageTypeMutation) ClearMessages() {
	m.clearedmessages = true
}

// MessagesCleared reports if the "messages" edge to the Message entity was cleared.
func (m *MessageTypeMutation) MessagesCleared() bool {
	return m.clearedmessages
}

// RemoveMessageIDs removes the "messages" edge to the Message entity by IDs.
func (m *MessageTypeMutation) RemoveMessageIDs(ids ...int) {
	if m.removedmessages == nil {
		m.removedmessages = make(map[int]struct{})
	}
	for i := range ids {
		m.removedmessages[ids[i]] = struct{}{}
	}
}

// RemovedMessages returns the removed IDs of the "messages" edge to the Message entity.
func (m *MessageTypeMutation) RemovedMessagesIDs() (ids []int) {
	for id := range m.removedmessages {
		ids = append(ids, id)
	}
	return
}

// MessagesIDs returns the "messages" edge IDs in the mutation.
func (m *MessageTypeMutation) MessagesIDs() (ids []int) {
	for id := range m.messages {
		ids = append(ids, id)
	}
	return
}

// ResetMessages resets all changes to the "messages" edge.
func (m *MessageTypeMutation) ResetMessages() {
	m.messages = nil
	m.clearedmessages = false
	m.removedmessages = nil
}

// Op returns the operation name.
func (m *MessageTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (MessageType).
func (m *MessageTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MessageTypeMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.uuid != nil {
		fields = append(fields, messagetype.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, messagetype.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, messagetype.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, messagetype.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, messagetype.FieldName)
	}
	if m.status != nil {
		fields = append(fields, messagetype.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MessageTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case messagetype.FieldUUID:
		return m.UUID()
	case messagetype.FieldCreatedAt:
		return m.CreatedAt()
	case messagetype.FieldUpdatedAt:
		return m.UpdatedAt()
	case messagetype.FieldDeletedAt:
		return m.DeletedAt()
	case messagetype.FieldName:
		return m.Name()
	case messagetype.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MessageTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case messagetype.FieldUUID:
		return m.OldUUID(ctx)
	case messagetype.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case messagetype.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case messagetype.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case messagetype.FieldName:
		return m.OldName(ctx)
	case messagetype.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown MessageType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessageTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case messagetype.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case messagetype.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case messagetype.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case messagetype.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case messagetype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case messagetype.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown MessageType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MessageTypeMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, messagetype.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MessageTypeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case messagetype.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessageTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case messagetype.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown MessageType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MessageTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(messagetype.FieldCreatedAt) {
		fields = append(fields, messagetype.FieldCreatedAt)
	}
	if m.FieldCleared(messagetype.FieldUpdatedAt) {
		fields = append(fields, messagetype.FieldUpdatedAt)
	}
	if m.FieldCleared(messagetype.FieldDeletedAt) {
		fields = append(fields, messagetype.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MessageTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MessageTypeMutation) ClearField(name string) error {
	switch name {
	case messagetype.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case messagetype.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case messagetype.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown MessageType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MessageTypeMutation) ResetField(name string) error {
	switch name {
	case messagetype.FieldUUID:
		m.ResetUUID()
		return nil
	case messagetype.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case messagetype.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case messagetype.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case messagetype.FieldName:
		m.ResetName()
		return nil
	case messagetype.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown MessageType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MessageTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.messages != nil {
		edges = append(edges, messagetype.EdgeMessages)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MessageTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case messagetype.EdgeMessages:
		ids := make([]ent.Value, 0, len(m.messages))
		for id := range m.messages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MessageTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedmessages != nil {
		edges = append(edges, messagetype.EdgeMessages)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MessageTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case messagetype.EdgeMessages:
		ids := make([]ent.Value, 0, len(m.removedmessages))
		for id := range m.removedmessages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MessageTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmessages {
		edges = append(edges, messagetype.EdgeMessages)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MessageTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case messagetype.EdgeMessages:
		return m.clearedmessages
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MessageTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown MessageType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MessageTypeMutation) ResetEdge(name string) error {
	switch name {
	case messagetype.EdgeMessages:
		m.ResetMessages()
		return nil
	}
	return fmt.Errorf("unknown MessageType edge %s", name)
}

// PermissionMutation represents an operation that mutates the Permission nodes in the graph.
type PermissionMutation struct {
	config
	op            Op
	typ           string
	id            *int
	uuid          *string
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	name          *string
	desc          *string
	pid           *uint32
	addpid        *uint32
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Permission, error)
	predicates    []predicate.Permission
}

var _ ent.Mutation = (*PermissionMutation)(nil)

// permissionOption allows management of the mutation configuration using functional options.
type permissionOption func(*PermissionMutation)

// newPermissionMutation creates new mutation for the Permission entity.
func newPermissionMutation(c config, op Op, opts ...permissionOption) *PermissionMutation {
	m := &PermissionMutation{
		config:        c,
		op:            op,
		typ:           TypePermission,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPermissionID sets the ID field of the mutation.
func withPermissionID(id int) permissionOption {
	return func(m *PermissionMutation) {
		var (
			err   error
			once  sync.Once
			value *Permission
		)
		m.oldValue = func(ctx context.Context) (*Permission, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Permission.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPermission sets the old Permission of the mutation.
func withPermission(node *Permission) permissionOption {
	return func(m *PermissionMutation) {
		m.oldValue = func(context.Context) (*Permission, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PermissionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PermissionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *PermissionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *PermissionMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *PermissionMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *PermissionMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PermissionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PermissionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *PermissionMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[permission.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *PermissionMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[permission.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PermissionMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, permission.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PermissionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PermissionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *PermissionMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[permission.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *PermissionMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[permission.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PermissionMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, permission.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PermissionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PermissionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PermissionMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[permission.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PermissionMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[permission.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PermissionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, permission.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *PermissionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PermissionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PermissionMutation) ResetName() {
	m.name = nil
}

// SetDesc sets the "desc" field.
func (m *PermissionMutation) SetDesc(s string) {
	m.desc = &s
}

// Desc returns the value of the "desc" field in the mutation.
func (m *PermissionMutation) Desc() (r string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldDesc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// ResetDesc resets all changes to the "desc" field.
func (m *PermissionMutation) ResetDesc() {
	m.desc = nil
}

// SetPid sets the "pid" field.
func (m *PermissionMutation) SetPid(u uint32) {
	m.pid = &u
	m.addpid = nil
}

// Pid returns the value of the "pid" field in the mutation.
func (m *PermissionMutation) Pid() (r uint32, exists bool) {
	v := m.pid
	if v == nil {
		return
	}
	return *v, true
}

// OldPid returns the old "pid" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldPid(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPid: %w", err)
	}
	return oldValue.Pid, nil
}

// AddPid adds u to the "pid" field.
func (m *PermissionMutation) AddPid(u uint32) {
	if m.addpid != nil {
		*m.addpid += u
	} else {
		m.addpid = &u
	}
}

// AddedPid returns the value that was added to the "pid" field in this mutation.
func (m *PermissionMutation) AddedPid() (r uint32, exists bool) {
	v := m.addpid
	if v == nil {
		return
	}
	return *v, true
}

// ResetPid resets all changes to the "pid" field.
func (m *PermissionMutation) ResetPid() {
	m.pid = nil
	m.addpid = nil
}

// Op returns the operation name.
func (m *PermissionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Permission).
func (m *PermissionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PermissionMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.uuid != nil {
		fields = append(fields, permission.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, permission.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, permission.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, permission.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, permission.FieldName)
	}
	if m.desc != nil {
		fields = append(fields, permission.FieldDesc)
	}
	if m.pid != nil {
		fields = append(fields, permission.FieldPid)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PermissionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case permission.FieldUUID:
		return m.UUID()
	case permission.FieldCreatedAt:
		return m.CreatedAt()
	case permission.FieldUpdatedAt:
		return m.UpdatedAt()
	case permission.FieldDeletedAt:
		return m.DeletedAt()
	case permission.FieldName:
		return m.Name()
	case permission.FieldDesc:
		return m.Desc()
	case permission.FieldPid:
		return m.Pid()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PermissionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case permission.FieldUUID:
		return m.OldUUID(ctx)
	case permission.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case permission.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case permission.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case permission.FieldName:
		return m.OldName(ctx)
	case permission.FieldDesc:
		return m.OldDesc(ctx)
	case permission.FieldPid:
		return m.OldPid(ctx)
	}
	return nil, fmt.Errorf("unknown Permission field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case permission.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case permission.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case permission.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case permission.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case permission.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case permission.FieldDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	case permission.FieldPid:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPid(v)
		return nil
	}
	return fmt.Errorf("unknown Permission field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PermissionMutation) AddedFields() []string {
	var fields []string
	if m.addpid != nil {
		fields = append(fields, permission.FieldPid)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PermissionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case permission.FieldPid:
		return m.AddedPid()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case permission.FieldPid:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPid(v)
		return nil
	}
	return fmt.Errorf("unknown Permission numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PermissionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(permission.FieldCreatedAt) {
		fields = append(fields, permission.FieldCreatedAt)
	}
	if m.FieldCleared(permission.FieldUpdatedAt) {
		fields = append(fields, permission.FieldUpdatedAt)
	}
	if m.FieldCleared(permission.FieldDeletedAt) {
		fields = append(fields, permission.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PermissionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PermissionMutation) ClearField(name string) error {
	switch name {
	case permission.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case permission.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case permission.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Permission nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PermissionMutation) ResetField(name string) error {
	switch name {
	case permission.FieldUUID:
		m.ResetUUID()
		return nil
	case permission.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case permission.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case permission.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case permission.FieldName:
		m.ResetName()
		return nil
	case permission.FieldDesc:
		m.ResetDesc()
		return nil
	case permission.FieldPid:
		m.ResetPid()
		return nil
	}
	return fmt.Errorf("unknown Permission field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PermissionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PermissionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PermissionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PermissionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PermissionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PermissionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PermissionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Permission unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PermissionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Permission edge %s", name)
}

// RoleMutation represents an operation that mutates the Role nodes in the graph.
type RoleMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	uuid                   *string
	created_at             *time.Time
	updated_at             *time.Time
	deleted_at             *time.Time
	name                   *string
	desc                   *string
	status                 *uint8
	addstatus              *uint8
	clearedFields          map[string]struct{}
	admins                 map[int]struct{}
	removedadmins          map[int]struct{}
	clearedadmins          bool
	role_permission        *int
	clearedrole_permission bool
	done                   bool
	oldValue               func(context.Context) (*Role, error)
	predicates             []predicate.Role
}

var _ ent.Mutation = (*RoleMutation)(nil)

// roleOption allows management of the mutation configuration using functional options.
type roleOption func(*RoleMutation)

// newRoleMutation creates new mutation for the Role entity.
func newRoleMutation(c config, op Op, opts ...roleOption) *RoleMutation {
	m := &RoleMutation{
		config:        c,
		op:            op,
		typ:           TypeRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleID sets the ID field of the mutation.
func withRoleID(id int) roleOption {
	return func(m *RoleMutation) {
		var (
			err   error
			once  sync.Once
			value *Role
		)
		m.oldValue = func(ctx context.Context) (*Role, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Role.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRole sets the old Role of the mutation.
func withRole(node *Role) roleOption {
	return func(m *RoleMutation) {
		m.oldValue = func(context.Context) (*Role, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *RoleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *RoleMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *RoleMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *RoleMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *RoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *RoleMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[role.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *RoleMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[role.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RoleMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, role.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RoleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *RoleMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[role.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *RoleMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[role.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, role.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *RoleMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *RoleMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *RoleMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[role.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *RoleMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[role.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *RoleMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, role.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *RoleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RoleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RoleMutation) ResetName() {
	m.name = nil
}

// SetDesc sets the "desc" field.
func (m *RoleMutation) SetDesc(s string) {
	m.desc = &s
}

// Desc returns the value of the "desc" field in the mutation.
func (m *RoleMutation) Desc() (r string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldDesc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// ResetDesc resets all changes to the "desc" field.
func (m *RoleMutation) ResetDesc() {
	m.desc = nil
}

// SetStatus sets the "status" field.
func (m *RoleMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *RoleMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *RoleMutation) AddStatus(u uint8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *RoleMutation) AddedStatus() (r uint8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *RoleMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// AddAdminIDs adds the "admins" edge to the Admin entity by ids.
func (m *RoleMutation) AddAdminIDs(ids ...int) {
	if m.admins == nil {
		m.admins = make(map[int]struct{})
	}
	for i := range ids {
		m.admins[ids[i]] = struct{}{}
	}
}

// ClearAdmins clears the "admins" edge to the Admin entity.
func (m *RoleMutation) ClearAdmins() {
	m.clearedadmins = true
}

// AdminsCleared reports if the "admins" edge to the Admin entity was cleared.
func (m *RoleMutation) AdminsCleared() bool {
	return m.clearedadmins
}

// RemoveAdminIDs removes the "admins" edge to the Admin entity by IDs.
func (m *RoleMutation) RemoveAdminIDs(ids ...int) {
	if m.removedadmins == nil {
		m.removedadmins = make(map[int]struct{})
	}
	for i := range ids {
		m.removedadmins[ids[i]] = struct{}{}
	}
}

// RemovedAdmins returns the removed IDs of the "admins" edge to the Admin entity.
func (m *RoleMutation) RemovedAdminsIDs() (ids []int) {
	for id := range m.removedadmins {
		ids = append(ids, id)
	}
	return
}

// AdminsIDs returns the "admins" edge IDs in the mutation.
func (m *RoleMutation) AdminsIDs() (ids []int) {
	for id := range m.admins {
		ids = append(ids, id)
	}
	return
}

// ResetAdmins resets all changes to the "admins" edge.
func (m *RoleMutation) ResetAdmins() {
	m.admins = nil
	m.clearedadmins = false
	m.removedadmins = nil
}

// SetRolePermissionID sets the "role_permission" edge to the RolePermission entity by id.
func (m *RoleMutation) SetRolePermissionID(id int) {
	m.role_permission = &id
}

// ClearRolePermission clears the "role_permission" edge to the RolePermission entity.
func (m *RoleMutation) ClearRolePermission() {
	m.clearedrole_permission = true
}

// RolePermissionCleared reports if the "role_permission" edge to the RolePermission entity was cleared.
func (m *RoleMutation) RolePermissionCleared() bool {
	return m.clearedrole_permission
}

// RolePermissionID returns the "role_permission" edge ID in the mutation.
func (m *RoleMutation) RolePermissionID() (id int, exists bool) {
	if m.role_permission != nil {
		return *m.role_permission, true
	}
	return
}

// RolePermissionIDs returns the "role_permission" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RolePermissionID instead. It exists only for internal usage by the builders.
func (m *RoleMutation) RolePermissionIDs() (ids []int) {
	if id := m.role_permission; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRolePermission resets all changes to the "role_permission" edge.
func (m *RoleMutation) ResetRolePermission() {
	m.role_permission = nil
	m.clearedrole_permission = false
}

// Op returns the operation name.
func (m *RoleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Role).
func (m *RoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoleMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.uuid != nil {
		fields = append(fields, role.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, role.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, role.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, role.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, role.FieldName)
	}
	if m.desc != nil {
		fields = append(fields, role.FieldDesc)
	}
	if m.status != nil {
		fields = append(fields, role.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case role.FieldUUID:
		return m.UUID()
	case role.FieldCreatedAt:
		return m.CreatedAt()
	case role.FieldUpdatedAt:
		return m.UpdatedAt()
	case role.FieldDeletedAt:
		return m.DeletedAt()
	case role.FieldName:
		return m.Name()
	case role.FieldDesc:
		return m.Desc()
	case role.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case role.FieldUUID:
		return m.OldUUID(ctx)
	case role.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case role.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case role.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case role.FieldName:
		return m.OldName(ctx)
	case role.FieldDesc:
		return m.OldDesc(ctx)
	case role.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Role field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case role.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case role.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case role.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case role.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case role.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case role.FieldDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	case role.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoleMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, role.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case role.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case role.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Role numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(role.FieldCreatedAt) {
		fields = append(fields, role.FieldCreatedAt)
	}
	if m.FieldCleared(role.FieldUpdatedAt) {
		fields = append(fields, role.FieldUpdatedAt)
	}
	if m.FieldCleared(role.FieldDeletedAt) {
		fields = append(fields, role.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleMutation) ClearField(name string) error {
	switch name {
	case role.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case role.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case role.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Role nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoleMutation) ResetField(name string) error {
	switch name {
	case role.FieldUUID:
		m.ResetUUID()
		return nil
	case role.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case role.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case role.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case role.FieldName:
		m.ResetName()
		return nil
	case role.FieldDesc:
		m.ResetDesc()
		return nil
	case role.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.admins != nil {
		edges = append(edges, role.EdgeAdmins)
	}
	if m.role_permission != nil {
		edges = append(edges, role.EdgeRolePermission)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeAdmins:
		ids := make([]ent.Value, 0, len(m.admins))
		for id := range m.admins {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeRolePermission:
		if id := m.role_permission; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedadmins != nil {
		edges = append(edges, role.EdgeAdmins)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeAdmins:
		ids := make([]ent.Value, 0, len(m.removedadmins))
		for id := range m.removedadmins {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedadmins {
		edges = append(edges, role.EdgeAdmins)
	}
	if m.clearedrole_permission {
		edges = append(edges, role.EdgeRolePermission)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoleMutation) EdgeCleared(name string) bool {
	switch name {
	case role.EdgeAdmins:
		return m.clearedadmins
	case role.EdgeRolePermission:
		return m.clearedrole_permission
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoleMutation) ClearEdge(name string) error {
	switch name {
	case role.EdgeRolePermission:
		m.ClearRolePermission()
		return nil
	}
	return fmt.Errorf("unknown Role unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoleMutation) ResetEdge(name string) error {
	switch name {
	case role.EdgeAdmins:
		m.ResetAdmins()
		return nil
	case role.EdgeRolePermission:
		m.ResetRolePermission()
		return nil
	}
	return fmt.Errorf("unknown Role edge %s", name)
}

// RolePermissionMutation represents an operation that mutates the RolePermission nodes in the graph.
type RolePermissionMutation struct {
	config
	op            Op
	typ           string
	id            *int
	permission_id *string
	clearedFields map[string]struct{}
	role          *int
	clearedrole   bool
	done          bool
	oldValue      func(context.Context) (*RolePermission, error)
	predicates    []predicate.RolePermission
}

var _ ent.Mutation = (*RolePermissionMutation)(nil)

// rolepermissionOption allows management of the mutation configuration using functional options.
type rolepermissionOption func(*RolePermissionMutation)

// newRolePermissionMutation creates new mutation for the RolePermission entity.
func newRolePermissionMutation(c config, op Op, opts ...rolepermissionOption) *RolePermissionMutation {
	m := &RolePermissionMutation{
		config:        c,
		op:            op,
		typ:           TypeRolePermission,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRolePermissionID sets the ID field of the mutation.
func withRolePermissionID(id int) rolepermissionOption {
	return func(m *RolePermissionMutation) {
		var (
			err   error
			once  sync.Once
			value *RolePermission
		)
		m.oldValue = func(ctx context.Context) (*RolePermission, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RolePermission.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRolePermission sets the old RolePermission of the mutation.
func withRolePermission(node *RolePermission) rolepermissionOption {
	return func(m *RolePermissionMutation) {
		m.oldValue = func(context.Context) (*RolePermission, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RolePermissionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RolePermissionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *RolePermissionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetRoleID sets the "role_id" field.
func (m *RolePermissionMutation) SetRoleID(i int) {
	m.role = &i
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *RolePermissionMutation) RoleID() (r int, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the RolePermission entity.
// If the RolePermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RolePermissionMutation) OldRoleID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// ClearRoleID clears the value of the "role_id" field.
func (m *RolePermissionMutation) ClearRoleID() {
	m.role = nil
	m.clearedFields[rolepermission.FieldRoleID] = struct{}{}
}

// RoleIDCleared returns if the "role_id" field was cleared in this mutation.
func (m *RolePermissionMutation) RoleIDCleared() bool {
	_, ok := m.clearedFields[rolepermission.FieldRoleID]
	return ok
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *RolePermissionMutation) ResetRoleID() {
	m.role = nil
	delete(m.clearedFields, rolepermission.FieldRoleID)
}

// SetPermissionID sets the "permission_id" field.
func (m *RolePermissionMutation) SetPermissionID(s string) {
	m.permission_id = &s
}

// PermissionID returns the value of the "permission_id" field in the mutation.
func (m *RolePermissionMutation) PermissionID() (r string, exists bool) {
	v := m.permission_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPermissionID returns the old "permission_id" field's value of the RolePermission entity.
// If the RolePermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RolePermissionMutation) OldPermissionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPermissionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPermissionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPermissionID: %w", err)
	}
	return oldValue.PermissionID, nil
}

// ClearPermissionID clears the value of the "permission_id" field.
func (m *RolePermissionMutation) ClearPermissionID() {
	m.permission_id = nil
	m.clearedFields[rolepermission.FieldPermissionID] = struct{}{}
}

// PermissionIDCleared returns if the "permission_id" field was cleared in this mutation.
func (m *RolePermissionMutation) PermissionIDCleared() bool {
	_, ok := m.clearedFields[rolepermission.FieldPermissionID]
	return ok
}

// ResetPermissionID resets all changes to the "permission_id" field.
func (m *RolePermissionMutation) ResetPermissionID() {
	m.permission_id = nil
	delete(m.clearedFields, rolepermission.FieldPermissionID)
}

// ClearRole clears the "role" edge to the Role entity.
func (m *RolePermissionMutation) ClearRole() {
	m.clearedrole = true
}

// RoleCleared reports if the "role" edge to the Role entity was cleared.
func (m *RolePermissionMutation) RoleCleared() bool {
	return m.RoleIDCleared() || m.clearedrole
}

// RoleIDs returns the "role" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoleID instead. It exists only for internal usage by the builders.
func (m *RolePermissionMutation) RoleIDs() (ids []int) {
	if id := m.role; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRole resets all changes to the "role" edge.
func (m *RolePermissionMutation) ResetRole() {
	m.role = nil
	m.clearedrole = false
}

// Op returns the operation name.
func (m *RolePermissionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (RolePermission).
func (m *RolePermissionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RolePermissionMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.role != nil {
		fields = append(fields, rolepermission.FieldRoleID)
	}
	if m.permission_id != nil {
		fields = append(fields, rolepermission.FieldPermissionID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RolePermissionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case rolepermission.FieldRoleID:
		return m.RoleID()
	case rolepermission.FieldPermissionID:
		return m.PermissionID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RolePermissionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case rolepermission.FieldRoleID:
		return m.OldRoleID(ctx)
	case rolepermission.FieldPermissionID:
		return m.OldPermissionID(ctx)
	}
	return nil, fmt.Errorf("unknown RolePermission field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RolePermissionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case rolepermission.FieldRoleID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	case rolepermission.FieldPermissionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermissionID(v)
		return nil
	}
	return fmt.Errorf("unknown RolePermission field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RolePermissionMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RolePermissionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RolePermissionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RolePermission numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RolePermissionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(rolepermission.FieldRoleID) {
		fields = append(fields, rolepermission.FieldRoleID)
	}
	if m.FieldCleared(rolepermission.FieldPermissionID) {
		fields = append(fields, rolepermission.FieldPermissionID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RolePermissionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RolePermissionMutation) ClearField(name string) error {
	switch name {
	case rolepermission.FieldRoleID:
		m.ClearRoleID()
		return nil
	case rolepermission.FieldPermissionID:
		m.ClearPermissionID()
		return nil
	}
	return fmt.Errorf("unknown RolePermission nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RolePermissionMutation) ResetField(name string) error {
	switch name {
	case rolepermission.FieldRoleID:
		m.ResetRoleID()
		return nil
	case rolepermission.FieldPermissionID:
		m.ResetPermissionID()
		return nil
	}
	return fmt.Errorf("unknown RolePermission field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RolePermissionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.role != nil {
		edges = append(edges, rolepermission.EdgeRole)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RolePermissionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case rolepermission.EdgeRole:
		if id := m.role; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RolePermissionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RolePermissionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RolePermissionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrole {
		edges = append(edges, rolepermission.EdgeRole)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RolePermissionMutation) EdgeCleared(name string) bool {
	switch name {
	case rolepermission.EdgeRole:
		return m.clearedrole
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RolePermissionMutation) ClearEdge(name string) error {
	switch name {
	case rolepermission.EdgeRole:
		m.ClearRole()
		return nil
	}
	return fmt.Errorf("unknown RolePermission unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RolePermissionMutation) ResetEdge(name string) error {
	switch name {
	case rolepermission.EdgeRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown RolePermission edge %s", name)
}

// SharePosterMutation represents an operation that mutates the SharePoster nodes in the graph.
type SharePosterMutation struct {
	config
	op                Op
	typ               string
	id                *int
	uuid              *string
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	name              *string
	status            *uint8
	addstatus         *uint8
	url               *string
	remark            *string
	share_count       *int
	addshare_count    *int
	sort_order        *int
	addsort_order     *int
	clearedFields     map[string]struct{}
	attachment        *int
	clearedattachment bool
	done              bool
	oldValue          func(context.Context) (*SharePoster, error)
	predicates        []predicate.SharePoster
}

var _ ent.Mutation = (*SharePosterMutation)(nil)

// shareposterOption allows management of the mutation configuration using functional options.
type shareposterOption func(*SharePosterMutation)

// newSharePosterMutation creates new mutation for the SharePoster entity.
func newSharePosterMutation(c config, op Op, opts ...shareposterOption) *SharePosterMutation {
	m := &SharePosterMutation{
		config:        c,
		op:            op,
		typ:           TypeSharePoster,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSharePosterID sets the ID field of the mutation.
func withSharePosterID(id int) shareposterOption {
	return func(m *SharePosterMutation) {
		var (
			err   error
			once  sync.Once
			value *SharePoster
		)
		m.oldValue = func(ctx context.Context) (*SharePoster, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SharePoster.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSharePoster sets the old SharePoster of the mutation.
func withSharePoster(node *SharePoster) shareposterOption {
	return func(m *SharePosterMutation) {
		m.oldValue = func(context.Context) (*SharePoster, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SharePosterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SharePosterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *SharePosterMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *SharePosterMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *SharePosterMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the SharePoster entity.
// If the SharePoster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SharePosterMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *SharePosterMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SharePosterMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SharePosterMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SharePoster entity.
// If the SharePoster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SharePosterMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *SharePosterMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[shareposter.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *SharePosterMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[shareposter.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SharePosterMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, shareposter.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SharePosterMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SharePosterMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SharePoster entity.
// If the SharePoster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SharePosterMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *SharePosterMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[shareposter.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *SharePosterMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[shareposter.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SharePosterMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, shareposter.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SharePosterMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SharePosterMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the SharePoster entity.
// If the SharePoster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SharePosterMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *SharePosterMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[shareposter.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *SharePosterMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[shareposter.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SharePosterMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, shareposter.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *SharePosterMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SharePosterMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the SharePoster entity.
// If the SharePoster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SharePosterMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SharePosterMutation) ResetName() {
	m.name = nil
}

// SetStatus sets the "status" field.
func (m *SharePosterMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *SharePosterMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the SharePoster entity.
// If the SharePoster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SharePosterMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *SharePosterMutation) AddStatus(u uint8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *SharePosterMutation) AddedStatus() (r uint8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *SharePosterMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetURL sets the "url" field.
func (m *SharePosterMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *SharePosterMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the SharePoster entity.
// If the SharePoster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SharePosterMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *SharePosterMutation) ResetURL() {
	m.url = nil
}

// SetRemark sets the "remark" field.
func (m *SharePosterMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *SharePosterMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the SharePoster entity.
// If the SharePoster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SharePosterMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ResetRemark resets all changes to the "remark" field.
func (m *SharePosterMutation) ResetRemark() {
	m.remark = nil
}

// SetSharePosterImgID sets the "share_poster_img_id" field.
func (m *SharePosterMutation) SetSharePosterImgID(i int) {
	m.attachment = &i
}

// SharePosterImgID returns the value of the "share_poster_img_id" field in the mutation.
func (m *SharePosterMutation) SharePosterImgID() (r int, exists bool) {
	v := m.attachment
	if v == nil {
		return
	}
	return *v, true
}

// OldSharePosterImgID returns the old "share_poster_img_id" field's value of the SharePoster entity.
// If the SharePoster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SharePosterMutation) OldSharePosterImgID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSharePosterImgID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSharePosterImgID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSharePosterImgID: %w", err)
	}
	return oldValue.SharePosterImgID, nil
}

// ClearSharePosterImgID clears the value of the "share_poster_img_id" field.
func (m *SharePosterMutation) ClearSharePosterImgID() {
	m.attachment = nil
	m.clearedFields[shareposter.FieldSharePosterImgID] = struct{}{}
}

// SharePosterImgIDCleared returns if the "share_poster_img_id" field was cleared in this mutation.
func (m *SharePosterMutation) SharePosterImgIDCleared() bool {
	_, ok := m.clearedFields[shareposter.FieldSharePosterImgID]
	return ok
}

// ResetSharePosterImgID resets all changes to the "share_poster_img_id" field.
func (m *SharePosterMutation) ResetSharePosterImgID() {
	m.attachment = nil
	delete(m.clearedFields, shareposter.FieldSharePosterImgID)
}

// SetShareCount sets the "share_count" field.
func (m *SharePosterMutation) SetShareCount(i int) {
	m.share_count = &i
	m.addshare_count = nil
}

// ShareCount returns the value of the "share_count" field in the mutation.
func (m *SharePosterMutation) ShareCount() (r int, exists bool) {
	v := m.share_count
	if v == nil {
		return
	}
	return *v, true
}

// OldShareCount returns the old "share_count" field's value of the SharePoster entity.
// If the SharePoster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SharePosterMutation) OldShareCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShareCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShareCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShareCount: %w", err)
	}
	return oldValue.ShareCount, nil
}

// AddShareCount adds i to the "share_count" field.
func (m *SharePosterMutation) AddShareCount(i int) {
	if m.addshare_count != nil {
		*m.addshare_count += i
	} else {
		m.addshare_count = &i
	}
}

// AddedShareCount returns the value that was added to the "share_count" field in this mutation.
func (m *SharePosterMutation) AddedShareCount() (r int, exists bool) {
	v := m.addshare_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetShareCount resets all changes to the "share_count" field.
func (m *SharePosterMutation) ResetShareCount() {
	m.share_count = nil
	m.addshare_count = nil
}

// SetSortOrder sets the "sort_order" field.
func (m *SharePosterMutation) SetSortOrder(i int) {
	m.sort_order = &i
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *SharePosterMutation) SortOrder() (r int, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the SharePoster entity.
// If the SharePoster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SharePosterMutation) OldSortOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds i to the "sort_order" field.
func (m *SharePosterMutation) AddSortOrder(i int) {
	if m.addsort_order != nil {
		*m.addsort_order += i
	} else {
		m.addsort_order = &i
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *SharePosterMutation) AddedSortOrder() (r int, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *SharePosterMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
}

// SetAttachmentID sets the "attachment" edge to the Attachment entity by id.
func (m *SharePosterMutation) SetAttachmentID(id int) {
	m.attachment = &id
}

// ClearAttachment clears the "attachment" edge to the Attachment entity.
func (m *SharePosterMutation) ClearAttachment() {
	m.clearedattachment = true
}

// AttachmentCleared reports if the "attachment" edge to the Attachment entity was cleared.
func (m *SharePosterMutation) AttachmentCleared() bool {
	return m.SharePosterImgIDCleared() || m.clearedattachment
}

// AttachmentID returns the "attachment" edge ID in the mutation.
func (m *SharePosterMutation) AttachmentID() (id int, exists bool) {
	if m.attachment != nil {
		return *m.attachment, true
	}
	return
}

// AttachmentIDs returns the "attachment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AttachmentID instead. It exists only for internal usage by the builders.
func (m *SharePosterMutation) AttachmentIDs() (ids []int) {
	if id := m.attachment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAttachment resets all changes to the "attachment" edge.
func (m *SharePosterMutation) ResetAttachment() {
	m.attachment = nil
	m.clearedattachment = false
}

// Op returns the operation name.
func (m *SharePosterMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (SharePoster).
func (m *SharePosterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SharePosterMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.uuid != nil {
		fields = append(fields, shareposter.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, shareposter.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, shareposter.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, shareposter.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, shareposter.FieldName)
	}
	if m.status != nil {
		fields = append(fields, shareposter.FieldStatus)
	}
	if m.url != nil {
		fields = append(fields, shareposter.FieldURL)
	}
	if m.remark != nil {
		fields = append(fields, shareposter.FieldRemark)
	}
	if m.attachment != nil {
		fields = append(fields, shareposter.FieldSharePosterImgID)
	}
	if m.share_count != nil {
		fields = append(fields, shareposter.FieldShareCount)
	}
	if m.sort_order != nil {
		fields = append(fields, shareposter.FieldSortOrder)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SharePosterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case shareposter.FieldUUID:
		return m.UUID()
	case shareposter.FieldCreatedAt:
		return m.CreatedAt()
	case shareposter.FieldUpdatedAt:
		return m.UpdatedAt()
	case shareposter.FieldDeletedAt:
		return m.DeletedAt()
	case shareposter.FieldName:
		return m.Name()
	case shareposter.FieldStatus:
		return m.Status()
	case shareposter.FieldURL:
		return m.URL()
	case shareposter.FieldRemark:
		return m.Remark()
	case shareposter.FieldSharePosterImgID:
		return m.SharePosterImgID()
	case shareposter.FieldShareCount:
		return m.ShareCount()
	case shareposter.FieldSortOrder:
		return m.SortOrder()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SharePosterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case shareposter.FieldUUID:
		return m.OldUUID(ctx)
	case shareposter.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case shareposter.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case shareposter.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case shareposter.FieldName:
		return m.OldName(ctx)
	case shareposter.FieldStatus:
		return m.OldStatus(ctx)
	case shareposter.FieldURL:
		return m.OldURL(ctx)
	case shareposter.FieldRemark:
		return m.OldRemark(ctx)
	case shareposter.FieldSharePosterImgID:
		return m.OldSharePosterImgID(ctx)
	case shareposter.FieldShareCount:
		return m.OldShareCount(ctx)
	case shareposter.FieldSortOrder:
		return m.OldSortOrder(ctx)
	}
	return nil, fmt.Errorf("unknown SharePoster field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SharePosterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case shareposter.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case shareposter.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case shareposter.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case shareposter.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case shareposter.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case shareposter.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case shareposter.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case shareposter.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case shareposter.FieldSharePosterImgID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSharePosterImgID(v)
		return nil
	case shareposter.FieldShareCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShareCount(v)
		return nil
	case shareposter.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown SharePoster field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SharePosterMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, shareposter.FieldStatus)
	}
	if m.addshare_count != nil {
		fields = append(fields, shareposter.FieldShareCount)
	}
	if m.addsort_order != nil {
		fields = append(fields, shareposter.FieldSortOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SharePosterMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case shareposter.FieldStatus:
		return m.AddedStatus()
	case shareposter.FieldShareCount:
		return m.AddedShareCount()
	case shareposter.FieldSortOrder:
		return m.AddedSortOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SharePosterMutation) AddField(name string, value ent.Value) error {
	switch name {
	case shareposter.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case shareposter.FieldShareCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShareCount(v)
		return nil
	case shareposter.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown SharePoster numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SharePosterMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(shareposter.FieldCreatedAt) {
		fields = append(fields, shareposter.FieldCreatedAt)
	}
	if m.FieldCleared(shareposter.FieldUpdatedAt) {
		fields = append(fields, shareposter.FieldUpdatedAt)
	}
	if m.FieldCleared(shareposter.FieldDeletedAt) {
		fields = append(fields, shareposter.FieldDeletedAt)
	}
	if m.FieldCleared(shareposter.FieldSharePosterImgID) {
		fields = append(fields, shareposter.FieldSharePosterImgID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SharePosterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SharePosterMutation) ClearField(name string) error {
	switch name {
	case shareposter.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case shareposter.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case shareposter.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case shareposter.FieldSharePosterImgID:
		m.ClearSharePosterImgID()
		return nil
	}
	return fmt.Errorf("unknown SharePoster nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SharePosterMutation) ResetField(name string) error {
	switch name {
	case shareposter.FieldUUID:
		m.ResetUUID()
		return nil
	case shareposter.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case shareposter.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case shareposter.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case shareposter.FieldName:
		m.ResetName()
		return nil
	case shareposter.FieldStatus:
		m.ResetStatus()
		return nil
	case shareposter.FieldURL:
		m.ResetURL()
		return nil
	case shareposter.FieldRemark:
		m.ResetRemark()
		return nil
	case shareposter.FieldSharePosterImgID:
		m.ResetSharePosterImgID()
		return nil
	case shareposter.FieldShareCount:
		m.ResetShareCount()
		return nil
	case shareposter.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	}
	return fmt.Errorf("unknown SharePoster field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SharePosterMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.attachment != nil {
		edges = append(edges, shareposter.EdgeAttachment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SharePosterMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case shareposter.EdgeAttachment:
		if id := m.attachment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SharePosterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SharePosterMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SharePosterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedattachment {
		edges = append(edges, shareposter.EdgeAttachment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SharePosterMutation) EdgeCleared(name string) bool {
	switch name {
	case shareposter.EdgeAttachment:
		return m.clearedattachment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SharePosterMutation) ClearEdge(name string) error {
	switch name {
	case shareposter.EdgeAttachment:
		m.ClearAttachment()
		return nil
	}
	return fmt.Errorf("unknown SharePoster unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SharePosterMutation) ResetEdge(name string) error {
	switch name {
	case shareposter.EdgeAttachment:
		m.ResetAttachment()
		return nil
	}
	return fmt.Errorf("unknown SharePoster edge %s", name)
}

// TeacherMutation represents an operation that mutates the Teacher nodes in the graph.
type TeacherMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	uuid                       *string
	created_at                 *time.Time
	updated_at                 *time.Time
	deleted_at                 *time.Time
	name                       *string
	sex                        *uint8
	addsex                     *uint8
	email                      *string
	phone                      *string
	nickname                   *string
	sub_title                  *string
	detail                     *string
	status                     *uint8
	addstatus                  *uint8
	teaching_age               *uint8
	addteaching_age            *uint8
	sort_order                 *int
	addsort_order              *int
	clearedFields              map[string]struct{}
	majors                     map[int]struct{}
	removedmajors              map[int]struct{}
	clearedmajors              bool
	teacher_tags               map[int]struct{}
	removedteacher_tags        map[int]struct{}
	clearedteacher_tags        bool
	teacher_classes            map[int]struct{}
	removedteacher_classes     map[int]struct{}
	clearedteacher_classes     bool
	kc_class_masters           map[int]struct{}
	removedkc_class_masters    map[int]struct{}
	clearedkc_class_masters    bool
	teacher_courses            map[int]struct{}
	removedteacher_courses     map[int]struct{}
	clearedteacher_courses     bool
	user_exams_teachers        map[int]struct{}
	removeduser_exams_teachers map[int]struct{}
	cleareduser_exams_teachers bool
	ask_teachers               map[int]struct{}
	removedask_teachers        map[int]struct{}
	clearedask_teachers        bool
	attachment                 *int
	clearedattachment          bool
	done                       bool
	oldValue                   func(context.Context) (*Teacher, error)
	predicates                 []predicate.Teacher
}

var _ ent.Mutation = (*TeacherMutation)(nil)

// teacherOption allows management of the mutation configuration using functional options.
type teacherOption func(*TeacherMutation)

// newTeacherMutation creates new mutation for the Teacher entity.
func newTeacherMutation(c config, op Op, opts ...teacherOption) *TeacherMutation {
	m := &TeacherMutation{
		config:        c,
		op:            op,
		typ:           TypeTeacher,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTeacherID sets the ID field of the mutation.
func withTeacherID(id int) teacherOption {
	return func(m *TeacherMutation) {
		var (
			err   error
			once  sync.Once
			value *Teacher
		)
		m.oldValue = func(ctx context.Context) (*Teacher, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Teacher.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTeacher sets the old Teacher of the mutation.
func withTeacher(node *Teacher) teacherOption {
	return func(m *TeacherMutation) {
		m.oldValue = func(context.Context) (*Teacher, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TeacherMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TeacherMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *TeacherMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *TeacherMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *TeacherMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the Teacher entity.
// If the Teacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeacherMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *TeacherMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TeacherMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TeacherMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Teacher entity.
// If the Teacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeacherMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *TeacherMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[teacher.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *TeacherMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[teacher.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TeacherMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, teacher.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TeacherMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TeacherMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Teacher entity.
// If the Teacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeacherMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TeacherMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[teacher.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TeacherMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[teacher.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TeacherMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, teacher.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TeacherMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TeacherMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Teacher entity.
// If the Teacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeacherMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TeacherMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[teacher.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TeacherMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[teacher.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TeacherMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, teacher.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *TeacherMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TeacherMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Teacher entity.
// If the Teacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeacherMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TeacherMutation) ResetName() {
	m.name = nil
}

// SetSex sets the "sex" field.
func (m *TeacherMutation) SetSex(u uint8) {
	m.sex = &u
	m.addsex = nil
}

// Sex returns the value of the "sex" field in the mutation.
func (m *TeacherMutation) Sex() (r uint8, exists bool) {
	v := m.sex
	if v == nil {
		return
	}
	return *v, true
}

// OldSex returns the old "sex" field's value of the Teacher entity.
// If the Teacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeacherMutation) OldSex(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSex: %w", err)
	}
	return oldValue.Sex, nil
}

// AddSex adds u to the "sex" field.
func (m *TeacherMutation) AddSex(u uint8) {
	if m.addsex != nil {
		*m.addsex += u
	} else {
		m.addsex = &u
	}
}

// AddedSex returns the value that was added to the "sex" field in this mutation.
func (m *TeacherMutation) AddedSex() (r uint8, exists bool) {
	v := m.addsex
	if v == nil {
		return
	}
	return *v, true
}

// ResetSex resets all changes to the "sex" field.
func (m *TeacherMutation) ResetSex() {
	m.sex = nil
	m.addsex = nil
}

// SetEmail sets the "email" field.
func (m *TeacherMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *TeacherMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Teacher entity.
// If the Teacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeacherMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *TeacherMutation) ResetEmail() {
	m.email = nil
}

// SetPhone sets the "phone" field.
func (m *TeacherMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *TeacherMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Teacher entity.
// If the Teacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeacherMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *TeacherMutation) ResetPhone() {
	m.phone = nil
}

// SetNickname sets the "nickname" field.
func (m *TeacherMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the value of the "nickname" field in the mutation.
func (m *TeacherMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old "nickname" field's value of the Teacher entity.
// If the Teacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeacherMutation) OldNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ResetNickname resets all changes to the "nickname" field.
func (m *TeacherMutation) ResetNickname() {
	m.nickname = nil
}

// SetSubTitle sets the "sub_title" field.
func (m *TeacherMutation) SetSubTitle(s string) {
	m.sub_title = &s
}

// SubTitle returns the value of the "sub_title" field in the mutation.
func (m *TeacherMutation) SubTitle() (r string, exists bool) {
	v := m.sub_title
	if v == nil {
		return
	}
	return *v, true
}

// OldSubTitle returns the old "sub_title" field's value of the Teacher entity.
// If the Teacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeacherMutation) OldSubTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSubTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSubTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubTitle: %w", err)
	}
	return oldValue.SubTitle, nil
}

// ResetSubTitle resets all changes to the "sub_title" field.
func (m *TeacherMutation) ResetSubTitle() {
	m.sub_title = nil
}

// SetDetail sets the "detail" field.
func (m *TeacherMutation) SetDetail(s string) {
	m.detail = &s
}

// Detail returns the value of the "detail" field in the mutation.
func (m *TeacherMutation) Detail() (r string, exists bool) {
	v := m.detail
	if v == nil {
		return
	}
	return *v, true
}

// OldDetail returns the old "detail" field's value of the Teacher entity.
// If the Teacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeacherMutation) OldDetail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDetail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDetail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetail: %w", err)
	}
	return oldValue.Detail, nil
}

// ClearDetail clears the value of the "detail" field.
func (m *TeacherMutation) ClearDetail() {
	m.detail = nil
	m.clearedFields[teacher.FieldDetail] = struct{}{}
}

// DetailCleared returns if the "detail" field was cleared in this mutation.
func (m *TeacherMutation) DetailCleared() bool {
	_, ok := m.clearedFields[teacher.FieldDetail]
	return ok
}

// ResetDetail resets all changes to the "detail" field.
func (m *TeacherMutation) ResetDetail() {
	m.detail = nil
	delete(m.clearedFields, teacher.FieldDetail)
}

// SetStatus sets the "status" field.
func (m *TeacherMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *TeacherMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Teacher entity.
// If the Teacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeacherMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *TeacherMutation) AddStatus(u uint8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *TeacherMutation) AddedStatus() (r uint8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *TeacherMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetTeachingAge sets the "teaching_age" field.
func (m *TeacherMutation) SetTeachingAge(u uint8) {
	m.teaching_age = &u
	m.addteaching_age = nil
}

// TeachingAge returns the value of the "teaching_age" field in the mutation.
func (m *TeacherMutation) TeachingAge() (r uint8, exists bool) {
	v := m.teaching_age
	if v == nil {
		return
	}
	return *v, true
}

// OldTeachingAge returns the old "teaching_age" field's value of the Teacher entity.
// If the Teacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeacherMutation) OldTeachingAge(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTeachingAge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTeachingAge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeachingAge: %w", err)
	}
	return oldValue.TeachingAge, nil
}

// AddTeachingAge adds u to the "teaching_age" field.
func (m *TeacherMutation) AddTeachingAge(u uint8) {
	if m.addteaching_age != nil {
		*m.addteaching_age += u
	} else {
		m.addteaching_age = &u
	}
}

// AddedTeachingAge returns the value that was added to the "teaching_age" field in this mutation.
func (m *TeacherMutation) AddedTeachingAge() (r uint8, exists bool) {
	v := m.addteaching_age
	if v == nil {
		return
	}
	return *v, true
}

// ResetTeachingAge resets all changes to the "teaching_age" field.
func (m *TeacherMutation) ResetTeachingAge() {
	m.teaching_age = nil
	m.addteaching_age = nil
}

// SetAvatarID sets the "avatar_id" field.
func (m *TeacherMutation) SetAvatarID(i int) {
	m.attachment = &i
}

// AvatarID returns the value of the "avatar_id" field in the mutation.
func (m *TeacherMutation) AvatarID() (r int, exists bool) {
	v := m.attachment
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarID returns the old "avatar_id" field's value of the Teacher entity.
// If the Teacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeacherMutation) OldAvatarID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAvatarID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAvatarID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarID: %w", err)
	}
	return oldValue.AvatarID, nil
}

// ClearAvatarID clears the value of the "avatar_id" field.
func (m *TeacherMutation) ClearAvatarID() {
	m.attachment = nil
	m.clearedFields[teacher.FieldAvatarID] = struct{}{}
}

// AvatarIDCleared returns if the "avatar_id" field was cleared in this mutation.
func (m *TeacherMutation) AvatarIDCleared() bool {
	_, ok := m.clearedFields[teacher.FieldAvatarID]
	return ok
}

// ResetAvatarID resets all changes to the "avatar_id" field.
func (m *TeacherMutation) ResetAvatarID() {
	m.attachment = nil
	delete(m.clearedFields, teacher.FieldAvatarID)
}

// SetSortOrder sets the "sort_order" field.
func (m *TeacherMutation) SetSortOrder(i int) {
	m.sort_order = &i
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *TeacherMutation) SortOrder() (r int, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the Teacher entity.
// If the Teacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeacherMutation) OldSortOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds i to the "sort_order" field.
func (m *TeacherMutation) AddSortOrder(i int) {
	if m.addsort_order != nil {
		*m.addsort_order += i
	} else {
		m.addsort_order = &i
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *TeacherMutation) AddedSortOrder() (r int, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *TeacherMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
}

// AddMajorIDs adds the "majors" edge to the Major entity by ids.
func (m *TeacherMutation) AddMajorIDs(ids ...int) {
	if m.majors == nil {
		m.majors = make(map[int]struct{})
	}
	for i := range ids {
		m.majors[ids[i]] = struct{}{}
	}
}

// ClearMajors clears the "majors" edge to the Major entity.
func (m *TeacherMutation) ClearMajors() {
	m.clearedmajors = true
}

// MajorsCleared reports if the "majors" edge to the Major entity was cleared.
func (m *TeacherMutation) MajorsCleared() bool {
	return m.clearedmajors
}

// RemoveMajorIDs removes the "majors" edge to the Major entity by IDs.
func (m *TeacherMutation) RemoveMajorIDs(ids ...int) {
	if m.removedmajors == nil {
		m.removedmajors = make(map[int]struct{})
	}
	for i := range ids {
		m.removedmajors[ids[i]] = struct{}{}
	}
}

// RemovedMajors returns the removed IDs of the "majors" edge to the Major entity.
func (m *TeacherMutation) RemovedMajorsIDs() (ids []int) {
	for id := range m.removedmajors {
		ids = append(ids, id)
	}
	return
}

// MajorsIDs returns the "majors" edge IDs in the mutation.
func (m *TeacherMutation) MajorsIDs() (ids []int) {
	for id := range m.majors {
		ids = append(ids, id)
	}
	return
}

// ResetMajors resets all changes to the "majors" edge.
func (m *TeacherMutation) ResetMajors() {
	m.majors = nil
	m.clearedmajors = false
	m.removedmajors = nil
}

// AddTeacherTagIDs adds the "teacher_tags" edge to the TeacherTag entity by ids.
func (m *TeacherMutation) AddTeacherTagIDs(ids ...int) {
	if m.teacher_tags == nil {
		m.teacher_tags = make(map[int]struct{})
	}
	for i := range ids {
		m.teacher_tags[ids[i]] = struct{}{}
	}
}

// ClearTeacherTags clears the "teacher_tags" edge to the TeacherTag entity.
func (m *TeacherMutation) ClearTeacherTags() {
	m.clearedteacher_tags = true
}

// TeacherTagsCleared reports if the "teacher_tags" edge to the TeacherTag entity was cleared.
func (m *TeacherMutation) TeacherTagsCleared() bool {
	return m.clearedteacher_tags
}

// RemoveTeacherTagIDs removes the "teacher_tags" edge to the TeacherTag entity by IDs.
func (m *TeacherMutation) RemoveTeacherTagIDs(ids ...int) {
	if m.removedteacher_tags == nil {
		m.removedteacher_tags = make(map[int]struct{})
	}
	for i := range ids {
		m.removedteacher_tags[ids[i]] = struct{}{}
	}
}

// RemovedTeacherTags returns the removed IDs of the "teacher_tags" edge to the TeacherTag entity.
func (m *TeacherMutation) RemovedTeacherTagsIDs() (ids []int) {
	for id := range m.removedteacher_tags {
		ids = append(ids, id)
	}
	return
}

// TeacherTagsIDs returns the "teacher_tags" edge IDs in the mutation.
func (m *TeacherMutation) TeacherTagsIDs() (ids []int) {
	for id := range m.teacher_tags {
		ids = append(ids, id)
	}
	return
}

// ResetTeacherTags resets all changes to the "teacher_tags" edge.
func (m *TeacherMutation) ResetTeacherTags() {
	m.teacher_tags = nil
	m.clearedteacher_tags = false
	m.removedteacher_tags = nil
}

// AddTeacherClassIDs adds the "teacher_classes" edge to the KcClassTeacher entity by ids.
func (m *TeacherMutation) AddTeacherClassIDs(ids ...int) {
	if m.teacher_classes == nil {
		m.teacher_classes = make(map[int]struct{})
	}
	for i := range ids {
		m.teacher_classes[ids[i]] = struct{}{}
	}
}

// ClearTeacherClasses clears the "teacher_classes" edge to the KcClassTeacher entity.
func (m *TeacherMutation) ClearTeacherClasses() {
	m.clearedteacher_classes = true
}

// TeacherClassesCleared reports if the "teacher_classes" edge to the KcClassTeacher entity was cleared.
func (m *TeacherMutation) TeacherClassesCleared() bool {
	return m.clearedteacher_classes
}

// RemoveTeacherClassIDs removes the "teacher_classes" edge to the KcClassTeacher entity by IDs.
func (m *TeacherMutation) RemoveTeacherClassIDs(ids ...int) {
	if m.removedteacher_classes == nil {
		m.removedteacher_classes = make(map[int]struct{})
	}
	for i := range ids {
		m.removedteacher_classes[ids[i]] = struct{}{}
	}
}

// RemovedTeacherClasses returns the removed IDs of the "teacher_classes" edge to the KcClassTeacher entity.
func (m *TeacherMutation) RemovedTeacherClassesIDs() (ids []int) {
	for id := range m.removedteacher_classes {
		ids = append(ids, id)
	}
	return
}

// TeacherClassesIDs returns the "teacher_classes" edge IDs in the mutation.
func (m *TeacherMutation) TeacherClassesIDs() (ids []int) {
	for id := range m.teacher_classes {
		ids = append(ids, id)
	}
	return
}

// ResetTeacherClasses resets all changes to the "teacher_classes" edge.
func (m *TeacherMutation) ResetTeacherClasses() {
	m.teacher_classes = nil
	m.clearedteacher_classes = false
	m.removedteacher_classes = nil
}

// AddKcClassMasterIDs adds the "kc_class_masters" edge to the KcClass entity by ids.
func (m *TeacherMutation) AddKcClassMasterIDs(ids ...int) {
	if m.kc_class_masters == nil {
		m.kc_class_masters = make(map[int]struct{})
	}
	for i := range ids {
		m.kc_class_masters[ids[i]] = struct{}{}
	}
}

// ClearKcClassMasters clears the "kc_class_masters" edge to the KcClass entity.
func (m *TeacherMutation) ClearKcClassMasters() {
	m.clearedkc_class_masters = true
}

// KcClassMastersCleared reports if the "kc_class_masters" edge to the KcClass entity was cleared.
func (m *TeacherMutation) KcClassMastersCleared() bool {
	return m.clearedkc_class_masters
}

// RemoveKcClassMasterIDs removes the "kc_class_masters" edge to the KcClass entity by IDs.
func (m *TeacherMutation) RemoveKcClassMasterIDs(ids ...int) {
	if m.removedkc_class_masters == nil {
		m.removedkc_class_masters = make(map[int]struct{})
	}
	for i := range ids {
		m.removedkc_class_masters[ids[i]] = struct{}{}
	}
}

// RemovedKcClassMasters returns the removed IDs of the "kc_class_masters" edge to the KcClass entity.
func (m *TeacherMutation) RemovedKcClassMastersIDs() (ids []int) {
	for id := range m.removedkc_class_masters {
		ids = append(ids, id)
	}
	return
}

// KcClassMastersIDs returns the "kc_class_masters" edge IDs in the mutation.
func (m *TeacherMutation) KcClassMastersIDs() (ids []int) {
	for id := range m.kc_class_masters {
		ids = append(ids, id)
	}
	return
}

// ResetKcClassMasters resets all changes to the "kc_class_masters" edge.
func (m *TeacherMutation) ResetKcClassMasters() {
	m.kc_class_masters = nil
	m.clearedkc_class_masters = false
	m.removedkc_class_masters = nil
}

// AddTeacherCourseIDs adds the "teacher_courses" edge to the KcCourseTeacher entity by ids.
func (m *TeacherMutation) AddTeacherCourseIDs(ids ...int) {
	if m.teacher_courses == nil {
		m.teacher_courses = make(map[int]struct{})
	}
	for i := range ids {
		m.teacher_courses[ids[i]] = struct{}{}
	}
}

// ClearTeacherCourses clears the "teacher_courses" edge to the KcCourseTeacher entity.
func (m *TeacherMutation) ClearTeacherCourses() {
	m.clearedteacher_courses = true
}

// TeacherCoursesCleared reports if the "teacher_courses" edge to the KcCourseTeacher entity was cleared.
func (m *TeacherMutation) TeacherCoursesCleared() bool {
	return m.clearedteacher_courses
}

// RemoveTeacherCourseIDs removes the "teacher_courses" edge to the KcCourseTeacher entity by IDs.
func (m *TeacherMutation) RemoveTeacherCourseIDs(ids ...int) {
	if m.removedteacher_courses == nil {
		m.removedteacher_courses = make(map[int]struct{})
	}
	for i := range ids {
		m.removedteacher_courses[ids[i]] = struct{}{}
	}
}

// RemovedTeacherCourses returns the removed IDs of the "teacher_courses" edge to the KcCourseTeacher entity.
func (m *TeacherMutation) RemovedTeacherCoursesIDs() (ids []int) {
	for id := range m.removedteacher_courses {
		ids = append(ids, id)
	}
	return
}

// TeacherCoursesIDs returns the "teacher_courses" edge IDs in the mutation.
func (m *TeacherMutation) TeacherCoursesIDs() (ids []int) {
	for id := range m.teacher_courses {
		ids = append(ids, id)
	}
	return
}

// ResetTeacherCourses resets all changes to the "teacher_courses" edge.
func (m *TeacherMutation) ResetTeacherCourses() {
	m.teacher_courses = nil
	m.clearedteacher_courses = false
	m.removedteacher_courses = nil
}

// AddUserExamsTeacherIDs adds the "user_exams_teachers" edge to the TkUserExamScoreRecord entity by ids.
func (m *TeacherMutation) AddUserExamsTeacherIDs(ids ...int) {
	if m.user_exams_teachers == nil {
		m.user_exams_teachers = make(map[int]struct{})
	}
	for i := range ids {
		m.user_exams_teachers[ids[i]] = struct{}{}
	}
}

// ClearUserExamsTeachers clears the "user_exams_teachers" edge to the TkUserExamScoreRecord entity.
func (m *TeacherMutation) ClearUserExamsTeachers() {
	m.cleareduser_exams_teachers = true
}

// UserExamsTeachersCleared reports if the "user_exams_teachers" edge to the TkUserExamScoreRecord entity was cleared.
func (m *TeacherMutation) UserExamsTeachersCleared() bool {
	return m.cleareduser_exams_teachers
}

// RemoveUserExamsTeacherIDs removes the "user_exams_teachers" edge to the TkUserExamScoreRecord entity by IDs.
func (m *TeacherMutation) RemoveUserExamsTeacherIDs(ids ...int) {
	if m.removeduser_exams_teachers == nil {
		m.removeduser_exams_teachers = make(map[int]struct{})
	}
	for i := range ids {
		m.removeduser_exams_teachers[ids[i]] = struct{}{}
	}
}

// RemovedUserExamsTeachers returns the removed IDs of the "user_exams_teachers" edge to the TkUserExamScoreRecord entity.
func (m *TeacherMutation) RemovedUserExamsTeachersIDs() (ids []int) {
	for id := range m.removeduser_exams_teachers {
		ids = append(ids, id)
	}
	return
}

// UserExamsTeachersIDs returns the "user_exams_teachers" edge IDs in the mutation.
func (m *TeacherMutation) UserExamsTeachersIDs() (ids []int) {
	for id := range m.user_exams_teachers {
		ids = append(ids, id)
	}
	return
}

// ResetUserExamsTeachers resets all changes to the "user_exams_teachers" edge.
func (m *TeacherMutation) ResetUserExamsTeachers() {
	m.user_exams_teachers = nil
	m.cleareduser_exams_teachers = false
	m.removeduser_exams_teachers = nil
}

// AddAskTeacherIDs adds the "ask_teachers" edge to the UserAskAnswer entity by ids.
func (m *TeacherMutation) AddAskTeacherIDs(ids ...int) {
	if m.ask_teachers == nil {
		m.ask_teachers = make(map[int]struct{})
	}
	for i := range ids {
		m.ask_teachers[ids[i]] = struct{}{}
	}
}

// ClearAskTeachers clears the "ask_teachers" edge to the UserAskAnswer entity.
func (m *TeacherMutation) ClearAskTeachers() {
	m.clearedask_teachers = true
}

// AskTeachersCleared reports if the "ask_teachers" edge to the UserAskAnswer entity was cleared.
func (m *TeacherMutation) AskTeachersCleared() bool {
	return m.clearedask_teachers
}

// RemoveAskTeacherIDs removes the "ask_teachers" edge to the UserAskAnswer entity by IDs.
func (m *TeacherMutation) RemoveAskTeacherIDs(ids ...int) {
	if m.removedask_teachers == nil {
		m.removedask_teachers = make(map[int]struct{})
	}
	for i := range ids {
		m.removedask_teachers[ids[i]] = struct{}{}
	}
}

// RemovedAskTeachers returns the removed IDs of the "ask_teachers" edge to the UserAskAnswer entity.
func (m *TeacherMutation) RemovedAskTeachersIDs() (ids []int) {
	for id := range m.removedask_teachers {
		ids = append(ids, id)
	}
	return
}

// AskTeachersIDs returns the "ask_teachers" edge IDs in the mutation.
func (m *TeacherMutation) AskTeachersIDs() (ids []int) {
	for id := range m.ask_teachers {
		ids = append(ids, id)
	}
	return
}

// ResetAskTeachers resets all changes to the "ask_teachers" edge.
func (m *TeacherMutation) ResetAskTeachers() {
	m.ask_teachers = nil
	m.clearedask_teachers = false
	m.removedask_teachers = nil
}

// SetAttachmentID sets the "attachment" edge to the Attachment entity by id.
func (m *TeacherMutation) SetAttachmentID(id int) {
	m.attachment = &id
}

// ClearAttachment clears the "attachment" edge to the Attachment entity.
func (m *TeacherMutation) ClearAttachment() {
	m.clearedattachment = true
}

// AttachmentCleared reports if the "attachment" edge to the Attachment entity was cleared.
func (m *TeacherMutation) AttachmentCleared() bool {
	return m.AvatarIDCleared() || m.clearedattachment
}

// AttachmentID returns the "attachment" edge ID in the mutation.
func (m *TeacherMutation) AttachmentID() (id int, exists bool) {
	if m.attachment != nil {
		return *m.attachment, true
	}
	return
}

// AttachmentIDs returns the "attachment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AttachmentID instead. It exists only for internal usage by the builders.
func (m *TeacherMutation) AttachmentIDs() (ids []int) {
	if id := m.attachment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAttachment resets all changes to the "attachment" edge.
func (m *TeacherMutation) ResetAttachment() {
	m.attachment = nil
	m.clearedattachment = false
}

// Op returns the operation name.
func (m *TeacherMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Teacher).
func (m *TeacherMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TeacherMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.uuid != nil {
		fields = append(fields, teacher.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, teacher.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, teacher.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, teacher.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, teacher.FieldName)
	}
	if m.sex != nil {
		fields = append(fields, teacher.FieldSex)
	}
	if m.email != nil {
		fields = append(fields, teacher.FieldEmail)
	}
	if m.phone != nil {
		fields = append(fields, teacher.FieldPhone)
	}
	if m.nickname != nil {
		fields = append(fields, teacher.FieldNickname)
	}
	if m.sub_title != nil {
		fields = append(fields, teacher.FieldSubTitle)
	}
	if m.detail != nil {
		fields = append(fields, teacher.FieldDetail)
	}
	if m.status != nil {
		fields = append(fields, teacher.FieldStatus)
	}
	if m.teaching_age != nil {
		fields = append(fields, teacher.FieldTeachingAge)
	}
	if m.attachment != nil {
		fields = append(fields, teacher.FieldAvatarID)
	}
	if m.sort_order != nil {
		fields = append(fields, teacher.FieldSortOrder)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TeacherMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case teacher.FieldUUID:
		return m.UUID()
	case teacher.FieldCreatedAt:
		return m.CreatedAt()
	case teacher.FieldUpdatedAt:
		return m.UpdatedAt()
	case teacher.FieldDeletedAt:
		return m.DeletedAt()
	case teacher.FieldName:
		return m.Name()
	case teacher.FieldSex:
		return m.Sex()
	case teacher.FieldEmail:
		return m.Email()
	case teacher.FieldPhone:
		return m.Phone()
	case teacher.FieldNickname:
		return m.Nickname()
	case teacher.FieldSubTitle:
		return m.SubTitle()
	case teacher.FieldDetail:
		return m.Detail()
	case teacher.FieldStatus:
		return m.Status()
	case teacher.FieldTeachingAge:
		return m.TeachingAge()
	case teacher.FieldAvatarID:
		return m.AvatarID()
	case teacher.FieldSortOrder:
		return m.SortOrder()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TeacherMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case teacher.FieldUUID:
		return m.OldUUID(ctx)
	case teacher.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case teacher.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case teacher.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case teacher.FieldName:
		return m.OldName(ctx)
	case teacher.FieldSex:
		return m.OldSex(ctx)
	case teacher.FieldEmail:
		return m.OldEmail(ctx)
	case teacher.FieldPhone:
		return m.OldPhone(ctx)
	case teacher.FieldNickname:
		return m.OldNickname(ctx)
	case teacher.FieldSubTitle:
		return m.OldSubTitle(ctx)
	case teacher.FieldDetail:
		return m.OldDetail(ctx)
	case teacher.FieldStatus:
		return m.OldStatus(ctx)
	case teacher.FieldTeachingAge:
		return m.OldTeachingAge(ctx)
	case teacher.FieldAvatarID:
		return m.OldAvatarID(ctx)
	case teacher.FieldSortOrder:
		return m.OldSortOrder(ctx)
	}
	return nil, fmt.Errorf("unknown Teacher field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeacherMutation) SetField(name string, value ent.Value) error {
	switch name {
	case teacher.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case teacher.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case teacher.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case teacher.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case teacher.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case teacher.FieldSex:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSex(v)
		return nil
	case teacher.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case teacher.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case teacher.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	case teacher.FieldSubTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubTitle(v)
		return nil
	case teacher.FieldDetail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetail(v)
		return nil
	case teacher.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case teacher.FieldTeachingAge:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeachingAge(v)
		return nil
	case teacher.FieldAvatarID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarID(v)
		return nil
	case teacher.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Teacher field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TeacherMutation) AddedFields() []string {
	var fields []string
	if m.addsex != nil {
		fields = append(fields, teacher.FieldSex)
	}
	if m.addstatus != nil {
		fields = append(fields, teacher.FieldStatus)
	}
	if m.addteaching_age != nil {
		fields = append(fields, teacher.FieldTeachingAge)
	}
	if m.addsort_order != nil {
		fields = append(fields, teacher.FieldSortOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TeacherMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case teacher.FieldSex:
		return m.AddedSex()
	case teacher.FieldStatus:
		return m.AddedStatus()
	case teacher.FieldTeachingAge:
		return m.AddedTeachingAge()
	case teacher.FieldSortOrder:
		return m.AddedSortOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeacherMutation) AddField(name string, value ent.Value) error {
	switch name {
	case teacher.FieldSex:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSex(v)
		return nil
	case teacher.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case teacher.FieldTeachingAge:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTeachingAge(v)
		return nil
	case teacher.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Teacher numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TeacherMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(teacher.FieldCreatedAt) {
		fields = append(fields, teacher.FieldCreatedAt)
	}
	if m.FieldCleared(teacher.FieldUpdatedAt) {
		fields = append(fields, teacher.FieldUpdatedAt)
	}
	if m.FieldCleared(teacher.FieldDeletedAt) {
		fields = append(fields, teacher.FieldDeletedAt)
	}
	if m.FieldCleared(teacher.FieldDetail) {
		fields = append(fields, teacher.FieldDetail)
	}
	if m.FieldCleared(teacher.FieldAvatarID) {
		fields = append(fields, teacher.FieldAvatarID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TeacherMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TeacherMutation) ClearField(name string) error {
	switch name {
	case teacher.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case teacher.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case teacher.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case teacher.FieldDetail:
		m.ClearDetail()
		return nil
	case teacher.FieldAvatarID:
		m.ClearAvatarID()
		return nil
	}
	return fmt.Errorf("unknown Teacher nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TeacherMutation) ResetField(name string) error {
	switch name {
	case teacher.FieldUUID:
		m.ResetUUID()
		return nil
	case teacher.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case teacher.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case teacher.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case teacher.FieldName:
		m.ResetName()
		return nil
	case teacher.FieldSex:
		m.ResetSex()
		return nil
	case teacher.FieldEmail:
		m.ResetEmail()
		return nil
	case teacher.FieldPhone:
		m.ResetPhone()
		return nil
	case teacher.FieldNickname:
		m.ResetNickname()
		return nil
	case teacher.FieldSubTitle:
		m.ResetSubTitle()
		return nil
	case teacher.FieldDetail:
		m.ResetDetail()
		return nil
	case teacher.FieldStatus:
		m.ResetStatus()
		return nil
	case teacher.FieldTeachingAge:
		m.ResetTeachingAge()
		return nil
	case teacher.FieldAvatarID:
		m.ResetAvatarID()
		return nil
	case teacher.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	}
	return fmt.Errorf("unknown Teacher field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TeacherMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.majors != nil {
		edges = append(edges, teacher.EdgeMajors)
	}
	if m.teacher_tags != nil {
		edges = append(edges, teacher.EdgeTeacherTags)
	}
	if m.teacher_classes != nil {
		edges = append(edges, teacher.EdgeTeacherClasses)
	}
	if m.kc_class_masters != nil {
		edges = append(edges, teacher.EdgeKcClassMasters)
	}
	if m.teacher_courses != nil {
		edges = append(edges, teacher.EdgeTeacherCourses)
	}
	if m.user_exams_teachers != nil {
		edges = append(edges, teacher.EdgeUserExamsTeachers)
	}
	if m.ask_teachers != nil {
		edges = append(edges, teacher.EdgeAskTeachers)
	}
	if m.attachment != nil {
		edges = append(edges, teacher.EdgeAttachment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TeacherMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case teacher.EdgeMajors:
		ids := make([]ent.Value, 0, len(m.majors))
		for id := range m.majors {
			ids = append(ids, id)
		}
		return ids
	case teacher.EdgeTeacherTags:
		ids := make([]ent.Value, 0, len(m.teacher_tags))
		for id := range m.teacher_tags {
			ids = append(ids, id)
		}
		return ids
	case teacher.EdgeTeacherClasses:
		ids := make([]ent.Value, 0, len(m.teacher_classes))
		for id := range m.teacher_classes {
			ids = append(ids, id)
		}
		return ids
	case teacher.EdgeKcClassMasters:
		ids := make([]ent.Value, 0, len(m.kc_class_masters))
		for id := range m.kc_class_masters {
			ids = append(ids, id)
		}
		return ids
	case teacher.EdgeTeacherCourses:
		ids := make([]ent.Value, 0, len(m.teacher_courses))
		for id := range m.teacher_courses {
			ids = append(ids, id)
		}
		return ids
	case teacher.EdgeUserExamsTeachers:
		ids := make([]ent.Value, 0, len(m.user_exams_teachers))
		for id := range m.user_exams_teachers {
			ids = append(ids, id)
		}
		return ids
	case teacher.EdgeAskTeachers:
		ids := make([]ent.Value, 0, len(m.ask_teachers))
		for id := range m.ask_teachers {
			ids = append(ids, id)
		}
		return ids
	case teacher.EdgeAttachment:
		if id := m.attachment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TeacherMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedmajors != nil {
		edges = append(edges, teacher.EdgeMajors)
	}
	if m.removedteacher_tags != nil {
		edges = append(edges, teacher.EdgeTeacherTags)
	}
	if m.removedteacher_classes != nil {
		edges = append(edges, teacher.EdgeTeacherClasses)
	}
	if m.removedkc_class_masters != nil {
		edges = append(edges, teacher.EdgeKcClassMasters)
	}
	if m.removedteacher_courses != nil {
		edges = append(edges, teacher.EdgeTeacherCourses)
	}
	if m.removeduser_exams_teachers != nil {
		edges = append(edges, teacher.EdgeUserExamsTeachers)
	}
	if m.removedask_teachers != nil {
		edges = append(edges, teacher.EdgeAskTeachers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TeacherMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case teacher.EdgeMajors:
		ids := make([]ent.Value, 0, len(m.removedmajors))
		for id := range m.removedmajors {
			ids = append(ids, id)
		}
		return ids
	case teacher.EdgeTeacherTags:
		ids := make([]ent.Value, 0, len(m.removedteacher_tags))
		for id := range m.removedteacher_tags {
			ids = append(ids, id)
		}
		return ids
	case teacher.EdgeTeacherClasses:
		ids := make([]ent.Value, 0, len(m.removedteacher_classes))
		for id := range m.removedteacher_classes {
			ids = append(ids, id)
		}
		return ids
	case teacher.EdgeKcClassMasters:
		ids := make([]ent.Value, 0, len(m.removedkc_class_masters))
		for id := range m.removedkc_class_masters {
			ids = append(ids, id)
		}
		return ids
	case teacher.EdgeTeacherCourses:
		ids := make([]ent.Value, 0, len(m.removedteacher_courses))
		for id := range m.removedteacher_courses {
			ids = append(ids, id)
		}
		return ids
	case teacher.EdgeUserExamsTeachers:
		ids := make([]ent.Value, 0, len(m.removeduser_exams_teachers))
		for id := range m.removeduser_exams_teachers {
			ids = append(ids, id)
		}
		return ids
	case teacher.EdgeAskTeachers:
		ids := make([]ent.Value, 0, len(m.removedask_teachers))
		for id := range m.removedask_teachers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TeacherMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedmajors {
		edges = append(edges, teacher.EdgeMajors)
	}
	if m.clearedteacher_tags {
		edges = append(edges, teacher.EdgeTeacherTags)
	}
	if m.clearedteacher_classes {
		edges = append(edges, teacher.EdgeTeacherClasses)
	}
	if m.clearedkc_class_masters {
		edges = append(edges, teacher.EdgeKcClassMasters)
	}
	if m.clearedteacher_courses {
		edges = append(edges, teacher.EdgeTeacherCourses)
	}
	if m.cleareduser_exams_teachers {
		edges = append(edges, teacher.EdgeUserExamsTeachers)
	}
	if m.clearedask_teachers {
		edges = append(edges, teacher.EdgeAskTeachers)
	}
	if m.clearedattachment {
		edges = append(edges, teacher.EdgeAttachment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TeacherMutation) EdgeCleared(name string) bool {
	switch name {
	case teacher.EdgeMajors:
		return m.clearedmajors
	case teacher.EdgeTeacherTags:
		return m.clearedteacher_tags
	case teacher.EdgeTeacherClasses:
		return m.clearedteacher_classes
	case teacher.EdgeKcClassMasters:
		return m.clearedkc_class_masters
	case teacher.EdgeTeacherCourses:
		return m.clearedteacher_courses
	case teacher.EdgeUserExamsTeachers:
		return m.cleareduser_exams_teachers
	case teacher.EdgeAskTeachers:
		return m.clearedask_teachers
	case teacher.EdgeAttachment:
		return m.clearedattachment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TeacherMutation) ClearEdge(name string) error {
	switch name {
	case teacher.EdgeAttachment:
		m.ClearAttachment()
		return nil
	}
	return fmt.Errorf("unknown Teacher unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TeacherMutation) ResetEdge(name string) error {
	switch name {
	case teacher.EdgeMajors:
		m.ResetMajors()
		return nil
	case teacher.EdgeTeacherTags:
		m.ResetTeacherTags()
		return nil
	case teacher.EdgeTeacherClasses:
		m.ResetTeacherClasses()
		return nil
	case teacher.EdgeKcClassMasters:
		m.ResetKcClassMasters()
		return nil
	case teacher.EdgeTeacherCourses:
		m.ResetTeacherCourses()
		return nil
	case teacher.EdgeUserExamsTeachers:
		m.ResetUserExamsTeachers()
		return nil
	case teacher.EdgeAskTeachers:
		m.ResetAskTeachers()
		return nil
	case teacher.EdgeAttachment:
		m.ResetAttachment()
		return nil
	}
	return fmt.Errorf("unknown Teacher edge %s", name)
}

// TeacherTagMutation represents an operation that mutates the TeacherTag nodes in the graph.
type TeacherTagMutation struct {
	config
	op             Op
	typ            string
	id             *int
	uuid           *string
	created_at     *time.Time
	updated_at     *time.Time
	deleted_at     *time.Time
	name           *string
	clearedFields  map[string]struct{}
	teacher        *int
	clearedteacher bool
	done           bool
	oldValue       func(context.Context) (*TeacherTag, error)
	predicates     []predicate.TeacherTag
}

var _ ent.Mutation = (*TeacherTagMutation)(nil)

// teachertagOption allows management of the mutation configuration using functional options.
type teachertagOption func(*TeacherTagMutation)

// newTeacherTagMutation creates new mutation for the TeacherTag entity.
func newTeacherTagMutation(c config, op Op, opts ...teachertagOption) *TeacherTagMutation {
	m := &TeacherTagMutation{
		config:        c,
		op:            op,
		typ:           TypeTeacherTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTeacherTagID sets the ID field of the mutation.
func withTeacherTagID(id int) teachertagOption {
	return func(m *TeacherTagMutation) {
		var (
			err   error
			once  sync.Once
			value *TeacherTag
		)
		m.oldValue = func(ctx context.Context) (*TeacherTag, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TeacherTag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTeacherTag sets the old TeacherTag of the mutation.
func withTeacherTag(node *TeacherTag) teachertagOption {
	return func(m *TeacherTagMutation) {
		m.oldValue = func(context.Context) (*TeacherTag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TeacherTagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TeacherTagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *TeacherTagMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *TeacherTagMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *TeacherTagMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the TeacherTag entity.
// If the TeacherTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeacherTagMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *TeacherTagMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TeacherTagMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TeacherTagMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TeacherTag entity.
// If the TeacherTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeacherTagMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *TeacherTagMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[teachertag.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *TeacherTagMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[teachertag.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TeacherTagMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, teachertag.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TeacherTagMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TeacherTagMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TeacherTag entity.
// If the TeacherTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeacherTagMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TeacherTagMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[teachertag.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TeacherTagMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[teachertag.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TeacherTagMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, teachertag.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TeacherTagMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TeacherTagMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TeacherTag entity.
// If the TeacherTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeacherTagMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TeacherTagMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[teachertag.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TeacherTagMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[teachertag.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TeacherTagMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, teachertag.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *TeacherTagMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TeacherTagMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TeacherTag entity.
// If the TeacherTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeacherTagMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TeacherTagMutation) ResetName() {
	m.name = nil
}

// SetTeacherID sets the "teacher_id" field.
func (m *TeacherTagMutation) SetTeacherID(i int) {
	m.teacher = &i
}

// TeacherID returns the value of the "teacher_id" field in the mutation.
func (m *TeacherTagMutation) TeacherID() (r int, exists bool) {
	v := m.teacher
	if v == nil {
		return
	}
	return *v, true
}

// OldTeacherID returns the old "teacher_id" field's value of the TeacherTag entity.
// If the TeacherTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeacherTagMutation) OldTeacherID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTeacherID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTeacherID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeacherID: %w", err)
	}
	return oldValue.TeacherID, nil
}

// ClearTeacherID clears the value of the "teacher_id" field.
func (m *TeacherTagMutation) ClearTeacherID() {
	m.teacher = nil
	m.clearedFields[teachertag.FieldTeacherID] = struct{}{}
}

// TeacherIDCleared returns if the "teacher_id" field was cleared in this mutation.
func (m *TeacherTagMutation) TeacherIDCleared() bool {
	_, ok := m.clearedFields[teachertag.FieldTeacherID]
	return ok
}

// ResetTeacherID resets all changes to the "teacher_id" field.
func (m *TeacherTagMutation) ResetTeacherID() {
	m.teacher = nil
	delete(m.clearedFields, teachertag.FieldTeacherID)
}

// ClearTeacher clears the "teacher" edge to the Teacher entity.
func (m *TeacherTagMutation) ClearTeacher() {
	m.clearedteacher = true
}

// TeacherCleared reports if the "teacher" edge to the Teacher entity was cleared.
func (m *TeacherTagMutation) TeacherCleared() bool {
	return m.TeacherIDCleared() || m.clearedteacher
}

// TeacherIDs returns the "teacher" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeacherID instead. It exists only for internal usage by the builders.
func (m *TeacherTagMutation) TeacherIDs() (ids []int) {
	if id := m.teacher; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeacher resets all changes to the "teacher" edge.
func (m *TeacherTagMutation) ResetTeacher() {
	m.teacher = nil
	m.clearedteacher = false
}

// Op returns the operation name.
func (m *TeacherTagMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TeacherTag).
func (m *TeacherTagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TeacherTagMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.uuid != nil {
		fields = append(fields, teachertag.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, teachertag.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, teachertag.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, teachertag.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, teachertag.FieldName)
	}
	if m.teacher != nil {
		fields = append(fields, teachertag.FieldTeacherID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TeacherTagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case teachertag.FieldUUID:
		return m.UUID()
	case teachertag.FieldCreatedAt:
		return m.CreatedAt()
	case teachertag.FieldUpdatedAt:
		return m.UpdatedAt()
	case teachertag.FieldDeletedAt:
		return m.DeletedAt()
	case teachertag.FieldName:
		return m.Name()
	case teachertag.FieldTeacherID:
		return m.TeacherID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TeacherTagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case teachertag.FieldUUID:
		return m.OldUUID(ctx)
	case teachertag.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case teachertag.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case teachertag.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case teachertag.FieldName:
		return m.OldName(ctx)
	case teachertag.FieldTeacherID:
		return m.OldTeacherID(ctx)
	}
	return nil, fmt.Errorf("unknown TeacherTag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeacherTagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case teachertag.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case teachertag.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case teachertag.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case teachertag.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case teachertag.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case teachertag.FieldTeacherID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeacherID(v)
		return nil
	}
	return fmt.Errorf("unknown TeacherTag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TeacherTagMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TeacherTagMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeacherTagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TeacherTag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TeacherTagMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(teachertag.FieldCreatedAt) {
		fields = append(fields, teachertag.FieldCreatedAt)
	}
	if m.FieldCleared(teachertag.FieldUpdatedAt) {
		fields = append(fields, teachertag.FieldUpdatedAt)
	}
	if m.FieldCleared(teachertag.FieldDeletedAt) {
		fields = append(fields, teachertag.FieldDeletedAt)
	}
	if m.FieldCleared(teachertag.FieldTeacherID) {
		fields = append(fields, teachertag.FieldTeacherID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TeacherTagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TeacherTagMutation) ClearField(name string) error {
	switch name {
	case teachertag.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case teachertag.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case teachertag.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case teachertag.FieldTeacherID:
		m.ClearTeacherID()
		return nil
	}
	return fmt.Errorf("unknown TeacherTag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TeacherTagMutation) ResetField(name string) error {
	switch name {
	case teachertag.FieldUUID:
		m.ResetUUID()
		return nil
	case teachertag.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case teachertag.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case teachertag.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case teachertag.FieldName:
		m.ResetName()
		return nil
	case teachertag.FieldTeacherID:
		m.ResetTeacherID()
		return nil
	}
	return fmt.Errorf("unknown TeacherTag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TeacherTagMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.teacher != nil {
		edges = append(edges, teachertag.EdgeTeacher)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TeacherTagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case teachertag.EdgeTeacher:
		if id := m.teacher; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TeacherTagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TeacherTagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TeacherTagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedteacher {
		edges = append(edges, teachertag.EdgeTeacher)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TeacherTagMutation) EdgeCleared(name string) bool {
	switch name {
	case teachertag.EdgeTeacher:
		return m.clearedteacher
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TeacherTagMutation) ClearEdge(name string) error {
	switch name {
	case teachertag.EdgeTeacher:
		m.ClearTeacher()
		return nil
	}
	return fmt.Errorf("unknown TeacherTag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TeacherTagMutation) ResetEdge(name string) error {
	switch name {
	case teachertag.EdgeTeacher:
		m.ResetTeacher()
		return nil
	}
	return fmt.Errorf("unknown TeacherTag edge %s", name)
}

// TkChapterMutation represents an operation that mutates the TkChapter nodes in the graph.
type TkChapterMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	uuid                 *string
	created_at           *time.Time
	updated_at           *time.Time
	deleted_at           *time.Time
	name                 *string
	question_count       *int
	addquestion_count    *int
	clearedFields        map[string]struct{}
	question_bank        *int
	clearedquestion_bank bool
	sections             map[int]struct{}
	removedsections      map[int]struct{}
	clearedsections      bool
	done                 bool
	oldValue             func(context.Context) (*TkChapter, error)
	predicates           []predicate.TkChapter
}

var _ ent.Mutation = (*TkChapterMutation)(nil)

// tkchapterOption allows management of the mutation configuration using functional options.
type tkchapterOption func(*TkChapterMutation)

// newTkChapterMutation creates new mutation for the TkChapter entity.
func newTkChapterMutation(c config, op Op, opts ...tkchapterOption) *TkChapterMutation {
	m := &TkChapterMutation{
		config:        c,
		op:            op,
		typ:           TypeTkChapter,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTkChapterID sets the ID field of the mutation.
func withTkChapterID(id int) tkchapterOption {
	return func(m *TkChapterMutation) {
		var (
			err   error
			once  sync.Once
			value *TkChapter
		)
		m.oldValue = func(ctx context.Context) (*TkChapter, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TkChapter.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTkChapter sets the old TkChapter of the mutation.
func withTkChapter(node *TkChapter) tkchapterOption {
	return func(m *TkChapterMutation) {
		m.oldValue = func(context.Context) (*TkChapter, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TkChapterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TkChapterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *TkChapterMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *TkChapterMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *TkChapterMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the TkChapter entity.
// If the TkChapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkChapterMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *TkChapterMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TkChapterMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TkChapterMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TkChapter entity.
// If the TkChapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkChapterMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *TkChapterMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[tkchapter.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *TkChapterMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[tkchapter.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TkChapterMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, tkchapter.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TkChapterMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TkChapterMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TkChapter entity.
// If the TkChapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkChapterMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TkChapterMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[tkchapter.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TkChapterMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[tkchapter.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TkChapterMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, tkchapter.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TkChapterMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TkChapterMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TkChapter entity.
// If the TkChapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkChapterMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TkChapterMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[tkchapter.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TkChapterMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[tkchapter.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TkChapterMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, tkchapter.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *TkChapterMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TkChapterMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TkChapter entity.
// If the TkChapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkChapterMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TkChapterMutation) ResetName() {
	m.name = nil
}

// SetQuestionBankID sets the "question_bank_id" field.
func (m *TkChapterMutation) SetQuestionBankID(i int) {
	m.question_bank = &i
}

// QuestionBankID returns the value of the "question_bank_id" field in the mutation.
func (m *TkChapterMutation) QuestionBankID() (r int, exists bool) {
	v := m.question_bank
	if v == nil {
		return
	}
	return *v, true
}

// OldQuestionBankID returns the old "question_bank_id" field's value of the TkChapter entity.
// If the TkChapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkChapterMutation) OldQuestionBankID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldQuestionBankID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldQuestionBankID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuestionBankID: %w", err)
	}
	return oldValue.QuestionBankID, nil
}

// ClearQuestionBankID clears the value of the "question_bank_id" field.
func (m *TkChapterMutation) ClearQuestionBankID() {
	m.question_bank = nil
	m.clearedFields[tkchapter.FieldQuestionBankID] = struct{}{}
}

// QuestionBankIDCleared returns if the "question_bank_id" field was cleared in this mutation.
func (m *TkChapterMutation) QuestionBankIDCleared() bool {
	_, ok := m.clearedFields[tkchapter.FieldQuestionBankID]
	return ok
}

// ResetQuestionBankID resets all changes to the "question_bank_id" field.
func (m *TkChapterMutation) ResetQuestionBankID() {
	m.question_bank = nil
	delete(m.clearedFields, tkchapter.FieldQuestionBankID)
}

// SetQuestionCount sets the "question_count" field.
func (m *TkChapterMutation) SetQuestionCount(i int) {
	m.question_count = &i
	m.addquestion_count = nil
}

// QuestionCount returns the value of the "question_count" field in the mutation.
func (m *TkChapterMutation) QuestionCount() (r int, exists bool) {
	v := m.question_count
	if v == nil {
		return
	}
	return *v, true
}

// OldQuestionCount returns the old "question_count" field's value of the TkChapter entity.
// If the TkChapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkChapterMutation) OldQuestionCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldQuestionCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldQuestionCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuestionCount: %w", err)
	}
	return oldValue.QuestionCount, nil
}

// AddQuestionCount adds i to the "question_count" field.
func (m *TkChapterMutation) AddQuestionCount(i int) {
	if m.addquestion_count != nil {
		*m.addquestion_count += i
	} else {
		m.addquestion_count = &i
	}
}

// AddedQuestionCount returns the value that was added to the "question_count" field in this mutation.
func (m *TkChapterMutation) AddedQuestionCount() (r int, exists bool) {
	v := m.addquestion_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuestionCount resets all changes to the "question_count" field.
func (m *TkChapterMutation) ResetQuestionCount() {
	m.question_count = nil
	m.addquestion_count = nil
}

// ClearQuestionBank clears the "question_bank" edge to the TkQuestionBank entity.
func (m *TkChapterMutation) ClearQuestionBank() {
	m.clearedquestion_bank = true
}

// QuestionBankCleared reports if the "question_bank" edge to the TkQuestionBank entity was cleared.
func (m *TkChapterMutation) QuestionBankCleared() bool {
	return m.QuestionBankIDCleared() || m.clearedquestion_bank
}

// QuestionBankIDs returns the "question_bank" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// QuestionBankID instead. It exists only for internal usage by the builders.
func (m *TkChapterMutation) QuestionBankIDs() (ids []int) {
	if id := m.question_bank; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetQuestionBank resets all changes to the "question_bank" edge.
func (m *TkChapterMutation) ResetQuestionBank() {
	m.question_bank = nil
	m.clearedquestion_bank = false
}

// AddSectionIDs adds the "sections" edge to the TkSection entity by ids.
func (m *TkChapterMutation) AddSectionIDs(ids ...int) {
	if m.sections == nil {
		m.sections = make(map[int]struct{})
	}
	for i := range ids {
		m.sections[ids[i]] = struct{}{}
	}
}

// ClearSections clears the "sections" edge to the TkSection entity.
func (m *TkChapterMutation) ClearSections() {
	m.clearedsections = true
}

// SectionsCleared reports if the "sections" edge to the TkSection entity was cleared.
func (m *TkChapterMutation) SectionsCleared() bool {
	return m.clearedsections
}

// RemoveSectionIDs removes the "sections" edge to the TkSection entity by IDs.
func (m *TkChapterMutation) RemoveSectionIDs(ids ...int) {
	if m.removedsections == nil {
		m.removedsections = make(map[int]struct{})
	}
	for i := range ids {
		m.removedsections[ids[i]] = struct{}{}
	}
}

// RemovedSections returns the removed IDs of the "sections" edge to the TkSection entity.
func (m *TkChapterMutation) RemovedSectionsIDs() (ids []int) {
	for id := range m.removedsections {
		ids = append(ids, id)
	}
	return
}

// SectionsIDs returns the "sections" edge IDs in the mutation.
func (m *TkChapterMutation) SectionsIDs() (ids []int) {
	for id := range m.sections {
		ids = append(ids, id)
	}
	return
}

// ResetSections resets all changes to the "sections" edge.
func (m *TkChapterMutation) ResetSections() {
	m.sections = nil
	m.clearedsections = false
	m.removedsections = nil
}

// Op returns the operation name.
func (m *TkChapterMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TkChapter).
func (m *TkChapterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TkChapterMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.uuid != nil {
		fields = append(fields, tkchapter.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, tkchapter.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tkchapter.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, tkchapter.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, tkchapter.FieldName)
	}
	if m.question_bank != nil {
		fields = append(fields, tkchapter.FieldQuestionBankID)
	}
	if m.question_count != nil {
		fields = append(fields, tkchapter.FieldQuestionCount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TkChapterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tkchapter.FieldUUID:
		return m.UUID()
	case tkchapter.FieldCreatedAt:
		return m.CreatedAt()
	case tkchapter.FieldUpdatedAt:
		return m.UpdatedAt()
	case tkchapter.FieldDeletedAt:
		return m.DeletedAt()
	case tkchapter.FieldName:
		return m.Name()
	case tkchapter.FieldQuestionBankID:
		return m.QuestionBankID()
	case tkchapter.FieldQuestionCount:
		return m.QuestionCount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TkChapterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tkchapter.FieldUUID:
		return m.OldUUID(ctx)
	case tkchapter.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tkchapter.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tkchapter.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case tkchapter.FieldName:
		return m.OldName(ctx)
	case tkchapter.FieldQuestionBankID:
		return m.OldQuestionBankID(ctx)
	case tkchapter.FieldQuestionCount:
		return m.OldQuestionCount(ctx)
	}
	return nil, fmt.Errorf("unknown TkChapter field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TkChapterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tkchapter.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case tkchapter.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tkchapter.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tkchapter.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case tkchapter.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tkchapter.FieldQuestionBankID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuestionBankID(v)
		return nil
	case tkchapter.FieldQuestionCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuestionCount(v)
		return nil
	}
	return fmt.Errorf("unknown TkChapter field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TkChapterMutation) AddedFields() []string {
	var fields []string
	if m.addquestion_count != nil {
		fields = append(fields, tkchapter.FieldQuestionCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TkChapterMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tkchapter.FieldQuestionCount:
		return m.AddedQuestionCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TkChapterMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tkchapter.FieldQuestionCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuestionCount(v)
		return nil
	}
	return fmt.Errorf("unknown TkChapter numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TkChapterMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tkchapter.FieldCreatedAt) {
		fields = append(fields, tkchapter.FieldCreatedAt)
	}
	if m.FieldCleared(tkchapter.FieldUpdatedAt) {
		fields = append(fields, tkchapter.FieldUpdatedAt)
	}
	if m.FieldCleared(tkchapter.FieldDeletedAt) {
		fields = append(fields, tkchapter.FieldDeletedAt)
	}
	if m.FieldCleared(tkchapter.FieldQuestionBankID) {
		fields = append(fields, tkchapter.FieldQuestionBankID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TkChapterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TkChapterMutation) ClearField(name string) error {
	switch name {
	case tkchapter.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case tkchapter.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case tkchapter.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case tkchapter.FieldQuestionBankID:
		m.ClearQuestionBankID()
		return nil
	}
	return fmt.Errorf("unknown TkChapter nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TkChapterMutation) ResetField(name string) error {
	switch name {
	case tkchapter.FieldUUID:
		m.ResetUUID()
		return nil
	case tkchapter.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tkchapter.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tkchapter.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case tkchapter.FieldName:
		m.ResetName()
		return nil
	case tkchapter.FieldQuestionBankID:
		m.ResetQuestionBankID()
		return nil
	case tkchapter.FieldQuestionCount:
		m.ResetQuestionCount()
		return nil
	}
	return fmt.Errorf("unknown TkChapter field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TkChapterMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.question_bank != nil {
		edges = append(edges, tkchapter.EdgeQuestionBank)
	}
	if m.sections != nil {
		edges = append(edges, tkchapter.EdgeSections)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TkChapterMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tkchapter.EdgeQuestionBank:
		if id := m.question_bank; id != nil {
			return []ent.Value{*id}
		}
	case tkchapter.EdgeSections:
		ids := make([]ent.Value, 0, len(m.sections))
		for id := range m.sections {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TkChapterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedsections != nil {
		edges = append(edges, tkchapter.EdgeSections)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TkChapterMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tkchapter.EdgeSections:
		ids := make([]ent.Value, 0, len(m.removedsections))
		for id := range m.removedsections {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TkChapterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedquestion_bank {
		edges = append(edges, tkchapter.EdgeQuestionBank)
	}
	if m.clearedsections {
		edges = append(edges, tkchapter.EdgeSections)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TkChapterMutation) EdgeCleared(name string) bool {
	switch name {
	case tkchapter.EdgeQuestionBank:
		return m.clearedquestion_bank
	case tkchapter.EdgeSections:
		return m.clearedsections
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TkChapterMutation) ClearEdge(name string) error {
	switch name {
	case tkchapter.EdgeQuestionBank:
		m.ClearQuestionBank()
		return nil
	}
	return fmt.Errorf("unknown TkChapter unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TkChapterMutation) ResetEdge(name string) error {
	switch name {
	case tkchapter.EdgeQuestionBank:
		m.ResetQuestionBank()
		return nil
	case tkchapter.EdgeSections:
		m.ResetSections()
		return nil
	}
	return fmt.Errorf("unknown TkChapter edge %s", name)
}

// TkExamPaperMutation represents an operation that mutates the TkExamPaper nodes in the graph.
type TkExamPaperMutation struct {
	config
	op                             Op
	typ                            string
	id                             *int
	uuid                           *string
	created_at                     *time.Time
	updated_at                     *time.Time
	deleted_at                     *time.Time
	name                           *string
	desc                           *string
	exam_question_type             *uint8
	addexam_question_type          *uint8
	exam_type                      *uint8
	addexam_type                   *uint8
	difficulty                     *uint8
	adddifficulty                  *uint8
	question_count                 *int
	addquestion_count              *int
	answered_user_count            *int
	addanswered_user_count         *int
	score                          *int
	addscore                       *int
	pass_score                     *int
	addpass_score                  *int
	duration                       *int
	addduration                    *int
	duration_type                  *int
	addduration_type               *int
	start_at                       *time.Time
	end_at                         *time.Time
	enable_status                  *uint8
	addenable_status               *uint8
	clearedFields                  map[string]struct{}
	question_bank                  *int
	clearedquestion_bank           bool
	admin                          *int
	clearedadmin                   bool
	exam_partitions                map[int]struct{}
	removedexam_partitions         map[int]struct{}
	clearedexam_partitions         bool
	make_user_question_exam        map[int]struct{}
	removedmake_user_question_exam map[int]struct{}
	clearedmake_user_question_exam bool
	user_exam_papers               map[int]struct{}
	removeduser_exam_papers        map[int]struct{}
	cleareduser_exam_papers        bool
	course_exam_papers             map[int]struct{}
	removedcourse_exam_papers      map[int]struct{}
	clearedcourse_exam_papers      bool
	exam_paper_records             map[int]struct{}
	removedexam_paper_records      map[int]struct{}
	clearedexam_paper_records      bool
	user_random_exam               map[int]struct{}
	removeduser_random_exam        map[int]struct{}
	cleareduser_random_exam        bool
	done                           bool
	oldValue                       func(context.Context) (*TkExamPaper, error)
	predicates                     []predicate.TkExamPaper
}

var _ ent.Mutation = (*TkExamPaperMutation)(nil)

// tkexampaperOption allows management of the mutation configuration using functional options.
type tkexampaperOption func(*TkExamPaperMutation)

// newTkExamPaperMutation creates new mutation for the TkExamPaper entity.
func newTkExamPaperMutation(c config, op Op, opts ...tkexampaperOption) *TkExamPaperMutation {
	m := &TkExamPaperMutation{
		config:        c,
		op:            op,
		typ:           TypeTkExamPaper,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTkExamPaperID sets the ID field of the mutation.
func withTkExamPaperID(id int) tkexampaperOption {
	return func(m *TkExamPaperMutation) {
		var (
			err   error
			once  sync.Once
			value *TkExamPaper
		)
		m.oldValue = func(ctx context.Context) (*TkExamPaper, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TkExamPaper.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTkExamPaper sets the old TkExamPaper of the mutation.
func withTkExamPaper(node *TkExamPaper) tkexampaperOption {
	return func(m *TkExamPaperMutation) {
		m.oldValue = func(context.Context) (*TkExamPaper, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TkExamPaperMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TkExamPaperMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *TkExamPaperMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *TkExamPaperMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *TkExamPaperMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the TkExamPaper entity.
// If the TkExamPaper object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamPaperMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *TkExamPaperMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TkExamPaperMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TkExamPaperMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TkExamPaper entity.
// If the TkExamPaper object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamPaperMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *TkExamPaperMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[tkexampaper.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *TkExamPaperMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[tkexampaper.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TkExamPaperMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, tkexampaper.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TkExamPaperMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TkExamPaperMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TkExamPaper entity.
// If the TkExamPaper object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamPaperMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TkExamPaperMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[tkexampaper.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TkExamPaperMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[tkexampaper.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TkExamPaperMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, tkexampaper.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TkExamPaperMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TkExamPaperMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TkExamPaper entity.
// If the TkExamPaper object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamPaperMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TkExamPaperMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[tkexampaper.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TkExamPaperMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[tkexampaper.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TkExamPaperMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, tkexampaper.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *TkExamPaperMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TkExamPaperMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TkExamPaper entity.
// If the TkExamPaper object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamPaperMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TkExamPaperMutation) ResetName() {
	m.name = nil
}

// SetDesc sets the "desc" field.
func (m *TkExamPaperMutation) SetDesc(s string) {
	m.desc = &s
}

// Desc returns the value of the "desc" field in the mutation.
func (m *TkExamPaperMutation) Desc() (r string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the TkExamPaper entity.
// If the TkExamPaper object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamPaperMutation) OldDesc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// ResetDesc resets all changes to the "desc" field.
func (m *TkExamPaperMutation) ResetDesc() {
	m.desc = nil
}

// SetExamQuestionType sets the "exam_question_type" field.
func (m *TkExamPaperMutation) SetExamQuestionType(u uint8) {
	m.exam_question_type = &u
	m.addexam_question_type = nil
}

// ExamQuestionType returns the value of the "exam_question_type" field in the mutation.
func (m *TkExamPaperMutation) ExamQuestionType() (r uint8, exists bool) {
	v := m.exam_question_type
	if v == nil {
		return
	}
	return *v, true
}

// OldExamQuestionType returns the old "exam_question_type" field's value of the TkExamPaper entity.
// If the TkExamPaper object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamPaperMutation) OldExamQuestionType(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExamQuestionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExamQuestionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamQuestionType: %w", err)
	}
	return oldValue.ExamQuestionType, nil
}

// AddExamQuestionType adds u to the "exam_question_type" field.
func (m *TkExamPaperMutation) AddExamQuestionType(u uint8) {
	if m.addexam_question_type != nil {
		*m.addexam_question_type += u
	} else {
		m.addexam_question_type = &u
	}
}

// AddedExamQuestionType returns the value that was added to the "exam_question_type" field in this mutation.
func (m *TkExamPaperMutation) AddedExamQuestionType() (r uint8, exists bool) {
	v := m.addexam_question_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetExamQuestionType resets all changes to the "exam_question_type" field.
func (m *TkExamPaperMutation) ResetExamQuestionType() {
	m.exam_question_type = nil
	m.addexam_question_type = nil
}

// SetExamType sets the "exam_type" field.
func (m *TkExamPaperMutation) SetExamType(u uint8) {
	m.exam_type = &u
	m.addexam_type = nil
}

// ExamType returns the value of the "exam_type" field in the mutation.
func (m *TkExamPaperMutation) ExamType() (r uint8, exists bool) {
	v := m.exam_type
	if v == nil {
		return
	}
	return *v, true
}

// OldExamType returns the old "exam_type" field's value of the TkExamPaper entity.
// If the TkExamPaper object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamPaperMutation) OldExamType(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExamType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExamType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamType: %w", err)
	}
	return oldValue.ExamType, nil
}

// AddExamType adds u to the "exam_type" field.
func (m *TkExamPaperMutation) AddExamType(u uint8) {
	if m.addexam_type != nil {
		*m.addexam_type += u
	} else {
		m.addexam_type = &u
	}
}

// AddedExamType returns the value that was added to the "exam_type" field in this mutation.
func (m *TkExamPaperMutation) AddedExamType() (r uint8, exists bool) {
	v := m.addexam_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetExamType resets all changes to the "exam_type" field.
func (m *TkExamPaperMutation) ResetExamType() {
	m.exam_type = nil
	m.addexam_type = nil
}

// SetDifficulty sets the "difficulty" field.
func (m *TkExamPaperMutation) SetDifficulty(u uint8) {
	m.difficulty = &u
	m.adddifficulty = nil
}

// Difficulty returns the value of the "difficulty" field in the mutation.
func (m *TkExamPaperMutation) Difficulty() (r uint8, exists bool) {
	v := m.difficulty
	if v == nil {
		return
	}
	return *v, true
}

// OldDifficulty returns the old "difficulty" field's value of the TkExamPaper entity.
// If the TkExamPaper object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamPaperMutation) OldDifficulty(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDifficulty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDifficulty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDifficulty: %w", err)
	}
	return oldValue.Difficulty, nil
}

// AddDifficulty adds u to the "difficulty" field.
func (m *TkExamPaperMutation) AddDifficulty(u uint8) {
	if m.adddifficulty != nil {
		*m.adddifficulty += u
	} else {
		m.adddifficulty = &u
	}
}

// AddedDifficulty returns the value that was added to the "difficulty" field in this mutation.
func (m *TkExamPaperMutation) AddedDifficulty() (r uint8, exists bool) {
	v := m.adddifficulty
	if v == nil {
		return
	}
	return *v, true
}

// ResetDifficulty resets all changes to the "difficulty" field.
func (m *TkExamPaperMutation) ResetDifficulty() {
	m.difficulty = nil
	m.adddifficulty = nil
}

// SetQuestionCount sets the "question_count" field.
func (m *TkExamPaperMutation) SetQuestionCount(i int) {
	m.question_count = &i
	m.addquestion_count = nil
}

// QuestionCount returns the value of the "question_count" field in the mutation.
func (m *TkExamPaperMutation) QuestionCount() (r int, exists bool) {
	v := m.question_count
	if v == nil {
		return
	}
	return *v, true
}

// OldQuestionCount returns the old "question_count" field's value of the TkExamPaper entity.
// If the TkExamPaper object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamPaperMutation) OldQuestionCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldQuestionCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldQuestionCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuestionCount: %w", err)
	}
	return oldValue.QuestionCount, nil
}

// AddQuestionCount adds i to the "question_count" field.
func (m *TkExamPaperMutation) AddQuestionCount(i int) {
	if m.addquestion_count != nil {
		*m.addquestion_count += i
	} else {
		m.addquestion_count = &i
	}
}

// AddedQuestionCount returns the value that was added to the "question_count" field in this mutation.
func (m *TkExamPaperMutation) AddedQuestionCount() (r int, exists bool) {
	v := m.addquestion_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuestionCount resets all changes to the "question_count" field.
func (m *TkExamPaperMutation) ResetQuestionCount() {
	m.question_count = nil
	m.addquestion_count = nil
}

// SetAnsweredUserCount sets the "answered_user_count" field.
func (m *TkExamPaperMutation) SetAnsweredUserCount(i int) {
	m.answered_user_count = &i
	m.addanswered_user_count = nil
}

// AnsweredUserCount returns the value of the "answered_user_count" field in the mutation.
func (m *TkExamPaperMutation) AnsweredUserCount() (r int, exists bool) {
	v := m.answered_user_count
	if v == nil {
		return
	}
	return *v, true
}

// OldAnsweredUserCount returns the old "answered_user_count" field's value of the TkExamPaper entity.
// If the TkExamPaper object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamPaperMutation) OldAnsweredUserCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAnsweredUserCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAnsweredUserCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnsweredUserCount: %w", err)
	}
	return oldValue.AnsweredUserCount, nil
}

// AddAnsweredUserCount adds i to the "answered_user_count" field.
func (m *TkExamPaperMutation) AddAnsweredUserCount(i int) {
	if m.addanswered_user_count != nil {
		*m.addanswered_user_count += i
	} else {
		m.addanswered_user_count = &i
	}
}

// AddedAnsweredUserCount returns the value that was added to the "answered_user_count" field in this mutation.
func (m *TkExamPaperMutation) AddedAnsweredUserCount() (r int, exists bool) {
	v := m.addanswered_user_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetAnsweredUserCount resets all changes to the "answered_user_count" field.
func (m *TkExamPaperMutation) ResetAnsweredUserCount() {
	m.answered_user_count = nil
	m.addanswered_user_count = nil
}

// SetScore sets the "score" field.
func (m *TkExamPaperMutation) SetScore(i int) {
	m.score = &i
	m.addscore = nil
}

// Score returns the value of the "score" field in the mutation.
func (m *TkExamPaperMutation) Score() (r int, exists bool) {
	v := m.score
	if v == nil {
		return
	}
	return *v, true
}

// OldScore returns the old "score" field's value of the TkExamPaper entity.
// If the TkExamPaper object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamPaperMutation) OldScore(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScore: %w", err)
	}
	return oldValue.Score, nil
}

// AddScore adds i to the "score" field.
func (m *TkExamPaperMutation) AddScore(i int) {
	if m.addscore != nil {
		*m.addscore += i
	} else {
		m.addscore = &i
	}
}

// AddedScore returns the value that was added to the "score" field in this mutation.
func (m *TkExamPaperMutation) AddedScore() (r int, exists bool) {
	v := m.addscore
	if v == nil {
		return
	}
	return *v, true
}

// ResetScore resets all changes to the "score" field.
func (m *TkExamPaperMutation) ResetScore() {
	m.score = nil
	m.addscore = nil
}

// SetPassScore sets the "pass_score" field.
func (m *TkExamPaperMutation) SetPassScore(i int) {
	m.pass_score = &i
	m.addpass_score = nil
}

// PassScore returns the value of the "pass_score" field in the mutation.
func (m *TkExamPaperMutation) PassScore() (r int, exists bool) {
	v := m.pass_score
	if v == nil {
		return
	}
	return *v, true
}

// OldPassScore returns the old "pass_score" field's value of the TkExamPaper entity.
// If the TkExamPaper object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamPaperMutation) OldPassScore(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPassScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPassScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassScore: %w", err)
	}
	return oldValue.PassScore, nil
}

// AddPassScore adds i to the "pass_score" field.
func (m *TkExamPaperMutation) AddPassScore(i int) {
	if m.addpass_score != nil {
		*m.addpass_score += i
	} else {
		m.addpass_score = &i
	}
}

// AddedPassScore returns the value that was added to the "pass_score" field in this mutation.
func (m *TkExamPaperMutation) AddedPassScore() (r int, exists bool) {
	v := m.addpass_score
	if v == nil {
		return
	}
	return *v, true
}

// ResetPassScore resets all changes to the "pass_score" field.
func (m *TkExamPaperMutation) ResetPassScore() {
	m.pass_score = nil
	m.addpass_score = nil
}

// SetDuration sets the "duration" field.
func (m *TkExamPaperMutation) SetDuration(i int) {
	m.duration = &i
	m.addduration = nil
}

// Duration returns the value of the "duration" field in the mutation.
func (m *TkExamPaperMutation) Duration() (r int, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old "duration" field's value of the TkExamPaper entity.
// If the TkExamPaper object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamPaperMutation) OldDuration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// AddDuration adds i to the "duration" field.
func (m *TkExamPaperMutation) AddDuration(i int) {
	if m.addduration != nil {
		*m.addduration += i
	} else {
		m.addduration = &i
	}
}

// AddedDuration returns the value that was added to the "duration" field in this mutation.
func (m *TkExamPaperMutation) AddedDuration() (r int, exists bool) {
	v := m.addduration
	if v == nil {
		return
	}
	return *v, true
}

// ResetDuration resets all changes to the "duration" field.
func (m *TkExamPaperMutation) ResetDuration() {
	m.duration = nil
	m.addduration = nil
}

// SetDurationType sets the "duration_type" field.
func (m *TkExamPaperMutation) SetDurationType(i int) {
	m.duration_type = &i
	m.addduration_type = nil
}

// DurationType returns the value of the "duration_type" field in the mutation.
func (m *TkExamPaperMutation) DurationType() (r int, exists bool) {
	v := m.duration_type
	if v == nil {
		return
	}
	return *v, true
}

// OldDurationType returns the old "duration_type" field's value of the TkExamPaper entity.
// If the TkExamPaper object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamPaperMutation) OldDurationType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDurationType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDurationType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDurationType: %w", err)
	}
	return oldValue.DurationType, nil
}

// AddDurationType adds i to the "duration_type" field.
func (m *TkExamPaperMutation) AddDurationType(i int) {
	if m.addduration_type != nil {
		*m.addduration_type += i
	} else {
		m.addduration_type = &i
	}
}

// AddedDurationType returns the value that was added to the "duration_type" field in this mutation.
func (m *TkExamPaperMutation) AddedDurationType() (r int, exists bool) {
	v := m.addduration_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetDurationType resets all changes to the "duration_type" field.
func (m *TkExamPaperMutation) ResetDurationType() {
	m.duration_type = nil
	m.addduration_type = nil
}

// SetStartAt sets the "start_at" field.
func (m *TkExamPaperMutation) SetStartAt(t time.Time) {
	m.start_at = &t
}

// StartAt returns the value of the "start_at" field in the mutation.
func (m *TkExamPaperMutation) StartAt() (r time.Time, exists bool) {
	v := m.start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAt returns the old "start_at" field's value of the TkExamPaper entity.
// If the TkExamPaper object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamPaperMutation) OldStartAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAt: %w", err)
	}
	return oldValue.StartAt, nil
}

// ClearStartAt clears the value of the "start_at" field.
func (m *TkExamPaperMutation) ClearStartAt() {
	m.start_at = nil
	m.clearedFields[tkexampaper.FieldStartAt] = struct{}{}
}

// StartAtCleared returns if the "start_at" field was cleared in this mutation.
func (m *TkExamPaperMutation) StartAtCleared() bool {
	_, ok := m.clearedFields[tkexampaper.FieldStartAt]
	return ok
}

// ResetStartAt resets all changes to the "start_at" field.
func (m *TkExamPaperMutation) ResetStartAt() {
	m.start_at = nil
	delete(m.clearedFields, tkexampaper.FieldStartAt)
}

// SetEndAt sets the "end_at" field.
func (m *TkExamPaperMutation) SetEndAt(t time.Time) {
	m.end_at = &t
}

// EndAt returns the value of the "end_at" field in the mutation.
func (m *TkExamPaperMutation) EndAt() (r time.Time, exists bool) {
	v := m.end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndAt returns the old "end_at" field's value of the TkExamPaper entity.
// If the TkExamPaper object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamPaperMutation) OldEndAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndAt: %w", err)
	}
	return oldValue.EndAt, nil
}

// ClearEndAt clears the value of the "end_at" field.
func (m *TkExamPaperMutation) ClearEndAt() {
	m.end_at = nil
	m.clearedFields[tkexampaper.FieldEndAt] = struct{}{}
}

// EndAtCleared returns if the "end_at" field was cleared in this mutation.
func (m *TkExamPaperMutation) EndAtCleared() bool {
	_, ok := m.clearedFields[tkexampaper.FieldEndAt]
	return ok
}

// ResetEndAt resets all changes to the "end_at" field.
func (m *TkExamPaperMutation) ResetEndAt() {
	m.end_at = nil
	delete(m.clearedFields, tkexampaper.FieldEndAt)
}

// SetEnableStatus sets the "enable_status" field.
func (m *TkExamPaperMutation) SetEnableStatus(u uint8) {
	m.enable_status = &u
	m.addenable_status = nil
}

// EnableStatus returns the value of the "enable_status" field in the mutation.
func (m *TkExamPaperMutation) EnableStatus() (r uint8, exists bool) {
	v := m.enable_status
	if v == nil {
		return
	}
	return *v, true
}

// OldEnableStatus returns the old "enable_status" field's value of the TkExamPaper entity.
// If the TkExamPaper object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamPaperMutation) OldEnableStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEnableStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEnableStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnableStatus: %w", err)
	}
	return oldValue.EnableStatus, nil
}

// AddEnableStatus adds u to the "enable_status" field.
func (m *TkExamPaperMutation) AddEnableStatus(u uint8) {
	if m.addenable_status != nil {
		*m.addenable_status += u
	} else {
		m.addenable_status = &u
	}
}

// AddedEnableStatus returns the value that was added to the "enable_status" field in this mutation.
func (m *TkExamPaperMutation) AddedEnableStatus() (r uint8, exists bool) {
	v := m.addenable_status
	if v == nil {
		return
	}
	return *v, true
}

// ResetEnableStatus resets all changes to the "enable_status" field.
func (m *TkExamPaperMutation) ResetEnableStatus() {
	m.enable_status = nil
	m.addenable_status = nil
}

// SetCreatedAdminID sets the "created_admin_id" field.
func (m *TkExamPaperMutation) SetCreatedAdminID(i int) {
	m.admin = &i
}

// CreatedAdminID returns the value of the "created_admin_id" field in the mutation.
func (m *TkExamPaperMutation) CreatedAdminID() (r int, exists bool) {
	v := m.admin
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAdminID returns the old "created_admin_id" field's value of the TkExamPaper entity.
// If the TkExamPaper object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamPaperMutation) OldCreatedAdminID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAdminID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAdminID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAdminID: %w", err)
	}
	return oldValue.CreatedAdminID, nil
}

// ClearCreatedAdminID clears the value of the "created_admin_id" field.
func (m *TkExamPaperMutation) ClearCreatedAdminID() {
	m.admin = nil
	m.clearedFields[tkexampaper.FieldCreatedAdminID] = struct{}{}
}

// CreatedAdminIDCleared returns if the "created_admin_id" field was cleared in this mutation.
func (m *TkExamPaperMutation) CreatedAdminIDCleared() bool {
	_, ok := m.clearedFields[tkexampaper.FieldCreatedAdminID]
	return ok
}

// ResetCreatedAdminID resets all changes to the "created_admin_id" field.
func (m *TkExamPaperMutation) ResetCreatedAdminID() {
	m.admin = nil
	delete(m.clearedFields, tkexampaper.FieldCreatedAdminID)
}

// SetQuestionBankID sets the "question_bank_id" field.
func (m *TkExamPaperMutation) SetQuestionBankID(i int) {
	m.question_bank = &i
}

// QuestionBankID returns the value of the "question_bank_id" field in the mutation.
func (m *TkExamPaperMutation) QuestionBankID() (r int, exists bool) {
	v := m.question_bank
	if v == nil {
		return
	}
	return *v, true
}

// OldQuestionBankID returns the old "question_bank_id" field's value of the TkExamPaper entity.
// If the TkExamPaper object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamPaperMutation) OldQuestionBankID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldQuestionBankID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldQuestionBankID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuestionBankID: %w", err)
	}
	return oldValue.QuestionBankID, nil
}

// ClearQuestionBankID clears the value of the "question_bank_id" field.
func (m *TkExamPaperMutation) ClearQuestionBankID() {
	m.question_bank = nil
	m.clearedFields[tkexampaper.FieldQuestionBankID] = struct{}{}
}

// QuestionBankIDCleared returns if the "question_bank_id" field was cleared in this mutation.
func (m *TkExamPaperMutation) QuestionBankIDCleared() bool {
	_, ok := m.clearedFields[tkexampaper.FieldQuestionBankID]
	return ok
}

// ResetQuestionBankID resets all changes to the "question_bank_id" field.
func (m *TkExamPaperMutation) ResetQuestionBankID() {
	m.question_bank = nil
	delete(m.clearedFields, tkexampaper.FieldQuestionBankID)
}

// ClearQuestionBank clears the "question_bank" edge to the TkQuestionBank entity.
func (m *TkExamPaperMutation) ClearQuestionBank() {
	m.clearedquestion_bank = true
}

// QuestionBankCleared reports if the "question_bank" edge to the TkQuestionBank entity was cleared.
func (m *TkExamPaperMutation) QuestionBankCleared() bool {
	return m.QuestionBankIDCleared() || m.clearedquestion_bank
}

// QuestionBankIDs returns the "question_bank" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// QuestionBankID instead. It exists only for internal usage by the builders.
func (m *TkExamPaperMutation) QuestionBankIDs() (ids []int) {
	if id := m.question_bank; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetQuestionBank resets all changes to the "question_bank" edge.
func (m *TkExamPaperMutation) ResetQuestionBank() {
	m.question_bank = nil
	m.clearedquestion_bank = false
}

// SetAdminID sets the "admin" edge to the Admin entity by id.
func (m *TkExamPaperMutation) SetAdminID(id int) {
	m.admin = &id
}

// ClearAdmin clears the "admin" edge to the Admin entity.
func (m *TkExamPaperMutation) ClearAdmin() {
	m.clearedadmin = true
}

// AdminCleared reports if the "admin" edge to the Admin entity was cleared.
func (m *TkExamPaperMutation) AdminCleared() bool {
	return m.CreatedAdminIDCleared() || m.clearedadmin
}

// AdminID returns the "admin" edge ID in the mutation.
func (m *TkExamPaperMutation) AdminID() (id int, exists bool) {
	if m.admin != nil {
		return *m.admin, true
	}
	return
}

// AdminIDs returns the "admin" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AdminID instead. It exists only for internal usage by the builders.
func (m *TkExamPaperMutation) AdminIDs() (ids []int) {
	if id := m.admin; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAdmin resets all changes to the "admin" edge.
func (m *TkExamPaperMutation) ResetAdmin() {
	m.admin = nil
	m.clearedadmin = false
}

// AddExamPartitionIDs adds the "exam_partitions" edge to the TkExamPaperPartition entity by ids.
func (m *TkExamPaperMutation) AddExamPartitionIDs(ids ...int) {
	if m.exam_partitions == nil {
		m.exam_partitions = make(map[int]struct{})
	}
	for i := range ids {
		m.exam_partitions[ids[i]] = struct{}{}
	}
}

// ClearExamPartitions clears the "exam_partitions" edge to the TkExamPaperPartition entity.
func (m *TkExamPaperMutation) ClearExamPartitions() {
	m.clearedexam_partitions = true
}

// ExamPartitionsCleared reports if the "exam_partitions" edge to the TkExamPaperPartition entity was cleared.
func (m *TkExamPaperMutation) ExamPartitionsCleared() bool {
	return m.clearedexam_partitions
}

// RemoveExamPartitionIDs removes the "exam_partitions" edge to the TkExamPaperPartition entity by IDs.
func (m *TkExamPaperMutation) RemoveExamPartitionIDs(ids ...int) {
	if m.removedexam_partitions == nil {
		m.removedexam_partitions = make(map[int]struct{})
	}
	for i := range ids {
		m.removedexam_partitions[ids[i]] = struct{}{}
	}
}

// RemovedExamPartitions returns the removed IDs of the "exam_partitions" edge to the TkExamPaperPartition entity.
func (m *TkExamPaperMutation) RemovedExamPartitionsIDs() (ids []int) {
	for id := range m.removedexam_partitions {
		ids = append(ids, id)
	}
	return
}

// ExamPartitionsIDs returns the "exam_partitions" edge IDs in the mutation.
func (m *TkExamPaperMutation) ExamPartitionsIDs() (ids []int) {
	for id := range m.exam_partitions {
		ids = append(ids, id)
	}
	return
}

// ResetExamPartitions resets all changes to the "exam_partitions" edge.
func (m *TkExamPaperMutation) ResetExamPartitions() {
	m.exam_partitions = nil
	m.clearedexam_partitions = false
	m.removedexam_partitions = nil
}

// AddMakeUserQuestionExamIDs adds the "make_user_question_exam" edge to the MakeUserQuestionRecord entity by ids.
func (m *TkExamPaperMutation) AddMakeUserQuestionExamIDs(ids ...int) {
	if m.make_user_question_exam == nil {
		m.make_user_question_exam = make(map[int]struct{})
	}
	for i := range ids {
		m.make_user_question_exam[ids[i]] = struct{}{}
	}
}

// ClearMakeUserQuestionExam clears the "make_user_question_exam" edge to the MakeUserQuestionRecord entity.
func (m *TkExamPaperMutation) ClearMakeUserQuestionExam() {
	m.clearedmake_user_question_exam = true
}

// MakeUserQuestionExamCleared reports if the "make_user_question_exam" edge to the MakeUserQuestionRecord entity was cleared.
func (m *TkExamPaperMutation) MakeUserQuestionExamCleared() bool {
	return m.clearedmake_user_question_exam
}

// RemoveMakeUserQuestionExamIDs removes the "make_user_question_exam" edge to the MakeUserQuestionRecord entity by IDs.
func (m *TkExamPaperMutation) RemoveMakeUserQuestionExamIDs(ids ...int) {
	if m.removedmake_user_question_exam == nil {
		m.removedmake_user_question_exam = make(map[int]struct{})
	}
	for i := range ids {
		m.removedmake_user_question_exam[ids[i]] = struct{}{}
	}
}

// RemovedMakeUserQuestionExam returns the removed IDs of the "make_user_question_exam" edge to the MakeUserQuestionRecord entity.
func (m *TkExamPaperMutation) RemovedMakeUserQuestionExamIDs() (ids []int) {
	for id := range m.removedmake_user_question_exam {
		ids = append(ids, id)
	}
	return
}

// MakeUserQuestionExamIDs returns the "make_user_question_exam" edge IDs in the mutation.
func (m *TkExamPaperMutation) MakeUserQuestionExamIDs() (ids []int) {
	for id := range m.make_user_question_exam {
		ids = append(ids, id)
	}
	return
}

// ResetMakeUserQuestionExam resets all changes to the "make_user_question_exam" edge.
func (m *TkExamPaperMutation) ResetMakeUserQuestionExam() {
	m.make_user_question_exam = nil
	m.clearedmake_user_question_exam = false
	m.removedmake_user_question_exam = nil
}

// AddUserExamPaperIDs adds the "user_exam_papers" edge to the TkUserExamScoreRecord entity by ids.
func (m *TkExamPaperMutation) AddUserExamPaperIDs(ids ...int) {
	if m.user_exam_papers == nil {
		m.user_exam_papers = make(map[int]struct{})
	}
	for i := range ids {
		m.user_exam_papers[ids[i]] = struct{}{}
	}
}

// ClearUserExamPapers clears the "user_exam_papers" edge to the TkUserExamScoreRecord entity.
func (m *TkExamPaperMutation) ClearUserExamPapers() {
	m.cleareduser_exam_papers = true
}

// UserExamPapersCleared reports if the "user_exam_papers" edge to the TkUserExamScoreRecord entity was cleared.
func (m *TkExamPaperMutation) UserExamPapersCleared() bool {
	return m.cleareduser_exam_papers
}

// RemoveUserExamPaperIDs removes the "user_exam_papers" edge to the TkUserExamScoreRecord entity by IDs.
func (m *TkExamPaperMutation) RemoveUserExamPaperIDs(ids ...int) {
	if m.removeduser_exam_papers == nil {
		m.removeduser_exam_papers = make(map[int]struct{})
	}
	for i := range ids {
		m.removeduser_exam_papers[ids[i]] = struct{}{}
	}
}

// RemovedUserExamPapers returns the removed IDs of the "user_exam_papers" edge to the TkUserExamScoreRecord entity.
func (m *TkExamPaperMutation) RemovedUserExamPapersIDs() (ids []int) {
	for id := range m.removeduser_exam_papers {
		ids = append(ids, id)
	}
	return
}

// UserExamPapersIDs returns the "user_exam_papers" edge IDs in the mutation.
func (m *TkExamPaperMutation) UserExamPapersIDs() (ids []int) {
	for id := range m.user_exam_papers {
		ids = append(ids, id)
	}
	return
}

// ResetUserExamPapers resets all changes to the "user_exam_papers" edge.
func (m *TkExamPaperMutation) ResetUserExamPapers() {
	m.user_exam_papers = nil
	m.cleareduser_exam_papers = false
	m.removeduser_exam_papers = nil
}

// AddCourseExamPaperIDs adds the "course_exam_papers" edge to the KcSmallCategoryExamPaper entity by ids.
func (m *TkExamPaperMutation) AddCourseExamPaperIDs(ids ...int) {
	if m.course_exam_papers == nil {
		m.course_exam_papers = make(map[int]struct{})
	}
	for i := range ids {
		m.course_exam_papers[ids[i]] = struct{}{}
	}
}

// ClearCourseExamPapers clears the "course_exam_papers" edge to the KcSmallCategoryExamPaper entity.
func (m *TkExamPaperMutation) ClearCourseExamPapers() {
	m.clearedcourse_exam_papers = true
}

// CourseExamPapersCleared reports if the "course_exam_papers" edge to the KcSmallCategoryExamPaper entity was cleared.
func (m *TkExamPaperMutation) CourseExamPapersCleared() bool {
	return m.clearedcourse_exam_papers
}

// RemoveCourseExamPaperIDs removes the "course_exam_papers" edge to the KcSmallCategoryExamPaper entity by IDs.
func (m *TkExamPaperMutation) RemoveCourseExamPaperIDs(ids ...int) {
	if m.removedcourse_exam_papers == nil {
		m.removedcourse_exam_papers = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcourse_exam_papers[ids[i]] = struct{}{}
	}
}

// RemovedCourseExamPapers returns the removed IDs of the "course_exam_papers" edge to the KcSmallCategoryExamPaper entity.
func (m *TkExamPaperMutation) RemovedCourseExamPapersIDs() (ids []int) {
	for id := range m.removedcourse_exam_papers {
		ids = append(ids, id)
	}
	return
}

// CourseExamPapersIDs returns the "course_exam_papers" edge IDs in the mutation.
func (m *TkExamPaperMutation) CourseExamPapersIDs() (ids []int) {
	for id := range m.course_exam_papers {
		ids = append(ids, id)
	}
	return
}

// ResetCourseExamPapers resets all changes to the "course_exam_papers" edge.
func (m *TkExamPaperMutation) ResetCourseExamPapers() {
	m.course_exam_papers = nil
	m.clearedcourse_exam_papers = false
	m.removedcourse_exam_papers = nil
}

// AddExamPaperRecordIDs adds the "exam_paper_records" edge to the TkUserQuestionRecord entity by ids.
func (m *TkExamPaperMutation) AddExamPaperRecordIDs(ids ...int) {
	if m.exam_paper_records == nil {
		m.exam_paper_records = make(map[int]struct{})
	}
	for i := range ids {
		m.exam_paper_records[ids[i]] = struct{}{}
	}
}

// ClearExamPaperRecords clears the "exam_paper_records" edge to the TkUserQuestionRecord entity.
func (m *TkExamPaperMutation) ClearExamPaperRecords() {
	m.clearedexam_paper_records = true
}

// ExamPaperRecordsCleared reports if the "exam_paper_records" edge to the TkUserQuestionRecord entity was cleared.
func (m *TkExamPaperMutation) ExamPaperRecordsCleared() bool {
	return m.clearedexam_paper_records
}

// RemoveExamPaperRecordIDs removes the "exam_paper_records" edge to the TkUserQuestionRecord entity by IDs.
func (m *TkExamPaperMutation) RemoveExamPaperRecordIDs(ids ...int) {
	if m.removedexam_paper_records == nil {
		m.removedexam_paper_records = make(map[int]struct{})
	}
	for i := range ids {
		m.removedexam_paper_records[ids[i]] = struct{}{}
	}
}

// RemovedExamPaperRecords returns the removed IDs of the "exam_paper_records" edge to the TkUserQuestionRecord entity.
func (m *TkExamPaperMutation) RemovedExamPaperRecordsIDs() (ids []int) {
	for id := range m.removedexam_paper_records {
		ids = append(ids, id)
	}
	return
}

// ExamPaperRecordsIDs returns the "exam_paper_records" edge IDs in the mutation.
func (m *TkExamPaperMutation) ExamPaperRecordsIDs() (ids []int) {
	for id := range m.exam_paper_records {
		ids = append(ids, id)
	}
	return
}

// ResetExamPaperRecords resets all changes to the "exam_paper_records" edge.
func (m *TkExamPaperMutation) ResetExamPaperRecords() {
	m.exam_paper_records = nil
	m.clearedexam_paper_records = false
	m.removedexam_paper_records = nil
}

// AddUserRandomExamIDs adds the "user_random_exam" edge to the TkUserRandomExamRecode entity by ids.
func (m *TkExamPaperMutation) AddUserRandomExamIDs(ids ...int) {
	if m.user_random_exam == nil {
		m.user_random_exam = make(map[int]struct{})
	}
	for i := range ids {
		m.user_random_exam[ids[i]] = struct{}{}
	}
}

// ClearUserRandomExam clears the "user_random_exam" edge to the TkUserRandomExamRecode entity.
func (m *TkExamPaperMutation) ClearUserRandomExam() {
	m.cleareduser_random_exam = true
}

// UserRandomExamCleared reports if the "user_random_exam" edge to the TkUserRandomExamRecode entity was cleared.
func (m *TkExamPaperMutation) UserRandomExamCleared() bool {
	return m.cleareduser_random_exam
}

// RemoveUserRandomExamIDs removes the "user_random_exam" edge to the TkUserRandomExamRecode entity by IDs.
func (m *TkExamPaperMutation) RemoveUserRandomExamIDs(ids ...int) {
	if m.removeduser_random_exam == nil {
		m.removeduser_random_exam = make(map[int]struct{})
	}
	for i := range ids {
		m.removeduser_random_exam[ids[i]] = struct{}{}
	}
}

// RemovedUserRandomExam returns the removed IDs of the "user_random_exam" edge to the TkUserRandomExamRecode entity.
func (m *TkExamPaperMutation) RemovedUserRandomExamIDs() (ids []int) {
	for id := range m.removeduser_random_exam {
		ids = append(ids, id)
	}
	return
}

// UserRandomExamIDs returns the "user_random_exam" edge IDs in the mutation.
func (m *TkExamPaperMutation) UserRandomExamIDs() (ids []int) {
	for id := range m.user_random_exam {
		ids = append(ids, id)
	}
	return
}

// ResetUserRandomExam resets all changes to the "user_random_exam" edge.
func (m *TkExamPaperMutation) ResetUserRandomExam() {
	m.user_random_exam = nil
	m.cleareduser_random_exam = false
	m.removeduser_random_exam = nil
}

// Op returns the operation name.
func (m *TkExamPaperMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TkExamPaper).
func (m *TkExamPaperMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TkExamPaperMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.uuid != nil {
		fields = append(fields, tkexampaper.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, tkexampaper.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tkexampaper.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, tkexampaper.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, tkexampaper.FieldName)
	}
	if m.desc != nil {
		fields = append(fields, tkexampaper.FieldDesc)
	}
	if m.exam_question_type != nil {
		fields = append(fields, tkexampaper.FieldExamQuestionType)
	}
	if m.exam_type != nil {
		fields = append(fields, tkexampaper.FieldExamType)
	}
	if m.difficulty != nil {
		fields = append(fields, tkexampaper.FieldDifficulty)
	}
	if m.question_count != nil {
		fields = append(fields, tkexampaper.FieldQuestionCount)
	}
	if m.answered_user_count != nil {
		fields = append(fields, tkexampaper.FieldAnsweredUserCount)
	}
	if m.score != nil {
		fields = append(fields, tkexampaper.FieldScore)
	}
	if m.pass_score != nil {
		fields = append(fields, tkexampaper.FieldPassScore)
	}
	if m.duration != nil {
		fields = append(fields, tkexampaper.FieldDuration)
	}
	if m.duration_type != nil {
		fields = append(fields, tkexampaper.FieldDurationType)
	}
	if m.start_at != nil {
		fields = append(fields, tkexampaper.FieldStartAt)
	}
	if m.end_at != nil {
		fields = append(fields, tkexampaper.FieldEndAt)
	}
	if m.enable_status != nil {
		fields = append(fields, tkexampaper.FieldEnableStatus)
	}
	if m.admin != nil {
		fields = append(fields, tkexampaper.FieldCreatedAdminID)
	}
	if m.question_bank != nil {
		fields = append(fields, tkexampaper.FieldQuestionBankID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TkExamPaperMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tkexampaper.FieldUUID:
		return m.UUID()
	case tkexampaper.FieldCreatedAt:
		return m.CreatedAt()
	case tkexampaper.FieldUpdatedAt:
		return m.UpdatedAt()
	case tkexampaper.FieldDeletedAt:
		return m.DeletedAt()
	case tkexampaper.FieldName:
		return m.Name()
	case tkexampaper.FieldDesc:
		return m.Desc()
	case tkexampaper.FieldExamQuestionType:
		return m.ExamQuestionType()
	case tkexampaper.FieldExamType:
		return m.ExamType()
	case tkexampaper.FieldDifficulty:
		return m.Difficulty()
	case tkexampaper.FieldQuestionCount:
		return m.QuestionCount()
	case tkexampaper.FieldAnsweredUserCount:
		return m.AnsweredUserCount()
	case tkexampaper.FieldScore:
		return m.Score()
	case tkexampaper.FieldPassScore:
		return m.PassScore()
	case tkexampaper.FieldDuration:
		return m.Duration()
	case tkexampaper.FieldDurationType:
		return m.DurationType()
	case tkexampaper.FieldStartAt:
		return m.StartAt()
	case tkexampaper.FieldEndAt:
		return m.EndAt()
	case tkexampaper.FieldEnableStatus:
		return m.EnableStatus()
	case tkexampaper.FieldCreatedAdminID:
		return m.CreatedAdminID()
	case tkexampaper.FieldQuestionBankID:
		return m.QuestionBankID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TkExamPaperMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tkexampaper.FieldUUID:
		return m.OldUUID(ctx)
	case tkexampaper.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tkexampaper.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tkexampaper.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case tkexampaper.FieldName:
		return m.OldName(ctx)
	case tkexampaper.FieldDesc:
		return m.OldDesc(ctx)
	case tkexampaper.FieldExamQuestionType:
		return m.OldExamQuestionType(ctx)
	case tkexampaper.FieldExamType:
		return m.OldExamType(ctx)
	case tkexampaper.FieldDifficulty:
		return m.OldDifficulty(ctx)
	case tkexampaper.FieldQuestionCount:
		return m.OldQuestionCount(ctx)
	case tkexampaper.FieldAnsweredUserCount:
		return m.OldAnsweredUserCount(ctx)
	case tkexampaper.FieldScore:
		return m.OldScore(ctx)
	case tkexampaper.FieldPassScore:
		return m.OldPassScore(ctx)
	case tkexampaper.FieldDuration:
		return m.OldDuration(ctx)
	case tkexampaper.FieldDurationType:
		return m.OldDurationType(ctx)
	case tkexampaper.FieldStartAt:
		return m.OldStartAt(ctx)
	case tkexampaper.FieldEndAt:
		return m.OldEndAt(ctx)
	case tkexampaper.FieldEnableStatus:
		return m.OldEnableStatus(ctx)
	case tkexampaper.FieldCreatedAdminID:
		return m.OldCreatedAdminID(ctx)
	case tkexampaper.FieldQuestionBankID:
		return m.OldQuestionBankID(ctx)
	}
	return nil, fmt.Errorf("unknown TkExamPaper field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TkExamPaperMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tkexampaper.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case tkexampaper.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tkexampaper.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tkexampaper.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case tkexampaper.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tkexampaper.FieldDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	case tkexampaper.FieldExamQuestionType:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamQuestionType(v)
		return nil
	case tkexampaper.FieldExamType:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamType(v)
		return nil
	case tkexampaper.FieldDifficulty:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDifficulty(v)
		return nil
	case tkexampaper.FieldQuestionCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuestionCount(v)
		return nil
	case tkexampaper.FieldAnsweredUserCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnsweredUserCount(v)
		return nil
	case tkexampaper.FieldScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScore(v)
		return nil
	case tkexampaper.FieldPassScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassScore(v)
		return nil
	case tkexampaper.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	case tkexampaper.FieldDurationType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDurationType(v)
		return nil
	case tkexampaper.FieldStartAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAt(v)
		return nil
	case tkexampaper.FieldEndAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndAt(v)
		return nil
	case tkexampaper.FieldEnableStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnableStatus(v)
		return nil
	case tkexampaper.FieldCreatedAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAdminID(v)
		return nil
	case tkexampaper.FieldQuestionBankID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuestionBankID(v)
		return nil
	}
	return fmt.Errorf("unknown TkExamPaper field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TkExamPaperMutation) AddedFields() []string {
	var fields []string
	if m.addexam_question_type != nil {
		fields = append(fields, tkexampaper.FieldExamQuestionType)
	}
	if m.addexam_type != nil {
		fields = append(fields, tkexampaper.FieldExamType)
	}
	if m.adddifficulty != nil {
		fields = append(fields, tkexampaper.FieldDifficulty)
	}
	if m.addquestion_count != nil {
		fields = append(fields, tkexampaper.FieldQuestionCount)
	}
	if m.addanswered_user_count != nil {
		fields = append(fields, tkexampaper.FieldAnsweredUserCount)
	}
	if m.addscore != nil {
		fields = append(fields, tkexampaper.FieldScore)
	}
	if m.addpass_score != nil {
		fields = append(fields, tkexampaper.FieldPassScore)
	}
	if m.addduration != nil {
		fields = append(fields, tkexampaper.FieldDuration)
	}
	if m.addduration_type != nil {
		fields = append(fields, tkexampaper.FieldDurationType)
	}
	if m.addenable_status != nil {
		fields = append(fields, tkexampaper.FieldEnableStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TkExamPaperMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tkexampaper.FieldExamQuestionType:
		return m.AddedExamQuestionType()
	case tkexampaper.FieldExamType:
		return m.AddedExamType()
	case tkexampaper.FieldDifficulty:
		return m.AddedDifficulty()
	case tkexampaper.FieldQuestionCount:
		return m.AddedQuestionCount()
	case tkexampaper.FieldAnsweredUserCount:
		return m.AddedAnsweredUserCount()
	case tkexampaper.FieldScore:
		return m.AddedScore()
	case tkexampaper.FieldPassScore:
		return m.AddedPassScore()
	case tkexampaper.FieldDuration:
		return m.AddedDuration()
	case tkexampaper.FieldDurationType:
		return m.AddedDurationType()
	case tkexampaper.FieldEnableStatus:
		return m.AddedEnableStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TkExamPaperMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tkexampaper.FieldExamQuestionType:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExamQuestionType(v)
		return nil
	case tkexampaper.FieldExamType:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExamType(v)
		return nil
	case tkexampaper.FieldDifficulty:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDifficulty(v)
		return nil
	case tkexampaper.FieldQuestionCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuestionCount(v)
		return nil
	case tkexampaper.FieldAnsweredUserCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAnsweredUserCount(v)
		return nil
	case tkexampaper.FieldScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScore(v)
		return nil
	case tkexampaper.FieldPassScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPassScore(v)
		return nil
	case tkexampaper.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDuration(v)
		return nil
	case tkexampaper.FieldDurationType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDurationType(v)
		return nil
	case tkexampaper.FieldEnableStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEnableStatus(v)
		return nil
	}
	return fmt.Errorf("unknown TkExamPaper numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TkExamPaperMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tkexampaper.FieldCreatedAt) {
		fields = append(fields, tkexampaper.FieldCreatedAt)
	}
	if m.FieldCleared(tkexampaper.FieldUpdatedAt) {
		fields = append(fields, tkexampaper.FieldUpdatedAt)
	}
	if m.FieldCleared(tkexampaper.FieldDeletedAt) {
		fields = append(fields, tkexampaper.FieldDeletedAt)
	}
	if m.FieldCleared(tkexampaper.FieldStartAt) {
		fields = append(fields, tkexampaper.FieldStartAt)
	}
	if m.FieldCleared(tkexampaper.FieldEndAt) {
		fields = append(fields, tkexampaper.FieldEndAt)
	}
	if m.FieldCleared(tkexampaper.FieldCreatedAdminID) {
		fields = append(fields, tkexampaper.FieldCreatedAdminID)
	}
	if m.FieldCleared(tkexampaper.FieldQuestionBankID) {
		fields = append(fields, tkexampaper.FieldQuestionBankID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TkExamPaperMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TkExamPaperMutation) ClearField(name string) error {
	switch name {
	case tkexampaper.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case tkexampaper.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case tkexampaper.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case tkexampaper.FieldStartAt:
		m.ClearStartAt()
		return nil
	case tkexampaper.FieldEndAt:
		m.ClearEndAt()
		return nil
	case tkexampaper.FieldCreatedAdminID:
		m.ClearCreatedAdminID()
		return nil
	case tkexampaper.FieldQuestionBankID:
		m.ClearQuestionBankID()
		return nil
	}
	return fmt.Errorf("unknown TkExamPaper nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TkExamPaperMutation) ResetField(name string) error {
	switch name {
	case tkexampaper.FieldUUID:
		m.ResetUUID()
		return nil
	case tkexampaper.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tkexampaper.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tkexampaper.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case tkexampaper.FieldName:
		m.ResetName()
		return nil
	case tkexampaper.FieldDesc:
		m.ResetDesc()
		return nil
	case tkexampaper.FieldExamQuestionType:
		m.ResetExamQuestionType()
		return nil
	case tkexampaper.FieldExamType:
		m.ResetExamType()
		return nil
	case tkexampaper.FieldDifficulty:
		m.ResetDifficulty()
		return nil
	case tkexampaper.FieldQuestionCount:
		m.ResetQuestionCount()
		return nil
	case tkexampaper.FieldAnsweredUserCount:
		m.ResetAnsweredUserCount()
		return nil
	case tkexampaper.FieldScore:
		m.ResetScore()
		return nil
	case tkexampaper.FieldPassScore:
		m.ResetPassScore()
		return nil
	case tkexampaper.FieldDuration:
		m.ResetDuration()
		return nil
	case tkexampaper.FieldDurationType:
		m.ResetDurationType()
		return nil
	case tkexampaper.FieldStartAt:
		m.ResetStartAt()
		return nil
	case tkexampaper.FieldEndAt:
		m.ResetEndAt()
		return nil
	case tkexampaper.FieldEnableStatus:
		m.ResetEnableStatus()
		return nil
	case tkexampaper.FieldCreatedAdminID:
		m.ResetCreatedAdminID()
		return nil
	case tkexampaper.FieldQuestionBankID:
		m.ResetQuestionBankID()
		return nil
	}
	return fmt.Errorf("unknown TkExamPaper field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TkExamPaperMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.question_bank != nil {
		edges = append(edges, tkexampaper.EdgeQuestionBank)
	}
	if m.admin != nil {
		edges = append(edges, tkexampaper.EdgeAdmin)
	}
	if m.exam_partitions != nil {
		edges = append(edges, tkexampaper.EdgeExamPartitions)
	}
	if m.make_user_question_exam != nil {
		edges = append(edges, tkexampaper.EdgeMakeUserQuestionExam)
	}
	if m.user_exam_papers != nil {
		edges = append(edges, tkexampaper.EdgeUserExamPapers)
	}
	if m.course_exam_papers != nil {
		edges = append(edges, tkexampaper.EdgeCourseExamPapers)
	}
	if m.exam_paper_records != nil {
		edges = append(edges, tkexampaper.EdgeExamPaperRecords)
	}
	if m.user_random_exam != nil {
		edges = append(edges, tkexampaper.EdgeUserRandomExam)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TkExamPaperMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tkexampaper.EdgeQuestionBank:
		if id := m.question_bank; id != nil {
			return []ent.Value{*id}
		}
	case tkexampaper.EdgeAdmin:
		if id := m.admin; id != nil {
			return []ent.Value{*id}
		}
	case tkexampaper.EdgeExamPartitions:
		ids := make([]ent.Value, 0, len(m.exam_partitions))
		for id := range m.exam_partitions {
			ids = append(ids, id)
		}
		return ids
	case tkexampaper.EdgeMakeUserQuestionExam:
		ids := make([]ent.Value, 0, len(m.make_user_question_exam))
		for id := range m.make_user_question_exam {
			ids = append(ids, id)
		}
		return ids
	case tkexampaper.EdgeUserExamPapers:
		ids := make([]ent.Value, 0, len(m.user_exam_papers))
		for id := range m.user_exam_papers {
			ids = append(ids, id)
		}
		return ids
	case tkexampaper.EdgeCourseExamPapers:
		ids := make([]ent.Value, 0, len(m.course_exam_papers))
		for id := range m.course_exam_papers {
			ids = append(ids, id)
		}
		return ids
	case tkexampaper.EdgeExamPaperRecords:
		ids := make([]ent.Value, 0, len(m.exam_paper_records))
		for id := range m.exam_paper_records {
			ids = append(ids, id)
		}
		return ids
	case tkexampaper.EdgeUserRandomExam:
		ids := make([]ent.Value, 0, len(m.user_random_exam))
		for id := range m.user_random_exam {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TkExamPaperMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedexam_partitions != nil {
		edges = append(edges, tkexampaper.EdgeExamPartitions)
	}
	if m.removedmake_user_question_exam != nil {
		edges = append(edges, tkexampaper.EdgeMakeUserQuestionExam)
	}
	if m.removeduser_exam_papers != nil {
		edges = append(edges, tkexampaper.EdgeUserExamPapers)
	}
	if m.removedcourse_exam_papers != nil {
		edges = append(edges, tkexampaper.EdgeCourseExamPapers)
	}
	if m.removedexam_paper_records != nil {
		edges = append(edges, tkexampaper.EdgeExamPaperRecords)
	}
	if m.removeduser_random_exam != nil {
		edges = append(edges, tkexampaper.EdgeUserRandomExam)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TkExamPaperMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tkexampaper.EdgeExamPartitions:
		ids := make([]ent.Value, 0, len(m.removedexam_partitions))
		for id := range m.removedexam_partitions {
			ids = append(ids, id)
		}
		return ids
	case tkexampaper.EdgeMakeUserQuestionExam:
		ids := make([]ent.Value, 0, len(m.removedmake_user_question_exam))
		for id := range m.removedmake_user_question_exam {
			ids = append(ids, id)
		}
		return ids
	case tkexampaper.EdgeUserExamPapers:
		ids := make([]ent.Value, 0, len(m.removeduser_exam_papers))
		for id := range m.removeduser_exam_papers {
			ids = append(ids, id)
		}
		return ids
	case tkexampaper.EdgeCourseExamPapers:
		ids := make([]ent.Value, 0, len(m.removedcourse_exam_papers))
		for id := range m.removedcourse_exam_papers {
			ids = append(ids, id)
		}
		return ids
	case tkexampaper.EdgeExamPaperRecords:
		ids := make([]ent.Value, 0, len(m.removedexam_paper_records))
		for id := range m.removedexam_paper_records {
			ids = append(ids, id)
		}
		return ids
	case tkexampaper.EdgeUserRandomExam:
		ids := make([]ent.Value, 0, len(m.removeduser_random_exam))
		for id := range m.removeduser_random_exam {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TkExamPaperMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedquestion_bank {
		edges = append(edges, tkexampaper.EdgeQuestionBank)
	}
	if m.clearedadmin {
		edges = append(edges, tkexampaper.EdgeAdmin)
	}
	if m.clearedexam_partitions {
		edges = append(edges, tkexampaper.EdgeExamPartitions)
	}
	if m.clearedmake_user_question_exam {
		edges = append(edges, tkexampaper.EdgeMakeUserQuestionExam)
	}
	if m.cleareduser_exam_papers {
		edges = append(edges, tkexampaper.EdgeUserExamPapers)
	}
	if m.clearedcourse_exam_papers {
		edges = append(edges, tkexampaper.EdgeCourseExamPapers)
	}
	if m.clearedexam_paper_records {
		edges = append(edges, tkexampaper.EdgeExamPaperRecords)
	}
	if m.cleareduser_random_exam {
		edges = append(edges, tkexampaper.EdgeUserRandomExam)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TkExamPaperMutation) EdgeCleared(name string) bool {
	switch name {
	case tkexampaper.EdgeQuestionBank:
		return m.clearedquestion_bank
	case tkexampaper.EdgeAdmin:
		return m.clearedadmin
	case tkexampaper.EdgeExamPartitions:
		return m.clearedexam_partitions
	case tkexampaper.EdgeMakeUserQuestionExam:
		return m.clearedmake_user_question_exam
	case tkexampaper.EdgeUserExamPapers:
		return m.cleareduser_exam_papers
	case tkexampaper.EdgeCourseExamPapers:
		return m.clearedcourse_exam_papers
	case tkexampaper.EdgeExamPaperRecords:
		return m.clearedexam_paper_records
	case tkexampaper.EdgeUserRandomExam:
		return m.cleareduser_random_exam
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TkExamPaperMutation) ClearEdge(name string) error {
	switch name {
	case tkexampaper.EdgeQuestionBank:
		m.ClearQuestionBank()
		return nil
	case tkexampaper.EdgeAdmin:
		m.ClearAdmin()
		return nil
	}
	return fmt.Errorf("unknown TkExamPaper unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TkExamPaperMutation) ResetEdge(name string) error {
	switch name {
	case tkexampaper.EdgeQuestionBank:
		m.ResetQuestionBank()
		return nil
	case tkexampaper.EdgeAdmin:
		m.ResetAdmin()
		return nil
	case tkexampaper.EdgeExamPartitions:
		m.ResetExamPartitions()
		return nil
	case tkexampaper.EdgeMakeUserQuestionExam:
		m.ResetMakeUserQuestionExam()
		return nil
	case tkexampaper.EdgeUserExamPapers:
		m.ResetUserExamPapers()
		return nil
	case tkexampaper.EdgeCourseExamPapers:
		m.ResetCourseExamPapers()
		return nil
	case tkexampaper.EdgeExamPaperRecords:
		m.ResetExamPaperRecords()
		return nil
	case tkexampaper.EdgeUserRandomExam:
		m.ResetUserRandomExam()
		return nil
	}
	return fmt.Errorf("unknown TkExamPaper edge %s", name)
}

// TkExamPaperPartitionMutation represents an operation that mutates the TkExamPaperPartition nodes in the graph.
type TkExamPaperPartitionMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	uuid                         *string
	created_at                   *time.Time
	updated_at                   *time.Time
	deleted_at                   *time.Time
	name                         *string
	desc                         *string
	duration                     *int
	addduration                  *int
	_type                        *int
	add_type                     *int
	question_count               *uint8
	addquestion_count            *uint8
	clearedFields                map[string]struct{}
	exam_paper                   *int
	clearedexam_paper            bool
	exam_partition_links         map[int]struct{}
	removedexam_partition_links  map[int]struct{}
	clearedexam_partition_links  bool
	exam_partition_scores        map[int]struct{}
	removedexam_partition_scores map[int]struct{}
	clearedexam_partition_scores bool
	done                         bool
	oldValue                     func(context.Context) (*TkExamPaperPartition, error)
	predicates                   []predicate.TkExamPaperPartition
}

var _ ent.Mutation = (*TkExamPaperPartitionMutation)(nil)

// tkexampaperpartitionOption allows management of the mutation configuration using functional options.
type tkexampaperpartitionOption func(*TkExamPaperPartitionMutation)

// newTkExamPaperPartitionMutation creates new mutation for the TkExamPaperPartition entity.
func newTkExamPaperPartitionMutation(c config, op Op, opts ...tkexampaperpartitionOption) *TkExamPaperPartitionMutation {
	m := &TkExamPaperPartitionMutation{
		config:        c,
		op:            op,
		typ:           TypeTkExamPaperPartition,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTkExamPaperPartitionID sets the ID field of the mutation.
func withTkExamPaperPartitionID(id int) tkexampaperpartitionOption {
	return func(m *TkExamPaperPartitionMutation) {
		var (
			err   error
			once  sync.Once
			value *TkExamPaperPartition
		)
		m.oldValue = func(ctx context.Context) (*TkExamPaperPartition, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TkExamPaperPartition.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTkExamPaperPartition sets the old TkExamPaperPartition of the mutation.
func withTkExamPaperPartition(node *TkExamPaperPartition) tkexampaperpartitionOption {
	return func(m *TkExamPaperPartitionMutation) {
		m.oldValue = func(context.Context) (*TkExamPaperPartition, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TkExamPaperPartitionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TkExamPaperPartitionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *TkExamPaperPartitionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *TkExamPaperPartitionMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *TkExamPaperPartitionMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the TkExamPaperPartition entity.
// If the TkExamPaperPartition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamPaperPartitionMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *TkExamPaperPartitionMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TkExamPaperPartitionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TkExamPaperPartitionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TkExamPaperPartition entity.
// If the TkExamPaperPartition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamPaperPartitionMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *TkExamPaperPartitionMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[tkexampaperpartition.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *TkExamPaperPartitionMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[tkexampaperpartition.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TkExamPaperPartitionMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, tkexampaperpartition.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TkExamPaperPartitionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TkExamPaperPartitionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TkExamPaperPartition entity.
// If the TkExamPaperPartition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamPaperPartitionMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TkExamPaperPartitionMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[tkexampaperpartition.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TkExamPaperPartitionMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[tkexampaperpartition.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TkExamPaperPartitionMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, tkexampaperpartition.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TkExamPaperPartitionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TkExamPaperPartitionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TkExamPaperPartition entity.
// If the TkExamPaperPartition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamPaperPartitionMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TkExamPaperPartitionMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[tkexampaperpartition.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TkExamPaperPartitionMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[tkexampaperpartition.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TkExamPaperPartitionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, tkexampaperpartition.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *TkExamPaperPartitionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TkExamPaperPartitionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TkExamPaperPartition entity.
// If the TkExamPaperPartition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamPaperPartitionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TkExamPaperPartitionMutation) ResetName() {
	m.name = nil
}

// SetDesc sets the "desc" field.
func (m *TkExamPaperPartitionMutation) SetDesc(s string) {
	m.desc = &s
}

// Desc returns the value of the "desc" field in the mutation.
func (m *TkExamPaperPartitionMutation) Desc() (r string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the TkExamPaperPartition entity.
// If the TkExamPaperPartition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamPaperPartitionMutation) OldDesc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// ResetDesc resets all changes to the "desc" field.
func (m *TkExamPaperPartitionMutation) ResetDesc() {
	m.desc = nil
}

// SetDuration sets the "duration" field.
func (m *TkExamPaperPartitionMutation) SetDuration(i int) {
	m.duration = &i
	m.addduration = nil
}

// Duration returns the value of the "duration" field in the mutation.
func (m *TkExamPaperPartitionMutation) Duration() (r int, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old "duration" field's value of the TkExamPaperPartition entity.
// If the TkExamPaperPartition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamPaperPartitionMutation) OldDuration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// AddDuration adds i to the "duration" field.
func (m *TkExamPaperPartitionMutation) AddDuration(i int) {
	if m.addduration != nil {
		*m.addduration += i
	} else {
		m.addduration = &i
	}
}

// AddedDuration returns the value that was added to the "duration" field in this mutation.
func (m *TkExamPaperPartitionMutation) AddedDuration() (r int, exists bool) {
	v := m.addduration
	if v == nil {
		return
	}
	return *v, true
}

// ResetDuration resets all changes to the "duration" field.
func (m *TkExamPaperPartitionMutation) ResetDuration() {
	m.duration = nil
	m.addduration = nil
}

// SetType sets the "type" field.
func (m *TkExamPaperPartitionMutation) SetType(i int) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *TkExamPaperPartitionMutation) GetType() (r int, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the TkExamPaperPartition entity.
// If the TkExamPaperPartition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamPaperPartitionMutation) OldType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to the "type" field.
func (m *TkExamPaperPartitionMutation) AddType(i int) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *TkExamPaperPartitionMutation) AddedType() (r int, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *TkExamPaperPartitionMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetQuestionCount sets the "question_count" field.
func (m *TkExamPaperPartitionMutation) SetQuestionCount(u uint8) {
	m.question_count = &u
	m.addquestion_count = nil
}

// QuestionCount returns the value of the "question_count" field in the mutation.
func (m *TkExamPaperPartitionMutation) QuestionCount() (r uint8, exists bool) {
	v := m.question_count
	if v == nil {
		return
	}
	return *v, true
}

// OldQuestionCount returns the old "question_count" field's value of the TkExamPaperPartition entity.
// If the TkExamPaperPartition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamPaperPartitionMutation) OldQuestionCount(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldQuestionCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldQuestionCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuestionCount: %w", err)
	}
	return oldValue.QuestionCount, nil
}

// AddQuestionCount adds u to the "question_count" field.
func (m *TkExamPaperPartitionMutation) AddQuestionCount(u uint8) {
	if m.addquestion_count != nil {
		*m.addquestion_count += u
	} else {
		m.addquestion_count = &u
	}
}

// AddedQuestionCount returns the value that was added to the "question_count" field in this mutation.
func (m *TkExamPaperPartitionMutation) AddedQuestionCount() (r uint8, exists bool) {
	v := m.addquestion_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuestionCount resets all changes to the "question_count" field.
func (m *TkExamPaperPartitionMutation) ResetQuestionCount() {
	m.question_count = nil
	m.addquestion_count = nil
}

// SetExamPaperID sets the "exam_paper_id" field.
func (m *TkExamPaperPartitionMutation) SetExamPaperID(i int) {
	m.exam_paper = &i
}

// ExamPaperID returns the value of the "exam_paper_id" field in the mutation.
func (m *TkExamPaperPartitionMutation) ExamPaperID() (r int, exists bool) {
	v := m.exam_paper
	if v == nil {
		return
	}
	return *v, true
}

// OldExamPaperID returns the old "exam_paper_id" field's value of the TkExamPaperPartition entity.
// If the TkExamPaperPartition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamPaperPartitionMutation) OldExamPaperID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExamPaperID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExamPaperID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamPaperID: %w", err)
	}
	return oldValue.ExamPaperID, nil
}

// ClearExamPaperID clears the value of the "exam_paper_id" field.
func (m *TkExamPaperPartitionMutation) ClearExamPaperID() {
	m.exam_paper = nil
	m.clearedFields[tkexampaperpartition.FieldExamPaperID] = struct{}{}
}

// ExamPaperIDCleared returns if the "exam_paper_id" field was cleared in this mutation.
func (m *TkExamPaperPartitionMutation) ExamPaperIDCleared() bool {
	_, ok := m.clearedFields[tkexampaperpartition.FieldExamPaperID]
	return ok
}

// ResetExamPaperID resets all changes to the "exam_paper_id" field.
func (m *TkExamPaperPartitionMutation) ResetExamPaperID() {
	m.exam_paper = nil
	delete(m.clearedFields, tkexampaperpartition.FieldExamPaperID)
}

// ClearExamPaper clears the "exam_paper" edge to the TkExamPaper entity.
func (m *TkExamPaperPartitionMutation) ClearExamPaper() {
	m.clearedexam_paper = true
}

// ExamPaperCleared reports if the "exam_paper" edge to the TkExamPaper entity was cleared.
func (m *TkExamPaperPartitionMutation) ExamPaperCleared() bool {
	return m.ExamPaperIDCleared() || m.clearedexam_paper
}

// ExamPaperIDs returns the "exam_paper" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ExamPaperID instead. It exists only for internal usage by the builders.
func (m *TkExamPaperPartitionMutation) ExamPaperIDs() (ids []int) {
	if id := m.exam_paper; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExamPaper resets all changes to the "exam_paper" edge.
func (m *TkExamPaperPartitionMutation) ResetExamPaper() {
	m.exam_paper = nil
	m.clearedexam_paper = false
}

// AddExamPartitionLinkIDs adds the "exam_partition_links" edge to the TkExamPartitionQuestionLink entity by ids.
func (m *TkExamPaperPartitionMutation) AddExamPartitionLinkIDs(ids ...int) {
	if m.exam_partition_links == nil {
		m.exam_partition_links = make(map[int]struct{})
	}
	for i := range ids {
		m.exam_partition_links[ids[i]] = struct{}{}
	}
}

// ClearExamPartitionLinks clears the "exam_partition_links" edge to the TkExamPartitionQuestionLink entity.
func (m *TkExamPaperPartitionMutation) ClearExamPartitionLinks() {
	m.clearedexam_partition_links = true
}

// ExamPartitionLinksCleared reports if the "exam_partition_links" edge to the TkExamPartitionQuestionLink entity was cleared.
func (m *TkExamPaperPartitionMutation) ExamPartitionLinksCleared() bool {
	return m.clearedexam_partition_links
}

// RemoveExamPartitionLinkIDs removes the "exam_partition_links" edge to the TkExamPartitionQuestionLink entity by IDs.
func (m *TkExamPaperPartitionMutation) RemoveExamPartitionLinkIDs(ids ...int) {
	if m.removedexam_partition_links == nil {
		m.removedexam_partition_links = make(map[int]struct{})
	}
	for i := range ids {
		m.removedexam_partition_links[ids[i]] = struct{}{}
	}
}

// RemovedExamPartitionLinks returns the removed IDs of the "exam_partition_links" edge to the TkExamPartitionQuestionLink entity.
func (m *TkExamPaperPartitionMutation) RemovedExamPartitionLinksIDs() (ids []int) {
	for id := range m.removedexam_partition_links {
		ids = append(ids, id)
	}
	return
}

// ExamPartitionLinksIDs returns the "exam_partition_links" edge IDs in the mutation.
func (m *TkExamPaperPartitionMutation) ExamPartitionLinksIDs() (ids []int) {
	for id := range m.exam_partition_links {
		ids = append(ids, id)
	}
	return
}

// ResetExamPartitionLinks resets all changes to the "exam_partition_links" edge.
func (m *TkExamPaperPartitionMutation) ResetExamPartitionLinks() {
	m.exam_partition_links = nil
	m.clearedexam_partition_links = false
	m.removedexam_partition_links = nil
}

// AddExamPartitionScoreIDs adds the "exam_partition_scores" edge to the TkExamPaperPartitionScore entity by ids.
func (m *TkExamPaperPartitionMutation) AddExamPartitionScoreIDs(ids ...int) {
	if m.exam_partition_scores == nil {
		m.exam_partition_scores = make(map[int]struct{})
	}
	for i := range ids {
		m.exam_partition_scores[ids[i]] = struct{}{}
	}
}

// ClearExamPartitionScores clears the "exam_partition_scores" edge to the TkExamPaperPartitionScore entity.
func (m *TkExamPaperPartitionMutation) ClearExamPartitionScores() {
	m.clearedexam_partition_scores = true
}

// ExamPartitionScoresCleared reports if the "exam_partition_scores" edge to the TkExamPaperPartitionScore entity was cleared.
func (m *TkExamPaperPartitionMutation) ExamPartitionScoresCleared() bool {
	return m.clearedexam_partition_scores
}

// RemoveExamPartitionScoreIDs removes the "exam_partition_scores" edge to the TkExamPaperPartitionScore entity by IDs.
func (m *TkExamPaperPartitionMutation) RemoveExamPartitionScoreIDs(ids ...int) {
	if m.removedexam_partition_scores == nil {
		m.removedexam_partition_scores = make(map[int]struct{})
	}
	for i := range ids {
		m.removedexam_partition_scores[ids[i]] = struct{}{}
	}
}

// RemovedExamPartitionScores returns the removed IDs of the "exam_partition_scores" edge to the TkExamPaperPartitionScore entity.
func (m *TkExamPaperPartitionMutation) RemovedExamPartitionScoresIDs() (ids []int) {
	for id := range m.removedexam_partition_scores {
		ids = append(ids, id)
	}
	return
}

// ExamPartitionScoresIDs returns the "exam_partition_scores" edge IDs in the mutation.
func (m *TkExamPaperPartitionMutation) ExamPartitionScoresIDs() (ids []int) {
	for id := range m.exam_partition_scores {
		ids = append(ids, id)
	}
	return
}

// ResetExamPartitionScores resets all changes to the "exam_partition_scores" edge.
func (m *TkExamPaperPartitionMutation) ResetExamPartitionScores() {
	m.exam_partition_scores = nil
	m.clearedexam_partition_scores = false
	m.removedexam_partition_scores = nil
}

// Op returns the operation name.
func (m *TkExamPaperPartitionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TkExamPaperPartition).
func (m *TkExamPaperPartitionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TkExamPaperPartitionMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.uuid != nil {
		fields = append(fields, tkexampaperpartition.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, tkexampaperpartition.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tkexampaperpartition.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, tkexampaperpartition.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, tkexampaperpartition.FieldName)
	}
	if m.desc != nil {
		fields = append(fields, tkexampaperpartition.FieldDesc)
	}
	if m.duration != nil {
		fields = append(fields, tkexampaperpartition.FieldDuration)
	}
	if m._type != nil {
		fields = append(fields, tkexampaperpartition.FieldType)
	}
	if m.question_count != nil {
		fields = append(fields, tkexampaperpartition.FieldQuestionCount)
	}
	if m.exam_paper != nil {
		fields = append(fields, tkexampaperpartition.FieldExamPaperID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TkExamPaperPartitionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tkexampaperpartition.FieldUUID:
		return m.UUID()
	case tkexampaperpartition.FieldCreatedAt:
		return m.CreatedAt()
	case tkexampaperpartition.FieldUpdatedAt:
		return m.UpdatedAt()
	case tkexampaperpartition.FieldDeletedAt:
		return m.DeletedAt()
	case tkexampaperpartition.FieldName:
		return m.Name()
	case tkexampaperpartition.FieldDesc:
		return m.Desc()
	case tkexampaperpartition.FieldDuration:
		return m.Duration()
	case tkexampaperpartition.FieldType:
		return m.GetType()
	case tkexampaperpartition.FieldQuestionCount:
		return m.QuestionCount()
	case tkexampaperpartition.FieldExamPaperID:
		return m.ExamPaperID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TkExamPaperPartitionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tkexampaperpartition.FieldUUID:
		return m.OldUUID(ctx)
	case tkexampaperpartition.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tkexampaperpartition.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tkexampaperpartition.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case tkexampaperpartition.FieldName:
		return m.OldName(ctx)
	case tkexampaperpartition.FieldDesc:
		return m.OldDesc(ctx)
	case tkexampaperpartition.FieldDuration:
		return m.OldDuration(ctx)
	case tkexampaperpartition.FieldType:
		return m.OldType(ctx)
	case tkexampaperpartition.FieldQuestionCount:
		return m.OldQuestionCount(ctx)
	case tkexampaperpartition.FieldExamPaperID:
		return m.OldExamPaperID(ctx)
	}
	return nil, fmt.Errorf("unknown TkExamPaperPartition field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TkExamPaperPartitionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tkexampaperpartition.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case tkexampaperpartition.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tkexampaperpartition.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tkexampaperpartition.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case tkexampaperpartition.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tkexampaperpartition.FieldDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	case tkexampaperpartition.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	case tkexampaperpartition.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case tkexampaperpartition.FieldQuestionCount:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuestionCount(v)
		return nil
	case tkexampaperpartition.FieldExamPaperID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamPaperID(v)
		return nil
	}
	return fmt.Errorf("unknown TkExamPaperPartition field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TkExamPaperPartitionMutation) AddedFields() []string {
	var fields []string
	if m.addduration != nil {
		fields = append(fields, tkexampaperpartition.FieldDuration)
	}
	if m.add_type != nil {
		fields = append(fields, tkexampaperpartition.FieldType)
	}
	if m.addquestion_count != nil {
		fields = append(fields, tkexampaperpartition.FieldQuestionCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TkExamPaperPartitionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tkexampaperpartition.FieldDuration:
		return m.AddedDuration()
	case tkexampaperpartition.FieldType:
		return m.AddedType()
	case tkexampaperpartition.FieldQuestionCount:
		return m.AddedQuestionCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TkExamPaperPartitionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tkexampaperpartition.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDuration(v)
		return nil
	case tkexampaperpartition.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case tkexampaperpartition.FieldQuestionCount:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuestionCount(v)
		return nil
	}
	return fmt.Errorf("unknown TkExamPaperPartition numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TkExamPaperPartitionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tkexampaperpartition.FieldCreatedAt) {
		fields = append(fields, tkexampaperpartition.FieldCreatedAt)
	}
	if m.FieldCleared(tkexampaperpartition.FieldUpdatedAt) {
		fields = append(fields, tkexampaperpartition.FieldUpdatedAt)
	}
	if m.FieldCleared(tkexampaperpartition.FieldDeletedAt) {
		fields = append(fields, tkexampaperpartition.FieldDeletedAt)
	}
	if m.FieldCleared(tkexampaperpartition.FieldExamPaperID) {
		fields = append(fields, tkexampaperpartition.FieldExamPaperID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TkExamPaperPartitionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TkExamPaperPartitionMutation) ClearField(name string) error {
	switch name {
	case tkexampaperpartition.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case tkexampaperpartition.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case tkexampaperpartition.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case tkexampaperpartition.FieldExamPaperID:
		m.ClearExamPaperID()
		return nil
	}
	return fmt.Errorf("unknown TkExamPaperPartition nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TkExamPaperPartitionMutation) ResetField(name string) error {
	switch name {
	case tkexampaperpartition.FieldUUID:
		m.ResetUUID()
		return nil
	case tkexampaperpartition.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tkexampaperpartition.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tkexampaperpartition.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case tkexampaperpartition.FieldName:
		m.ResetName()
		return nil
	case tkexampaperpartition.FieldDesc:
		m.ResetDesc()
		return nil
	case tkexampaperpartition.FieldDuration:
		m.ResetDuration()
		return nil
	case tkexampaperpartition.FieldType:
		m.ResetType()
		return nil
	case tkexampaperpartition.FieldQuestionCount:
		m.ResetQuestionCount()
		return nil
	case tkexampaperpartition.FieldExamPaperID:
		m.ResetExamPaperID()
		return nil
	}
	return fmt.Errorf("unknown TkExamPaperPartition field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TkExamPaperPartitionMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.exam_paper != nil {
		edges = append(edges, tkexampaperpartition.EdgeExamPaper)
	}
	if m.exam_partition_links != nil {
		edges = append(edges, tkexampaperpartition.EdgeExamPartitionLinks)
	}
	if m.exam_partition_scores != nil {
		edges = append(edges, tkexampaperpartition.EdgeExamPartitionScores)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TkExamPaperPartitionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tkexampaperpartition.EdgeExamPaper:
		if id := m.exam_paper; id != nil {
			return []ent.Value{*id}
		}
	case tkexampaperpartition.EdgeExamPartitionLinks:
		ids := make([]ent.Value, 0, len(m.exam_partition_links))
		for id := range m.exam_partition_links {
			ids = append(ids, id)
		}
		return ids
	case tkexampaperpartition.EdgeExamPartitionScores:
		ids := make([]ent.Value, 0, len(m.exam_partition_scores))
		for id := range m.exam_partition_scores {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TkExamPaperPartitionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedexam_partition_links != nil {
		edges = append(edges, tkexampaperpartition.EdgeExamPartitionLinks)
	}
	if m.removedexam_partition_scores != nil {
		edges = append(edges, tkexampaperpartition.EdgeExamPartitionScores)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TkExamPaperPartitionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tkexampaperpartition.EdgeExamPartitionLinks:
		ids := make([]ent.Value, 0, len(m.removedexam_partition_links))
		for id := range m.removedexam_partition_links {
			ids = append(ids, id)
		}
		return ids
	case tkexampaperpartition.EdgeExamPartitionScores:
		ids := make([]ent.Value, 0, len(m.removedexam_partition_scores))
		for id := range m.removedexam_partition_scores {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TkExamPaperPartitionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedexam_paper {
		edges = append(edges, tkexampaperpartition.EdgeExamPaper)
	}
	if m.clearedexam_partition_links {
		edges = append(edges, tkexampaperpartition.EdgeExamPartitionLinks)
	}
	if m.clearedexam_partition_scores {
		edges = append(edges, tkexampaperpartition.EdgeExamPartitionScores)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TkExamPaperPartitionMutation) EdgeCleared(name string) bool {
	switch name {
	case tkexampaperpartition.EdgeExamPaper:
		return m.clearedexam_paper
	case tkexampaperpartition.EdgeExamPartitionLinks:
		return m.clearedexam_partition_links
	case tkexampaperpartition.EdgeExamPartitionScores:
		return m.clearedexam_partition_scores
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TkExamPaperPartitionMutation) ClearEdge(name string) error {
	switch name {
	case tkexampaperpartition.EdgeExamPaper:
		m.ClearExamPaper()
		return nil
	}
	return fmt.Errorf("unknown TkExamPaperPartition unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TkExamPaperPartitionMutation) ResetEdge(name string) error {
	switch name {
	case tkexampaperpartition.EdgeExamPaper:
		m.ResetExamPaper()
		return nil
	case tkexampaperpartition.EdgeExamPartitionLinks:
		m.ResetExamPartitionLinks()
		return nil
	case tkexampaperpartition.EdgeExamPartitionScores:
		m.ResetExamPartitionScores()
		return nil
	}
	return fmt.Errorf("unknown TkExamPaperPartition edge %s", name)
}

// TkExamPaperPartitionScoreMutation represents an operation that mutates the TkExamPaperPartitionScore nodes in the graph.
type TkExamPaperPartitionScoreMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int
	uuid                        *string
	created_at                  *time.Time
	updated_at                  *time.Time
	deleted_at                  *time.Time
	singe_select                *uint8
	addsinge_select             *uint8
	judge_question              *uint8
	addjudge_question           *uint8
	multi_select                *uint8
	addmulti_select             *uint8
	shorter_answer              *uint8
	addshorter_answer           *uint8
	material_question           *uint8
	addmaterial_question        *uint8
	singe_select_count          *uint8
	addsinge_select_count       *uint8
	judge_question_count        *uint8
	addjudge_question_count     *uint8
	multi_select_count          *uint8
	addmulti_select_count       *uint8
	shorter_answer_count        *uint8
	addshorter_answer_count     *uint8
	material_question_count     *uint8
	addmaterial_question_count  *uint8
	clearedFields               map[string]struct{}
	exam_paper_partition        *int
	clearedexam_paper_partition bool
	done                        bool
	oldValue                    func(context.Context) (*TkExamPaperPartitionScore, error)
	predicates                  []predicate.TkExamPaperPartitionScore
}

var _ ent.Mutation = (*TkExamPaperPartitionScoreMutation)(nil)

// tkexampaperpartitionscoreOption allows management of the mutation configuration using functional options.
type tkexampaperpartitionscoreOption func(*TkExamPaperPartitionScoreMutation)

// newTkExamPaperPartitionScoreMutation creates new mutation for the TkExamPaperPartitionScore entity.
func newTkExamPaperPartitionScoreMutation(c config, op Op, opts ...tkexampaperpartitionscoreOption) *TkExamPaperPartitionScoreMutation {
	m := &TkExamPaperPartitionScoreMutation{
		config:        c,
		op:            op,
		typ:           TypeTkExamPaperPartitionScore,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTkExamPaperPartitionScoreID sets the ID field of the mutation.
func withTkExamPaperPartitionScoreID(id int) tkexampaperpartitionscoreOption {
	return func(m *TkExamPaperPartitionScoreMutation) {
		var (
			err   error
			once  sync.Once
			value *TkExamPaperPartitionScore
		)
		m.oldValue = func(ctx context.Context) (*TkExamPaperPartitionScore, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TkExamPaperPartitionScore.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTkExamPaperPartitionScore sets the old TkExamPaperPartitionScore of the mutation.
func withTkExamPaperPartitionScore(node *TkExamPaperPartitionScore) tkexampaperpartitionscoreOption {
	return func(m *TkExamPaperPartitionScoreMutation) {
		m.oldValue = func(context.Context) (*TkExamPaperPartitionScore, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TkExamPaperPartitionScoreMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TkExamPaperPartitionScoreMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *TkExamPaperPartitionScoreMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *TkExamPaperPartitionScoreMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *TkExamPaperPartitionScoreMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the TkExamPaperPartitionScore entity.
// If the TkExamPaperPartitionScore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamPaperPartitionScoreMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *TkExamPaperPartitionScoreMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TkExamPaperPartitionScoreMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TkExamPaperPartitionScoreMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TkExamPaperPartitionScore entity.
// If the TkExamPaperPartitionScore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamPaperPartitionScoreMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *TkExamPaperPartitionScoreMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[tkexampaperpartitionscore.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *TkExamPaperPartitionScoreMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[tkexampaperpartitionscore.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TkExamPaperPartitionScoreMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, tkexampaperpartitionscore.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TkExamPaperPartitionScoreMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TkExamPaperPartitionScoreMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TkExamPaperPartitionScore entity.
// If the TkExamPaperPartitionScore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamPaperPartitionScoreMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TkExamPaperPartitionScoreMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[tkexampaperpartitionscore.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TkExamPaperPartitionScoreMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[tkexampaperpartitionscore.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TkExamPaperPartitionScoreMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, tkexampaperpartitionscore.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TkExamPaperPartitionScoreMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TkExamPaperPartitionScoreMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TkExamPaperPartitionScore entity.
// If the TkExamPaperPartitionScore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamPaperPartitionScoreMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TkExamPaperPartitionScoreMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[tkexampaperpartitionscore.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TkExamPaperPartitionScoreMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[tkexampaperpartitionscore.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TkExamPaperPartitionScoreMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, tkexampaperpartitionscore.FieldDeletedAt)
}

// SetSingeSelect sets the "singe_select" field.
func (m *TkExamPaperPartitionScoreMutation) SetSingeSelect(u uint8) {
	m.singe_select = &u
	m.addsinge_select = nil
}

// SingeSelect returns the value of the "singe_select" field in the mutation.
func (m *TkExamPaperPartitionScoreMutation) SingeSelect() (r uint8, exists bool) {
	v := m.singe_select
	if v == nil {
		return
	}
	return *v, true
}

// OldSingeSelect returns the old "singe_select" field's value of the TkExamPaperPartitionScore entity.
// If the TkExamPaperPartitionScore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamPaperPartitionScoreMutation) OldSingeSelect(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSingeSelect is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSingeSelect requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSingeSelect: %w", err)
	}
	return oldValue.SingeSelect, nil
}

// AddSingeSelect adds u to the "singe_select" field.
func (m *TkExamPaperPartitionScoreMutation) AddSingeSelect(u uint8) {
	if m.addsinge_select != nil {
		*m.addsinge_select += u
	} else {
		m.addsinge_select = &u
	}
}

// AddedSingeSelect returns the value that was added to the "singe_select" field in this mutation.
func (m *TkExamPaperPartitionScoreMutation) AddedSingeSelect() (r uint8, exists bool) {
	v := m.addsinge_select
	if v == nil {
		return
	}
	return *v, true
}

// ResetSingeSelect resets all changes to the "singe_select" field.
func (m *TkExamPaperPartitionScoreMutation) ResetSingeSelect() {
	m.singe_select = nil
	m.addsinge_select = nil
}

// SetJudgeQuestion sets the "judge_question" field.
func (m *TkExamPaperPartitionScoreMutation) SetJudgeQuestion(u uint8) {
	m.judge_question = &u
	m.addjudge_question = nil
}

// JudgeQuestion returns the value of the "judge_question" field in the mutation.
func (m *TkExamPaperPartitionScoreMutation) JudgeQuestion() (r uint8, exists bool) {
	v := m.judge_question
	if v == nil {
		return
	}
	return *v, true
}

// OldJudgeQuestion returns the old "judge_question" field's value of the TkExamPaperPartitionScore entity.
// If the TkExamPaperPartitionScore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamPaperPartitionScoreMutation) OldJudgeQuestion(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldJudgeQuestion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldJudgeQuestion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJudgeQuestion: %w", err)
	}
	return oldValue.JudgeQuestion, nil
}

// AddJudgeQuestion adds u to the "judge_question" field.
func (m *TkExamPaperPartitionScoreMutation) AddJudgeQuestion(u uint8) {
	if m.addjudge_question != nil {
		*m.addjudge_question += u
	} else {
		m.addjudge_question = &u
	}
}

// AddedJudgeQuestion returns the value that was added to the "judge_question" field in this mutation.
func (m *TkExamPaperPartitionScoreMutation) AddedJudgeQuestion() (r uint8, exists bool) {
	v := m.addjudge_question
	if v == nil {
		return
	}
	return *v, true
}

// ResetJudgeQuestion resets all changes to the "judge_question" field.
func (m *TkExamPaperPartitionScoreMutation) ResetJudgeQuestion() {
	m.judge_question = nil
	m.addjudge_question = nil
}

// SetMultiSelect sets the "multi_select" field.
func (m *TkExamPaperPartitionScoreMutation) SetMultiSelect(u uint8) {
	m.multi_select = &u
	m.addmulti_select = nil
}

// MultiSelect returns the value of the "multi_select" field in the mutation.
func (m *TkExamPaperPartitionScoreMutation) MultiSelect() (r uint8, exists bool) {
	v := m.multi_select
	if v == nil {
		return
	}
	return *v, true
}

// OldMultiSelect returns the old "multi_select" field's value of the TkExamPaperPartitionScore entity.
// If the TkExamPaperPartitionScore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamPaperPartitionScoreMutation) OldMultiSelect(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMultiSelect is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMultiSelect requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMultiSelect: %w", err)
	}
	return oldValue.MultiSelect, nil
}

// AddMultiSelect adds u to the "multi_select" field.
func (m *TkExamPaperPartitionScoreMutation) AddMultiSelect(u uint8) {
	if m.addmulti_select != nil {
		*m.addmulti_select += u
	} else {
		m.addmulti_select = &u
	}
}

// AddedMultiSelect returns the value that was added to the "multi_select" field in this mutation.
func (m *TkExamPaperPartitionScoreMutation) AddedMultiSelect() (r uint8, exists bool) {
	v := m.addmulti_select
	if v == nil {
		return
	}
	return *v, true
}

// ResetMultiSelect resets all changes to the "multi_select" field.
func (m *TkExamPaperPartitionScoreMutation) ResetMultiSelect() {
	m.multi_select = nil
	m.addmulti_select = nil
}

// SetShorterAnswer sets the "shorter_answer" field.
func (m *TkExamPaperPartitionScoreMutation) SetShorterAnswer(u uint8) {
	m.shorter_answer = &u
	m.addshorter_answer = nil
}

// ShorterAnswer returns the value of the "shorter_answer" field in the mutation.
func (m *TkExamPaperPartitionScoreMutation) ShorterAnswer() (r uint8, exists bool) {
	v := m.shorter_answer
	if v == nil {
		return
	}
	return *v, true
}

// OldShorterAnswer returns the old "shorter_answer" field's value of the TkExamPaperPartitionScore entity.
// If the TkExamPaperPartitionScore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamPaperPartitionScoreMutation) OldShorterAnswer(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShorterAnswer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShorterAnswer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShorterAnswer: %w", err)
	}
	return oldValue.ShorterAnswer, nil
}

// AddShorterAnswer adds u to the "shorter_answer" field.
func (m *TkExamPaperPartitionScoreMutation) AddShorterAnswer(u uint8) {
	if m.addshorter_answer != nil {
		*m.addshorter_answer += u
	} else {
		m.addshorter_answer = &u
	}
}

// AddedShorterAnswer returns the value that was added to the "shorter_answer" field in this mutation.
func (m *TkExamPaperPartitionScoreMutation) AddedShorterAnswer() (r uint8, exists bool) {
	v := m.addshorter_answer
	if v == nil {
		return
	}
	return *v, true
}

// ResetShorterAnswer resets all changes to the "shorter_answer" field.
func (m *TkExamPaperPartitionScoreMutation) ResetShorterAnswer() {
	m.shorter_answer = nil
	m.addshorter_answer = nil
}

// SetMaterialQuestion sets the "material_question" field.
func (m *TkExamPaperPartitionScoreMutation) SetMaterialQuestion(u uint8) {
	m.material_question = &u
	m.addmaterial_question = nil
}

// MaterialQuestion returns the value of the "material_question" field in the mutation.
func (m *TkExamPaperPartitionScoreMutation) MaterialQuestion() (r uint8, exists bool) {
	v := m.material_question
	if v == nil {
		return
	}
	return *v, true
}

// OldMaterialQuestion returns the old "material_question" field's value of the TkExamPaperPartitionScore entity.
// If the TkExamPaperPartitionScore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamPaperPartitionScoreMutation) OldMaterialQuestion(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMaterialQuestion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMaterialQuestion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaterialQuestion: %w", err)
	}
	return oldValue.MaterialQuestion, nil
}

// AddMaterialQuestion adds u to the "material_question" field.
func (m *TkExamPaperPartitionScoreMutation) AddMaterialQuestion(u uint8) {
	if m.addmaterial_question != nil {
		*m.addmaterial_question += u
	} else {
		m.addmaterial_question = &u
	}
}

// AddedMaterialQuestion returns the value that was added to the "material_question" field in this mutation.
func (m *TkExamPaperPartitionScoreMutation) AddedMaterialQuestion() (r uint8, exists bool) {
	v := m.addmaterial_question
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaterialQuestion resets all changes to the "material_question" field.
func (m *TkExamPaperPartitionScoreMutation) ResetMaterialQuestion() {
	m.material_question = nil
	m.addmaterial_question = nil
}

// SetSingeSelectCount sets the "singe_select_count" field.
func (m *TkExamPaperPartitionScoreMutation) SetSingeSelectCount(u uint8) {
	m.singe_select_count = &u
	m.addsinge_select_count = nil
}

// SingeSelectCount returns the value of the "singe_select_count" field in the mutation.
func (m *TkExamPaperPartitionScoreMutation) SingeSelectCount() (r uint8, exists bool) {
	v := m.singe_select_count
	if v == nil {
		return
	}
	return *v, true
}

// OldSingeSelectCount returns the old "singe_select_count" field's value of the TkExamPaperPartitionScore entity.
// If the TkExamPaperPartitionScore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamPaperPartitionScoreMutation) OldSingeSelectCount(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSingeSelectCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSingeSelectCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSingeSelectCount: %w", err)
	}
	return oldValue.SingeSelectCount, nil
}

// AddSingeSelectCount adds u to the "singe_select_count" field.
func (m *TkExamPaperPartitionScoreMutation) AddSingeSelectCount(u uint8) {
	if m.addsinge_select_count != nil {
		*m.addsinge_select_count += u
	} else {
		m.addsinge_select_count = &u
	}
}

// AddedSingeSelectCount returns the value that was added to the "singe_select_count" field in this mutation.
func (m *TkExamPaperPartitionScoreMutation) AddedSingeSelectCount() (r uint8, exists bool) {
	v := m.addsinge_select_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetSingeSelectCount resets all changes to the "singe_select_count" field.
func (m *TkExamPaperPartitionScoreMutation) ResetSingeSelectCount() {
	m.singe_select_count = nil
	m.addsinge_select_count = nil
}

// SetJudgeQuestionCount sets the "judge_question_count" field.
func (m *TkExamPaperPartitionScoreMutation) SetJudgeQuestionCount(u uint8) {
	m.judge_question_count = &u
	m.addjudge_question_count = nil
}

// JudgeQuestionCount returns the value of the "judge_question_count" field in the mutation.
func (m *TkExamPaperPartitionScoreMutation) JudgeQuestionCount() (r uint8, exists bool) {
	v := m.judge_question_count
	if v == nil {
		return
	}
	return *v, true
}

// OldJudgeQuestionCount returns the old "judge_question_count" field's value of the TkExamPaperPartitionScore entity.
// If the TkExamPaperPartitionScore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamPaperPartitionScoreMutation) OldJudgeQuestionCount(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldJudgeQuestionCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldJudgeQuestionCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJudgeQuestionCount: %w", err)
	}
	return oldValue.JudgeQuestionCount, nil
}

// AddJudgeQuestionCount adds u to the "judge_question_count" field.
func (m *TkExamPaperPartitionScoreMutation) AddJudgeQuestionCount(u uint8) {
	if m.addjudge_question_count != nil {
		*m.addjudge_question_count += u
	} else {
		m.addjudge_question_count = &u
	}
}

// AddedJudgeQuestionCount returns the value that was added to the "judge_question_count" field in this mutation.
func (m *TkExamPaperPartitionScoreMutation) AddedJudgeQuestionCount() (r uint8, exists bool) {
	v := m.addjudge_question_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetJudgeQuestionCount resets all changes to the "judge_question_count" field.
func (m *TkExamPaperPartitionScoreMutation) ResetJudgeQuestionCount() {
	m.judge_question_count = nil
	m.addjudge_question_count = nil
}

// SetMultiSelectCount sets the "multi_select_count" field.
func (m *TkExamPaperPartitionScoreMutation) SetMultiSelectCount(u uint8) {
	m.multi_select_count = &u
	m.addmulti_select_count = nil
}

// MultiSelectCount returns the value of the "multi_select_count" field in the mutation.
func (m *TkExamPaperPartitionScoreMutation) MultiSelectCount() (r uint8, exists bool) {
	v := m.multi_select_count
	if v == nil {
		return
	}
	return *v, true
}

// OldMultiSelectCount returns the old "multi_select_count" field's value of the TkExamPaperPartitionScore entity.
// If the TkExamPaperPartitionScore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamPaperPartitionScoreMutation) OldMultiSelectCount(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMultiSelectCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMultiSelectCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMultiSelectCount: %w", err)
	}
	return oldValue.MultiSelectCount, nil
}

// AddMultiSelectCount adds u to the "multi_select_count" field.
func (m *TkExamPaperPartitionScoreMutation) AddMultiSelectCount(u uint8) {
	if m.addmulti_select_count != nil {
		*m.addmulti_select_count += u
	} else {
		m.addmulti_select_count = &u
	}
}

// AddedMultiSelectCount returns the value that was added to the "multi_select_count" field in this mutation.
func (m *TkExamPaperPartitionScoreMutation) AddedMultiSelectCount() (r uint8, exists bool) {
	v := m.addmulti_select_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetMultiSelectCount resets all changes to the "multi_select_count" field.
func (m *TkExamPaperPartitionScoreMutation) ResetMultiSelectCount() {
	m.multi_select_count = nil
	m.addmulti_select_count = nil
}

// SetShorterAnswerCount sets the "shorter_answer_count" field.
func (m *TkExamPaperPartitionScoreMutation) SetShorterAnswerCount(u uint8) {
	m.shorter_answer_count = &u
	m.addshorter_answer_count = nil
}

// ShorterAnswerCount returns the value of the "shorter_answer_count" field in the mutation.
func (m *TkExamPaperPartitionScoreMutation) ShorterAnswerCount() (r uint8, exists bool) {
	v := m.shorter_answer_count
	if v == nil {
		return
	}
	return *v, true
}

// OldShorterAnswerCount returns the old "shorter_answer_count" field's value of the TkExamPaperPartitionScore entity.
// If the TkExamPaperPartitionScore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamPaperPartitionScoreMutation) OldShorterAnswerCount(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShorterAnswerCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShorterAnswerCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShorterAnswerCount: %w", err)
	}
	return oldValue.ShorterAnswerCount, nil
}

// AddShorterAnswerCount adds u to the "shorter_answer_count" field.
func (m *TkExamPaperPartitionScoreMutation) AddShorterAnswerCount(u uint8) {
	if m.addshorter_answer_count != nil {
		*m.addshorter_answer_count += u
	} else {
		m.addshorter_answer_count = &u
	}
}

// AddedShorterAnswerCount returns the value that was added to the "shorter_answer_count" field in this mutation.
func (m *TkExamPaperPartitionScoreMutation) AddedShorterAnswerCount() (r uint8, exists bool) {
	v := m.addshorter_answer_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetShorterAnswerCount resets all changes to the "shorter_answer_count" field.
func (m *TkExamPaperPartitionScoreMutation) ResetShorterAnswerCount() {
	m.shorter_answer_count = nil
	m.addshorter_answer_count = nil
}

// SetMaterialQuestionCount sets the "material_question_count" field.
func (m *TkExamPaperPartitionScoreMutation) SetMaterialQuestionCount(u uint8) {
	m.material_question_count = &u
	m.addmaterial_question_count = nil
}

// MaterialQuestionCount returns the value of the "material_question_count" field in the mutation.
func (m *TkExamPaperPartitionScoreMutation) MaterialQuestionCount() (r uint8, exists bool) {
	v := m.material_question_count
	if v == nil {
		return
	}
	return *v, true
}

// OldMaterialQuestionCount returns the old "material_question_count" field's value of the TkExamPaperPartitionScore entity.
// If the TkExamPaperPartitionScore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamPaperPartitionScoreMutation) OldMaterialQuestionCount(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMaterialQuestionCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMaterialQuestionCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaterialQuestionCount: %w", err)
	}
	return oldValue.MaterialQuestionCount, nil
}

// AddMaterialQuestionCount adds u to the "material_question_count" field.
func (m *TkExamPaperPartitionScoreMutation) AddMaterialQuestionCount(u uint8) {
	if m.addmaterial_question_count != nil {
		*m.addmaterial_question_count += u
	} else {
		m.addmaterial_question_count = &u
	}
}

// AddedMaterialQuestionCount returns the value that was added to the "material_question_count" field in this mutation.
func (m *TkExamPaperPartitionScoreMutation) AddedMaterialQuestionCount() (r uint8, exists bool) {
	v := m.addmaterial_question_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaterialQuestionCount resets all changes to the "material_question_count" field.
func (m *TkExamPaperPartitionScoreMutation) ResetMaterialQuestionCount() {
	m.material_question_count = nil
	m.addmaterial_question_count = nil
}

// SetExamPaperPartitionID sets the "exam_paper_partition_id" field.
func (m *TkExamPaperPartitionScoreMutation) SetExamPaperPartitionID(i int) {
	m.exam_paper_partition = &i
}

// ExamPaperPartitionID returns the value of the "exam_paper_partition_id" field in the mutation.
func (m *TkExamPaperPartitionScoreMutation) ExamPaperPartitionID() (r int, exists bool) {
	v := m.exam_paper_partition
	if v == nil {
		return
	}
	return *v, true
}

// OldExamPaperPartitionID returns the old "exam_paper_partition_id" field's value of the TkExamPaperPartitionScore entity.
// If the TkExamPaperPartitionScore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamPaperPartitionScoreMutation) OldExamPaperPartitionID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExamPaperPartitionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExamPaperPartitionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamPaperPartitionID: %w", err)
	}
	return oldValue.ExamPaperPartitionID, nil
}

// ClearExamPaperPartitionID clears the value of the "exam_paper_partition_id" field.
func (m *TkExamPaperPartitionScoreMutation) ClearExamPaperPartitionID() {
	m.exam_paper_partition = nil
	m.clearedFields[tkexampaperpartitionscore.FieldExamPaperPartitionID] = struct{}{}
}

// ExamPaperPartitionIDCleared returns if the "exam_paper_partition_id" field was cleared in this mutation.
func (m *TkExamPaperPartitionScoreMutation) ExamPaperPartitionIDCleared() bool {
	_, ok := m.clearedFields[tkexampaperpartitionscore.FieldExamPaperPartitionID]
	return ok
}

// ResetExamPaperPartitionID resets all changes to the "exam_paper_partition_id" field.
func (m *TkExamPaperPartitionScoreMutation) ResetExamPaperPartitionID() {
	m.exam_paper_partition = nil
	delete(m.clearedFields, tkexampaperpartitionscore.FieldExamPaperPartitionID)
}

// ClearExamPaperPartition clears the "exam_paper_partition" edge to the TkExamPaperPartition entity.
func (m *TkExamPaperPartitionScoreMutation) ClearExamPaperPartition() {
	m.clearedexam_paper_partition = true
}

// ExamPaperPartitionCleared reports if the "exam_paper_partition" edge to the TkExamPaperPartition entity was cleared.
func (m *TkExamPaperPartitionScoreMutation) ExamPaperPartitionCleared() bool {
	return m.ExamPaperPartitionIDCleared() || m.clearedexam_paper_partition
}

// ExamPaperPartitionIDs returns the "exam_paper_partition" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ExamPaperPartitionID instead. It exists only for internal usage by the builders.
func (m *TkExamPaperPartitionScoreMutation) ExamPaperPartitionIDs() (ids []int) {
	if id := m.exam_paper_partition; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExamPaperPartition resets all changes to the "exam_paper_partition" edge.
func (m *TkExamPaperPartitionScoreMutation) ResetExamPaperPartition() {
	m.exam_paper_partition = nil
	m.clearedexam_paper_partition = false
}

// Op returns the operation name.
func (m *TkExamPaperPartitionScoreMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TkExamPaperPartitionScore).
func (m *TkExamPaperPartitionScoreMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TkExamPaperPartitionScoreMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.uuid != nil {
		fields = append(fields, tkexampaperpartitionscore.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, tkexampaperpartitionscore.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tkexampaperpartitionscore.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, tkexampaperpartitionscore.FieldDeletedAt)
	}
	if m.singe_select != nil {
		fields = append(fields, tkexampaperpartitionscore.FieldSingeSelect)
	}
	if m.judge_question != nil {
		fields = append(fields, tkexampaperpartitionscore.FieldJudgeQuestion)
	}
	if m.multi_select != nil {
		fields = append(fields, tkexampaperpartitionscore.FieldMultiSelect)
	}
	if m.shorter_answer != nil {
		fields = append(fields, tkexampaperpartitionscore.FieldShorterAnswer)
	}
	if m.material_question != nil {
		fields = append(fields, tkexampaperpartitionscore.FieldMaterialQuestion)
	}
	if m.singe_select_count != nil {
		fields = append(fields, tkexampaperpartitionscore.FieldSingeSelectCount)
	}
	if m.judge_question_count != nil {
		fields = append(fields, tkexampaperpartitionscore.FieldJudgeQuestionCount)
	}
	if m.multi_select_count != nil {
		fields = append(fields, tkexampaperpartitionscore.FieldMultiSelectCount)
	}
	if m.shorter_answer_count != nil {
		fields = append(fields, tkexampaperpartitionscore.FieldShorterAnswerCount)
	}
	if m.material_question_count != nil {
		fields = append(fields, tkexampaperpartitionscore.FieldMaterialQuestionCount)
	}
	if m.exam_paper_partition != nil {
		fields = append(fields, tkexampaperpartitionscore.FieldExamPaperPartitionID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TkExamPaperPartitionScoreMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tkexampaperpartitionscore.FieldUUID:
		return m.UUID()
	case tkexampaperpartitionscore.FieldCreatedAt:
		return m.CreatedAt()
	case tkexampaperpartitionscore.FieldUpdatedAt:
		return m.UpdatedAt()
	case tkexampaperpartitionscore.FieldDeletedAt:
		return m.DeletedAt()
	case tkexampaperpartitionscore.FieldSingeSelect:
		return m.SingeSelect()
	case tkexampaperpartitionscore.FieldJudgeQuestion:
		return m.JudgeQuestion()
	case tkexampaperpartitionscore.FieldMultiSelect:
		return m.MultiSelect()
	case tkexampaperpartitionscore.FieldShorterAnswer:
		return m.ShorterAnswer()
	case tkexampaperpartitionscore.FieldMaterialQuestion:
		return m.MaterialQuestion()
	case tkexampaperpartitionscore.FieldSingeSelectCount:
		return m.SingeSelectCount()
	case tkexampaperpartitionscore.FieldJudgeQuestionCount:
		return m.JudgeQuestionCount()
	case tkexampaperpartitionscore.FieldMultiSelectCount:
		return m.MultiSelectCount()
	case tkexampaperpartitionscore.FieldShorterAnswerCount:
		return m.ShorterAnswerCount()
	case tkexampaperpartitionscore.FieldMaterialQuestionCount:
		return m.MaterialQuestionCount()
	case tkexampaperpartitionscore.FieldExamPaperPartitionID:
		return m.ExamPaperPartitionID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TkExamPaperPartitionScoreMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tkexampaperpartitionscore.FieldUUID:
		return m.OldUUID(ctx)
	case tkexampaperpartitionscore.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tkexampaperpartitionscore.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tkexampaperpartitionscore.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case tkexampaperpartitionscore.FieldSingeSelect:
		return m.OldSingeSelect(ctx)
	case tkexampaperpartitionscore.FieldJudgeQuestion:
		return m.OldJudgeQuestion(ctx)
	case tkexampaperpartitionscore.FieldMultiSelect:
		return m.OldMultiSelect(ctx)
	case tkexampaperpartitionscore.FieldShorterAnswer:
		return m.OldShorterAnswer(ctx)
	case tkexampaperpartitionscore.FieldMaterialQuestion:
		return m.OldMaterialQuestion(ctx)
	case tkexampaperpartitionscore.FieldSingeSelectCount:
		return m.OldSingeSelectCount(ctx)
	case tkexampaperpartitionscore.FieldJudgeQuestionCount:
		return m.OldJudgeQuestionCount(ctx)
	case tkexampaperpartitionscore.FieldMultiSelectCount:
		return m.OldMultiSelectCount(ctx)
	case tkexampaperpartitionscore.FieldShorterAnswerCount:
		return m.OldShorterAnswerCount(ctx)
	case tkexampaperpartitionscore.FieldMaterialQuestionCount:
		return m.OldMaterialQuestionCount(ctx)
	case tkexampaperpartitionscore.FieldExamPaperPartitionID:
		return m.OldExamPaperPartitionID(ctx)
	}
	return nil, fmt.Errorf("unknown TkExamPaperPartitionScore field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TkExamPaperPartitionScoreMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tkexampaperpartitionscore.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case tkexampaperpartitionscore.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tkexampaperpartitionscore.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tkexampaperpartitionscore.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case tkexampaperpartitionscore.FieldSingeSelect:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSingeSelect(v)
		return nil
	case tkexampaperpartitionscore.FieldJudgeQuestion:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJudgeQuestion(v)
		return nil
	case tkexampaperpartitionscore.FieldMultiSelect:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMultiSelect(v)
		return nil
	case tkexampaperpartitionscore.FieldShorterAnswer:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShorterAnswer(v)
		return nil
	case tkexampaperpartitionscore.FieldMaterialQuestion:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaterialQuestion(v)
		return nil
	case tkexampaperpartitionscore.FieldSingeSelectCount:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSingeSelectCount(v)
		return nil
	case tkexampaperpartitionscore.FieldJudgeQuestionCount:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJudgeQuestionCount(v)
		return nil
	case tkexampaperpartitionscore.FieldMultiSelectCount:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMultiSelectCount(v)
		return nil
	case tkexampaperpartitionscore.FieldShorterAnswerCount:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShorterAnswerCount(v)
		return nil
	case tkexampaperpartitionscore.FieldMaterialQuestionCount:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaterialQuestionCount(v)
		return nil
	case tkexampaperpartitionscore.FieldExamPaperPartitionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamPaperPartitionID(v)
		return nil
	}
	return fmt.Errorf("unknown TkExamPaperPartitionScore field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TkExamPaperPartitionScoreMutation) AddedFields() []string {
	var fields []string
	if m.addsinge_select != nil {
		fields = append(fields, tkexampaperpartitionscore.FieldSingeSelect)
	}
	if m.addjudge_question != nil {
		fields = append(fields, tkexampaperpartitionscore.FieldJudgeQuestion)
	}
	if m.addmulti_select != nil {
		fields = append(fields, tkexampaperpartitionscore.FieldMultiSelect)
	}
	if m.addshorter_answer != nil {
		fields = append(fields, tkexampaperpartitionscore.FieldShorterAnswer)
	}
	if m.addmaterial_question != nil {
		fields = append(fields, tkexampaperpartitionscore.FieldMaterialQuestion)
	}
	if m.addsinge_select_count != nil {
		fields = append(fields, tkexampaperpartitionscore.FieldSingeSelectCount)
	}
	if m.addjudge_question_count != nil {
		fields = append(fields, tkexampaperpartitionscore.FieldJudgeQuestionCount)
	}
	if m.addmulti_select_count != nil {
		fields = append(fields, tkexampaperpartitionscore.FieldMultiSelectCount)
	}
	if m.addshorter_answer_count != nil {
		fields = append(fields, tkexampaperpartitionscore.FieldShorterAnswerCount)
	}
	if m.addmaterial_question_count != nil {
		fields = append(fields, tkexampaperpartitionscore.FieldMaterialQuestionCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TkExamPaperPartitionScoreMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tkexampaperpartitionscore.FieldSingeSelect:
		return m.AddedSingeSelect()
	case tkexampaperpartitionscore.FieldJudgeQuestion:
		return m.AddedJudgeQuestion()
	case tkexampaperpartitionscore.FieldMultiSelect:
		return m.AddedMultiSelect()
	case tkexampaperpartitionscore.FieldShorterAnswer:
		return m.AddedShorterAnswer()
	case tkexampaperpartitionscore.FieldMaterialQuestion:
		return m.AddedMaterialQuestion()
	case tkexampaperpartitionscore.FieldSingeSelectCount:
		return m.AddedSingeSelectCount()
	case tkexampaperpartitionscore.FieldJudgeQuestionCount:
		return m.AddedJudgeQuestionCount()
	case tkexampaperpartitionscore.FieldMultiSelectCount:
		return m.AddedMultiSelectCount()
	case tkexampaperpartitionscore.FieldShorterAnswerCount:
		return m.AddedShorterAnswerCount()
	case tkexampaperpartitionscore.FieldMaterialQuestionCount:
		return m.AddedMaterialQuestionCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TkExamPaperPartitionScoreMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tkexampaperpartitionscore.FieldSingeSelect:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSingeSelect(v)
		return nil
	case tkexampaperpartitionscore.FieldJudgeQuestion:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddJudgeQuestion(v)
		return nil
	case tkexampaperpartitionscore.FieldMultiSelect:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMultiSelect(v)
		return nil
	case tkexampaperpartitionscore.FieldShorterAnswer:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShorterAnswer(v)
		return nil
	case tkexampaperpartitionscore.FieldMaterialQuestion:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaterialQuestion(v)
		return nil
	case tkexampaperpartitionscore.FieldSingeSelectCount:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSingeSelectCount(v)
		return nil
	case tkexampaperpartitionscore.FieldJudgeQuestionCount:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddJudgeQuestionCount(v)
		return nil
	case tkexampaperpartitionscore.FieldMultiSelectCount:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMultiSelectCount(v)
		return nil
	case tkexampaperpartitionscore.FieldShorterAnswerCount:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShorterAnswerCount(v)
		return nil
	case tkexampaperpartitionscore.FieldMaterialQuestionCount:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaterialQuestionCount(v)
		return nil
	}
	return fmt.Errorf("unknown TkExamPaperPartitionScore numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TkExamPaperPartitionScoreMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tkexampaperpartitionscore.FieldCreatedAt) {
		fields = append(fields, tkexampaperpartitionscore.FieldCreatedAt)
	}
	if m.FieldCleared(tkexampaperpartitionscore.FieldUpdatedAt) {
		fields = append(fields, tkexampaperpartitionscore.FieldUpdatedAt)
	}
	if m.FieldCleared(tkexampaperpartitionscore.FieldDeletedAt) {
		fields = append(fields, tkexampaperpartitionscore.FieldDeletedAt)
	}
	if m.FieldCleared(tkexampaperpartitionscore.FieldExamPaperPartitionID) {
		fields = append(fields, tkexampaperpartitionscore.FieldExamPaperPartitionID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TkExamPaperPartitionScoreMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TkExamPaperPartitionScoreMutation) ClearField(name string) error {
	switch name {
	case tkexampaperpartitionscore.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case tkexampaperpartitionscore.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case tkexampaperpartitionscore.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case tkexampaperpartitionscore.FieldExamPaperPartitionID:
		m.ClearExamPaperPartitionID()
		return nil
	}
	return fmt.Errorf("unknown TkExamPaperPartitionScore nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TkExamPaperPartitionScoreMutation) ResetField(name string) error {
	switch name {
	case tkexampaperpartitionscore.FieldUUID:
		m.ResetUUID()
		return nil
	case tkexampaperpartitionscore.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tkexampaperpartitionscore.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tkexampaperpartitionscore.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case tkexampaperpartitionscore.FieldSingeSelect:
		m.ResetSingeSelect()
		return nil
	case tkexampaperpartitionscore.FieldJudgeQuestion:
		m.ResetJudgeQuestion()
		return nil
	case tkexampaperpartitionscore.FieldMultiSelect:
		m.ResetMultiSelect()
		return nil
	case tkexampaperpartitionscore.FieldShorterAnswer:
		m.ResetShorterAnswer()
		return nil
	case tkexampaperpartitionscore.FieldMaterialQuestion:
		m.ResetMaterialQuestion()
		return nil
	case tkexampaperpartitionscore.FieldSingeSelectCount:
		m.ResetSingeSelectCount()
		return nil
	case tkexampaperpartitionscore.FieldJudgeQuestionCount:
		m.ResetJudgeQuestionCount()
		return nil
	case tkexampaperpartitionscore.FieldMultiSelectCount:
		m.ResetMultiSelectCount()
		return nil
	case tkexampaperpartitionscore.FieldShorterAnswerCount:
		m.ResetShorterAnswerCount()
		return nil
	case tkexampaperpartitionscore.FieldMaterialQuestionCount:
		m.ResetMaterialQuestionCount()
		return nil
	case tkexampaperpartitionscore.FieldExamPaperPartitionID:
		m.ResetExamPaperPartitionID()
		return nil
	}
	return fmt.Errorf("unknown TkExamPaperPartitionScore field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TkExamPaperPartitionScoreMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.exam_paper_partition != nil {
		edges = append(edges, tkexampaperpartitionscore.EdgeExamPaperPartition)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TkExamPaperPartitionScoreMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tkexampaperpartitionscore.EdgeExamPaperPartition:
		if id := m.exam_paper_partition; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TkExamPaperPartitionScoreMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TkExamPaperPartitionScoreMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TkExamPaperPartitionScoreMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedexam_paper_partition {
		edges = append(edges, tkexampaperpartitionscore.EdgeExamPaperPartition)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TkExamPaperPartitionScoreMutation) EdgeCleared(name string) bool {
	switch name {
	case tkexampaperpartitionscore.EdgeExamPaperPartition:
		return m.clearedexam_paper_partition
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TkExamPaperPartitionScoreMutation) ClearEdge(name string) error {
	switch name {
	case tkexampaperpartitionscore.EdgeExamPaperPartition:
		m.ClearExamPaperPartition()
		return nil
	}
	return fmt.Errorf("unknown TkExamPaperPartitionScore unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TkExamPaperPartitionScoreMutation) ResetEdge(name string) error {
	switch name {
	case tkexampaperpartitionscore.EdgeExamPaperPartition:
		m.ResetExamPaperPartition()
		return nil
	}
	return fmt.Errorf("unknown TkExamPaperPartitionScore edge %s", name)
}

// TkExamPaperSimulationMutation represents an operation that mutates the TkExamPaperSimulation nodes in the graph.
type TkExamPaperSimulationMutation struct {
	config
	op               Op
	typ              string
	id               *int
	uuid             *string
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	start_at         *time.Time
	end_at           *time.Time
	enable_status    *uint8
	addenable_status *uint8
	exam_paper_id    *int
	addexam_paper_id *int
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*TkExamPaperSimulation, error)
	predicates       []predicate.TkExamPaperSimulation
}

var _ ent.Mutation = (*TkExamPaperSimulationMutation)(nil)

// tkexampapersimulationOption allows management of the mutation configuration using functional options.
type tkexampapersimulationOption func(*TkExamPaperSimulationMutation)

// newTkExamPaperSimulationMutation creates new mutation for the TkExamPaperSimulation entity.
func newTkExamPaperSimulationMutation(c config, op Op, opts ...tkexampapersimulationOption) *TkExamPaperSimulationMutation {
	m := &TkExamPaperSimulationMutation{
		config:        c,
		op:            op,
		typ:           TypeTkExamPaperSimulation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTkExamPaperSimulationID sets the ID field of the mutation.
func withTkExamPaperSimulationID(id int) tkexampapersimulationOption {
	return func(m *TkExamPaperSimulationMutation) {
		var (
			err   error
			once  sync.Once
			value *TkExamPaperSimulation
		)
		m.oldValue = func(ctx context.Context) (*TkExamPaperSimulation, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TkExamPaperSimulation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTkExamPaperSimulation sets the old TkExamPaperSimulation of the mutation.
func withTkExamPaperSimulation(node *TkExamPaperSimulation) tkexampapersimulationOption {
	return func(m *TkExamPaperSimulationMutation) {
		m.oldValue = func(context.Context) (*TkExamPaperSimulation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TkExamPaperSimulationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TkExamPaperSimulationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *TkExamPaperSimulationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *TkExamPaperSimulationMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *TkExamPaperSimulationMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the TkExamPaperSimulation entity.
// If the TkExamPaperSimulation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamPaperSimulationMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *TkExamPaperSimulationMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TkExamPaperSimulationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TkExamPaperSimulationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TkExamPaperSimulation entity.
// If the TkExamPaperSimulation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamPaperSimulationMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *TkExamPaperSimulationMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[tkexampapersimulation.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *TkExamPaperSimulationMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[tkexampapersimulation.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TkExamPaperSimulationMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, tkexampapersimulation.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TkExamPaperSimulationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TkExamPaperSimulationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TkExamPaperSimulation entity.
// If the TkExamPaperSimulation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamPaperSimulationMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TkExamPaperSimulationMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[tkexampapersimulation.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TkExamPaperSimulationMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[tkexampapersimulation.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TkExamPaperSimulationMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, tkexampapersimulation.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TkExamPaperSimulationMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TkExamPaperSimulationMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TkExamPaperSimulation entity.
// If the TkExamPaperSimulation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamPaperSimulationMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TkExamPaperSimulationMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[tkexampapersimulation.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TkExamPaperSimulationMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[tkexampapersimulation.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TkExamPaperSimulationMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, tkexampapersimulation.FieldDeletedAt)
}

// SetStartAt sets the "start_at" field.
func (m *TkExamPaperSimulationMutation) SetStartAt(t time.Time) {
	m.start_at = &t
}

// StartAt returns the value of the "start_at" field in the mutation.
func (m *TkExamPaperSimulationMutation) StartAt() (r time.Time, exists bool) {
	v := m.start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAt returns the old "start_at" field's value of the TkExamPaperSimulation entity.
// If the TkExamPaperSimulation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamPaperSimulationMutation) OldStartAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAt: %w", err)
	}
	return oldValue.StartAt, nil
}

// ClearStartAt clears the value of the "start_at" field.
func (m *TkExamPaperSimulationMutation) ClearStartAt() {
	m.start_at = nil
	m.clearedFields[tkexampapersimulation.FieldStartAt] = struct{}{}
}

// StartAtCleared returns if the "start_at" field was cleared in this mutation.
func (m *TkExamPaperSimulationMutation) StartAtCleared() bool {
	_, ok := m.clearedFields[tkexampapersimulation.FieldStartAt]
	return ok
}

// ResetStartAt resets all changes to the "start_at" field.
func (m *TkExamPaperSimulationMutation) ResetStartAt() {
	m.start_at = nil
	delete(m.clearedFields, tkexampapersimulation.FieldStartAt)
}

// SetEndAt sets the "end_at" field.
func (m *TkExamPaperSimulationMutation) SetEndAt(t time.Time) {
	m.end_at = &t
}

// EndAt returns the value of the "end_at" field in the mutation.
func (m *TkExamPaperSimulationMutation) EndAt() (r time.Time, exists bool) {
	v := m.end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndAt returns the old "end_at" field's value of the TkExamPaperSimulation entity.
// If the TkExamPaperSimulation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamPaperSimulationMutation) OldEndAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndAt: %w", err)
	}
	return oldValue.EndAt, nil
}

// ClearEndAt clears the value of the "end_at" field.
func (m *TkExamPaperSimulationMutation) ClearEndAt() {
	m.end_at = nil
	m.clearedFields[tkexampapersimulation.FieldEndAt] = struct{}{}
}

// EndAtCleared returns if the "end_at" field was cleared in this mutation.
func (m *TkExamPaperSimulationMutation) EndAtCleared() bool {
	_, ok := m.clearedFields[tkexampapersimulation.FieldEndAt]
	return ok
}

// ResetEndAt resets all changes to the "end_at" field.
func (m *TkExamPaperSimulationMutation) ResetEndAt() {
	m.end_at = nil
	delete(m.clearedFields, tkexampapersimulation.FieldEndAt)
}

// SetEnableStatus sets the "enable_status" field.
func (m *TkExamPaperSimulationMutation) SetEnableStatus(u uint8) {
	m.enable_status = &u
	m.addenable_status = nil
}

// EnableStatus returns the value of the "enable_status" field in the mutation.
func (m *TkExamPaperSimulationMutation) EnableStatus() (r uint8, exists bool) {
	v := m.enable_status
	if v == nil {
		return
	}
	return *v, true
}

// OldEnableStatus returns the old "enable_status" field's value of the TkExamPaperSimulation entity.
// If the TkExamPaperSimulation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamPaperSimulationMutation) OldEnableStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEnableStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEnableStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnableStatus: %w", err)
	}
	return oldValue.EnableStatus, nil
}

// AddEnableStatus adds u to the "enable_status" field.
func (m *TkExamPaperSimulationMutation) AddEnableStatus(u uint8) {
	if m.addenable_status != nil {
		*m.addenable_status += u
	} else {
		m.addenable_status = &u
	}
}

// AddedEnableStatus returns the value that was added to the "enable_status" field in this mutation.
func (m *TkExamPaperSimulationMutation) AddedEnableStatus() (r uint8, exists bool) {
	v := m.addenable_status
	if v == nil {
		return
	}
	return *v, true
}

// ResetEnableStatus resets all changes to the "enable_status" field.
func (m *TkExamPaperSimulationMutation) ResetEnableStatus() {
	m.enable_status = nil
	m.addenable_status = nil
}

// SetExamPaperID sets the "exam_paper_id" field.
func (m *TkExamPaperSimulationMutation) SetExamPaperID(i int) {
	m.exam_paper_id = &i
	m.addexam_paper_id = nil
}

// ExamPaperID returns the value of the "exam_paper_id" field in the mutation.
func (m *TkExamPaperSimulationMutation) ExamPaperID() (r int, exists bool) {
	v := m.exam_paper_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExamPaperID returns the old "exam_paper_id" field's value of the TkExamPaperSimulation entity.
// If the TkExamPaperSimulation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamPaperSimulationMutation) OldExamPaperID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExamPaperID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExamPaperID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamPaperID: %w", err)
	}
	return oldValue.ExamPaperID, nil
}

// AddExamPaperID adds i to the "exam_paper_id" field.
func (m *TkExamPaperSimulationMutation) AddExamPaperID(i int) {
	if m.addexam_paper_id != nil {
		*m.addexam_paper_id += i
	} else {
		m.addexam_paper_id = &i
	}
}

// AddedExamPaperID returns the value that was added to the "exam_paper_id" field in this mutation.
func (m *TkExamPaperSimulationMutation) AddedExamPaperID() (r int, exists bool) {
	v := m.addexam_paper_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearExamPaperID clears the value of the "exam_paper_id" field.
func (m *TkExamPaperSimulationMutation) ClearExamPaperID() {
	m.exam_paper_id = nil
	m.addexam_paper_id = nil
	m.clearedFields[tkexampapersimulation.FieldExamPaperID] = struct{}{}
}

// ExamPaperIDCleared returns if the "exam_paper_id" field was cleared in this mutation.
func (m *TkExamPaperSimulationMutation) ExamPaperIDCleared() bool {
	_, ok := m.clearedFields[tkexampapersimulation.FieldExamPaperID]
	return ok
}

// ResetExamPaperID resets all changes to the "exam_paper_id" field.
func (m *TkExamPaperSimulationMutation) ResetExamPaperID() {
	m.exam_paper_id = nil
	m.addexam_paper_id = nil
	delete(m.clearedFields, tkexampapersimulation.FieldExamPaperID)
}

// Op returns the operation name.
func (m *TkExamPaperSimulationMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TkExamPaperSimulation).
func (m *TkExamPaperSimulationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TkExamPaperSimulationMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.uuid != nil {
		fields = append(fields, tkexampapersimulation.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, tkexampapersimulation.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tkexampapersimulation.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, tkexampapersimulation.FieldDeletedAt)
	}
	if m.start_at != nil {
		fields = append(fields, tkexampapersimulation.FieldStartAt)
	}
	if m.end_at != nil {
		fields = append(fields, tkexampapersimulation.FieldEndAt)
	}
	if m.enable_status != nil {
		fields = append(fields, tkexampapersimulation.FieldEnableStatus)
	}
	if m.exam_paper_id != nil {
		fields = append(fields, tkexampapersimulation.FieldExamPaperID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TkExamPaperSimulationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tkexampapersimulation.FieldUUID:
		return m.UUID()
	case tkexampapersimulation.FieldCreatedAt:
		return m.CreatedAt()
	case tkexampapersimulation.FieldUpdatedAt:
		return m.UpdatedAt()
	case tkexampapersimulation.FieldDeletedAt:
		return m.DeletedAt()
	case tkexampapersimulation.FieldStartAt:
		return m.StartAt()
	case tkexampapersimulation.FieldEndAt:
		return m.EndAt()
	case tkexampapersimulation.FieldEnableStatus:
		return m.EnableStatus()
	case tkexampapersimulation.FieldExamPaperID:
		return m.ExamPaperID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TkExamPaperSimulationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tkexampapersimulation.FieldUUID:
		return m.OldUUID(ctx)
	case tkexampapersimulation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tkexampapersimulation.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tkexampapersimulation.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case tkexampapersimulation.FieldStartAt:
		return m.OldStartAt(ctx)
	case tkexampapersimulation.FieldEndAt:
		return m.OldEndAt(ctx)
	case tkexampapersimulation.FieldEnableStatus:
		return m.OldEnableStatus(ctx)
	case tkexampapersimulation.FieldExamPaperID:
		return m.OldExamPaperID(ctx)
	}
	return nil, fmt.Errorf("unknown TkExamPaperSimulation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TkExamPaperSimulationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tkexampapersimulation.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case tkexampapersimulation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tkexampapersimulation.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tkexampapersimulation.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case tkexampapersimulation.FieldStartAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAt(v)
		return nil
	case tkexampapersimulation.FieldEndAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndAt(v)
		return nil
	case tkexampapersimulation.FieldEnableStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnableStatus(v)
		return nil
	case tkexampapersimulation.FieldExamPaperID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamPaperID(v)
		return nil
	}
	return fmt.Errorf("unknown TkExamPaperSimulation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TkExamPaperSimulationMutation) AddedFields() []string {
	var fields []string
	if m.addenable_status != nil {
		fields = append(fields, tkexampapersimulation.FieldEnableStatus)
	}
	if m.addexam_paper_id != nil {
		fields = append(fields, tkexampapersimulation.FieldExamPaperID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TkExamPaperSimulationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tkexampapersimulation.FieldEnableStatus:
		return m.AddedEnableStatus()
	case tkexampapersimulation.FieldExamPaperID:
		return m.AddedExamPaperID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TkExamPaperSimulationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tkexampapersimulation.FieldEnableStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEnableStatus(v)
		return nil
	case tkexampapersimulation.FieldExamPaperID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExamPaperID(v)
		return nil
	}
	return fmt.Errorf("unknown TkExamPaperSimulation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TkExamPaperSimulationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tkexampapersimulation.FieldCreatedAt) {
		fields = append(fields, tkexampapersimulation.FieldCreatedAt)
	}
	if m.FieldCleared(tkexampapersimulation.FieldUpdatedAt) {
		fields = append(fields, tkexampapersimulation.FieldUpdatedAt)
	}
	if m.FieldCleared(tkexampapersimulation.FieldDeletedAt) {
		fields = append(fields, tkexampapersimulation.FieldDeletedAt)
	}
	if m.FieldCleared(tkexampapersimulation.FieldStartAt) {
		fields = append(fields, tkexampapersimulation.FieldStartAt)
	}
	if m.FieldCleared(tkexampapersimulation.FieldEndAt) {
		fields = append(fields, tkexampapersimulation.FieldEndAt)
	}
	if m.FieldCleared(tkexampapersimulation.FieldExamPaperID) {
		fields = append(fields, tkexampapersimulation.FieldExamPaperID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TkExamPaperSimulationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TkExamPaperSimulationMutation) ClearField(name string) error {
	switch name {
	case tkexampapersimulation.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case tkexampapersimulation.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case tkexampapersimulation.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case tkexampapersimulation.FieldStartAt:
		m.ClearStartAt()
		return nil
	case tkexampapersimulation.FieldEndAt:
		m.ClearEndAt()
		return nil
	case tkexampapersimulation.FieldExamPaperID:
		m.ClearExamPaperID()
		return nil
	}
	return fmt.Errorf("unknown TkExamPaperSimulation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TkExamPaperSimulationMutation) ResetField(name string) error {
	switch name {
	case tkexampapersimulation.FieldUUID:
		m.ResetUUID()
		return nil
	case tkexampapersimulation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tkexampapersimulation.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tkexampapersimulation.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case tkexampapersimulation.FieldStartAt:
		m.ResetStartAt()
		return nil
	case tkexampapersimulation.FieldEndAt:
		m.ResetEndAt()
		return nil
	case tkexampapersimulation.FieldEnableStatus:
		m.ResetEnableStatus()
		return nil
	case tkexampapersimulation.FieldExamPaperID:
		m.ResetExamPaperID()
		return nil
	}
	return fmt.Errorf("unknown TkExamPaperSimulation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TkExamPaperSimulationMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TkExamPaperSimulationMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TkExamPaperSimulationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TkExamPaperSimulationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TkExamPaperSimulationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TkExamPaperSimulationMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TkExamPaperSimulationMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TkExamPaperSimulation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TkExamPaperSimulationMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TkExamPaperSimulation edge %s", name)
}

// TkExamPartitionQuestionLinkMutation represents an operation that mutates the TkExamPartitionQuestionLink nodes in the graph.
type TkExamPartitionQuestionLinkMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int
	uuid                        *string
	created_at                  *time.Time
	updated_at                  *time.Time
	deleted_at                  *time.Time
	question_score              *uint8
	addquestion_score           *uint8
	clearedFields               map[string]struct{}
	exam_paper_partition        *int
	clearedexam_paper_partition bool
	question                    *int
	clearedquestion             bool
	done                        bool
	oldValue                    func(context.Context) (*TkExamPartitionQuestionLink, error)
	predicates                  []predicate.TkExamPartitionQuestionLink
}

var _ ent.Mutation = (*TkExamPartitionQuestionLinkMutation)(nil)

// tkexampartitionquestionlinkOption allows management of the mutation configuration using functional options.
type tkexampartitionquestionlinkOption func(*TkExamPartitionQuestionLinkMutation)

// newTkExamPartitionQuestionLinkMutation creates new mutation for the TkExamPartitionQuestionLink entity.
func newTkExamPartitionQuestionLinkMutation(c config, op Op, opts ...tkexampartitionquestionlinkOption) *TkExamPartitionQuestionLinkMutation {
	m := &TkExamPartitionQuestionLinkMutation{
		config:        c,
		op:            op,
		typ:           TypeTkExamPartitionQuestionLink,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTkExamPartitionQuestionLinkID sets the ID field of the mutation.
func withTkExamPartitionQuestionLinkID(id int) tkexampartitionquestionlinkOption {
	return func(m *TkExamPartitionQuestionLinkMutation) {
		var (
			err   error
			once  sync.Once
			value *TkExamPartitionQuestionLink
		)
		m.oldValue = func(ctx context.Context) (*TkExamPartitionQuestionLink, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TkExamPartitionQuestionLink.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTkExamPartitionQuestionLink sets the old TkExamPartitionQuestionLink of the mutation.
func withTkExamPartitionQuestionLink(node *TkExamPartitionQuestionLink) tkexampartitionquestionlinkOption {
	return func(m *TkExamPartitionQuestionLinkMutation) {
		m.oldValue = func(context.Context) (*TkExamPartitionQuestionLink, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TkExamPartitionQuestionLinkMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TkExamPartitionQuestionLinkMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *TkExamPartitionQuestionLinkMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *TkExamPartitionQuestionLinkMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *TkExamPartitionQuestionLinkMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the TkExamPartitionQuestionLink entity.
// If the TkExamPartitionQuestionLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamPartitionQuestionLinkMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *TkExamPartitionQuestionLinkMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TkExamPartitionQuestionLinkMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TkExamPartitionQuestionLinkMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TkExamPartitionQuestionLink entity.
// If the TkExamPartitionQuestionLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamPartitionQuestionLinkMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *TkExamPartitionQuestionLinkMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[tkexampartitionquestionlink.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *TkExamPartitionQuestionLinkMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[tkexampartitionquestionlink.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TkExamPartitionQuestionLinkMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, tkexampartitionquestionlink.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TkExamPartitionQuestionLinkMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TkExamPartitionQuestionLinkMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TkExamPartitionQuestionLink entity.
// If the TkExamPartitionQuestionLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamPartitionQuestionLinkMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TkExamPartitionQuestionLinkMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[tkexampartitionquestionlink.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TkExamPartitionQuestionLinkMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[tkexampartitionquestionlink.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TkExamPartitionQuestionLinkMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, tkexampartitionquestionlink.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TkExamPartitionQuestionLinkMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TkExamPartitionQuestionLinkMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TkExamPartitionQuestionLink entity.
// If the TkExamPartitionQuestionLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamPartitionQuestionLinkMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TkExamPartitionQuestionLinkMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[tkexampartitionquestionlink.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TkExamPartitionQuestionLinkMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[tkexampartitionquestionlink.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TkExamPartitionQuestionLinkMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, tkexampartitionquestionlink.FieldDeletedAt)
}

// SetQuestionScore sets the "question_score" field.
func (m *TkExamPartitionQuestionLinkMutation) SetQuestionScore(u uint8) {
	m.question_score = &u
	m.addquestion_score = nil
}

// QuestionScore returns the value of the "question_score" field in the mutation.
func (m *TkExamPartitionQuestionLinkMutation) QuestionScore() (r uint8, exists bool) {
	v := m.question_score
	if v == nil {
		return
	}
	return *v, true
}

// OldQuestionScore returns the old "question_score" field's value of the TkExamPartitionQuestionLink entity.
// If the TkExamPartitionQuestionLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamPartitionQuestionLinkMutation) OldQuestionScore(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldQuestionScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldQuestionScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuestionScore: %w", err)
	}
	return oldValue.QuestionScore, nil
}

// AddQuestionScore adds u to the "question_score" field.
func (m *TkExamPartitionQuestionLinkMutation) AddQuestionScore(u uint8) {
	if m.addquestion_score != nil {
		*m.addquestion_score += u
	} else {
		m.addquestion_score = &u
	}
}

// AddedQuestionScore returns the value that was added to the "question_score" field in this mutation.
func (m *TkExamPartitionQuestionLinkMutation) AddedQuestionScore() (r uint8, exists bool) {
	v := m.addquestion_score
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuestionScore resets all changes to the "question_score" field.
func (m *TkExamPartitionQuestionLinkMutation) ResetQuestionScore() {
	m.question_score = nil
	m.addquestion_score = nil
}

// SetExamPaperPartitionID sets the "exam_paper_partition_id" field.
func (m *TkExamPartitionQuestionLinkMutation) SetExamPaperPartitionID(i int) {
	m.exam_paper_partition = &i
}

// ExamPaperPartitionID returns the value of the "exam_paper_partition_id" field in the mutation.
func (m *TkExamPartitionQuestionLinkMutation) ExamPaperPartitionID() (r int, exists bool) {
	v := m.exam_paper_partition
	if v == nil {
		return
	}
	return *v, true
}

// OldExamPaperPartitionID returns the old "exam_paper_partition_id" field's value of the TkExamPartitionQuestionLink entity.
// If the TkExamPartitionQuestionLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamPartitionQuestionLinkMutation) OldExamPaperPartitionID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExamPaperPartitionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExamPaperPartitionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamPaperPartitionID: %w", err)
	}
	return oldValue.ExamPaperPartitionID, nil
}

// ClearExamPaperPartitionID clears the value of the "exam_paper_partition_id" field.
func (m *TkExamPartitionQuestionLinkMutation) ClearExamPaperPartitionID() {
	m.exam_paper_partition = nil
	m.clearedFields[tkexampartitionquestionlink.FieldExamPaperPartitionID] = struct{}{}
}

// ExamPaperPartitionIDCleared returns if the "exam_paper_partition_id" field was cleared in this mutation.
func (m *TkExamPartitionQuestionLinkMutation) ExamPaperPartitionIDCleared() bool {
	_, ok := m.clearedFields[tkexampartitionquestionlink.FieldExamPaperPartitionID]
	return ok
}

// ResetExamPaperPartitionID resets all changes to the "exam_paper_partition_id" field.
func (m *TkExamPartitionQuestionLinkMutation) ResetExamPaperPartitionID() {
	m.exam_paper_partition = nil
	delete(m.clearedFields, tkexampartitionquestionlink.FieldExamPaperPartitionID)
}

// SetQuestionID sets the "question_id" field.
func (m *TkExamPartitionQuestionLinkMutation) SetQuestionID(i int) {
	m.question = &i
}

// QuestionID returns the value of the "question_id" field in the mutation.
func (m *TkExamPartitionQuestionLinkMutation) QuestionID() (r int, exists bool) {
	v := m.question
	if v == nil {
		return
	}
	return *v, true
}

// OldQuestionID returns the old "question_id" field's value of the TkExamPartitionQuestionLink entity.
// If the TkExamPartitionQuestionLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamPartitionQuestionLinkMutation) OldQuestionID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldQuestionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldQuestionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuestionID: %w", err)
	}
	return oldValue.QuestionID, nil
}

// ClearQuestionID clears the value of the "question_id" field.
func (m *TkExamPartitionQuestionLinkMutation) ClearQuestionID() {
	m.question = nil
	m.clearedFields[tkexampartitionquestionlink.FieldQuestionID] = struct{}{}
}

// QuestionIDCleared returns if the "question_id" field was cleared in this mutation.
func (m *TkExamPartitionQuestionLinkMutation) QuestionIDCleared() bool {
	_, ok := m.clearedFields[tkexampartitionquestionlink.FieldQuestionID]
	return ok
}

// ResetQuestionID resets all changes to the "question_id" field.
func (m *TkExamPartitionQuestionLinkMutation) ResetQuestionID() {
	m.question = nil
	delete(m.clearedFields, tkexampartitionquestionlink.FieldQuestionID)
}

// ClearExamPaperPartition clears the "exam_paper_partition" edge to the TkExamPaperPartition entity.
func (m *TkExamPartitionQuestionLinkMutation) ClearExamPaperPartition() {
	m.clearedexam_paper_partition = true
}

// ExamPaperPartitionCleared reports if the "exam_paper_partition" edge to the TkExamPaperPartition entity was cleared.
func (m *TkExamPartitionQuestionLinkMutation) ExamPaperPartitionCleared() bool {
	return m.ExamPaperPartitionIDCleared() || m.clearedexam_paper_partition
}

// ExamPaperPartitionIDs returns the "exam_paper_partition" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ExamPaperPartitionID instead. It exists only for internal usage by the builders.
func (m *TkExamPartitionQuestionLinkMutation) ExamPaperPartitionIDs() (ids []int) {
	if id := m.exam_paper_partition; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExamPaperPartition resets all changes to the "exam_paper_partition" edge.
func (m *TkExamPartitionQuestionLinkMutation) ResetExamPaperPartition() {
	m.exam_paper_partition = nil
	m.clearedexam_paper_partition = false
}

// ClearQuestion clears the "question" edge to the TkQuestion entity.
func (m *TkExamPartitionQuestionLinkMutation) ClearQuestion() {
	m.clearedquestion = true
}

// QuestionCleared reports if the "question" edge to the TkQuestion entity was cleared.
func (m *TkExamPartitionQuestionLinkMutation) QuestionCleared() bool {
	return m.QuestionIDCleared() || m.clearedquestion
}

// QuestionIDs returns the "question" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// QuestionID instead. It exists only for internal usage by the builders.
func (m *TkExamPartitionQuestionLinkMutation) QuestionIDs() (ids []int) {
	if id := m.question; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetQuestion resets all changes to the "question" edge.
func (m *TkExamPartitionQuestionLinkMutation) ResetQuestion() {
	m.question = nil
	m.clearedquestion = false
}

// Op returns the operation name.
func (m *TkExamPartitionQuestionLinkMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TkExamPartitionQuestionLink).
func (m *TkExamPartitionQuestionLinkMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TkExamPartitionQuestionLinkMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.uuid != nil {
		fields = append(fields, tkexampartitionquestionlink.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, tkexampartitionquestionlink.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tkexampartitionquestionlink.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, tkexampartitionquestionlink.FieldDeletedAt)
	}
	if m.question_score != nil {
		fields = append(fields, tkexampartitionquestionlink.FieldQuestionScore)
	}
	if m.exam_paper_partition != nil {
		fields = append(fields, tkexampartitionquestionlink.FieldExamPaperPartitionID)
	}
	if m.question != nil {
		fields = append(fields, tkexampartitionquestionlink.FieldQuestionID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TkExamPartitionQuestionLinkMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tkexampartitionquestionlink.FieldUUID:
		return m.UUID()
	case tkexampartitionquestionlink.FieldCreatedAt:
		return m.CreatedAt()
	case tkexampartitionquestionlink.FieldUpdatedAt:
		return m.UpdatedAt()
	case tkexampartitionquestionlink.FieldDeletedAt:
		return m.DeletedAt()
	case tkexampartitionquestionlink.FieldQuestionScore:
		return m.QuestionScore()
	case tkexampartitionquestionlink.FieldExamPaperPartitionID:
		return m.ExamPaperPartitionID()
	case tkexampartitionquestionlink.FieldQuestionID:
		return m.QuestionID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TkExamPartitionQuestionLinkMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tkexampartitionquestionlink.FieldUUID:
		return m.OldUUID(ctx)
	case tkexampartitionquestionlink.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tkexampartitionquestionlink.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tkexampartitionquestionlink.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case tkexampartitionquestionlink.FieldQuestionScore:
		return m.OldQuestionScore(ctx)
	case tkexampartitionquestionlink.FieldExamPaperPartitionID:
		return m.OldExamPaperPartitionID(ctx)
	case tkexampartitionquestionlink.FieldQuestionID:
		return m.OldQuestionID(ctx)
	}
	return nil, fmt.Errorf("unknown TkExamPartitionQuestionLink field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TkExamPartitionQuestionLinkMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tkexampartitionquestionlink.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case tkexampartitionquestionlink.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tkexampartitionquestionlink.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tkexampartitionquestionlink.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case tkexampartitionquestionlink.FieldQuestionScore:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuestionScore(v)
		return nil
	case tkexampartitionquestionlink.FieldExamPaperPartitionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamPaperPartitionID(v)
		return nil
	case tkexampartitionquestionlink.FieldQuestionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuestionID(v)
		return nil
	}
	return fmt.Errorf("unknown TkExamPartitionQuestionLink field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TkExamPartitionQuestionLinkMutation) AddedFields() []string {
	var fields []string
	if m.addquestion_score != nil {
		fields = append(fields, tkexampartitionquestionlink.FieldQuestionScore)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TkExamPartitionQuestionLinkMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tkexampartitionquestionlink.FieldQuestionScore:
		return m.AddedQuestionScore()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TkExamPartitionQuestionLinkMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tkexampartitionquestionlink.FieldQuestionScore:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuestionScore(v)
		return nil
	}
	return fmt.Errorf("unknown TkExamPartitionQuestionLink numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TkExamPartitionQuestionLinkMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tkexampartitionquestionlink.FieldCreatedAt) {
		fields = append(fields, tkexampartitionquestionlink.FieldCreatedAt)
	}
	if m.FieldCleared(tkexampartitionquestionlink.FieldUpdatedAt) {
		fields = append(fields, tkexampartitionquestionlink.FieldUpdatedAt)
	}
	if m.FieldCleared(tkexampartitionquestionlink.FieldDeletedAt) {
		fields = append(fields, tkexampartitionquestionlink.FieldDeletedAt)
	}
	if m.FieldCleared(tkexampartitionquestionlink.FieldExamPaperPartitionID) {
		fields = append(fields, tkexampartitionquestionlink.FieldExamPaperPartitionID)
	}
	if m.FieldCleared(tkexampartitionquestionlink.FieldQuestionID) {
		fields = append(fields, tkexampartitionquestionlink.FieldQuestionID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TkExamPartitionQuestionLinkMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TkExamPartitionQuestionLinkMutation) ClearField(name string) error {
	switch name {
	case tkexampartitionquestionlink.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case tkexampartitionquestionlink.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case tkexampartitionquestionlink.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case tkexampartitionquestionlink.FieldExamPaperPartitionID:
		m.ClearExamPaperPartitionID()
		return nil
	case tkexampartitionquestionlink.FieldQuestionID:
		m.ClearQuestionID()
		return nil
	}
	return fmt.Errorf("unknown TkExamPartitionQuestionLink nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TkExamPartitionQuestionLinkMutation) ResetField(name string) error {
	switch name {
	case tkexampartitionquestionlink.FieldUUID:
		m.ResetUUID()
		return nil
	case tkexampartitionquestionlink.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tkexampartitionquestionlink.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tkexampartitionquestionlink.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case tkexampartitionquestionlink.FieldQuestionScore:
		m.ResetQuestionScore()
		return nil
	case tkexampartitionquestionlink.FieldExamPaperPartitionID:
		m.ResetExamPaperPartitionID()
		return nil
	case tkexampartitionquestionlink.FieldQuestionID:
		m.ResetQuestionID()
		return nil
	}
	return fmt.Errorf("unknown TkExamPartitionQuestionLink field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TkExamPartitionQuestionLinkMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.exam_paper_partition != nil {
		edges = append(edges, tkexampartitionquestionlink.EdgeExamPaperPartition)
	}
	if m.question != nil {
		edges = append(edges, tkexampartitionquestionlink.EdgeQuestion)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TkExamPartitionQuestionLinkMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tkexampartitionquestionlink.EdgeExamPaperPartition:
		if id := m.exam_paper_partition; id != nil {
			return []ent.Value{*id}
		}
	case tkexampartitionquestionlink.EdgeQuestion:
		if id := m.question; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TkExamPartitionQuestionLinkMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TkExamPartitionQuestionLinkMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TkExamPartitionQuestionLinkMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedexam_paper_partition {
		edges = append(edges, tkexampartitionquestionlink.EdgeExamPaperPartition)
	}
	if m.clearedquestion {
		edges = append(edges, tkexampartitionquestionlink.EdgeQuestion)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TkExamPartitionQuestionLinkMutation) EdgeCleared(name string) bool {
	switch name {
	case tkexampartitionquestionlink.EdgeExamPaperPartition:
		return m.clearedexam_paper_partition
	case tkexampartitionquestionlink.EdgeQuestion:
		return m.clearedquestion
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TkExamPartitionQuestionLinkMutation) ClearEdge(name string) error {
	switch name {
	case tkexampartitionquestionlink.EdgeExamPaperPartition:
		m.ClearExamPaperPartition()
		return nil
	case tkexampartitionquestionlink.EdgeQuestion:
		m.ClearQuestion()
		return nil
	}
	return fmt.Errorf("unknown TkExamPartitionQuestionLink unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TkExamPartitionQuestionLinkMutation) ResetEdge(name string) error {
	switch name {
	case tkexampartitionquestionlink.EdgeExamPaperPartition:
		m.ResetExamPaperPartition()
		return nil
	case tkexampartitionquestionlink.EdgeQuestion:
		m.ResetQuestion()
		return nil
	}
	return fmt.Errorf("unknown TkExamPartitionQuestionLink edge %s", name)
}

// TkExamQuestionTypeMutation represents an operation that mutates the TkExamQuestionType nodes in the graph.
type TkExamQuestionTypeMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	uuid                   *string
	created_at             *time.Time
	updated_at             *time.Time
	deleted_at             *time.Time
	exam_question_type     *uint8
	addexam_question_type  *uint8
	question_count         *int
	addquestion_count      *int
	answered_count         *int
	addanswered_count      *int
	answered_user_count    *int
	addanswered_user_count *int
	clearedFields          map[string]struct{}
	question_bank          *int
	clearedquestion_bank   bool
	done                   bool
	oldValue               func(context.Context) (*TkExamQuestionType, error)
	predicates             []predicate.TkExamQuestionType
}

var _ ent.Mutation = (*TkExamQuestionTypeMutation)(nil)

// tkexamquestiontypeOption allows management of the mutation configuration using functional options.
type tkexamquestiontypeOption func(*TkExamQuestionTypeMutation)

// newTkExamQuestionTypeMutation creates new mutation for the TkExamQuestionType entity.
func newTkExamQuestionTypeMutation(c config, op Op, opts ...tkexamquestiontypeOption) *TkExamQuestionTypeMutation {
	m := &TkExamQuestionTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeTkExamQuestionType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTkExamQuestionTypeID sets the ID field of the mutation.
func withTkExamQuestionTypeID(id int) tkexamquestiontypeOption {
	return func(m *TkExamQuestionTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *TkExamQuestionType
		)
		m.oldValue = func(ctx context.Context) (*TkExamQuestionType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TkExamQuestionType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTkExamQuestionType sets the old TkExamQuestionType of the mutation.
func withTkExamQuestionType(node *TkExamQuestionType) tkexamquestiontypeOption {
	return func(m *TkExamQuestionTypeMutation) {
		m.oldValue = func(context.Context) (*TkExamQuestionType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TkExamQuestionTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TkExamQuestionTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *TkExamQuestionTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *TkExamQuestionTypeMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *TkExamQuestionTypeMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the TkExamQuestionType entity.
// If the TkExamQuestionType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamQuestionTypeMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *TkExamQuestionTypeMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TkExamQuestionTypeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TkExamQuestionTypeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TkExamQuestionType entity.
// If the TkExamQuestionType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamQuestionTypeMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *TkExamQuestionTypeMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[tkexamquestiontype.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *TkExamQuestionTypeMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[tkexamquestiontype.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TkExamQuestionTypeMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, tkexamquestiontype.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TkExamQuestionTypeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TkExamQuestionTypeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TkExamQuestionType entity.
// If the TkExamQuestionType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamQuestionTypeMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TkExamQuestionTypeMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[tkexamquestiontype.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TkExamQuestionTypeMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[tkexamquestiontype.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TkExamQuestionTypeMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, tkexamquestiontype.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TkExamQuestionTypeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TkExamQuestionTypeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TkExamQuestionType entity.
// If the TkExamQuestionType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamQuestionTypeMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TkExamQuestionTypeMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[tkexamquestiontype.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TkExamQuestionTypeMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[tkexamquestiontype.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TkExamQuestionTypeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, tkexamquestiontype.FieldDeletedAt)
}

// SetExamQuestionType sets the "exam_question_type" field.
func (m *TkExamQuestionTypeMutation) SetExamQuestionType(u uint8) {
	m.exam_question_type = &u
	m.addexam_question_type = nil
}

// ExamQuestionType returns the value of the "exam_question_type" field in the mutation.
func (m *TkExamQuestionTypeMutation) ExamQuestionType() (r uint8, exists bool) {
	v := m.exam_question_type
	if v == nil {
		return
	}
	return *v, true
}

// OldExamQuestionType returns the old "exam_question_type" field's value of the TkExamQuestionType entity.
// If the TkExamQuestionType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamQuestionTypeMutation) OldExamQuestionType(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExamQuestionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExamQuestionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamQuestionType: %w", err)
	}
	return oldValue.ExamQuestionType, nil
}

// AddExamQuestionType adds u to the "exam_question_type" field.
func (m *TkExamQuestionTypeMutation) AddExamQuestionType(u uint8) {
	if m.addexam_question_type != nil {
		*m.addexam_question_type += u
	} else {
		m.addexam_question_type = &u
	}
}

// AddedExamQuestionType returns the value that was added to the "exam_question_type" field in this mutation.
func (m *TkExamQuestionTypeMutation) AddedExamQuestionType() (r uint8, exists bool) {
	v := m.addexam_question_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetExamQuestionType resets all changes to the "exam_question_type" field.
func (m *TkExamQuestionTypeMutation) ResetExamQuestionType() {
	m.exam_question_type = nil
	m.addexam_question_type = nil
}

// SetQuestionCount sets the "question_count" field.
func (m *TkExamQuestionTypeMutation) SetQuestionCount(i int) {
	m.question_count = &i
	m.addquestion_count = nil
}

// QuestionCount returns the value of the "question_count" field in the mutation.
func (m *TkExamQuestionTypeMutation) QuestionCount() (r int, exists bool) {
	v := m.question_count
	if v == nil {
		return
	}
	return *v, true
}

// OldQuestionCount returns the old "question_count" field's value of the TkExamQuestionType entity.
// If the TkExamQuestionType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamQuestionTypeMutation) OldQuestionCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldQuestionCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldQuestionCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuestionCount: %w", err)
	}
	return oldValue.QuestionCount, nil
}

// AddQuestionCount adds i to the "question_count" field.
func (m *TkExamQuestionTypeMutation) AddQuestionCount(i int) {
	if m.addquestion_count != nil {
		*m.addquestion_count += i
	} else {
		m.addquestion_count = &i
	}
}

// AddedQuestionCount returns the value that was added to the "question_count" field in this mutation.
func (m *TkExamQuestionTypeMutation) AddedQuestionCount() (r int, exists bool) {
	v := m.addquestion_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuestionCount resets all changes to the "question_count" field.
func (m *TkExamQuestionTypeMutation) ResetQuestionCount() {
	m.question_count = nil
	m.addquestion_count = nil
}

// SetAnsweredCount sets the "answered_count" field.
func (m *TkExamQuestionTypeMutation) SetAnsweredCount(i int) {
	m.answered_count = &i
	m.addanswered_count = nil
}

// AnsweredCount returns the value of the "answered_count" field in the mutation.
func (m *TkExamQuestionTypeMutation) AnsweredCount() (r int, exists bool) {
	v := m.answered_count
	if v == nil {
		return
	}
	return *v, true
}

// OldAnsweredCount returns the old "answered_count" field's value of the TkExamQuestionType entity.
// If the TkExamQuestionType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamQuestionTypeMutation) OldAnsweredCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAnsweredCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAnsweredCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnsweredCount: %w", err)
	}
	return oldValue.AnsweredCount, nil
}

// AddAnsweredCount adds i to the "answered_count" field.
func (m *TkExamQuestionTypeMutation) AddAnsweredCount(i int) {
	if m.addanswered_count != nil {
		*m.addanswered_count += i
	} else {
		m.addanswered_count = &i
	}
}

// AddedAnsweredCount returns the value that was added to the "answered_count" field in this mutation.
func (m *TkExamQuestionTypeMutation) AddedAnsweredCount() (r int, exists bool) {
	v := m.addanswered_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetAnsweredCount resets all changes to the "answered_count" field.
func (m *TkExamQuestionTypeMutation) ResetAnsweredCount() {
	m.answered_count = nil
	m.addanswered_count = nil
}

// SetAnsweredUserCount sets the "answered_user_count" field.
func (m *TkExamQuestionTypeMutation) SetAnsweredUserCount(i int) {
	m.answered_user_count = &i
	m.addanswered_user_count = nil
}

// AnsweredUserCount returns the value of the "answered_user_count" field in the mutation.
func (m *TkExamQuestionTypeMutation) AnsweredUserCount() (r int, exists bool) {
	v := m.answered_user_count
	if v == nil {
		return
	}
	return *v, true
}

// OldAnsweredUserCount returns the old "answered_user_count" field's value of the TkExamQuestionType entity.
// If the TkExamQuestionType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamQuestionTypeMutation) OldAnsweredUserCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAnsweredUserCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAnsweredUserCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnsweredUserCount: %w", err)
	}
	return oldValue.AnsweredUserCount, nil
}

// AddAnsweredUserCount adds i to the "answered_user_count" field.
func (m *TkExamQuestionTypeMutation) AddAnsweredUserCount(i int) {
	if m.addanswered_user_count != nil {
		*m.addanswered_user_count += i
	} else {
		m.addanswered_user_count = &i
	}
}

// AddedAnsweredUserCount returns the value that was added to the "answered_user_count" field in this mutation.
func (m *TkExamQuestionTypeMutation) AddedAnsweredUserCount() (r int, exists bool) {
	v := m.addanswered_user_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetAnsweredUserCount resets all changes to the "answered_user_count" field.
func (m *TkExamQuestionTypeMutation) ResetAnsweredUserCount() {
	m.answered_user_count = nil
	m.addanswered_user_count = nil
}

// SetQuestionBankID sets the "question_bank_id" field.
func (m *TkExamQuestionTypeMutation) SetQuestionBankID(i int) {
	m.question_bank = &i
}

// QuestionBankID returns the value of the "question_bank_id" field in the mutation.
func (m *TkExamQuestionTypeMutation) QuestionBankID() (r int, exists bool) {
	v := m.question_bank
	if v == nil {
		return
	}
	return *v, true
}

// OldQuestionBankID returns the old "question_bank_id" field's value of the TkExamQuestionType entity.
// If the TkExamQuestionType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkExamQuestionTypeMutation) OldQuestionBankID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldQuestionBankID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldQuestionBankID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuestionBankID: %w", err)
	}
	return oldValue.QuestionBankID, nil
}

// ClearQuestionBankID clears the value of the "question_bank_id" field.
func (m *TkExamQuestionTypeMutation) ClearQuestionBankID() {
	m.question_bank = nil
	m.clearedFields[tkexamquestiontype.FieldQuestionBankID] = struct{}{}
}

// QuestionBankIDCleared returns if the "question_bank_id" field was cleared in this mutation.
func (m *TkExamQuestionTypeMutation) QuestionBankIDCleared() bool {
	_, ok := m.clearedFields[tkexamquestiontype.FieldQuestionBankID]
	return ok
}

// ResetQuestionBankID resets all changes to the "question_bank_id" field.
func (m *TkExamQuestionTypeMutation) ResetQuestionBankID() {
	m.question_bank = nil
	delete(m.clearedFields, tkexamquestiontype.FieldQuestionBankID)
}

// ClearQuestionBank clears the "question_bank" edge to the TkQuestionBank entity.
func (m *TkExamQuestionTypeMutation) ClearQuestionBank() {
	m.clearedquestion_bank = true
}

// QuestionBankCleared reports if the "question_bank" edge to the TkQuestionBank entity was cleared.
func (m *TkExamQuestionTypeMutation) QuestionBankCleared() bool {
	return m.QuestionBankIDCleared() || m.clearedquestion_bank
}

// QuestionBankIDs returns the "question_bank" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// QuestionBankID instead. It exists only for internal usage by the builders.
func (m *TkExamQuestionTypeMutation) QuestionBankIDs() (ids []int) {
	if id := m.question_bank; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetQuestionBank resets all changes to the "question_bank" edge.
func (m *TkExamQuestionTypeMutation) ResetQuestionBank() {
	m.question_bank = nil
	m.clearedquestion_bank = false
}

// Op returns the operation name.
func (m *TkExamQuestionTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TkExamQuestionType).
func (m *TkExamQuestionTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TkExamQuestionTypeMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.uuid != nil {
		fields = append(fields, tkexamquestiontype.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, tkexamquestiontype.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tkexamquestiontype.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, tkexamquestiontype.FieldDeletedAt)
	}
	if m.exam_question_type != nil {
		fields = append(fields, tkexamquestiontype.FieldExamQuestionType)
	}
	if m.question_count != nil {
		fields = append(fields, tkexamquestiontype.FieldQuestionCount)
	}
	if m.answered_count != nil {
		fields = append(fields, tkexamquestiontype.FieldAnsweredCount)
	}
	if m.answered_user_count != nil {
		fields = append(fields, tkexamquestiontype.FieldAnsweredUserCount)
	}
	if m.question_bank != nil {
		fields = append(fields, tkexamquestiontype.FieldQuestionBankID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TkExamQuestionTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tkexamquestiontype.FieldUUID:
		return m.UUID()
	case tkexamquestiontype.FieldCreatedAt:
		return m.CreatedAt()
	case tkexamquestiontype.FieldUpdatedAt:
		return m.UpdatedAt()
	case tkexamquestiontype.FieldDeletedAt:
		return m.DeletedAt()
	case tkexamquestiontype.FieldExamQuestionType:
		return m.ExamQuestionType()
	case tkexamquestiontype.FieldQuestionCount:
		return m.QuestionCount()
	case tkexamquestiontype.FieldAnsweredCount:
		return m.AnsweredCount()
	case tkexamquestiontype.FieldAnsweredUserCount:
		return m.AnsweredUserCount()
	case tkexamquestiontype.FieldQuestionBankID:
		return m.QuestionBankID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TkExamQuestionTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tkexamquestiontype.FieldUUID:
		return m.OldUUID(ctx)
	case tkexamquestiontype.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tkexamquestiontype.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tkexamquestiontype.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case tkexamquestiontype.FieldExamQuestionType:
		return m.OldExamQuestionType(ctx)
	case tkexamquestiontype.FieldQuestionCount:
		return m.OldQuestionCount(ctx)
	case tkexamquestiontype.FieldAnsweredCount:
		return m.OldAnsweredCount(ctx)
	case tkexamquestiontype.FieldAnsweredUserCount:
		return m.OldAnsweredUserCount(ctx)
	case tkexamquestiontype.FieldQuestionBankID:
		return m.OldQuestionBankID(ctx)
	}
	return nil, fmt.Errorf("unknown TkExamQuestionType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TkExamQuestionTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tkexamquestiontype.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case tkexamquestiontype.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tkexamquestiontype.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tkexamquestiontype.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case tkexamquestiontype.FieldExamQuestionType:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamQuestionType(v)
		return nil
	case tkexamquestiontype.FieldQuestionCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuestionCount(v)
		return nil
	case tkexamquestiontype.FieldAnsweredCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnsweredCount(v)
		return nil
	case tkexamquestiontype.FieldAnsweredUserCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnsweredUserCount(v)
		return nil
	case tkexamquestiontype.FieldQuestionBankID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuestionBankID(v)
		return nil
	}
	return fmt.Errorf("unknown TkExamQuestionType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TkExamQuestionTypeMutation) AddedFields() []string {
	var fields []string
	if m.addexam_question_type != nil {
		fields = append(fields, tkexamquestiontype.FieldExamQuestionType)
	}
	if m.addquestion_count != nil {
		fields = append(fields, tkexamquestiontype.FieldQuestionCount)
	}
	if m.addanswered_count != nil {
		fields = append(fields, tkexamquestiontype.FieldAnsweredCount)
	}
	if m.addanswered_user_count != nil {
		fields = append(fields, tkexamquestiontype.FieldAnsweredUserCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TkExamQuestionTypeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tkexamquestiontype.FieldExamQuestionType:
		return m.AddedExamQuestionType()
	case tkexamquestiontype.FieldQuestionCount:
		return m.AddedQuestionCount()
	case tkexamquestiontype.FieldAnsweredCount:
		return m.AddedAnsweredCount()
	case tkexamquestiontype.FieldAnsweredUserCount:
		return m.AddedAnsweredUserCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TkExamQuestionTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tkexamquestiontype.FieldExamQuestionType:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExamQuestionType(v)
		return nil
	case tkexamquestiontype.FieldQuestionCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuestionCount(v)
		return nil
	case tkexamquestiontype.FieldAnsweredCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAnsweredCount(v)
		return nil
	case tkexamquestiontype.FieldAnsweredUserCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAnsweredUserCount(v)
		return nil
	}
	return fmt.Errorf("unknown TkExamQuestionType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TkExamQuestionTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tkexamquestiontype.FieldCreatedAt) {
		fields = append(fields, tkexamquestiontype.FieldCreatedAt)
	}
	if m.FieldCleared(tkexamquestiontype.FieldUpdatedAt) {
		fields = append(fields, tkexamquestiontype.FieldUpdatedAt)
	}
	if m.FieldCleared(tkexamquestiontype.FieldDeletedAt) {
		fields = append(fields, tkexamquestiontype.FieldDeletedAt)
	}
	if m.FieldCleared(tkexamquestiontype.FieldQuestionBankID) {
		fields = append(fields, tkexamquestiontype.FieldQuestionBankID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TkExamQuestionTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TkExamQuestionTypeMutation) ClearField(name string) error {
	switch name {
	case tkexamquestiontype.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case tkexamquestiontype.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case tkexamquestiontype.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case tkexamquestiontype.FieldQuestionBankID:
		m.ClearQuestionBankID()
		return nil
	}
	return fmt.Errorf("unknown TkExamQuestionType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TkExamQuestionTypeMutation) ResetField(name string) error {
	switch name {
	case tkexamquestiontype.FieldUUID:
		m.ResetUUID()
		return nil
	case tkexamquestiontype.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tkexamquestiontype.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tkexamquestiontype.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case tkexamquestiontype.FieldExamQuestionType:
		m.ResetExamQuestionType()
		return nil
	case tkexamquestiontype.FieldQuestionCount:
		m.ResetQuestionCount()
		return nil
	case tkexamquestiontype.FieldAnsweredCount:
		m.ResetAnsweredCount()
		return nil
	case tkexamquestiontype.FieldAnsweredUserCount:
		m.ResetAnsweredUserCount()
		return nil
	case tkexamquestiontype.FieldQuestionBankID:
		m.ResetQuestionBankID()
		return nil
	}
	return fmt.Errorf("unknown TkExamQuestionType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TkExamQuestionTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.question_bank != nil {
		edges = append(edges, tkexamquestiontype.EdgeQuestionBank)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TkExamQuestionTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tkexamquestiontype.EdgeQuestionBank:
		if id := m.question_bank; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TkExamQuestionTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TkExamQuestionTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TkExamQuestionTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedquestion_bank {
		edges = append(edges, tkexamquestiontype.EdgeQuestionBank)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TkExamQuestionTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case tkexamquestiontype.EdgeQuestionBank:
		return m.clearedquestion_bank
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TkExamQuestionTypeMutation) ClearEdge(name string) error {
	switch name {
	case tkexamquestiontype.EdgeQuestionBank:
		m.ClearQuestionBank()
		return nil
	}
	return fmt.Errorf("unknown TkExamQuestionType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TkExamQuestionTypeMutation) ResetEdge(name string) error {
	switch name {
	case tkexamquestiontype.EdgeQuestionBank:
		m.ResetQuestionBank()
		return nil
	}
	return fmt.Errorf("unknown TkExamQuestionType edge %s", name)
}

// TkKnowledgePointMutation represents an operation that mutates the TkKnowledgePoint nodes in the graph.
type TkKnowledgePointMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	uuid                 *string
	created_at           *time.Time
	updated_at           *time.Time
	deleted_at           *time.Time
	name                 *string
	question_count       *int
	addquestion_count    *int
	clearedFields        map[string]struct{}
	question_bank        *int
	clearedquestion_bank bool
	questions            map[int]struct{}
	removedquestions     map[int]struct{}
	clearedquestions     bool
	done                 bool
	oldValue             func(context.Context) (*TkKnowledgePoint, error)
	predicates           []predicate.TkKnowledgePoint
}

var _ ent.Mutation = (*TkKnowledgePointMutation)(nil)

// tkknowledgepointOption allows management of the mutation configuration using functional options.
type tkknowledgepointOption func(*TkKnowledgePointMutation)

// newTkKnowledgePointMutation creates new mutation for the TkKnowledgePoint entity.
func newTkKnowledgePointMutation(c config, op Op, opts ...tkknowledgepointOption) *TkKnowledgePointMutation {
	m := &TkKnowledgePointMutation{
		config:        c,
		op:            op,
		typ:           TypeTkKnowledgePoint,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTkKnowledgePointID sets the ID field of the mutation.
func withTkKnowledgePointID(id int) tkknowledgepointOption {
	return func(m *TkKnowledgePointMutation) {
		var (
			err   error
			once  sync.Once
			value *TkKnowledgePoint
		)
		m.oldValue = func(ctx context.Context) (*TkKnowledgePoint, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TkKnowledgePoint.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTkKnowledgePoint sets the old TkKnowledgePoint of the mutation.
func withTkKnowledgePoint(node *TkKnowledgePoint) tkknowledgepointOption {
	return func(m *TkKnowledgePointMutation) {
		m.oldValue = func(context.Context) (*TkKnowledgePoint, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TkKnowledgePointMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TkKnowledgePointMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *TkKnowledgePointMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *TkKnowledgePointMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *TkKnowledgePointMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the TkKnowledgePoint entity.
// If the TkKnowledgePoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkKnowledgePointMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *TkKnowledgePointMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TkKnowledgePointMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TkKnowledgePointMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TkKnowledgePoint entity.
// If the TkKnowledgePoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkKnowledgePointMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *TkKnowledgePointMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[tkknowledgepoint.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *TkKnowledgePointMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[tkknowledgepoint.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TkKnowledgePointMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, tkknowledgepoint.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TkKnowledgePointMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TkKnowledgePointMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TkKnowledgePoint entity.
// If the TkKnowledgePoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkKnowledgePointMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TkKnowledgePointMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[tkknowledgepoint.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TkKnowledgePointMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[tkknowledgepoint.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TkKnowledgePointMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, tkknowledgepoint.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TkKnowledgePointMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TkKnowledgePointMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TkKnowledgePoint entity.
// If the TkKnowledgePoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkKnowledgePointMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TkKnowledgePointMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[tkknowledgepoint.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TkKnowledgePointMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[tkknowledgepoint.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TkKnowledgePointMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, tkknowledgepoint.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *TkKnowledgePointMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TkKnowledgePointMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TkKnowledgePoint entity.
// If the TkKnowledgePoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkKnowledgePointMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TkKnowledgePointMutation) ResetName() {
	m.name = nil
}

// SetQuestionBankID sets the "question_bank_id" field.
func (m *TkKnowledgePointMutation) SetQuestionBankID(i int) {
	m.question_bank = &i
}

// QuestionBankID returns the value of the "question_bank_id" field in the mutation.
func (m *TkKnowledgePointMutation) QuestionBankID() (r int, exists bool) {
	v := m.question_bank
	if v == nil {
		return
	}
	return *v, true
}

// OldQuestionBankID returns the old "question_bank_id" field's value of the TkKnowledgePoint entity.
// If the TkKnowledgePoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkKnowledgePointMutation) OldQuestionBankID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldQuestionBankID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldQuestionBankID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuestionBankID: %w", err)
	}
	return oldValue.QuestionBankID, nil
}

// ClearQuestionBankID clears the value of the "question_bank_id" field.
func (m *TkKnowledgePointMutation) ClearQuestionBankID() {
	m.question_bank = nil
	m.clearedFields[tkknowledgepoint.FieldQuestionBankID] = struct{}{}
}

// QuestionBankIDCleared returns if the "question_bank_id" field was cleared in this mutation.
func (m *TkKnowledgePointMutation) QuestionBankIDCleared() bool {
	_, ok := m.clearedFields[tkknowledgepoint.FieldQuestionBankID]
	return ok
}

// ResetQuestionBankID resets all changes to the "question_bank_id" field.
func (m *TkKnowledgePointMutation) ResetQuestionBankID() {
	m.question_bank = nil
	delete(m.clearedFields, tkknowledgepoint.FieldQuestionBankID)
}

// SetQuestionCount sets the "question_count" field.
func (m *TkKnowledgePointMutation) SetQuestionCount(i int) {
	m.question_count = &i
	m.addquestion_count = nil
}

// QuestionCount returns the value of the "question_count" field in the mutation.
func (m *TkKnowledgePointMutation) QuestionCount() (r int, exists bool) {
	v := m.question_count
	if v == nil {
		return
	}
	return *v, true
}

// OldQuestionCount returns the old "question_count" field's value of the TkKnowledgePoint entity.
// If the TkKnowledgePoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkKnowledgePointMutation) OldQuestionCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldQuestionCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldQuestionCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuestionCount: %w", err)
	}
	return oldValue.QuestionCount, nil
}

// AddQuestionCount adds i to the "question_count" field.
func (m *TkKnowledgePointMutation) AddQuestionCount(i int) {
	if m.addquestion_count != nil {
		*m.addquestion_count += i
	} else {
		m.addquestion_count = &i
	}
}

// AddedQuestionCount returns the value that was added to the "question_count" field in this mutation.
func (m *TkKnowledgePointMutation) AddedQuestionCount() (r int, exists bool) {
	v := m.addquestion_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuestionCount resets all changes to the "question_count" field.
func (m *TkKnowledgePointMutation) ResetQuestionCount() {
	m.question_count = nil
	m.addquestion_count = nil
}

// ClearQuestionBank clears the "question_bank" edge to the TkQuestionBank entity.
func (m *TkKnowledgePointMutation) ClearQuestionBank() {
	m.clearedquestion_bank = true
}

// QuestionBankCleared reports if the "question_bank" edge to the TkQuestionBank entity was cleared.
func (m *TkKnowledgePointMutation) QuestionBankCleared() bool {
	return m.QuestionBankIDCleared() || m.clearedquestion_bank
}

// QuestionBankIDs returns the "question_bank" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// QuestionBankID instead. It exists only for internal usage by the builders.
func (m *TkKnowledgePointMutation) QuestionBankIDs() (ids []int) {
	if id := m.question_bank; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetQuestionBank resets all changes to the "question_bank" edge.
func (m *TkKnowledgePointMutation) ResetQuestionBank() {
	m.question_bank = nil
	m.clearedquestion_bank = false
}

// AddQuestionIDs adds the "questions" edge to the TkQuestion entity by ids.
func (m *TkKnowledgePointMutation) AddQuestionIDs(ids ...int) {
	if m.questions == nil {
		m.questions = make(map[int]struct{})
	}
	for i := range ids {
		m.questions[ids[i]] = struct{}{}
	}
}

// ClearQuestions clears the "questions" edge to the TkQuestion entity.
func (m *TkKnowledgePointMutation) ClearQuestions() {
	m.clearedquestions = true
}

// QuestionsCleared reports if the "questions" edge to the TkQuestion entity was cleared.
func (m *TkKnowledgePointMutation) QuestionsCleared() bool {
	return m.clearedquestions
}

// RemoveQuestionIDs removes the "questions" edge to the TkQuestion entity by IDs.
func (m *TkKnowledgePointMutation) RemoveQuestionIDs(ids ...int) {
	if m.removedquestions == nil {
		m.removedquestions = make(map[int]struct{})
	}
	for i := range ids {
		m.removedquestions[ids[i]] = struct{}{}
	}
}

// RemovedQuestions returns the removed IDs of the "questions" edge to the TkQuestion entity.
func (m *TkKnowledgePointMutation) RemovedQuestionsIDs() (ids []int) {
	for id := range m.removedquestions {
		ids = append(ids, id)
	}
	return
}

// QuestionsIDs returns the "questions" edge IDs in the mutation.
func (m *TkKnowledgePointMutation) QuestionsIDs() (ids []int) {
	for id := range m.questions {
		ids = append(ids, id)
	}
	return
}

// ResetQuestions resets all changes to the "questions" edge.
func (m *TkKnowledgePointMutation) ResetQuestions() {
	m.questions = nil
	m.clearedquestions = false
	m.removedquestions = nil
}

// Op returns the operation name.
func (m *TkKnowledgePointMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TkKnowledgePoint).
func (m *TkKnowledgePointMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TkKnowledgePointMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.uuid != nil {
		fields = append(fields, tkknowledgepoint.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, tkknowledgepoint.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tkknowledgepoint.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, tkknowledgepoint.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, tkknowledgepoint.FieldName)
	}
	if m.question_bank != nil {
		fields = append(fields, tkknowledgepoint.FieldQuestionBankID)
	}
	if m.question_count != nil {
		fields = append(fields, tkknowledgepoint.FieldQuestionCount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TkKnowledgePointMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tkknowledgepoint.FieldUUID:
		return m.UUID()
	case tkknowledgepoint.FieldCreatedAt:
		return m.CreatedAt()
	case tkknowledgepoint.FieldUpdatedAt:
		return m.UpdatedAt()
	case tkknowledgepoint.FieldDeletedAt:
		return m.DeletedAt()
	case tkknowledgepoint.FieldName:
		return m.Name()
	case tkknowledgepoint.FieldQuestionBankID:
		return m.QuestionBankID()
	case tkknowledgepoint.FieldQuestionCount:
		return m.QuestionCount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TkKnowledgePointMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tkknowledgepoint.FieldUUID:
		return m.OldUUID(ctx)
	case tkknowledgepoint.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tkknowledgepoint.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tkknowledgepoint.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case tkknowledgepoint.FieldName:
		return m.OldName(ctx)
	case tkknowledgepoint.FieldQuestionBankID:
		return m.OldQuestionBankID(ctx)
	case tkknowledgepoint.FieldQuestionCount:
		return m.OldQuestionCount(ctx)
	}
	return nil, fmt.Errorf("unknown TkKnowledgePoint field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TkKnowledgePointMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tkknowledgepoint.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case tkknowledgepoint.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tkknowledgepoint.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tkknowledgepoint.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case tkknowledgepoint.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tkknowledgepoint.FieldQuestionBankID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuestionBankID(v)
		return nil
	case tkknowledgepoint.FieldQuestionCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuestionCount(v)
		return nil
	}
	return fmt.Errorf("unknown TkKnowledgePoint field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TkKnowledgePointMutation) AddedFields() []string {
	var fields []string
	if m.addquestion_count != nil {
		fields = append(fields, tkknowledgepoint.FieldQuestionCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TkKnowledgePointMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tkknowledgepoint.FieldQuestionCount:
		return m.AddedQuestionCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TkKnowledgePointMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tkknowledgepoint.FieldQuestionCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuestionCount(v)
		return nil
	}
	return fmt.Errorf("unknown TkKnowledgePoint numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TkKnowledgePointMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tkknowledgepoint.FieldCreatedAt) {
		fields = append(fields, tkknowledgepoint.FieldCreatedAt)
	}
	if m.FieldCleared(tkknowledgepoint.FieldUpdatedAt) {
		fields = append(fields, tkknowledgepoint.FieldUpdatedAt)
	}
	if m.FieldCleared(tkknowledgepoint.FieldDeletedAt) {
		fields = append(fields, tkknowledgepoint.FieldDeletedAt)
	}
	if m.FieldCleared(tkknowledgepoint.FieldQuestionBankID) {
		fields = append(fields, tkknowledgepoint.FieldQuestionBankID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TkKnowledgePointMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TkKnowledgePointMutation) ClearField(name string) error {
	switch name {
	case tkknowledgepoint.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case tkknowledgepoint.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case tkknowledgepoint.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case tkknowledgepoint.FieldQuestionBankID:
		m.ClearQuestionBankID()
		return nil
	}
	return fmt.Errorf("unknown TkKnowledgePoint nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TkKnowledgePointMutation) ResetField(name string) error {
	switch name {
	case tkknowledgepoint.FieldUUID:
		m.ResetUUID()
		return nil
	case tkknowledgepoint.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tkknowledgepoint.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tkknowledgepoint.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case tkknowledgepoint.FieldName:
		m.ResetName()
		return nil
	case tkknowledgepoint.FieldQuestionBankID:
		m.ResetQuestionBankID()
		return nil
	case tkknowledgepoint.FieldQuestionCount:
		m.ResetQuestionCount()
		return nil
	}
	return fmt.Errorf("unknown TkKnowledgePoint field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TkKnowledgePointMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.question_bank != nil {
		edges = append(edges, tkknowledgepoint.EdgeQuestionBank)
	}
	if m.questions != nil {
		edges = append(edges, tkknowledgepoint.EdgeQuestions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TkKnowledgePointMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tkknowledgepoint.EdgeQuestionBank:
		if id := m.question_bank; id != nil {
			return []ent.Value{*id}
		}
	case tkknowledgepoint.EdgeQuestions:
		ids := make([]ent.Value, 0, len(m.questions))
		for id := range m.questions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TkKnowledgePointMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedquestions != nil {
		edges = append(edges, tkknowledgepoint.EdgeQuestions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TkKnowledgePointMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tkknowledgepoint.EdgeQuestions:
		ids := make([]ent.Value, 0, len(m.removedquestions))
		for id := range m.removedquestions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TkKnowledgePointMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedquestion_bank {
		edges = append(edges, tkknowledgepoint.EdgeQuestionBank)
	}
	if m.clearedquestions {
		edges = append(edges, tkknowledgepoint.EdgeQuestions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TkKnowledgePointMutation) EdgeCleared(name string) bool {
	switch name {
	case tkknowledgepoint.EdgeQuestionBank:
		return m.clearedquestion_bank
	case tkknowledgepoint.EdgeQuestions:
		return m.clearedquestions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TkKnowledgePointMutation) ClearEdge(name string) error {
	switch name {
	case tkknowledgepoint.EdgeQuestionBank:
		m.ClearQuestionBank()
		return nil
	}
	return fmt.Errorf("unknown TkKnowledgePoint unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TkKnowledgePointMutation) ResetEdge(name string) error {
	switch name {
	case tkknowledgepoint.EdgeQuestionBank:
		m.ResetQuestionBank()
		return nil
	case tkknowledgepoint.EdgeQuestions:
		m.ResetQuestions()
		return nil
	}
	return fmt.Errorf("unknown TkKnowledgePoint edge %s", name)
}

// TkQuestionMutation represents an operation that mutates the TkQuestion nodes in the graph.
type TkQuestionMutation struct {
	config
	op                              Op
	typ                             string
	id                              *int
	uuid                            *string
	created_at                      *time.Time
	updated_at                      *time.Time
	deleted_at                      *time.Time
	name                            *string
	difficulty                      *uint8
	adddifficulty                   *uint8
	_type                           *uint8
	add_type                        *uint8
	desc                            *string
	answer_count                    *int
	addanswer_count                 *int
	right_count                     *int
	addright_count                  *int
	clearedFields                   map[string]struct{}
	question_bank                   *int
	clearedquestion_bank            bool
	admin                           *int
	clearedadmin                    bool
	user_rand_dom                   map[int]struct{}
	removeduser_rand_dom            map[int]struct{}
	cleareduser_rand_dom            bool
	answer_options                  map[int]struct{}
	removedanswer_options           map[int]struct{}
	clearedanswer_options           bool
	knowledge_points                map[int]struct{}
	removedknowledge_points         map[int]struct{}
	clearedknowledge_points         bool
	question_section_links          map[int]struct{}
	removedquestion_section_links   map[int]struct{}
	clearedquestion_section_links   bool
	exam_partition_questions        map[int]struct{}
	removedexam_partition_questions map[int]struct{}
	clearedexam_partition_questions bool
	question_error_feedbacks        map[int]struct{}
	removedquestion_error_feedbacks map[int]struct{}
	clearedquestion_error_feedbacks bool
	user_records                    map[int]struct{}
	removeduser_records             map[int]struct{}
	cleareduser_records             bool
	small_category_questions        map[int]struct{}
	removedsmall_category_questions map[int]struct{}
	clearedsmall_category_questions bool
	user_exam_questions             map[int]struct{}
	removeduser_exam_questions      map[int]struct{}
	cleareduser_exam_questions      bool
	user_recode_wrong               map[int]struct{}
	removeduser_recode_wrong        map[int]struct{}
	cleareduser_recode_wrong        bool
	parent                          *int
	clearedparent                   bool
	children                        map[int]struct{}
	removedchildren                 map[int]struct{}
	clearedchildren                 bool
	collection_question             map[int]struct{}
	removedcollection_question      map[int]struct{}
	clearedcollection_question      bool
	done                            bool
	oldValue                        func(context.Context) (*TkQuestion, error)
	predicates                      []predicate.TkQuestion
}

var _ ent.Mutation = (*TkQuestionMutation)(nil)

// tkquestionOption allows management of the mutation configuration using functional options.
type tkquestionOption func(*TkQuestionMutation)

// newTkQuestionMutation creates new mutation for the TkQuestion entity.
func newTkQuestionMutation(c config, op Op, opts ...tkquestionOption) *TkQuestionMutation {
	m := &TkQuestionMutation{
		config:        c,
		op:            op,
		typ:           TypeTkQuestion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTkQuestionID sets the ID field of the mutation.
func withTkQuestionID(id int) tkquestionOption {
	return func(m *TkQuestionMutation) {
		var (
			err   error
			once  sync.Once
			value *TkQuestion
		)
		m.oldValue = func(ctx context.Context) (*TkQuestion, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TkQuestion.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTkQuestion sets the old TkQuestion of the mutation.
func withTkQuestion(node *TkQuestion) tkquestionOption {
	return func(m *TkQuestionMutation) {
		m.oldValue = func(context.Context) (*TkQuestion, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TkQuestionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TkQuestionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *TkQuestionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *TkQuestionMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *TkQuestionMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the TkQuestion entity.
// If the TkQuestion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkQuestionMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *TkQuestionMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TkQuestionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TkQuestionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TkQuestion entity.
// If the TkQuestion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkQuestionMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *TkQuestionMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[tkquestion.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *TkQuestionMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[tkquestion.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TkQuestionMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, tkquestion.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TkQuestionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TkQuestionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TkQuestion entity.
// If the TkQuestion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkQuestionMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TkQuestionMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[tkquestion.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TkQuestionMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[tkquestion.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TkQuestionMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, tkquestion.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TkQuestionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TkQuestionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TkQuestion entity.
// If the TkQuestion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkQuestionMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TkQuestionMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[tkquestion.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TkQuestionMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[tkquestion.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TkQuestionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, tkquestion.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *TkQuestionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TkQuestionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TkQuestion entity.
// If the TkQuestion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkQuestionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *TkQuestionMutation) ClearName() {
	m.name = nil
	m.clearedFields[tkquestion.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *TkQuestionMutation) NameCleared() bool {
	_, ok := m.clearedFields[tkquestion.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *TkQuestionMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, tkquestion.FieldName)
}

// SetDifficulty sets the "difficulty" field.
func (m *TkQuestionMutation) SetDifficulty(u uint8) {
	m.difficulty = &u
	m.adddifficulty = nil
}

// Difficulty returns the value of the "difficulty" field in the mutation.
func (m *TkQuestionMutation) Difficulty() (r uint8, exists bool) {
	v := m.difficulty
	if v == nil {
		return
	}
	return *v, true
}

// OldDifficulty returns the old "difficulty" field's value of the TkQuestion entity.
// If the TkQuestion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkQuestionMutation) OldDifficulty(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDifficulty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDifficulty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDifficulty: %w", err)
	}
	return oldValue.Difficulty, nil
}

// AddDifficulty adds u to the "difficulty" field.
func (m *TkQuestionMutation) AddDifficulty(u uint8) {
	if m.adddifficulty != nil {
		*m.adddifficulty += u
	} else {
		m.adddifficulty = &u
	}
}

// AddedDifficulty returns the value that was added to the "difficulty" field in this mutation.
func (m *TkQuestionMutation) AddedDifficulty() (r uint8, exists bool) {
	v := m.adddifficulty
	if v == nil {
		return
	}
	return *v, true
}

// ResetDifficulty resets all changes to the "difficulty" field.
func (m *TkQuestionMutation) ResetDifficulty() {
	m.difficulty = nil
	m.adddifficulty = nil
}

// SetType sets the "type" field.
func (m *TkQuestionMutation) SetType(u uint8) {
	m._type = &u
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *TkQuestionMutation) GetType() (r uint8, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the TkQuestion entity.
// If the TkQuestion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkQuestionMutation) OldType(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds u to the "type" field.
func (m *TkQuestionMutation) AddType(u uint8) {
	if m.add_type != nil {
		*m.add_type += u
	} else {
		m.add_type = &u
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *TkQuestionMutation) AddedType() (r uint8, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *TkQuestionMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetDesc sets the "desc" field.
func (m *TkQuestionMutation) SetDesc(s string) {
	m.desc = &s
}

// Desc returns the value of the "desc" field in the mutation.
func (m *TkQuestionMutation) Desc() (r string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the TkQuestion entity.
// If the TkQuestion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkQuestionMutation) OldDesc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// ClearDesc clears the value of the "desc" field.
func (m *TkQuestionMutation) ClearDesc() {
	m.desc = nil
	m.clearedFields[tkquestion.FieldDesc] = struct{}{}
}

// DescCleared returns if the "desc" field was cleared in this mutation.
func (m *TkQuestionMutation) DescCleared() bool {
	_, ok := m.clearedFields[tkquestion.FieldDesc]
	return ok
}

// ResetDesc resets all changes to the "desc" field.
func (m *TkQuestionMutation) ResetDesc() {
	m.desc = nil
	delete(m.clearedFields, tkquestion.FieldDesc)
}

// SetCreatedAdminID sets the "created_admin_id" field.
func (m *TkQuestionMutation) SetCreatedAdminID(i int) {
	m.admin = &i
}

// CreatedAdminID returns the value of the "created_admin_id" field in the mutation.
func (m *TkQuestionMutation) CreatedAdminID() (r int, exists bool) {
	v := m.admin
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAdminID returns the old "created_admin_id" field's value of the TkQuestion entity.
// If the TkQuestion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkQuestionMutation) OldCreatedAdminID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAdminID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAdminID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAdminID: %w", err)
	}
	return oldValue.CreatedAdminID, nil
}

// ClearCreatedAdminID clears the value of the "created_admin_id" field.
func (m *TkQuestionMutation) ClearCreatedAdminID() {
	m.admin = nil
	m.clearedFields[tkquestion.FieldCreatedAdminID] = struct{}{}
}

// CreatedAdminIDCleared returns if the "created_admin_id" field was cleared in this mutation.
func (m *TkQuestionMutation) CreatedAdminIDCleared() bool {
	_, ok := m.clearedFields[tkquestion.FieldCreatedAdminID]
	return ok
}

// ResetCreatedAdminID resets all changes to the "created_admin_id" field.
func (m *TkQuestionMutation) ResetCreatedAdminID() {
	m.admin = nil
	delete(m.clearedFields, tkquestion.FieldCreatedAdminID)
}

// SetQuestionBankID sets the "question_bank_id" field.
func (m *TkQuestionMutation) SetQuestionBankID(i int) {
	m.question_bank = &i
}

// QuestionBankID returns the value of the "question_bank_id" field in the mutation.
func (m *TkQuestionMutation) QuestionBankID() (r int, exists bool) {
	v := m.question_bank
	if v == nil {
		return
	}
	return *v, true
}

// OldQuestionBankID returns the old "question_bank_id" field's value of the TkQuestion entity.
// If the TkQuestion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkQuestionMutation) OldQuestionBankID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldQuestionBankID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldQuestionBankID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuestionBankID: %w", err)
	}
	return oldValue.QuestionBankID, nil
}

// ClearQuestionBankID clears the value of the "question_bank_id" field.
func (m *TkQuestionMutation) ClearQuestionBankID() {
	m.question_bank = nil
	m.clearedFields[tkquestion.FieldQuestionBankID] = struct{}{}
}

// QuestionBankIDCleared returns if the "question_bank_id" field was cleared in this mutation.
func (m *TkQuestionMutation) QuestionBankIDCleared() bool {
	_, ok := m.clearedFields[tkquestion.FieldQuestionBankID]
	return ok
}

// ResetQuestionBankID resets all changes to the "question_bank_id" field.
func (m *TkQuestionMutation) ResetQuestionBankID() {
	m.question_bank = nil
	delete(m.clearedFields, tkquestion.FieldQuestionBankID)
}

// SetAnswerCount sets the "answer_count" field.
func (m *TkQuestionMutation) SetAnswerCount(i int) {
	m.answer_count = &i
	m.addanswer_count = nil
}

// AnswerCount returns the value of the "answer_count" field in the mutation.
func (m *TkQuestionMutation) AnswerCount() (r int, exists bool) {
	v := m.answer_count
	if v == nil {
		return
	}
	return *v, true
}

// OldAnswerCount returns the old "answer_count" field's value of the TkQuestion entity.
// If the TkQuestion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkQuestionMutation) OldAnswerCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAnswerCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAnswerCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnswerCount: %w", err)
	}
	return oldValue.AnswerCount, nil
}

// AddAnswerCount adds i to the "answer_count" field.
func (m *TkQuestionMutation) AddAnswerCount(i int) {
	if m.addanswer_count != nil {
		*m.addanswer_count += i
	} else {
		m.addanswer_count = &i
	}
}

// AddedAnswerCount returns the value that was added to the "answer_count" field in this mutation.
func (m *TkQuestionMutation) AddedAnswerCount() (r int, exists bool) {
	v := m.addanswer_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetAnswerCount resets all changes to the "answer_count" field.
func (m *TkQuestionMutation) ResetAnswerCount() {
	m.answer_count = nil
	m.addanswer_count = nil
}

// SetRightCount sets the "right_count" field.
func (m *TkQuestionMutation) SetRightCount(i int) {
	m.right_count = &i
	m.addright_count = nil
}

// RightCount returns the value of the "right_count" field in the mutation.
func (m *TkQuestionMutation) RightCount() (r int, exists bool) {
	v := m.right_count
	if v == nil {
		return
	}
	return *v, true
}

// OldRightCount returns the old "right_count" field's value of the TkQuestion entity.
// If the TkQuestion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkQuestionMutation) OldRightCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRightCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRightCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRightCount: %w", err)
	}
	return oldValue.RightCount, nil
}

// AddRightCount adds i to the "right_count" field.
func (m *TkQuestionMutation) AddRightCount(i int) {
	if m.addright_count != nil {
		*m.addright_count += i
	} else {
		m.addright_count = &i
	}
}

// AddedRightCount returns the value that was added to the "right_count" field in this mutation.
func (m *TkQuestionMutation) AddedRightCount() (r int, exists bool) {
	v := m.addright_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetRightCount resets all changes to the "right_count" field.
func (m *TkQuestionMutation) ResetRightCount() {
	m.right_count = nil
	m.addright_count = nil
}

// SetPid sets the "pid" field.
func (m *TkQuestionMutation) SetPid(i int) {
	m.parent = &i
}

// Pid returns the value of the "pid" field in the mutation.
func (m *TkQuestionMutation) Pid() (r int, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldPid returns the old "pid" field's value of the TkQuestion entity.
// If the TkQuestion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkQuestionMutation) OldPid(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPid: %w", err)
	}
	return oldValue.Pid, nil
}

// ClearPid clears the value of the "pid" field.
func (m *TkQuestionMutation) ClearPid() {
	m.parent = nil
	m.clearedFields[tkquestion.FieldPid] = struct{}{}
}

// PidCleared returns if the "pid" field was cleared in this mutation.
func (m *TkQuestionMutation) PidCleared() bool {
	_, ok := m.clearedFields[tkquestion.FieldPid]
	return ok
}

// ResetPid resets all changes to the "pid" field.
func (m *TkQuestionMutation) ResetPid() {
	m.parent = nil
	delete(m.clearedFields, tkquestion.FieldPid)
}

// ClearQuestionBank clears the "question_bank" edge to the TkQuestionBank entity.
func (m *TkQuestionMutation) ClearQuestionBank() {
	m.clearedquestion_bank = true
}

// QuestionBankCleared reports if the "question_bank" edge to the TkQuestionBank entity was cleared.
func (m *TkQuestionMutation) QuestionBankCleared() bool {
	return m.QuestionBankIDCleared() || m.clearedquestion_bank
}

// QuestionBankIDs returns the "question_bank" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// QuestionBankID instead. It exists only for internal usage by the builders.
func (m *TkQuestionMutation) QuestionBankIDs() (ids []int) {
	if id := m.question_bank; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetQuestionBank resets all changes to the "question_bank" edge.
func (m *TkQuestionMutation) ResetQuestionBank() {
	m.question_bank = nil
	m.clearedquestion_bank = false
}

// SetAdminID sets the "admin" edge to the Admin entity by id.
func (m *TkQuestionMutation) SetAdminID(id int) {
	m.admin = &id
}

// ClearAdmin clears the "admin" edge to the Admin entity.
func (m *TkQuestionMutation) ClearAdmin() {
	m.clearedadmin = true
}

// AdminCleared reports if the "admin" edge to the Admin entity was cleared.
func (m *TkQuestionMutation) AdminCleared() bool {
	return m.CreatedAdminIDCleared() || m.clearedadmin
}

// AdminID returns the "admin" edge ID in the mutation.
func (m *TkQuestionMutation) AdminID() (id int, exists bool) {
	if m.admin != nil {
		return *m.admin, true
	}
	return
}

// AdminIDs returns the "admin" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AdminID instead. It exists only for internal usage by the builders.
func (m *TkQuestionMutation) AdminIDs() (ids []int) {
	if id := m.admin; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAdmin resets all changes to the "admin" edge.
func (m *TkQuestionMutation) ResetAdmin() {
	m.admin = nil
	m.clearedadmin = false
}

// AddUserRandDomIDs adds the "user_rand_dom" edge to the TkUserRandomExamRecode entity by ids.
func (m *TkQuestionMutation) AddUserRandDomIDs(ids ...int) {
	if m.user_rand_dom == nil {
		m.user_rand_dom = make(map[int]struct{})
	}
	for i := range ids {
		m.user_rand_dom[ids[i]] = struct{}{}
	}
}

// ClearUserRandDom clears the "user_rand_dom" edge to the TkUserRandomExamRecode entity.
func (m *TkQuestionMutation) ClearUserRandDom() {
	m.cleareduser_rand_dom = true
}

// UserRandDomCleared reports if the "user_rand_dom" edge to the TkUserRandomExamRecode entity was cleared.
func (m *TkQuestionMutation) UserRandDomCleared() bool {
	return m.cleareduser_rand_dom
}

// RemoveUserRandDomIDs removes the "user_rand_dom" edge to the TkUserRandomExamRecode entity by IDs.
func (m *TkQuestionMutation) RemoveUserRandDomIDs(ids ...int) {
	if m.removeduser_rand_dom == nil {
		m.removeduser_rand_dom = make(map[int]struct{})
	}
	for i := range ids {
		m.removeduser_rand_dom[ids[i]] = struct{}{}
	}
}

// RemovedUserRandDom returns the removed IDs of the "user_rand_dom" edge to the TkUserRandomExamRecode entity.
func (m *TkQuestionMutation) RemovedUserRandDomIDs() (ids []int) {
	for id := range m.removeduser_rand_dom {
		ids = append(ids, id)
	}
	return
}

// UserRandDomIDs returns the "user_rand_dom" edge IDs in the mutation.
func (m *TkQuestionMutation) UserRandDomIDs() (ids []int) {
	for id := range m.user_rand_dom {
		ids = append(ids, id)
	}
	return
}

// ResetUserRandDom resets all changes to the "user_rand_dom" edge.
func (m *TkQuestionMutation) ResetUserRandDom() {
	m.user_rand_dom = nil
	m.cleareduser_rand_dom = false
	m.removeduser_rand_dom = nil
}

// AddAnswerOptionIDs adds the "answer_options" edge to the TkQuestionAnswerOption entity by ids.
func (m *TkQuestionMutation) AddAnswerOptionIDs(ids ...int) {
	if m.answer_options == nil {
		m.answer_options = make(map[int]struct{})
	}
	for i := range ids {
		m.answer_options[ids[i]] = struct{}{}
	}
}

// ClearAnswerOptions clears the "answer_options" edge to the TkQuestionAnswerOption entity.
func (m *TkQuestionMutation) ClearAnswerOptions() {
	m.clearedanswer_options = true
}

// AnswerOptionsCleared reports if the "answer_options" edge to the TkQuestionAnswerOption entity was cleared.
func (m *TkQuestionMutation) AnswerOptionsCleared() bool {
	return m.clearedanswer_options
}

// RemoveAnswerOptionIDs removes the "answer_options" edge to the TkQuestionAnswerOption entity by IDs.
func (m *TkQuestionMutation) RemoveAnswerOptionIDs(ids ...int) {
	if m.removedanswer_options == nil {
		m.removedanswer_options = make(map[int]struct{})
	}
	for i := range ids {
		m.removedanswer_options[ids[i]] = struct{}{}
	}
}

// RemovedAnswerOptions returns the removed IDs of the "answer_options" edge to the TkQuestionAnswerOption entity.
func (m *TkQuestionMutation) RemovedAnswerOptionsIDs() (ids []int) {
	for id := range m.removedanswer_options {
		ids = append(ids, id)
	}
	return
}

// AnswerOptionsIDs returns the "answer_options" edge IDs in the mutation.
func (m *TkQuestionMutation) AnswerOptionsIDs() (ids []int) {
	for id := range m.answer_options {
		ids = append(ids, id)
	}
	return
}

// ResetAnswerOptions resets all changes to the "answer_options" edge.
func (m *TkQuestionMutation) ResetAnswerOptions() {
	m.answer_options = nil
	m.clearedanswer_options = false
	m.removedanswer_options = nil
}

// AddKnowledgePointIDs adds the "knowledge_points" edge to the TkKnowledgePoint entity by ids.
func (m *TkQuestionMutation) AddKnowledgePointIDs(ids ...int) {
	if m.knowledge_points == nil {
		m.knowledge_points = make(map[int]struct{})
	}
	for i := range ids {
		m.knowledge_points[ids[i]] = struct{}{}
	}
}

// ClearKnowledgePoints clears the "knowledge_points" edge to the TkKnowledgePoint entity.
func (m *TkQuestionMutation) ClearKnowledgePoints() {
	m.clearedknowledge_points = true
}

// KnowledgePointsCleared reports if the "knowledge_points" edge to the TkKnowledgePoint entity was cleared.
func (m *TkQuestionMutation) KnowledgePointsCleared() bool {
	return m.clearedknowledge_points
}

// RemoveKnowledgePointIDs removes the "knowledge_points" edge to the TkKnowledgePoint entity by IDs.
func (m *TkQuestionMutation) RemoveKnowledgePointIDs(ids ...int) {
	if m.removedknowledge_points == nil {
		m.removedknowledge_points = make(map[int]struct{})
	}
	for i := range ids {
		m.removedknowledge_points[ids[i]] = struct{}{}
	}
}

// RemovedKnowledgePoints returns the removed IDs of the "knowledge_points" edge to the TkKnowledgePoint entity.
func (m *TkQuestionMutation) RemovedKnowledgePointsIDs() (ids []int) {
	for id := range m.removedknowledge_points {
		ids = append(ids, id)
	}
	return
}

// KnowledgePointsIDs returns the "knowledge_points" edge IDs in the mutation.
func (m *TkQuestionMutation) KnowledgePointsIDs() (ids []int) {
	for id := range m.knowledge_points {
		ids = append(ids, id)
	}
	return
}

// ResetKnowledgePoints resets all changes to the "knowledge_points" edge.
func (m *TkQuestionMutation) ResetKnowledgePoints() {
	m.knowledge_points = nil
	m.clearedknowledge_points = false
	m.removedknowledge_points = nil
}

// AddQuestionSectionLinkIDs adds the "question_section_links" edge to the TkQuestionSection entity by ids.
func (m *TkQuestionMutation) AddQuestionSectionLinkIDs(ids ...int) {
	if m.question_section_links == nil {
		m.question_section_links = make(map[int]struct{})
	}
	for i := range ids {
		m.question_section_links[ids[i]] = struct{}{}
	}
}

// ClearQuestionSectionLinks clears the "question_section_links" edge to the TkQuestionSection entity.
func (m *TkQuestionMutation) ClearQuestionSectionLinks() {
	m.clearedquestion_section_links = true
}

// QuestionSectionLinksCleared reports if the "question_section_links" edge to the TkQuestionSection entity was cleared.
func (m *TkQuestionMutation) QuestionSectionLinksCleared() bool {
	return m.clearedquestion_section_links
}

// RemoveQuestionSectionLinkIDs removes the "question_section_links" edge to the TkQuestionSection entity by IDs.
func (m *TkQuestionMutation) RemoveQuestionSectionLinkIDs(ids ...int) {
	if m.removedquestion_section_links == nil {
		m.removedquestion_section_links = make(map[int]struct{})
	}
	for i := range ids {
		m.removedquestion_section_links[ids[i]] = struct{}{}
	}
}

// RemovedQuestionSectionLinks returns the removed IDs of the "question_section_links" edge to the TkQuestionSection entity.
func (m *TkQuestionMutation) RemovedQuestionSectionLinksIDs() (ids []int) {
	for id := range m.removedquestion_section_links {
		ids = append(ids, id)
	}
	return
}

// QuestionSectionLinksIDs returns the "question_section_links" edge IDs in the mutation.
func (m *TkQuestionMutation) QuestionSectionLinksIDs() (ids []int) {
	for id := range m.question_section_links {
		ids = append(ids, id)
	}
	return
}

// ResetQuestionSectionLinks resets all changes to the "question_section_links" edge.
func (m *TkQuestionMutation) ResetQuestionSectionLinks() {
	m.question_section_links = nil
	m.clearedquestion_section_links = false
	m.removedquestion_section_links = nil
}

// AddExamPartitionQuestionIDs adds the "exam_partition_questions" edge to the TkExamPartitionQuestionLink entity by ids.
func (m *TkQuestionMutation) AddExamPartitionQuestionIDs(ids ...int) {
	if m.exam_partition_questions == nil {
		m.exam_partition_questions = make(map[int]struct{})
	}
	for i := range ids {
		m.exam_partition_questions[ids[i]] = struct{}{}
	}
}

// ClearExamPartitionQuestions clears the "exam_partition_questions" edge to the TkExamPartitionQuestionLink entity.
func (m *TkQuestionMutation) ClearExamPartitionQuestions() {
	m.clearedexam_partition_questions = true
}

// ExamPartitionQuestionsCleared reports if the "exam_partition_questions" edge to the TkExamPartitionQuestionLink entity was cleared.
func (m *TkQuestionMutation) ExamPartitionQuestionsCleared() bool {
	return m.clearedexam_partition_questions
}

// RemoveExamPartitionQuestionIDs removes the "exam_partition_questions" edge to the TkExamPartitionQuestionLink entity by IDs.
func (m *TkQuestionMutation) RemoveExamPartitionQuestionIDs(ids ...int) {
	if m.removedexam_partition_questions == nil {
		m.removedexam_partition_questions = make(map[int]struct{})
	}
	for i := range ids {
		m.removedexam_partition_questions[ids[i]] = struct{}{}
	}
}

// RemovedExamPartitionQuestions returns the removed IDs of the "exam_partition_questions" edge to the TkExamPartitionQuestionLink entity.
func (m *TkQuestionMutation) RemovedExamPartitionQuestionsIDs() (ids []int) {
	for id := range m.removedexam_partition_questions {
		ids = append(ids, id)
	}
	return
}

// ExamPartitionQuestionsIDs returns the "exam_partition_questions" edge IDs in the mutation.
func (m *TkQuestionMutation) ExamPartitionQuestionsIDs() (ids []int) {
	for id := range m.exam_partition_questions {
		ids = append(ids, id)
	}
	return
}

// ResetExamPartitionQuestions resets all changes to the "exam_partition_questions" edge.
func (m *TkQuestionMutation) ResetExamPartitionQuestions() {
	m.exam_partition_questions = nil
	m.clearedexam_partition_questions = false
	m.removedexam_partition_questions = nil
}

// AddQuestionErrorFeedbackIDs adds the "question_error_feedbacks" edge to the TkQuestionErrorFeedback entity by ids.
func (m *TkQuestionMutation) AddQuestionErrorFeedbackIDs(ids ...int) {
	if m.question_error_feedbacks == nil {
		m.question_error_feedbacks = make(map[int]struct{})
	}
	for i := range ids {
		m.question_error_feedbacks[ids[i]] = struct{}{}
	}
}

// ClearQuestionErrorFeedbacks clears the "question_error_feedbacks" edge to the TkQuestionErrorFeedback entity.
func (m *TkQuestionMutation) ClearQuestionErrorFeedbacks() {
	m.clearedquestion_error_feedbacks = true
}

// QuestionErrorFeedbacksCleared reports if the "question_error_feedbacks" edge to the TkQuestionErrorFeedback entity was cleared.
func (m *TkQuestionMutation) QuestionErrorFeedbacksCleared() bool {
	return m.clearedquestion_error_feedbacks
}

// RemoveQuestionErrorFeedbackIDs removes the "question_error_feedbacks" edge to the TkQuestionErrorFeedback entity by IDs.
func (m *TkQuestionMutation) RemoveQuestionErrorFeedbackIDs(ids ...int) {
	if m.removedquestion_error_feedbacks == nil {
		m.removedquestion_error_feedbacks = make(map[int]struct{})
	}
	for i := range ids {
		m.removedquestion_error_feedbacks[ids[i]] = struct{}{}
	}
}

// RemovedQuestionErrorFeedbacks returns the removed IDs of the "question_error_feedbacks" edge to the TkQuestionErrorFeedback entity.
func (m *TkQuestionMutation) RemovedQuestionErrorFeedbacksIDs() (ids []int) {
	for id := range m.removedquestion_error_feedbacks {
		ids = append(ids, id)
	}
	return
}

// QuestionErrorFeedbacksIDs returns the "question_error_feedbacks" edge IDs in the mutation.
func (m *TkQuestionMutation) QuestionErrorFeedbacksIDs() (ids []int) {
	for id := range m.question_error_feedbacks {
		ids = append(ids, id)
	}
	return
}

// ResetQuestionErrorFeedbacks resets all changes to the "question_error_feedbacks" edge.
func (m *TkQuestionMutation) ResetQuestionErrorFeedbacks() {
	m.question_error_feedbacks = nil
	m.clearedquestion_error_feedbacks = false
	m.removedquestion_error_feedbacks = nil
}

// AddUserRecordIDs adds the "user_records" edge to the TkUserQuestionRecord entity by ids.
func (m *TkQuestionMutation) AddUserRecordIDs(ids ...int) {
	if m.user_records == nil {
		m.user_records = make(map[int]struct{})
	}
	for i := range ids {
		m.user_records[ids[i]] = struct{}{}
	}
}

// ClearUserRecords clears the "user_records" edge to the TkUserQuestionRecord entity.
func (m *TkQuestionMutation) ClearUserRecords() {
	m.cleareduser_records = true
}

// UserRecordsCleared reports if the "user_records" edge to the TkUserQuestionRecord entity was cleared.
func (m *TkQuestionMutation) UserRecordsCleared() bool {
	return m.cleareduser_records
}

// RemoveUserRecordIDs removes the "user_records" edge to the TkUserQuestionRecord entity by IDs.
func (m *TkQuestionMutation) RemoveUserRecordIDs(ids ...int) {
	if m.removeduser_records == nil {
		m.removeduser_records = make(map[int]struct{})
	}
	for i := range ids {
		m.removeduser_records[ids[i]] = struct{}{}
	}
}

// RemovedUserRecords returns the removed IDs of the "user_records" edge to the TkUserQuestionRecord entity.
func (m *TkQuestionMutation) RemovedUserRecordsIDs() (ids []int) {
	for id := range m.removeduser_records {
		ids = append(ids, id)
	}
	return
}

// UserRecordsIDs returns the "user_records" edge IDs in the mutation.
func (m *TkQuestionMutation) UserRecordsIDs() (ids []int) {
	for id := range m.user_records {
		ids = append(ids, id)
	}
	return
}

// ResetUserRecords resets all changes to the "user_records" edge.
func (m *TkQuestionMutation) ResetUserRecords() {
	m.user_records = nil
	m.cleareduser_records = false
	m.removeduser_records = nil
}

// AddSmallCategoryQuestionIDs adds the "small_category_questions" edge to the KcSmallCategoryQuestion entity by ids.
func (m *TkQuestionMutation) AddSmallCategoryQuestionIDs(ids ...int) {
	if m.small_category_questions == nil {
		m.small_category_questions = make(map[int]struct{})
	}
	for i := range ids {
		m.small_category_questions[ids[i]] = struct{}{}
	}
}

// ClearSmallCategoryQuestions clears the "small_category_questions" edge to the KcSmallCategoryQuestion entity.
func (m *TkQuestionMutation) ClearSmallCategoryQuestions() {
	m.clearedsmall_category_questions = true
}

// SmallCategoryQuestionsCleared reports if the "small_category_questions" edge to the KcSmallCategoryQuestion entity was cleared.
func (m *TkQuestionMutation) SmallCategoryQuestionsCleared() bool {
	return m.clearedsmall_category_questions
}

// RemoveSmallCategoryQuestionIDs removes the "small_category_questions" edge to the KcSmallCategoryQuestion entity by IDs.
func (m *TkQuestionMutation) RemoveSmallCategoryQuestionIDs(ids ...int) {
	if m.removedsmall_category_questions == nil {
		m.removedsmall_category_questions = make(map[int]struct{})
	}
	for i := range ids {
		m.removedsmall_category_questions[ids[i]] = struct{}{}
	}
}

// RemovedSmallCategoryQuestions returns the removed IDs of the "small_category_questions" edge to the KcSmallCategoryQuestion entity.
func (m *TkQuestionMutation) RemovedSmallCategoryQuestionsIDs() (ids []int) {
	for id := range m.removedsmall_category_questions {
		ids = append(ids, id)
	}
	return
}

// SmallCategoryQuestionsIDs returns the "small_category_questions" edge IDs in the mutation.
func (m *TkQuestionMutation) SmallCategoryQuestionsIDs() (ids []int) {
	for id := range m.small_category_questions {
		ids = append(ids, id)
	}
	return
}

// ResetSmallCategoryQuestions resets all changes to the "small_category_questions" edge.
func (m *TkQuestionMutation) ResetSmallCategoryQuestions() {
	m.small_category_questions = nil
	m.clearedsmall_category_questions = false
	m.removedsmall_category_questions = nil
}

// AddUserExamQuestionIDs adds the "user_exam_questions" edge to the TkUserSimulationTeacherMark entity by ids.
func (m *TkQuestionMutation) AddUserExamQuestionIDs(ids ...int) {
	if m.user_exam_questions == nil {
		m.user_exam_questions = make(map[int]struct{})
	}
	for i := range ids {
		m.user_exam_questions[ids[i]] = struct{}{}
	}
}

// ClearUserExamQuestions clears the "user_exam_questions" edge to the TkUserSimulationTeacherMark entity.
func (m *TkQuestionMutation) ClearUserExamQuestions() {
	m.cleareduser_exam_questions = true
}

// UserExamQuestionsCleared reports if the "user_exam_questions" edge to the TkUserSimulationTeacherMark entity was cleared.
func (m *TkQuestionMutation) UserExamQuestionsCleared() bool {
	return m.cleareduser_exam_questions
}

// RemoveUserExamQuestionIDs removes the "user_exam_questions" edge to the TkUserSimulationTeacherMark entity by IDs.
func (m *TkQuestionMutation) RemoveUserExamQuestionIDs(ids ...int) {
	if m.removeduser_exam_questions == nil {
		m.removeduser_exam_questions = make(map[int]struct{})
	}
	for i := range ids {
		m.removeduser_exam_questions[ids[i]] = struct{}{}
	}
}

// RemovedUserExamQuestions returns the removed IDs of the "user_exam_questions" edge to the TkUserSimulationTeacherMark entity.
func (m *TkQuestionMutation) RemovedUserExamQuestionsIDs() (ids []int) {
	for id := range m.removeduser_exam_questions {
		ids = append(ids, id)
	}
	return
}

// UserExamQuestionsIDs returns the "user_exam_questions" edge IDs in the mutation.
func (m *TkQuestionMutation) UserExamQuestionsIDs() (ids []int) {
	for id := range m.user_exam_questions {
		ids = append(ids, id)
	}
	return
}

// ResetUserExamQuestions resets all changes to the "user_exam_questions" edge.
func (m *TkQuestionMutation) ResetUserExamQuestions() {
	m.user_exam_questions = nil
	m.cleareduser_exam_questions = false
	m.removeduser_exam_questions = nil
}

// AddUserRecodeWrongIDs adds the "user_recode_wrong" edge to the TkUserWrongQuestionRecode entity by ids.
func (m *TkQuestionMutation) AddUserRecodeWrongIDs(ids ...int) {
	if m.user_recode_wrong == nil {
		m.user_recode_wrong = make(map[int]struct{})
	}
	for i := range ids {
		m.user_recode_wrong[ids[i]] = struct{}{}
	}
}

// ClearUserRecodeWrong clears the "user_recode_wrong" edge to the TkUserWrongQuestionRecode entity.
func (m *TkQuestionMutation) ClearUserRecodeWrong() {
	m.cleareduser_recode_wrong = true
}

// UserRecodeWrongCleared reports if the "user_recode_wrong" edge to the TkUserWrongQuestionRecode entity was cleared.
func (m *TkQuestionMutation) UserRecodeWrongCleared() bool {
	return m.cleareduser_recode_wrong
}

// RemoveUserRecodeWrongIDs removes the "user_recode_wrong" edge to the TkUserWrongQuestionRecode entity by IDs.
func (m *TkQuestionMutation) RemoveUserRecodeWrongIDs(ids ...int) {
	if m.removeduser_recode_wrong == nil {
		m.removeduser_recode_wrong = make(map[int]struct{})
	}
	for i := range ids {
		m.removeduser_recode_wrong[ids[i]] = struct{}{}
	}
}

// RemovedUserRecodeWrong returns the removed IDs of the "user_recode_wrong" edge to the TkUserWrongQuestionRecode entity.
func (m *TkQuestionMutation) RemovedUserRecodeWrongIDs() (ids []int) {
	for id := range m.removeduser_recode_wrong {
		ids = append(ids, id)
	}
	return
}

// UserRecodeWrongIDs returns the "user_recode_wrong" edge IDs in the mutation.
func (m *TkQuestionMutation) UserRecodeWrongIDs() (ids []int) {
	for id := range m.user_recode_wrong {
		ids = append(ids, id)
	}
	return
}

// ResetUserRecodeWrong resets all changes to the "user_recode_wrong" edge.
func (m *TkQuestionMutation) ResetUserRecodeWrong() {
	m.user_recode_wrong = nil
	m.cleareduser_recode_wrong = false
	m.removeduser_recode_wrong = nil
}

// SetParentID sets the "parent" edge to the TkQuestion entity by id.
func (m *TkQuestionMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the TkQuestion entity.
func (m *TkQuestionMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the TkQuestion entity was cleared.
func (m *TkQuestionMutation) ParentCleared() bool {
	return m.PidCleared() || m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *TkQuestionMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *TkQuestionMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *TkQuestionMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the TkQuestion entity by ids.
func (m *TkQuestionMutation) AddChildIDs(ids ...int) {
	if m.children == nil {
		m.children = make(map[int]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the TkQuestion entity.
func (m *TkQuestionMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the TkQuestion entity was cleared.
func (m *TkQuestionMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the TkQuestion entity by IDs.
func (m *TkQuestionMutation) RemoveChildIDs(ids ...int) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int]struct{})
	}
	for i := range ids {
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the TkQuestion entity.
func (m *TkQuestionMutation) RemovedChildrenIDs() (ids []int) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *TkQuestionMutation) ChildrenIDs() (ids []int) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *TkQuestionMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddCollectionQuestionIDs adds the "collection_question" edge to the Collection entity by ids.
func (m *TkQuestionMutation) AddCollectionQuestionIDs(ids ...int) {
	if m.collection_question == nil {
		m.collection_question = make(map[int]struct{})
	}
	for i := range ids {
		m.collection_question[ids[i]] = struct{}{}
	}
}

// ClearCollectionQuestion clears the "collection_question" edge to the Collection entity.
func (m *TkQuestionMutation) ClearCollectionQuestion() {
	m.clearedcollection_question = true
}

// CollectionQuestionCleared reports if the "collection_question" edge to the Collection entity was cleared.
func (m *TkQuestionMutation) CollectionQuestionCleared() bool {
	return m.clearedcollection_question
}

// RemoveCollectionQuestionIDs removes the "collection_question" edge to the Collection entity by IDs.
func (m *TkQuestionMutation) RemoveCollectionQuestionIDs(ids ...int) {
	if m.removedcollection_question == nil {
		m.removedcollection_question = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcollection_question[ids[i]] = struct{}{}
	}
}

// RemovedCollectionQuestion returns the removed IDs of the "collection_question" edge to the Collection entity.
func (m *TkQuestionMutation) RemovedCollectionQuestionIDs() (ids []int) {
	for id := range m.removedcollection_question {
		ids = append(ids, id)
	}
	return
}

// CollectionQuestionIDs returns the "collection_question" edge IDs in the mutation.
func (m *TkQuestionMutation) CollectionQuestionIDs() (ids []int) {
	for id := range m.collection_question {
		ids = append(ids, id)
	}
	return
}

// ResetCollectionQuestion resets all changes to the "collection_question" edge.
func (m *TkQuestionMutation) ResetCollectionQuestion() {
	m.collection_question = nil
	m.clearedcollection_question = false
	m.removedcollection_question = nil
}

// Op returns the operation name.
func (m *TkQuestionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TkQuestion).
func (m *TkQuestionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TkQuestionMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.uuid != nil {
		fields = append(fields, tkquestion.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, tkquestion.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tkquestion.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, tkquestion.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, tkquestion.FieldName)
	}
	if m.difficulty != nil {
		fields = append(fields, tkquestion.FieldDifficulty)
	}
	if m._type != nil {
		fields = append(fields, tkquestion.FieldType)
	}
	if m.desc != nil {
		fields = append(fields, tkquestion.FieldDesc)
	}
	if m.admin != nil {
		fields = append(fields, tkquestion.FieldCreatedAdminID)
	}
	if m.question_bank != nil {
		fields = append(fields, tkquestion.FieldQuestionBankID)
	}
	if m.answer_count != nil {
		fields = append(fields, tkquestion.FieldAnswerCount)
	}
	if m.right_count != nil {
		fields = append(fields, tkquestion.FieldRightCount)
	}
	if m.parent != nil {
		fields = append(fields, tkquestion.FieldPid)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TkQuestionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tkquestion.FieldUUID:
		return m.UUID()
	case tkquestion.FieldCreatedAt:
		return m.CreatedAt()
	case tkquestion.FieldUpdatedAt:
		return m.UpdatedAt()
	case tkquestion.FieldDeletedAt:
		return m.DeletedAt()
	case tkquestion.FieldName:
		return m.Name()
	case tkquestion.FieldDifficulty:
		return m.Difficulty()
	case tkquestion.FieldType:
		return m.GetType()
	case tkquestion.FieldDesc:
		return m.Desc()
	case tkquestion.FieldCreatedAdminID:
		return m.CreatedAdminID()
	case tkquestion.FieldQuestionBankID:
		return m.QuestionBankID()
	case tkquestion.FieldAnswerCount:
		return m.AnswerCount()
	case tkquestion.FieldRightCount:
		return m.RightCount()
	case tkquestion.FieldPid:
		return m.Pid()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TkQuestionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tkquestion.FieldUUID:
		return m.OldUUID(ctx)
	case tkquestion.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tkquestion.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tkquestion.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case tkquestion.FieldName:
		return m.OldName(ctx)
	case tkquestion.FieldDifficulty:
		return m.OldDifficulty(ctx)
	case tkquestion.FieldType:
		return m.OldType(ctx)
	case tkquestion.FieldDesc:
		return m.OldDesc(ctx)
	case tkquestion.FieldCreatedAdminID:
		return m.OldCreatedAdminID(ctx)
	case tkquestion.FieldQuestionBankID:
		return m.OldQuestionBankID(ctx)
	case tkquestion.FieldAnswerCount:
		return m.OldAnswerCount(ctx)
	case tkquestion.FieldRightCount:
		return m.OldRightCount(ctx)
	case tkquestion.FieldPid:
		return m.OldPid(ctx)
	}
	return nil, fmt.Errorf("unknown TkQuestion field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TkQuestionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tkquestion.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case tkquestion.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tkquestion.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tkquestion.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case tkquestion.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tkquestion.FieldDifficulty:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDifficulty(v)
		return nil
	case tkquestion.FieldType:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case tkquestion.FieldDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	case tkquestion.FieldCreatedAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAdminID(v)
		return nil
	case tkquestion.FieldQuestionBankID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuestionBankID(v)
		return nil
	case tkquestion.FieldAnswerCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnswerCount(v)
		return nil
	case tkquestion.FieldRightCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRightCount(v)
		return nil
	case tkquestion.FieldPid:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPid(v)
		return nil
	}
	return fmt.Errorf("unknown TkQuestion field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TkQuestionMutation) AddedFields() []string {
	var fields []string
	if m.adddifficulty != nil {
		fields = append(fields, tkquestion.FieldDifficulty)
	}
	if m.add_type != nil {
		fields = append(fields, tkquestion.FieldType)
	}
	if m.addanswer_count != nil {
		fields = append(fields, tkquestion.FieldAnswerCount)
	}
	if m.addright_count != nil {
		fields = append(fields, tkquestion.FieldRightCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TkQuestionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tkquestion.FieldDifficulty:
		return m.AddedDifficulty()
	case tkquestion.FieldType:
		return m.AddedType()
	case tkquestion.FieldAnswerCount:
		return m.AddedAnswerCount()
	case tkquestion.FieldRightCount:
		return m.AddedRightCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TkQuestionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tkquestion.FieldDifficulty:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDifficulty(v)
		return nil
	case tkquestion.FieldType:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case tkquestion.FieldAnswerCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAnswerCount(v)
		return nil
	case tkquestion.FieldRightCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRightCount(v)
		return nil
	}
	return fmt.Errorf("unknown TkQuestion numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TkQuestionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tkquestion.FieldCreatedAt) {
		fields = append(fields, tkquestion.FieldCreatedAt)
	}
	if m.FieldCleared(tkquestion.FieldUpdatedAt) {
		fields = append(fields, tkquestion.FieldUpdatedAt)
	}
	if m.FieldCleared(tkquestion.FieldDeletedAt) {
		fields = append(fields, tkquestion.FieldDeletedAt)
	}
	if m.FieldCleared(tkquestion.FieldName) {
		fields = append(fields, tkquestion.FieldName)
	}
	if m.FieldCleared(tkquestion.FieldDesc) {
		fields = append(fields, tkquestion.FieldDesc)
	}
	if m.FieldCleared(tkquestion.FieldCreatedAdminID) {
		fields = append(fields, tkquestion.FieldCreatedAdminID)
	}
	if m.FieldCleared(tkquestion.FieldQuestionBankID) {
		fields = append(fields, tkquestion.FieldQuestionBankID)
	}
	if m.FieldCleared(tkquestion.FieldPid) {
		fields = append(fields, tkquestion.FieldPid)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TkQuestionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TkQuestionMutation) ClearField(name string) error {
	switch name {
	case tkquestion.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case tkquestion.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case tkquestion.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case tkquestion.FieldName:
		m.ClearName()
		return nil
	case tkquestion.FieldDesc:
		m.ClearDesc()
		return nil
	case tkquestion.FieldCreatedAdminID:
		m.ClearCreatedAdminID()
		return nil
	case tkquestion.FieldQuestionBankID:
		m.ClearQuestionBankID()
		return nil
	case tkquestion.FieldPid:
		m.ClearPid()
		return nil
	}
	return fmt.Errorf("unknown TkQuestion nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TkQuestionMutation) ResetField(name string) error {
	switch name {
	case tkquestion.FieldUUID:
		m.ResetUUID()
		return nil
	case tkquestion.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tkquestion.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tkquestion.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case tkquestion.FieldName:
		m.ResetName()
		return nil
	case tkquestion.FieldDifficulty:
		m.ResetDifficulty()
		return nil
	case tkquestion.FieldType:
		m.ResetType()
		return nil
	case tkquestion.FieldDesc:
		m.ResetDesc()
		return nil
	case tkquestion.FieldCreatedAdminID:
		m.ResetCreatedAdminID()
		return nil
	case tkquestion.FieldQuestionBankID:
		m.ResetQuestionBankID()
		return nil
	case tkquestion.FieldAnswerCount:
		m.ResetAnswerCount()
		return nil
	case tkquestion.FieldRightCount:
		m.ResetRightCount()
		return nil
	case tkquestion.FieldPid:
		m.ResetPid()
		return nil
	}
	return fmt.Errorf("unknown TkQuestion field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TkQuestionMutation) AddedEdges() []string {
	edges := make([]string, 0, 15)
	if m.question_bank != nil {
		edges = append(edges, tkquestion.EdgeQuestionBank)
	}
	if m.admin != nil {
		edges = append(edges, tkquestion.EdgeAdmin)
	}
	if m.user_rand_dom != nil {
		edges = append(edges, tkquestion.EdgeUserRandDom)
	}
	if m.answer_options != nil {
		edges = append(edges, tkquestion.EdgeAnswerOptions)
	}
	if m.knowledge_points != nil {
		edges = append(edges, tkquestion.EdgeKnowledgePoints)
	}
	if m.question_section_links != nil {
		edges = append(edges, tkquestion.EdgeQuestionSectionLinks)
	}
	if m.exam_partition_questions != nil {
		edges = append(edges, tkquestion.EdgeExamPartitionQuestions)
	}
	if m.question_error_feedbacks != nil {
		edges = append(edges, tkquestion.EdgeQuestionErrorFeedbacks)
	}
	if m.user_records != nil {
		edges = append(edges, tkquestion.EdgeUserRecords)
	}
	if m.small_category_questions != nil {
		edges = append(edges, tkquestion.EdgeSmallCategoryQuestions)
	}
	if m.user_exam_questions != nil {
		edges = append(edges, tkquestion.EdgeUserExamQuestions)
	}
	if m.user_recode_wrong != nil {
		edges = append(edges, tkquestion.EdgeUserRecodeWrong)
	}
	if m.parent != nil {
		edges = append(edges, tkquestion.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, tkquestion.EdgeChildren)
	}
	if m.collection_question != nil {
		edges = append(edges, tkquestion.EdgeCollectionQuestion)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TkQuestionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tkquestion.EdgeQuestionBank:
		if id := m.question_bank; id != nil {
			return []ent.Value{*id}
		}
	case tkquestion.EdgeAdmin:
		if id := m.admin; id != nil {
			return []ent.Value{*id}
		}
	case tkquestion.EdgeUserRandDom:
		ids := make([]ent.Value, 0, len(m.user_rand_dom))
		for id := range m.user_rand_dom {
			ids = append(ids, id)
		}
		return ids
	case tkquestion.EdgeAnswerOptions:
		ids := make([]ent.Value, 0, len(m.answer_options))
		for id := range m.answer_options {
			ids = append(ids, id)
		}
		return ids
	case tkquestion.EdgeKnowledgePoints:
		ids := make([]ent.Value, 0, len(m.knowledge_points))
		for id := range m.knowledge_points {
			ids = append(ids, id)
		}
		return ids
	case tkquestion.EdgeQuestionSectionLinks:
		ids := make([]ent.Value, 0, len(m.question_section_links))
		for id := range m.question_section_links {
			ids = append(ids, id)
		}
		return ids
	case tkquestion.EdgeExamPartitionQuestions:
		ids := make([]ent.Value, 0, len(m.exam_partition_questions))
		for id := range m.exam_partition_questions {
			ids = append(ids, id)
		}
		return ids
	case tkquestion.EdgeQuestionErrorFeedbacks:
		ids := make([]ent.Value, 0, len(m.question_error_feedbacks))
		for id := range m.question_error_feedbacks {
			ids = append(ids, id)
		}
		return ids
	case tkquestion.EdgeUserRecords:
		ids := make([]ent.Value, 0, len(m.user_records))
		for id := range m.user_records {
			ids = append(ids, id)
		}
		return ids
	case tkquestion.EdgeSmallCategoryQuestions:
		ids := make([]ent.Value, 0, len(m.small_category_questions))
		for id := range m.small_category_questions {
			ids = append(ids, id)
		}
		return ids
	case tkquestion.EdgeUserExamQuestions:
		ids := make([]ent.Value, 0, len(m.user_exam_questions))
		for id := range m.user_exam_questions {
			ids = append(ids, id)
		}
		return ids
	case tkquestion.EdgeUserRecodeWrong:
		ids := make([]ent.Value, 0, len(m.user_recode_wrong))
		for id := range m.user_recode_wrong {
			ids = append(ids, id)
		}
		return ids
	case tkquestion.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case tkquestion.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case tkquestion.EdgeCollectionQuestion:
		ids := make([]ent.Value, 0, len(m.collection_question))
		for id := range m.collection_question {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TkQuestionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 15)
	if m.removeduser_rand_dom != nil {
		edges = append(edges, tkquestion.EdgeUserRandDom)
	}
	if m.removedanswer_options != nil {
		edges = append(edges, tkquestion.EdgeAnswerOptions)
	}
	if m.removedknowledge_points != nil {
		edges = append(edges, tkquestion.EdgeKnowledgePoints)
	}
	if m.removedquestion_section_links != nil {
		edges = append(edges, tkquestion.EdgeQuestionSectionLinks)
	}
	if m.removedexam_partition_questions != nil {
		edges = append(edges, tkquestion.EdgeExamPartitionQuestions)
	}
	if m.removedquestion_error_feedbacks != nil {
		edges = append(edges, tkquestion.EdgeQuestionErrorFeedbacks)
	}
	if m.removeduser_records != nil {
		edges = append(edges, tkquestion.EdgeUserRecords)
	}
	if m.removedsmall_category_questions != nil {
		edges = append(edges, tkquestion.EdgeSmallCategoryQuestions)
	}
	if m.removeduser_exam_questions != nil {
		edges = append(edges, tkquestion.EdgeUserExamQuestions)
	}
	if m.removeduser_recode_wrong != nil {
		edges = append(edges, tkquestion.EdgeUserRecodeWrong)
	}
	if m.removedchildren != nil {
		edges = append(edges, tkquestion.EdgeChildren)
	}
	if m.removedcollection_question != nil {
		edges = append(edges, tkquestion.EdgeCollectionQuestion)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TkQuestionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tkquestion.EdgeUserRandDom:
		ids := make([]ent.Value, 0, len(m.removeduser_rand_dom))
		for id := range m.removeduser_rand_dom {
			ids = append(ids, id)
		}
		return ids
	case tkquestion.EdgeAnswerOptions:
		ids := make([]ent.Value, 0, len(m.removedanswer_options))
		for id := range m.removedanswer_options {
			ids = append(ids, id)
		}
		return ids
	case tkquestion.EdgeKnowledgePoints:
		ids := make([]ent.Value, 0, len(m.removedknowledge_points))
		for id := range m.removedknowledge_points {
			ids = append(ids, id)
		}
		return ids
	case tkquestion.EdgeQuestionSectionLinks:
		ids := make([]ent.Value, 0, len(m.removedquestion_section_links))
		for id := range m.removedquestion_section_links {
			ids = append(ids, id)
		}
		return ids
	case tkquestion.EdgeExamPartitionQuestions:
		ids := make([]ent.Value, 0, len(m.removedexam_partition_questions))
		for id := range m.removedexam_partition_questions {
			ids = append(ids, id)
		}
		return ids
	case tkquestion.EdgeQuestionErrorFeedbacks:
		ids := make([]ent.Value, 0, len(m.removedquestion_error_feedbacks))
		for id := range m.removedquestion_error_feedbacks {
			ids = append(ids, id)
		}
		return ids
	case tkquestion.EdgeUserRecords:
		ids := make([]ent.Value, 0, len(m.removeduser_records))
		for id := range m.removeduser_records {
			ids = append(ids, id)
		}
		return ids
	case tkquestion.EdgeSmallCategoryQuestions:
		ids := make([]ent.Value, 0, len(m.removedsmall_category_questions))
		for id := range m.removedsmall_category_questions {
			ids = append(ids, id)
		}
		return ids
	case tkquestion.EdgeUserExamQuestions:
		ids := make([]ent.Value, 0, len(m.removeduser_exam_questions))
		for id := range m.removeduser_exam_questions {
			ids = append(ids, id)
		}
		return ids
	case tkquestion.EdgeUserRecodeWrong:
		ids := make([]ent.Value, 0, len(m.removeduser_recode_wrong))
		for id := range m.removeduser_recode_wrong {
			ids = append(ids, id)
		}
		return ids
	case tkquestion.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case tkquestion.EdgeCollectionQuestion:
		ids := make([]ent.Value, 0, len(m.removedcollection_question))
		for id := range m.removedcollection_question {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TkQuestionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 15)
	if m.clearedquestion_bank {
		edges = append(edges, tkquestion.EdgeQuestionBank)
	}
	if m.clearedadmin {
		edges = append(edges, tkquestion.EdgeAdmin)
	}
	if m.cleareduser_rand_dom {
		edges = append(edges, tkquestion.EdgeUserRandDom)
	}
	if m.clearedanswer_options {
		edges = append(edges, tkquestion.EdgeAnswerOptions)
	}
	if m.clearedknowledge_points {
		edges = append(edges, tkquestion.EdgeKnowledgePoints)
	}
	if m.clearedquestion_section_links {
		edges = append(edges, tkquestion.EdgeQuestionSectionLinks)
	}
	if m.clearedexam_partition_questions {
		edges = append(edges, tkquestion.EdgeExamPartitionQuestions)
	}
	if m.clearedquestion_error_feedbacks {
		edges = append(edges, tkquestion.EdgeQuestionErrorFeedbacks)
	}
	if m.cleareduser_records {
		edges = append(edges, tkquestion.EdgeUserRecords)
	}
	if m.clearedsmall_category_questions {
		edges = append(edges, tkquestion.EdgeSmallCategoryQuestions)
	}
	if m.cleareduser_exam_questions {
		edges = append(edges, tkquestion.EdgeUserExamQuestions)
	}
	if m.cleareduser_recode_wrong {
		edges = append(edges, tkquestion.EdgeUserRecodeWrong)
	}
	if m.clearedparent {
		edges = append(edges, tkquestion.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, tkquestion.EdgeChildren)
	}
	if m.clearedcollection_question {
		edges = append(edges, tkquestion.EdgeCollectionQuestion)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TkQuestionMutation) EdgeCleared(name string) bool {
	switch name {
	case tkquestion.EdgeQuestionBank:
		return m.clearedquestion_bank
	case tkquestion.EdgeAdmin:
		return m.clearedadmin
	case tkquestion.EdgeUserRandDom:
		return m.cleareduser_rand_dom
	case tkquestion.EdgeAnswerOptions:
		return m.clearedanswer_options
	case tkquestion.EdgeKnowledgePoints:
		return m.clearedknowledge_points
	case tkquestion.EdgeQuestionSectionLinks:
		return m.clearedquestion_section_links
	case tkquestion.EdgeExamPartitionQuestions:
		return m.clearedexam_partition_questions
	case tkquestion.EdgeQuestionErrorFeedbacks:
		return m.clearedquestion_error_feedbacks
	case tkquestion.EdgeUserRecords:
		return m.cleareduser_records
	case tkquestion.EdgeSmallCategoryQuestions:
		return m.clearedsmall_category_questions
	case tkquestion.EdgeUserExamQuestions:
		return m.cleareduser_exam_questions
	case tkquestion.EdgeUserRecodeWrong:
		return m.cleareduser_recode_wrong
	case tkquestion.EdgeParent:
		return m.clearedparent
	case tkquestion.EdgeChildren:
		return m.clearedchildren
	case tkquestion.EdgeCollectionQuestion:
		return m.clearedcollection_question
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TkQuestionMutation) ClearEdge(name string) error {
	switch name {
	case tkquestion.EdgeQuestionBank:
		m.ClearQuestionBank()
		return nil
	case tkquestion.EdgeAdmin:
		m.ClearAdmin()
		return nil
	case tkquestion.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown TkQuestion unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TkQuestionMutation) ResetEdge(name string) error {
	switch name {
	case tkquestion.EdgeQuestionBank:
		m.ResetQuestionBank()
		return nil
	case tkquestion.EdgeAdmin:
		m.ResetAdmin()
		return nil
	case tkquestion.EdgeUserRandDom:
		m.ResetUserRandDom()
		return nil
	case tkquestion.EdgeAnswerOptions:
		m.ResetAnswerOptions()
		return nil
	case tkquestion.EdgeKnowledgePoints:
		m.ResetKnowledgePoints()
		return nil
	case tkquestion.EdgeQuestionSectionLinks:
		m.ResetQuestionSectionLinks()
		return nil
	case tkquestion.EdgeExamPartitionQuestions:
		m.ResetExamPartitionQuestions()
		return nil
	case tkquestion.EdgeQuestionErrorFeedbacks:
		m.ResetQuestionErrorFeedbacks()
		return nil
	case tkquestion.EdgeUserRecords:
		m.ResetUserRecords()
		return nil
	case tkquestion.EdgeSmallCategoryQuestions:
		m.ResetSmallCategoryQuestions()
		return nil
	case tkquestion.EdgeUserExamQuestions:
		m.ResetUserExamQuestions()
		return nil
	case tkquestion.EdgeUserRecodeWrong:
		m.ResetUserRecodeWrong()
		return nil
	case tkquestion.EdgeParent:
		m.ResetParent()
		return nil
	case tkquestion.EdgeChildren:
		m.ResetChildren()
		return nil
	case tkquestion.EdgeCollectionQuestion:
		m.ResetCollectionQuestion()
		return nil
	}
	return fmt.Errorf("unknown TkQuestion edge %s", name)
}

// TkQuestionAnswerOptionMutation represents an operation that mutates the TkQuestionAnswerOption nodes in the graph.
type TkQuestionAnswerOptionMutation struct {
	config
	op              Op
	typ             string
	id              *int
	uuid            *string
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *time.Time
	option_name     *string
	content         *string
	is_right        *uint8
	addis_right     *uint8
	clearedFields   map[string]struct{}
	question        *int
	clearedquestion bool
	done            bool
	oldValue        func(context.Context) (*TkQuestionAnswerOption, error)
	predicates      []predicate.TkQuestionAnswerOption
}

var _ ent.Mutation = (*TkQuestionAnswerOptionMutation)(nil)

// tkquestionansweroptionOption allows management of the mutation configuration using functional options.
type tkquestionansweroptionOption func(*TkQuestionAnswerOptionMutation)

// newTkQuestionAnswerOptionMutation creates new mutation for the TkQuestionAnswerOption entity.
func newTkQuestionAnswerOptionMutation(c config, op Op, opts ...tkquestionansweroptionOption) *TkQuestionAnswerOptionMutation {
	m := &TkQuestionAnswerOptionMutation{
		config:        c,
		op:            op,
		typ:           TypeTkQuestionAnswerOption,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTkQuestionAnswerOptionID sets the ID field of the mutation.
func withTkQuestionAnswerOptionID(id int) tkquestionansweroptionOption {
	return func(m *TkQuestionAnswerOptionMutation) {
		var (
			err   error
			once  sync.Once
			value *TkQuestionAnswerOption
		)
		m.oldValue = func(ctx context.Context) (*TkQuestionAnswerOption, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TkQuestionAnswerOption.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTkQuestionAnswerOption sets the old TkQuestionAnswerOption of the mutation.
func withTkQuestionAnswerOption(node *TkQuestionAnswerOption) tkquestionansweroptionOption {
	return func(m *TkQuestionAnswerOptionMutation) {
		m.oldValue = func(context.Context) (*TkQuestionAnswerOption, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TkQuestionAnswerOptionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TkQuestionAnswerOptionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *TkQuestionAnswerOptionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *TkQuestionAnswerOptionMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *TkQuestionAnswerOptionMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the TkQuestionAnswerOption entity.
// If the TkQuestionAnswerOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkQuestionAnswerOptionMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *TkQuestionAnswerOptionMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TkQuestionAnswerOptionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TkQuestionAnswerOptionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TkQuestionAnswerOption entity.
// If the TkQuestionAnswerOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkQuestionAnswerOptionMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *TkQuestionAnswerOptionMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[tkquestionansweroption.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *TkQuestionAnswerOptionMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[tkquestionansweroption.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TkQuestionAnswerOptionMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, tkquestionansweroption.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TkQuestionAnswerOptionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TkQuestionAnswerOptionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TkQuestionAnswerOption entity.
// If the TkQuestionAnswerOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkQuestionAnswerOptionMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TkQuestionAnswerOptionMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[tkquestionansweroption.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TkQuestionAnswerOptionMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[tkquestionansweroption.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TkQuestionAnswerOptionMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, tkquestionansweroption.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TkQuestionAnswerOptionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TkQuestionAnswerOptionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TkQuestionAnswerOption entity.
// If the TkQuestionAnswerOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkQuestionAnswerOptionMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TkQuestionAnswerOptionMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[tkquestionansweroption.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TkQuestionAnswerOptionMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[tkquestionansweroption.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TkQuestionAnswerOptionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, tkquestionansweroption.FieldDeletedAt)
}

// SetOptionName sets the "option_name" field.
func (m *TkQuestionAnswerOptionMutation) SetOptionName(s string) {
	m.option_name = &s
}

// OptionName returns the value of the "option_name" field in the mutation.
func (m *TkQuestionAnswerOptionMutation) OptionName() (r string, exists bool) {
	v := m.option_name
	if v == nil {
		return
	}
	return *v, true
}

// OldOptionName returns the old "option_name" field's value of the TkQuestionAnswerOption entity.
// If the TkQuestionAnswerOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkQuestionAnswerOptionMutation) OldOptionName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOptionName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOptionName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOptionName: %w", err)
	}
	return oldValue.OptionName, nil
}

// ResetOptionName resets all changes to the "option_name" field.
func (m *TkQuestionAnswerOptionMutation) ResetOptionName() {
	m.option_name = nil
}

// SetContent sets the "content" field.
func (m *TkQuestionAnswerOptionMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *TkQuestionAnswerOptionMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the TkQuestionAnswerOption entity.
// If the TkQuestionAnswerOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkQuestionAnswerOptionMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *TkQuestionAnswerOptionMutation) ResetContent() {
	m.content = nil
}

// SetIsRight sets the "is_right" field.
func (m *TkQuestionAnswerOptionMutation) SetIsRight(u uint8) {
	m.is_right = &u
	m.addis_right = nil
}

// IsRight returns the value of the "is_right" field in the mutation.
func (m *TkQuestionAnswerOptionMutation) IsRight() (r uint8, exists bool) {
	v := m.is_right
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRight returns the old "is_right" field's value of the TkQuestionAnswerOption entity.
// If the TkQuestionAnswerOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkQuestionAnswerOptionMutation) OldIsRight(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsRight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsRight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRight: %w", err)
	}
	return oldValue.IsRight, nil
}

// AddIsRight adds u to the "is_right" field.
func (m *TkQuestionAnswerOptionMutation) AddIsRight(u uint8) {
	if m.addis_right != nil {
		*m.addis_right += u
	} else {
		m.addis_right = &u
	}
}

// AddedIsRight returns the value that was added to the "is_right" field in this mutation.
func (m *TkQuestionAnswerOptionMutation) AddedIsRight() (r uint8, exists bool) {
	v := m.addis_right
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsRight resets all changes to the "is_right" field.
func (m *TkQuestionAnswerOptionMutation) ResetIsRight() {
	m.is_right = nil
	m.addis_right = nil
}

// SetQuestionID sets the "question_id" field.
func (m *TkQuestionAnswerOptionMutation) SetQuestionID(i int) {
	m.question = &i
}

// QuestionID returns the value of the "question_id" field in the mutation.
func (m *TkQuestionAnswerOptionMutation) QuestionID() (r int, exists bool) {
	v := m.question
	if v == nil {
		return
	}
	return *v, true
}

// OldQuestionID returns the old "question_id" field's value of the TkQuestionAnswerOption entity.
// If the TkQuestionAnswerOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkQuestionAnswerOptionMutation) OldQuestionID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldQuestionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldQuestionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuestionID: %w", err)
	}
	return oldValue.QuestionID, nil
}

// ClearQuestionID clears the value of the "question_id" field.
func (m *TkQuestionAnswerOptionMutation) ClearQuestionID() {
	m.question = nil
	m.clearedFields[tkquestionansweroption.FieldQuestionID] = struct{}{}
}

// QuestionIDCleared returns if the "question_id" field was cleared in this mutation.
func (m *TkQuestionAnswerOptionMutation) QuestionIDCleared() bool {
	_, ok := m.clearedFields[tkquestionansweroption.FieldQuestionID]
	return ok
}

// ResetQuestionID resets all changes to the "question_id" field.
func (m *TkQuestionAnswerOptionMutation) ResetQuestionID() {
	m.question = nil
	delete(m.clearedFields, tkquestionansweroption.FieldQuestionID)
}

// ClearQuestion clears the "question" edge to the TkQuestion entity.
func (m *TkQuestionAnswerOptionMutation) ClearQuestion() {
	m.clearedquestion = true
}

// QuestionCleared reports if the "question" edge to the TkQuestion entity was cleared.
func (m *TkQuestionAnswerOptionMutation) QuestionCleared() bool {
	return m.QuestionIDCleared() || m.clearedquestion
}

// QuestionIDs returns the "question" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// QuestionID instead. It exists only for internal usage by the builders.
func (m *TkQuestionAnswerOptionMutation) QuestionIDs() (ids []int) {
	if id := m.question; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetQuestion resets all changes to the "question" edge.
func (m *TkQuestionAnswerOptionMutation) ResetQuestion() {
	m.question = nil
	m.clearedquestion = false
}

// Op returns the operation name.
func (m *TkQuestionAnswerOptionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TkQuestionAnswerOption).
func (m *TkQuestionAnswerOptionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TkQuestionAnswerOptionMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.uuid != nil {
		fields = append(fields, tkquestionansweroption.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, tkquestionansweroption.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tkquestionansweroption.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, tkquestionansweroption.FieldDeletedAt)
	}
	if m.option_name != nil {
		fields = append(fields, tkquestionansweroption.FieldOptionName)
	}
	if m.content != nil {
		fields = append(fields, tkquestionansweroption.FieldContent)
	}
	if m.is_right != nil {
		fields = append(fields, tkquestionansweroption.FieldIsRight)
	}
	if m.question != nil {
		fields = append(fields, tkquestionansweroption.FieldQuestionID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TkQuestionAnswerOptionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tkquestionansweroption.FieldUUID:
		return m.UUID()
	case tkquestionansweroption.FieldCreatedAt:
		return m.CreatedAt()
	case tkquestionansweroption.FieldUpdatedAt:
		return m.UpdatedAt()
	case tkquestionansweroption.FieldDeletedAt:
		return m.DeletedAt()
	case tkquestionansweroption.FieldOptionName:
		return m.OptionName()
	case tkquestionansweroption.FieldContent:
		return m.Content()
	case tkquestionansweroption.FieldIsRight:
		return m.IsRight()
	case tkquestionansweroption.FieldQuestionID:
		return m.QuestionID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TkQuestionAnswerOptionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tkquestionansweroption.FieldUUID:
		return m.OldUUID(ctx)
	case tkquestionansweroption.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tkquestionansweroption.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tkquestionansweroption.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case tkquestionansweroption.FieldOptionName:
		return m.OldOptionName(ctx)
	case tkquestionansweroption.FieldContent:
		return m.OldContent(ctx)
	case tkquestionansweroption.FieldIsRight:
		return m.OldIsRight(ctx)
	case tkquestionansweroption.FieldQuestionID:
		return m.OldQuestionID(ctx)
	}
	return nil, fmt.Errorf("unknown TkQuestionAnswerOption field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TkQuestionAnswerOptionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tkquestionansweroption.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case tkquestionansweroption.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tkquestionansweroption.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tkquestionansweroption.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case tkquestionansweroption.FieldOptionName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOptionName(v)
		return nil
	case tkquestionansweroption.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case tkquestionansweroption.FieldIsRight:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRight(v)
		return nil
	case tkquestionansweroption.FieldQuestionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuestionID(v)
		return nil
	}
	return fmt.Errorf("unknown TkQuestionAnswerOption field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TkQuestionAnswerOptionMutation) AddedFields() []string {
	var fields []string
	if m.addis_right != nil {
		fields = append(fields, tkquestionansweroption.FieldIsRight)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TkQuestionAnswerOptionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tkquestionansweroption.FieldIsRight:
		return m.AddedIsRight()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TkQuestionAnswerOptionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tkquestionansweroption.FieldIsRight:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsRight(v)
		return nil
	}
	return fmt.Errorf("unknown TkQuestionAnswerOption numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TkQuestionAnswerOptionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tkquestionansweroption.FieldCreatedAt) {
		fields = append(fields, tkquestionansweroption.FieldCreatedAt)
	}
	if m.FieldCleared(tkquestionansweroption.FieldUpdatedAt) {
		fields = append(fields, tkquestionansweroption.FieldUpdatedAt)
	}
	if m.FieldCleared(tkquestionansweroption.FieldDeletedAt) {
		fields = append(fields, tkquestionansweroption.FieldDeletedAt)
	}
	if m.FieldCleared(tkquestionansweroption.FieldQuestionID) {
		fields = append(fields, tkquestionansweroption.FieldQuestionID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TkQuestionAnswerOptionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TkQuestionAnswerOptionMutation) ClearField(name string) error {
	switch name {
	case tkquestionansweroption.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case tkquestionansweroption.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case tkquestionansweroption.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case tkquestionansweroption.FieldQuestionID:
		m.ClearQuestionID()
		return nil
	}
	return fmt.Errorf("unknown TkQuestionAnswerOption nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TkQuestionAnswerOptionMutation) ResetField(name string) error {
	switch name {
	case tkquestionansweroption.FieldUUID:
		m.ResetUUID()
		return nil
	case tkquestionansweroption.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tkquestionansweroption.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tkquestionansweroption.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case tkquestionansweroption.FieldOptionName:
		m.ResetOptionName()
		return nil
	case tkquestionansweroption.FieldContent:
		m.ResetContent()
		return nil
	case tkquestionansweroption.FieldIsRight:
		m.ResetIsRight()
		return nil
	case tkquestionansweroption.FieldQuestionID:
		m.ResetQuestionID()
		return nil
	}
	return fmt.Errorf("unknown TkQuestionAnswerOption field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TkQuestionAnswerOptionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.question != nil {
		edges = append(edges, tkquestionansweroption.EdgeQuestion)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TkQuestionAnswerOptionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tkquestionansweroption.EdgeQuestion:
		if id := m.question; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TkQuestionAnswerOptionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TkQuestionAnswerOptionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TkQuestionAnswerOptionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedquestion {
		edges = append(edges, tkquestionansweroption.EdgeQuestion)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TkQuestionAnswerOptionMutation) EdgeCleared(name string) bool {
	switch name {
	case tkquestionansweroption.EdgeQuestion:
		return m.clearedquestion
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TkQuestionAnswerOptionMutation) ClearEdge(name string) error {
	switch name {
	case tkquestionansweroption.EdgeQuestion:
		m.ClearQuestion()
		return nil
	}
	return fmt.Errorf("unknown TkQuestionAnswerOption unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TkQuestionAnswerOptionMutation) ResetEdge(name string) error {
	switch name {
	case tkquestionansweroption.EdgeQuestion:
		m.ResetQuestion()
		return nil
	}
	return fmt.Errorf("unknown TkQuestionAnswerOption edge %s", name)
}

// TkQuestionBankMutation represents an operation that mutates the TkQuestionBank nodes in the graph.
type TkQuestionBankMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	uuid                         *string
	created_at                   *time.Time
	updated_at                   *time.Time
	deleted_at                   *time.Time
	name                         *string
	status                       *uint8
	addstatus                    *uint8
	question_count               *int
	addquestion_count            *int
	clearedFields                map[string]struct{}
	item_category                *int
	cleareditem_category         bool
	admin                        *int
	clearedadmin                 bool
	question_chapters            map[int]struct{}
	removedquestion_chapters     map[int]struct{}
	clearedquestion_chapters     bool
	question_bank_courses        map[int]struct{}
	removedquestion_bank_courses map[int]struct{}
	clearedquestion_bank_courses bool
	questions                    map[int]struct{}
	removedquestions             map[int]struct{}
	clearedquestions             bool
	exam_papers                  map[int]struct{}
	removedexam_papers           map[int]struct{}
	clearedexam_papers           bool
	exam_question_types          map[int]struct{}
	removedexam_question_types   map[int]struct{}
	clearedexam_question_types   bool
	user_question_bank           map[int]struct{}
	removeduser_question_bank    map[int]struct{}
	cleareduser_question_bank    bool
	user_bank_records            map[int]struct{}
	removeduser_bank_records     map[int]struct{}
	cleareduser_bank_records     bool
	knowledge_points             map[int]struct{}
	removedknowledge_points      map[int]struct{}
	clearedknowledge_points      bool
	done                         bool
	oldValue                     func(context.Context) (*TkQuestionBank, error)
	predicates                   []predicate.TkQuestionBank
}

var _ ent.Mutation = (*TkQuestionBankMutation)(nil)

// tkquestionbankOption allows management of the mutation configuration using functional options.
type tkquestionbankOption func(*TkQuestionBankMutation)

// newTkQuestionBankMutation creates new mutation for the TkQuestionBank entity.
func newTkQuestionBankMutation(c config, op Op, opts ...tkquestionbankOption) *TkQuestionBankMutation {
	m := &TkQuestionBankMutation{
		config:        c,
		op:            op,
		typ:           TypeTkQuestionBank,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTkQuestionBankID sets the ID field of the mutation.
func withTkQuestionBankID(id int) tkquestionbankOption {
	return func(m *TkQuestionBankMutation) {
		var (
			err   error
			once  sync.Once
			value *TkQuestionBank
		)
		m.oldValue = func(ctx context.Context) (*TkQuestionBank, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TkQuestionBank.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTkQuestionBank sets the old TkQuestionBank of the mutation.
func withTkQuestionBank(node *TkQuestionBank) tkquestionbankOption {
	return func(m *TkQuestionBankMutation) {
		m.oldValue = func(context.Context) (*TkQuestionBank, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TkQuestionBankMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TkQuestionBankMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *TkQuestionBankMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *TkQuestionBankMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *TkQuestionBankMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the TkQuestionBank entity.
// If the TkQuestionBank object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkQuestionBankMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *TkQuestionBankMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TkQuestionBankMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TkQuestionBankMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TkQuestionBank entity.
// If the TkQuestionBank object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkQuestionBankMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *TkQuestionBankMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[tkquestionbank.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *TkQuestionBankMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[tkquestionbank.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TkQuestionBankMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, tkquestionbank.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TkQuestionBankMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TkQuestionBankMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TkQuestionBank entity.
// If the TkQuestionBank object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkQuestionBankMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TkQuestionBankMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[tkquestionbank.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TkQuestionBankMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[tkquestionbank.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TkQuestionBankMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, tkquestionbank.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TkQuestionBankMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TkQuestionBankMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TkQuestionBank entity.
// If the TkQuestionBank object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkQuestionBankMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TkQuestionBankMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[tkquestionbank.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TkQuestionBankMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[tkquestionbank.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TkQuestionBankMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, tkquestionbank.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *TkQuestionBankMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TkQuestionBankMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TkQuestionBank entity.
// If the TkQuestionBank object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkQuestionBankMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TkQuestionBankMutation) ResetName() {
	m.name = nil
}

// SetStatus sets the "status" field.
func (m *TkQuestionBankMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *TkQuestionBankMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the TkQuestionBank entity.
// If the TkQuestionBank object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkQuestionBankMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *TkQuestionBankMutation) AddStatus(u uint8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *TkQuestionBankMutation) AddedStatus() (r uint8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *TkQuestionBankMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetQuestionCount sets the "question_count" field.
func (m *TkQuestionBankMutation) SetQuestionCount(i int) {
	m.question_count = &i
	m.addquestion_count = nil
}

// QuestionCount returns the value of the "question_count" field in the mutation.
func (m *TkQuestionBankMutation) QuestionCount() (r int, exists bool) {
	v := m.question_count
	if v == nil {
		return
	}
	return *v, true
}

// OldQuestionCount returns the old "question_count" field's value of the TkQuestionBank entity.
// If the TkQuestionBank object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkQuestionBankMutation) OldQuestionCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldQuestionCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldQuestionCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuestionCount: %w", err)
	}
	return oldValue.QuestionCount, nil
}

// AddQuestionCount adds i to the "question_count" field.
func (m *TkQuestionBankMutation) AddQuestionCount(i int) {
	if m.addquestion_count != nil {
		*m.addquestion_count += i
	} else {
		m.addquestion_count = &i
	}
}

// AddedQuestionCount returns the value that was added to the "question_count" field in this mutation.
func (m *TkQuestionBankMutation) AddedQuestionCount() (r int, exists bool) {
	v := m.addquestion_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuestionCount resets all changes to the "question_count" field.
func (m *TkQuestionBankMutation) ResetQuestionCount() {
	m.question_count = nil
	m.addquestion_count = nil
}

// SetCreatedAdminID sets the "created_admin_id" field.
func (m *TkQuestionBankMutation) SetCreatedAdminID(i int) {
	m.admin = &i
}

// CreatedAdminID returns the value of the "created_admin_id" field in the mutation.
func (m *TkQuestionBankMutation) CreatedAdminID() (r int, exists bool) {
	v := m.admin
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAdminID returns the old "created_admin_id" field's value of the TkQuestionBank entity.
// If the TkQuestionBank object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkQuestionBankMutation) OldCreatedAdminID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAdminID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAdminID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAdminID: %w", err)
	}
	return oldValue.CreatedAdminID, nil
}

// ClearCreatedAdminID clears the value of the "created_admin_id" field.
func (m *TkQuestionBankMutation) ClearCreatedAdminID() {
	m.admin = nil
	m.clearedFields[tkquestionbank.FieldCreatedAdminID] = struct{}{}
}

// CreatedAdminIDCleared returns if the "created_admin_id" field was cleared in this mutation.
func (m *TkQuestionBankMutation) CreatedAdminIDCleared() bool {
	_, ok := m.clearedFields[tkquestionbank.FieldCreatedAdminID]
	return ok
}

// ResetCreatedAdminID resets all changes to the "created_admin_id" field.
func (m *TkQuestionBankMutation) ResetCreatedAdminID() {
	m.admin = nil
	delete(m.clearedFields, tkquestionbank.FieldCreatedAdminID)
}

// SetItemCategoryID sets the "item_category_id" field.
func (m *TkQuestionBankMutation) SetItemCategoryID(i int) {
	m.item_category = &i
}

// ItemCategoryID returns the value of the "item_category_id" field in the mutation.
func (m *TkQuestionBankMutation) ItemCategoryID() (r int, exists bool) {
	v := m.item_category
	if v == nil {
		return
	}
	return *v, true
}

// OldItemCategoryID returns the old "item_category_id" field's value of the TkQuestionBank entity.
// If the TkQuestionBank object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkQuestionBankMutation) OldItemCategoryID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldItemCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldItemCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldItemCategoryID: %w", err)
	}
	return oldValue.ItemCategoryID, nil
}

// ClearItemCategoryID clears the value of the "item_category_id" field.
func (m *TkQuestionBankMutation) ClearItemCategoryID() {
	m.item_category = nil
	m.clearedFields[tkquestionbank.FieldItemCategoryID] = struct{}{}
}

// ItemCategoryIDCleared returns if the "item_category_id" field was cleared in this mutation.
func (m *TkQuestionBankMutation) ItemCategoryIDCleared() bool {
	_, ok := m.clearedFields[tkquestionbank.FieldItemCategoryID]
	return ok
}

// ResetItemCategoryID resets all changes to the "item_category_id" field.
func (m *TkQuestionBankMutation) ResetItemCategoryID() {
	m.item_category = nil
	delete(m.clearedFields, tkquestionbank.FieldItemCategoryID)
}

// ClearItemCategory clears the "item_category" edge to the ItemCategory entity.
func (m *TkQuestionBankMutation) ClearItemCategory() {
	m.cleareditem_category = true
}

// ItemCategoryCleared reports if the "item_category" edge to the ItemCategory entity was cleared.
func (m *TkQuestionBankMutation) ItemCategoryCleared() bool {
	return m.ItemCategoryIDCleared() || m.cleareditem_category
}

// ItemCategoryIDs returns the "item_category" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ItemCategoryID instead. It exists only for internal usage by the builders.
func (m *TkQuestionBankMutation) ItemCategoryIDs() (ids []int) {
	if id := m.item_category; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetItemCategory resets all changes to the "item_category" edge.
func (m *TkQuestionBankMutation) ResetItemCategory() {
	m.item_category = nil
	m.cleareditem_category = false
}

// SetAdminID sets the "admin" edge to the Admin entity by id.
func (m *TkQuestionBankMutation) SetAdminID(id int) {
	m.admin = &id
}

// ClearAdmin clears the "admin" edge to the Admin entity.
func (m *TkQuestionBankMutation) ClearAdmin() {
	m.clearedadmin = true
}

// AdminCleared reports if the "admin" edge to the Admin entity was cleared.
func (m *TkQuestionBankMutation) AdminCleared() bool {
	return m.CreatedAdminIDCleared() || m.clearedadmin
}

// AdminID returns the "admin" edge ID in the mutation.
func (m *TkQuestionBankMutation) AdminID() (id int, exists bool) {
	if m.admin != nil {
		return *m.admin, true
	}
	return
}

// AdminIDs returns the "admin" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AdminID instead. It exists only for internal usage by the builders.
func (m *TkQuestionBankMutation) AdminIDs() (ids []int) {
	if id := m.admin; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAdmin resets all changes to the "admin" edge.
func (m *TkQuestionBankMutation) ResetAdmin() {
	m.admin = nil
	m.clearedadmin = false
}

// AddQuestionChapterIDs adds the "question_chapters" edge to the TkChapter entity by ids.
func (m *TkQuestionBankMutation) AddQuestionChapterIDs(ids ...int) {
	if m.question_chapters == nil {
		m.question_chapters = make(map[int]struct{})
	}
	for i := range ids {
		m.question_chapters[ids[i]] = struct{}{}
	}
}

// ClearQuestionChapters clears the "question_chapters" edge to the TkChapter entity.
func (m *TkQuestionBankMutation) ClearQuestionChapters() {
	m.clearedquestion_chapters = true
}

// QuestionChaptersCleared reports if the "question_chapters" edge to the TkChapter entity was cleared.
func (m *TkQuestionBankMutation) QuestionChaptersCleared() bool {
	return m.clearedquestion_chapters
}

// RemoveQuestionChapterIDs removes the "question_chapters" edge to the TkChapter entity by IDs.
func (m *TkQuestionBankMutation) RemoveQuestionChapterIDs(ids ...int) {
	if m.removedquestion_chapters == nil {
		m.removedquestion_chapters = make(map[int]struct{})
	}
	for i := range ids {
		m.removedquestion_chapters[ids[i]] = struct{}{}
	}
}

// RemovedQuestionChapters returns the removed IDs of the "question_chapters" edge to the TkChapter entity.
func (m *TkQuestionBankMutation) RemovedQuestionChaptersIDs() (ids []int) {
	for id := range m.removedquestion_chapters {
		ids = append(ids, id)
	}
	return
}

// QuestionChaptersIDs returns the "question_chapters" edge IDs in the mutation.
func (m *TkQuestionBankMutation) QuestionChaptersIDs() (ids []int) {
	for id := range m.question_chapters {
		ids = append(ids, id)
	}
	return
}

// ResetQuestionChapters resets all changes to the "question_chapters" edge.
func (m *TkQuestionBankMutation) ResetQuestionChapters() {
	m.question_chapters = nil
	m.clearedquestion_chapters = false
	m.removedquestion_chapters = nil
}

// AddQuestionBankCourseIDs adds the "question_bank_courses" edge to the KcCourse entity by ids.
func (m *TkQuestionBankMutation) AddQuestionBankCourseIDs(ids ...int) {
	if m.question_bank_courses == nil {
		m.question_bank_courses = make(map[int]struct{})
	}
	for i := range ids {
		m.question_bank_courses[ids[i]] = struct{}{}
	}
}

// ClearQuestionBankCourses clears the "question_bank_courses" edge to the KcCourse entity.
func (m *TkQuestionBankMutation) ClearQuestionBankCourses() {
	m.clearedquestion_bank_courses = true
}

// QuestionBankCoursesCleared reports if the "question_bank_courses" edge to the KcCourse entity was cleared.
func (m *TkQuestionBankMutation) QuestionBankCoursesCleared() bool {
	return m.clearedquestion_bank_courses
}

// RemoveQuestionBankCourseIDs removes the "question_bank_courses" edge to the KcCourse entity by IDs.
func (m *TkQuestionBankMutation) RemoveQuestionBankCourseIDs(ids ...int) {
	if m.removedquestion_bank_courses == nil {
		m.removedquestion_bank_courses = make(map[int]struct{})
	}
	for i := range ids {
		m.removedquestion_bank_courses[ids[i]] = struct{}{}
	}
}

// RemovedQuestionBankCourses returns the removed IDs of the "question_bank_courses" edge to the KcCourse entity.
func (m *TkQuestionBankMutation) RemovedQuestionBankCoursesIDs() (ids []int) {
	for id := range m.removedquestion_bank_courses {
		ids = append(ids, id)
	}
	return
}

// QuestionBankCoursesIDs returns the "question_bank_courses" edge IDs in the mutation.
func (m *TkQuestionBankMutation) QuestionBankCoursesIDs() (ids []int) {
	for id := range m.question_bank_courses {
		ids = append(ids, id)
	}
	return
}

// ResetQuestionBankCourses resets all changes to the "question_bank_courses" edge.
func (m *TkQuestionBankMutation) ResetQuestionBankCourses() {
	m.question_bank_courses = nil
	m.clearedquestion_bank_courses = false
	m.removedquestion_bank_courses = nil
}

// AddQuestionIDs adds the "questions" edge to the TkQuestion entity by ids.
func (m *TkQuestionBankMutation) AddQuestionIDs(ids ...int) {
	if m.questions == nil {
		m.questions = make(map[int]struct{})
	}
	for i := range ids {
		m.questions[ids[i]] = struct{}{}
	}
}

// ClearQuestions clears the "questions" edge to the TkQuestion entity.
func (m *TkQuestionBankMutation) ClearQuestions() {
	m.clearedquestions = true
}

// QuestionsCleared reports if the "questions" edge to the TkQuestion entity was cleared.
func (m *TkQuestionBankMutation) QuestionsCleared() bool {
	return m.clearedquestions
}

// RemoveQuestionIDs removes the "questions" edge to the TkQuestion entity by IDs.
func (m *TkQuestionBankMutation) RemoveQuestionIDs(ids ...int) {
	if m.removedquestions == nil {
		m.removedquestions = make(map[int]struct{})
	}
	for i := range ids {
		m.removedquestions[ids[i]] = struct{}{}
	}
}

// RemovedQuestions returns the removed IDs of the "questions" edge to the TkQuestion entity.
func (m *TkQuestionBankMutation) RemovedQuestionsIDs() (ids []int) {
	for id := range m.removedquestions {
		ids = append(ids, id)
	}
	return
}

// QuestionsIDs returns the "questions" edge IDs in the mutation.
func (m *TkQuestionBankMutation) QuestionsIDs() (ids []int) {
	for id := range m.questions {
		ids = append(ids, id)
	}
	return
}

// ResetQuestions resets all changes to the "questions" edge.
func (m *TkQuestionBankMutation) ResetQuestions() {
	m.questions = nil
	m.clearedquestions = false
	m.removedquestions = nil
}

// AddExamPaperIDs adds the "exam_papers" edge to the TkExamPaper entity by ids.
func (m *TkQuestionBankMutation) AddExamPaperIDs(ids ...int) {
	if m.exam_papers == nil {
		m.exam_papers = make(map[int]struct{})
	}
	for i := range ids {
		m.exam_papers[ids[i]] = struct{}{}
	}
}

// ClearExamPapers clears the "exam_papers" edge to the TkExamPaper entity.
func (m *TkQuestionBankMutation) ClearExamPapers() {
	m.clearedexam_papers = true
}

// ExamPapersCleared reports if the "exam_papers" edge to the TkExamPaper entity was cleared.
func (m *TkQuestionBankMutation) ExamPapersCleared() bool {
	return m.clearedexam_papers
}

// RemoveExamPaperIDs removes the "exam_papers" edge to the TkExamPaper entity by IDs.
func (m *TkQuestionBankMutation) RemoveExamPaperIDs(ids ...int) {
	if m.removedexam_papers == nil {
		m.removedexam_papers = make(map[int]struct{})
	}
	for i := range ids {
		m.removedexam_papers[ids[i]] = struct{}{}
	}
}

// RemovedExamPapers returns the removed IDs of the "exam_papers" edge to the TkExamPaper entity.
func (m *TkQuestionBankMutation) RemovedExamPapersIDs() (ids []int) {
	for id := range m.removedexam_papers {
		ids = append(ids, id)
	}
	return
}

// ExamPapersIDs returns the "exam_papers" edge IDs in the mutation.
func (m *TkQuestionBankMutation) ExamPapersIDs() (ids []int) {
	for id := range m.exam_papers {
		ids = append(ids, id)
	}
	return
}

// ResetExamPapers resets all changes to the "exam_papers" edge.
func (m *TkQuestionBankMutation) ResetExamPapers() {
	m.exam_papers = nil
	m.clearedexam_papers = false
	m.removedexam_papers = nil
}

// AddExamQuestionTypeIDs adds the "exam_question_types" edge to the TkExamQuestionType entity by ids.
func (m *TkQuestionBankMutation) AddExamQuestionTypeIDs(ids ...int) {
	if m.exam_question_types == nil {
		m.exam_question_types = make(map[int]struct{})
	}
	for i := range ids {
		m.exam_question_types[ids[i]] = struct{}{}
	}
}

// ClearExamQuestionTypes clears the "exam_question_types" edge to the TkExamQuestionType entity.
func (m *TkQuestionBankMutation) ClearExamQuestionTypes() {
	m.clearedexam_question_types = true
}

// ExamQuestionTypesCleared reports if the "exam_question_types" edge to the TkExamQuestionType entity was cleared.
func (m *TkQuestionBankMutation) ExamQuestionTypesCleared() bool {
	return m.clearedexam_question_types
}

// RemoveExamQuestionTypeIDs removes the "exam_question_types" edge to the TkExamQuestionType entity by IDs.
func (m *TkQuestionBankMutation) RemoveExamQuestionTypeIDs(ids ...int) {
	if m.removedexam_question_types == nil {
		m.removedexam_question_types = make(map[int]struct{})
	}
	for i := range ids {
		m.removedexam_question_types[ids[i]] = struct{}{}
	}
}

// RemovedExamQuestionTypes returns the removed IDs of the "exam_question_types" edge to the TkExamQuestionType entity.
func (m *TkQuestionBankMutation) RemovedExamQuestionTypesIDs() (ids []int) {
	for id := range m.removedexam_question_types {
		ids = append(ids, id)
	}
	return
}

// ExamQuestionTypesIDs returns the "exam_question_types" edge IDs in the mutation.
func (m *TkQuestionBankMutation) ExamQuestionTypesIDs() (ids []int) {
	for id := range m.exam_question_types {
		ids = append(ids, id)
	}
	return
}

// ResetExamQuestionTypes resets all changes to the "exam_question_types" edge.
func (m *TkQuestionBankMutation) ResetExamQuestionTypes() {
	m.exam_question_types = nil
	m.clearedexam_question_types = false
	m.removedexam_question_types = nil
}

// AddUserQuestionBankIDs adds the "user_question_bank" edge to the TkUserQuestionBankRecord entity by ids.
func (m *TkQuestionBankMutation) AddUserQuestionBankIDs(ids ...int) {
	if m.user_question_bank == nil {
		m.user_question_bank = make(map[int]struct{})
	}
	for i := range ids {
		m.user_question_bank[ids[i]] = struct{}{}
	}
}

// ClearUserQuestionBank clears the "user_question_bank" edge to the TkUserQuestionBankRecord entity.
func (m *TkQuestionBankMutation) ClearUserQuestionBank() {
	m.cleareduser_question_bank = true
}

// UserQuestionBankCleared reports if the "user_question_bank" edge to the TkUserQuestionBankRecord entity was cleared.
func (m *TkQuestionBankMutation) UserQuestionBankCleared() bool {
	return m.cleareduser_question_bank
}

// RemoveUserQuestionBankIDs removes the "user_question_bank" edge to the TkUserQuestionBankRecord entity by IDs.
func (m *TkQuestionBankMutation) RemoveUserQuestionBankIDs(ids ...int) {
	if m.removeduser_question_bank == nil {
		m.removeduser_question_bank = make(map[int]struct{})
	}
	for i := range ids {
		m.removeduser_question_bank[ids[i]] = struct{}{}
	}
}

// RemovedUserQuestionBank returns the removed IDs of the "user_question_bank" edge to the TkUserQuestionBankRecord entity.
func (m *TkQuestionBankMutation) RemovedUserQuestionBankIDs() (ids []int) {
	for id := range m.removeduser_question_bank {
		ids = append(ids, id)
	}
	return
}

// UserQuestionBankIDs returns the "user_question_bank" edge IDs in the mutation.
func (m *TkQuestionBankMutation) UserQuestionBankIDs() (ids []int) {
	for id := range m.user_question_bank {
		ids = append(ids, id)
	}
	return
}

// ResetUserQuestionBank resets all changes to the "user_question_bank" edge.
func (m *TkQuestionBankMutation) ResetUserQuestionBank() {
	m.user_question_bank = nil
	m.cleareduser_question_bank = false
	m.removeduser_question_bank = nil
}

// AddUserBankRecordIDs adds the "user_bank_records" edge to the TkUserQuestionRecord entity by ids.
func (m *TkQuestionBankMutation) AddUserBankRecordIDs(ids ...int) {
	if m.user_bank_records == nil {
		m.user_bank_records = make(map[int]struct{})
	}
	for i := range ids {
		m.user_bank_records[ids[i]] = struct{}{}
	}
}

// ClearUserBankRecords clears the "user_bank_records" edge to the TkUserQuestionRecord entity.
func (m *TkQuestionBankMutation) ClearUserBankRecords() {
	m.cleareduser_bank_records = true
}

// UserBankRecordsCleared reports if the "user_bank_records" edge to the TkUserQuestionRecord entity was cleared.
func (m *TkQuestionBankMutation) UserBankRecordsCleared() bool {
	return m.cleareduser_bank_records
}

// RemoveUserBankRecordIDs removes the "user_bank_records" edge to the TkUserQuestionRecord entity by IDs.
func (m *TkQuestionBankMutation) RemoveUserBankRecordIDs(ids ...int) {
	if m.removeduser_bank_records == nil {
		m.removeduser_bank_records = make(map[int]struct{})
	}
	for i := range ids {
		m.removeduser_bank_records[ids[i]] = struct{}{}
	}
}

// RemovedUserBankRecords returns the removed IDs of the "user_bank_records" edge to the TkUserQuestionRecord entity.
func (m *TkQuestionBankMutation) RemovedUserBankRecordsIDs() (ids []int) {
	for id := range m.removeduser_bank_records {
		ids = append(ids, id)
	}
	return
}

// UserBankRecordsIDs returns the "user_bank_records" edge IDs in the mutation.
func (m *TkQuestionBankMutation) UserBankRecordsIDs() (ids []int) {
	for id := range m.user_bank_records {
		ids = append(ids, id)
	}
	return
}

// ResetUserBankRecords resets all changes to the "user_bank_records" edge.
func (m *TkQuestionBankMutation) ResetUserBankRecords() {
	m.user_bank_records = nil
	m.cleareduser_bank_records = false
	m.removeduser_bank_records = nil
}

// AddKnowledgePointIDs adds the "knowledge_points" edge to the TkKnowledgePoint entity by ids.
func (m *TkQuestionBankMutation) AddKnowledgePointIDs(ids ...int) {
	if m.knowledge_points == nil {
		m.knowledge_points = make(map[int]struct{})
	}
	for i := range ids {
		m.knowledge_points[ids[i]] = struct{}{}
	}
}

// ClearKnowledgePoints clears the "knowledge_points" edge to the TkKnowledgePoint entity.
func (m *TkQuestionBankMutation) ClearKnowledgePoints() {
	m.clearedknowledge_points = true
}

// KnowledgePointsCleared reports if the "knowledge_points" edge to the TkKnowledgePoint entity was cleared.
func (m *TkQuestionBankMutation) KnowledgePointsCleared() bool {
	return m.clearedknowledge_points
}

// RemoveKnowledgePointIDs removes the "knowledge_points" edge to the TkKnowledgePoint entity by IDs.
func (m *TkQuestionBankMutation) RemoveKnowledgePointIDs(ids ...int) {
	if m.removedknowledge_points == nil {
		m.removedknowledge_points = make(map[int]struct{})
	}
	for i := range ids {
		m.removedknowledge_points[ids[i]] = struct{}{}
	}
}

// RemovedKnowledgePoints returns the removed IDs of the "knowledge_points" edge to the TkKnowledgePoint entity.
func (m *TkQuestionBankMutation) RemovedKnowledgePointsIDs() (ids []int) {
	for id := range m.removedknowledge_points {
		ids = append(ids, id)
	}
	return
}

// KnowledgePointsIDs returns the "knowledge_points" edge IDs in the mutation.
func (m *TkQuestionBankMutation) KnowledgePointsIDs() (ids []int) {
	for id := range m.knowledge_points {
		ids = append(ids, id)
	}
	return
}

// ResetKnowledgePoints resets all changes to the "knowledge_points" edge.
func (m *TkQuestionBankMutation) ResetKnowledgePoints() {
	m.knowledge_points = nil
	m.clearedknowledge_points = false
	m.removedknowledge_points = nil
}

// Op returns the operation name.
func (m *TkQuestionBankMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TkQuestionBank).
func (m *TkQuestionBankMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TkQuestionBankMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.uuid != nil {
		fields = append(fields, tkquestionbank.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, tkquestionbank.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tkquestionbank.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, tkquestionbank.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, tkquestionbank.FieldName)
	}
	if m.status != nil {
		fields = append(fields, tkquestionbank.FieldStatus)
	}
	if m.question_count != nil {
		fields = append(fields, tkquestionbank.FieldQuestionCount)
	}
	if m.admin != nil {
		fields = append(fields, tkquestionbank.FieldCreatedAdminID)
	}
	if m.item_category != nil {
		fields = append(fields, tkquestionbank.FieldItemCategoryID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TkQuestionBankMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tkquestionbank.FieldUUID:
		return m.UUID()
	case tkquestionbank.FieldCreatedAt:
		return m.CreatedAt()
	case tkquestionbank.FieldUpdatedAt:
		return m.UpdatedAt()
	case tkquestionbank.FieldDeletedAt:
		return m.DeletedAt()
	case tkquestionbank.FieldName:
		return m.Name()
	case tkquestionbank.FieldStatus:
		return m.Status()
	case tkquestionbank.FieldQuestionCount:
		return m.QuestionCount()
	case tkquestionbank.FieldCreatedAdminID:
		return m.CreatedAdminID()
	case tkquestionbank.FieldItemCategoryID:
		return m.ItemCategoryID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TkQuestionBankMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tkquestionbank.FieldUUID:
		return m.OldUUID(ctx)
	case tkquestionbank.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tkquestionbank.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tkquestionbank.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case tkquestionbank.FieldName:
		return m.OldName(ctx)
	case tkquestionbank.FieldStatus:
		return m.OldStatus(ctx)
	case tkquestionbank.FieldQuestionCount:
		return m.OldQuestionCount(ctx)
	case tkquestionbank.FieldCreatedAdminID:
		return m.OldCreatedAdminID(ctx)
	case tkquestionbank.FieldItemCategoryID:
		return m.OldItemCategoryID(ctx)
	}
	return nil, fmt.Errorf("unknown TkQuestionBank field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TkQuestionBankMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tkquestionbank.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case tkquestionbank.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tkquestionbank.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tkquestionbank.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case tkquestionbank.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tkquestionbank.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case tkquestionbank.FieldQuestionCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuestionCount(v)
		return nil
	case tkquestionbank.FieldCreatedAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAdminID(v)
		return nil
	case tkquestionbank.FieldItemCategoryID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetItemCategoryID(v)
		return nil
	}
	return fmt.Errorf("unknown TkQuestionBank field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TkQuestionBankMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, tkquestionbank.FieldStatus)
	}
	if m.addquestion_count != nil {
		fields = append(fields, tkquestionbank.FieldQuestionCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TkQuestionBankMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tkquestionbank.FieldStatus:
		return m.AddedStatus()
	case tkquestionbank.FieldQuestionCount:
		return m.AddedQuestionCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TkQuestionBankMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tkquestionbank.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case tkquestionbank.FieldQuestionCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuestionCount(v)
		return nil
	}
	return fmt.Errorf("unknown TkQuestionBank numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TkQuestionBankMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tkquestionbank.FieldCreatedAt) {
		fields = append(fields, tkquestionbank.FieldCreatedAt)
	}
	if m.FieldCleared(tkquestionbank.FieldUpdatedAt) {
		fields = append(fields, tkquestionbank.FieldUpdatedAt)
	}
	if m.FieldCleared(tkquestionbank.FieldDeletedAt) {
		fields = append(fields, tkquestionbank.FieldDeletedAt)
	}
	if m.FieldCleared(tkquestionbank.FieldCreatedAdminID) {
		fields = append(fields, tkquestionbank.FieldCreatedAdminID)
	}
	if m.FieldCleared(tkquestionbank.FieldItemCategoryID) {
		fields = append(fields, tkquestionbank.FieldItemCategoryID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TkQuestionBankMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TkQuestionBankMutation) ClearField(name string) error {
	switch name {
	case tkquestionbank.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case tkquestionbank.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case tkquestionbank.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case tkquestionbank.FieldCreatedAdminID:
		m.ClearCreatedAdminID()
		return nil
	case tkquestionbank.FieldItemCategoryID:
		m.ClearItemCategoryID()
		return nil
	}
	return fmt.Errorf("unknown TkQuestionBank nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TkQuestionBankMutation) ResetField(name string) error {
	switch name {
	case tkquestionbank.FieldUUID:
		m.ResetUUID()
		return nil
	case tkquestionbank.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tkquestionbank.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tkquestionbank.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case tkquestionbank.FieldName:
		m.ResetName()
		return nil
	case tkquestionbank.FieldStatus:
		m.ResetStatus()
		return nil
	case tkquestionbank.FieldQuestionCount:
		m.ResetQuestionCount()
		return nil
	case tkquestionbank.FieldCreatedAdminID:
		m.ResetCreatedAdminID()
		return nil
	case tkquestionbank.FieldItemCategoryID:
		m.ResetItemCategoryID()
		return nil
	}
	return fmt.Errorf("unknown TkQuestionBank field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TkQuestionBankMutation) AddedEdges() []string {
	edges := make([]string, 0, 10)
	if m.item_category != nil {
		edges = append(edges, tkquestionbank.EdgeItemCategory)
	}
	if m.admin != nil {
		edges = append(edges, tkquestionbank.EdgeAdmin)
	}
	if m.question_chapters != nil {
		edges = append(edges, tkquestionbank.EdgeQuestionChapters)
	}
	if m.question_bank_courses != nil {
		edges = append(edges, tkquestionbank.EdgeQuestionBankCourses)
	}
	if m.questions != nil {
		edges = append(edges, tkquestionbank.EdgeQuestions)
	}
	if m.exam_papers != nil {
		edges = append(edges, tkquestionbank.EdgeExamPapers)
	}
	if m.exam_question_types != nil {
		edges = append(edges, tkquestionbank.EdgeExamQuestionTypes)
	}
	if m.user_question_bank != nil {
		edges = append(edges, tkquestionbank.EdgeUserQuestionBank)
	}
	if m.user_bank_records != nil {
		edges = append(edges, tkquestionbank.EdgeUserBankRecords)
	}
	if m.knowledge_points != nil {
		edges = append(edges, tkquestionbank.EdgeKnowledgePoints)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TkQuestionBankMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tkquestionbank.EdgeItemCategory:
		if id := m.item_category; id != nil {
			return []ent.Value{*id}
		}
	case tkquestionbank.EdgeAdmin:
		if id := m.admin; id != nil {
			return []ent.Value{*id}
		}
	case tkquestionbank.EdgeQuestionChapters:
		ids := make([]ent.Value, 0, len(m.question_chapters))
		for id := range m.question_chapters {
			ids = append(ids, id)
		}
		return ids
	case tkquestionbank.EdgeQuestionBankCourses:
		ids := make([]ent.Value, 0, len(m.question_bank_courses))
		for id := range m.question_bank_courses {
			ids = append(ids, id)
		}
		return ids
	case tkquestionbank.EdgeQuestions:
		ids := make([]ent.Value, 0, len(m.questions))
		for id := range m.questions {
			ids = append(ids, id)
		}
		return ids
	case tkquestionbank.EdgeExamPapers:
		ids := make([]ent.Value, 0, len(m.exam_papers))
		for id := range m.exam_papers {
			ids = append(ids, id)
		}
		return ids
	case tkquestionbank.EdgeExamQuestionTypes:
		ids := make([]ent.Value, 0, len(m.exam_question_types))
		for id := range m.exam_question_types {
			ids = append(ids, id)
		}
		return ids
	case tkquestionbank.EdgeUserQuestionBank:
		ids := make([]ent.Value, 0, len(m.user_question_bank))
		for id := range m.user_question_bank {
			ids = append(ids, id)
		}
		return ids
	case tkquestionbank.EdgeUserBankRecords:
		ids := make([]ent.Value, 0, len(m.user_bank_records))
		for id := range m.user_bank_records {
			ids = append(ids, id)
		}
		return ids
	case tkquestionbank.EdgeKnowledgePoints:
		ids := make([]ent.Value, 0, len(m.knowledge_points))
		for id := range m.knowledge_points {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TkQuestionBankMutation) RemovedEdges() []string {
	edges := make([]string, 0, 10)
	if m.removedquestion_chapters != nil {
		edges = append(edges, tkquestionbank.EdgeQuestionChapters)
	}
	if m.removedquestion_bank_courses != nil {
		edges = append(edges, tkquestionbank.EdgeQuestionBankCourses)
	}
	if m.removedquestions != nil {
		edges = append(edges, tkquestionbank.EdgeQuestions)
	}
	if m.removedexam_papers != nil {
		edges = append(edges, tkquestionbank.EdgeExamPapers)
	}
	if m.removedexam_question_types != nil {
		edges = append(edges, tkquestionbank.EdgeExamQuestionTypes)
	}
	if m.removeduser_question_bank != nil {
		edges = append(edges, tkquestionbank.EdgeUserQuestionBank)
	}
	if m.removeduser_bank_records != nil {
		edges = append(edges, tkquestionbank.EdgeUserBankRecords)
	}
	if m.removedknowledge_points != nil {
		edges = append(edges, tkquestionbank.EdgeKnowledgePoints)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TkQuestionBankMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tkquestionbank.EdgeQuestionChapters:
		ids := make([]ent.Value, 0, len(m.removedquestion_chapters))
		for id := range m.removedquestion_chapters {
			ids = append(ids, id)
		}
		return ids
	case tkquestionbank.EdgeQuestionBankCourses:
		ids := make([]ent.Value, 0, len(m.removedquestion_bank_courses))
		for id := range m.removedquestion_bank_courses {
			ids = append(ids, id)
		}
		return ids
	case tkquestionbank.EdgeQuestions:
		ids := make([]ent.Value, 0, len(m.removedquestions))
		for id := range m.removedquestions {
			ids = append(ids, id)
		}
		return ids
	case tkquestionbank.EdgeExamPapers:
		ids := make([]ent.Value, 0, len(m.removedexam_papers))
		for id := range m.removedexam_papers {
			ids = append(ids, id)
		}
		return ids
	case tkquestionbank.EdgeExamQuestionTypes:
		ids := make([]ent.Value, 0, len(m.removedexam_question_types))
		for id := range m.removedexam_question_types {
			ids = append(ids, id)
		}
		return ids
	case tkquestionbank.EdgeUserQuestionBank:
		ids := make([]ent.Value, 0, len(m.removeduser_question_bank))
		for id := range m.removeduser_question_bank {
			ids = append(ids, id)
		}
		return ids
	case tkquestionbank.EdgeUserBankRecords:
		ids := make([]ent.Value, 0, len(m.removeduser_bank_records))
		for id := range m.removeduser_bank_records {
			ids = append(ids, id)
		}
		return ids
	case tkquestionbank.EdgeKnowledgePoints:
		ids := make([]ent.Value, 0, len(m.removedknowledge_points))
		for id := range m.removedknowledge_points {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TkQuestionBankMutation) ClearedEdges() []string {
	edges := make([]string, 0, 10)
	if m.cleareditem_category {
		edges = append(edges, tkquestionbank.EdgeItemCategory)
	}
	if m.clearedadmin {
		edges = append(edges, tkquestionbank.EdgeAdmin)
	}
	if m.clearedquestion_chapters {
		edges = append(edges, tkquestionbank.EdgeQuestionChapters)
	}
	if m.clearedquestion_bank_courses {
		edges = append(edges, tkquestionbank.EdgeQuestionBankCourses)
	}
	if m.clearedquestions {
		edges = append(edges, tkquestionbank.EdgeQuestions)
	}
	if m.clearedexam_papers {
		edges = append(edges, tkquestionbank.EdgeExamPapers)
	}
	if m.clearedexam_question_types {
		edges = append(edges, tkquestionbank.EdgeExamQuestionTypes)
	}
	if m.cleareduser_question_bank {
		edges = append(edges, tkquestionbank.EdgeUserQuestionBank)
	}
	if m.cleareduser_bank_records {
		edges = append(edges, tkquestionbank.EdgeUserBankRecords)
	}
	if m.clearedknowledge_points {
		edges = append(edges, tkquestionbank.EdgeKnowledgePoints)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TkQuestionBankMutation) EdgeCleared(name string) bool {
	switch name {
	case tkquestionbank.EdgeItemCategory:
		return m.cleareditem_category
	case tkquestionbank.EdgeAdmin:
		return m.clearedadmin
	case tkquestionbank.EdgeQuestionChapters:
		return m.clearedquestion_chapters
	case tkquestionbank.EdgeQuestionBankCourses:
		return m.clearedquestion_bank_courses
	case tkquestionbank.EdgeQuestions:
		return m.clearedquestions
	case tkquestionbank.EdgeExamPapers:
		return m.clearedexam_papers
	case tkquestionbank.EdgeExamQuestionTypes:
		return m.clearedexam_question_types
	case tkquestionbank.EdgeUserQuestionBank:
		return m.cleareduser_question_bank
	case tkquestionbank.EdgeUserBankRecords:
		return m.cleareduser_bank_records
	case tkquestionbank.EdgeKnowledgePoints:
		return m.clearedknowledge_points
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TkQuestionBankMutation) ClearEdge(name string) error {
	switch name {
	case tkquestionbank.EdgeItemCategory:
		m.ClearItemCategory()
		return nil
	case tkquestionbank.EdgeAdmin:
		m.ClearAdmin()
		return nil
	}
	return fmt.Errorf("unknown TkQuestionBank unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TkQuestionBankMutation) ResetEdge(name string) error {
	switch name {
	case tkquestionbank.EdgeItemCategory:
		m.ResetItemCategory()
		return nil
	case tkquestionbank.EdgeAdmin:
		m.ResetAdmin()
		return nil
	case tkquestionbank.EdgeQuestionChapters:
		m.ResetQuestionChapters()
		return nil
	case tkquestionbank.EdgeQuestionBankCourses:
		m.ResetQuestionBankCourses()
		return nil
	case tkquestionbank.EdgeQuestions:
		m.ResetQuestions()
		return nil
	case tkquestionbank.EdgeExamPapers:
		m.ResetExamPapers()
		return nil
	case tkquestionbank.EdgeExamQuestionTypes:
		m.ResetExamQuestionTypes()
		return nil
	case tkquestionbank.EdgeUserQuestionBank:
		m.ResetUserQuestionBank()
		return nil
	case tkquestionbank.EdgeUserBankRecords:
		m.ResetUserBankRecords()
		return nil
	case tkquestionbank.EdgeKnowledgePoints:
		m.ResetKnowledgePoints()
		return nil
	}
	return fmt.Errorf("unknown TkQuestionBank edge %s", name)
}

// TkQuestionErrorFeedbackMutation represents an operation that mutates the TkQuestionErrorFeedback nodes in the graph.
type TkQuestionErrorFeedbackMutation struct {
	config
	op              Op
	typ             string
	id              *int
	uuid            *string
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *time.Time
	username        *string
	phone           *string
	error_desc      *string
	error_type      *uint8
	adderror_type   *uint8
	status          *uint8
	addstatus       *uint8
	deal_remark     *string
	clearedFields   map[string]struct{}
	question        *int
	clearedquestion bool
	admin           *int
	clearedadmin    bool
	done            bool
	oldValue        func(context.Context) (*TkQuestionErrorFeedback, error)
	predicates      []predicate.TkQuestionErrorFeedback
}

var _ ent.Mutation = (*TkQuestionErrorFeedbackMutation)(nil)

// tkquestionerrorfeedbackOption allows management of the mutation configuration using functional options.
type tkquestionerrorfeedbackOption func(*TkQuestionErrorFeedbackMutation)

// newTkQuestionErrorFeedbackMutation creates new mutation for the TkQuestionErrorFeedback entity.
func newTkQuestionErrorFeedbackMutation(c config, op Op, opts ...tkquestionerrorfeedbackOption) *TkQuestionErrorFeedbackMutation {
	m := &TkQuestionErrorFeedbackMutation{
		config:        c,
		op:            op,
		typ:           TypeTkQuestionErrorFeedback,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTkQuestionErrorFeedbackID sets the ID field of the mutation.
func withTkQuestionErrorFeedbackID(id int) tkquestionerrorfeedbackOption {
	return func(m *TkQuestionErrorFeedbackMutation) {
		var (
			err   error
			once  sync.Once
			value *TkQuestionErrorFeedback
		)
		m.oldValue = func(ctx context.Context) (*TkQuestionErrorFeedback, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TkQuestionErrorFeedback.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTkQuestionErrorFeedback sets the old TkQuestionErrorFeedback of the mutation.
func withTkQuestionErrorFeedback(node *TkQuestionErrorFeedback) tkquestionerrorfeedbackOption {
	return func(m *TkQuestionErrorFeedbackMutation) {
		m.oldValue = func(context.Context) (*TkQuestionErrorFeedback, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TkQuestionErrorFeedbackMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TkQuestionErrorFeedbackMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *TkQuestionErrorFeedbackMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *TkQuestionErrorFeedbackMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *TkQuestionErrorFeedbackMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the TkQuestionErrorFeedback entity.
// If the TkQuestionErrorFeedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkQuestionErrorFeedbackMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *TkQuestionErrorFeedbackMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TkQuestionErrorFeedbackMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TkQuestionErrorFeedbackMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TkQuestionErrorFeedback entity.
// If the TkQuestionErrorFeedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkQuestionErrorFeedbackMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *TkQuestionErrorFeedbackMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[tkquestionerrorfeedback.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *TkQuestionErrorFeedbackMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[tkquestionerrorfeedback.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TkQuestionErrorFeedbackMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, tkquestionerrorfeedback.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TkQuestionErrorFeedbackMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TkQuestionErrorFeedbackMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TkQuestionErrorFeedback entity.
// If the TkQuestionErrorFeedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkQuestionErrorFeedbackMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TkQuestionErrorFeedbackMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[tkquestionerrorfeedback.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TkQuestionErrorFeedbackMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[tkquestionerrorfeedback.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TkQuestionErrorFeedbackMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, tkquestionerrorfeedback.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TkQuestionErrorFeedbackMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TkQuestionErrorFeedbackMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TkQuestionErrorFeedback entity.
// If the TkQuestionErrorFeedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkQuestionErrorFeedbackMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TkQuestionErrorFeedbackMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[tkquestionerrorfeedback.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TkQuestionErrorFeedbackMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[tkquestionerrorfeedback.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TkQuestionErrorFeedbackMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, tkquestionerrorfeedback.FieldDeletedAt)
}

// SetUsername sets the "username" field.
func (m *TkQuestionErrorFeedbackMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *TkQuestionErrorFeedbackMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the TkQuestionErrorFeedback entity.
// If the TkQuestionErrorFeedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkQuestionErrorFeedbackMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *TkQuestionErrorFeedbackMutation) ResetUsername() {
	m.username = nil
}

// SetPhone sets the "phone" field.
func (m *TkQuestionErrorFeedbackMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *TkQuestionErrorFeedbackMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the TkQuestionErrorFeedback entity.
// If the TkQuestionErrorFeedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkQuestionErrorFeedbackMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *TkQuestionErrorFeedbackMutation) ResetPhone() {
	m.phone = nil
}

// SetErrorDesc sets the "error_desc" field.
func (m *TkQuestionErrorFeedbackMutation) SetErrorDesc(s string) {
	m.error_desc = &s
}

// ErrorDesc returns the value of the "error_desc" field in the mutation.
func (m *TkQuestionErrorFeedbackMutation) ErrorDesc() (r string, exists bool) {
	v := m.error_desc
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorDesc returns the old "error_desc" field's value of the TkQuestionErrorFeedback entity.
// If the TkQuestionErrorFeedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkQuestionErrorFeedbackMutation) OldErrorDesc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldErrorDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldErrorDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorDesc: %w", err)
	}
	return oldValue.ErrorDesc, nil
}

// ResetErrorDesc resets all changes to the "error_desc" field.
func (m *TkQuestionErrorFeedbackMutation) ResetErrorDesc() {
	m.error_desc = nil
}

// SetErrorType sets the "error_type" field.
func (m *TkQuestionErrorFeedbackMutation) SetErrorType(u uint8) {
	m.error_type = &u
	m.adderror_type = nil
}

// ErrorType returns the value of the "error_type" field in the mutation.
func (m *TkQuestionErrorFeedbackMutation) ErrorType() (r uint8, exists bool) {
	v := m.error_type
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorType returns the old "error_type" field's value of the TkQuestionErrorFeedback entity.
// If the TkQuestionErrorFeedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkQuestionErrorFeedbackMutation) OldErrorType(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldErrorType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldErrorType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorType: %w", err)
	}
	return oldValue.ErrorType, nil
}

// AddErrorType adds u to the "error_type" field.
func (m *TkQuestionErrorFeedbackMutation) AddErrorType(u uint8) {
	if m.adderror_type != nil {
		*m.adderror_type += u
	} else {
		m.adderror_type = &u
	}
}

// AddedErrorType returns the value that was added to the "error_type" field in this mutation.
func (m *TkQuestionErrorFeedbackMutation) AddedErrorType() (r uint8, exists bool) {
	v := m.adderror_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetErrorType resets all changes to the "error_type" field.
func (m *TkQuestionErrorFeedbackMutation) ResetErrorType() {
	m.error_type = nil
	m.adderror_type = nil
}

// SetStatus sets the "status" field.
func (m *TkQuestionErrorFeedbackMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *TkQuestionErrorFeedbackMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the TkQuestionErrorFeedback entity.
// If the TkQuestionErrorFeedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkQuestionErrorFeedbackMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *TkQuestionErrorFeedbackMutation) AddStatus(u uint8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *TkQuestionErrorFeedbackMutation) AddedStatus() (r uint8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *TkQuestionErrorFeedbackMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetDealRemark sets the "deal_remark" field.
func (m *TkQuestionErrorFeedbackMutation) SetDealRemark(s string) {
	m.deal_remark = &s
}

// DealRemark returns the value of the "deal_remark" field in the mutation.
func (m *TkQuestionErrorFeedbackMutation) DealRemark() (r string, exists bool) {
	v := m.deal_remark
	if v == nil {
		return
	}
	return *v, true
}

// OldDealRemark returns the old "deal_remark" field's value of the TkQuestionErrorFeedback entity.
// If the TkQuestionErrorFeedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkQuestionErrorFeedbackMutation) OldDealRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDealRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDealRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDealRemark: %w", err)
	}
	return oldValue.DealRemark, nil
}

// ResetDealRemark resets all changes to the "deal_remark" field.
func (m *TkQuestionErrorFeedbackMutation) ResetDealRemark() {
	m.deal_remark = nil
}

// SetOperatorAdminID sets the "operator_admin_id" field.
func (m *TkQuestionErrorFeedbackMutation) SetOperatorAdminID(i int) {
	m.admin = &i
}

// OperatorAdminID returns the value of the "operator_admin_id" field in the mutation.
func (m *TkQuestionErrorFeedbackMutation) OperatorAdminID() (r int, exists bool) {
	v := m.admin
	if v == nil {
		return
	}
	return *v, true
}

// OldOperatorAdminID returns the old "operator_admin_id" field's value of the TkQuestionErrorFeedback entity.
// If the TkQuestionErrorFeedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkQuestionErrorFeedbackMutation) OldOperatorAdminID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOperatorAdminID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOperatorAdminID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperatorAdminID: %w", err)
	}
	return oldValue.OperatorAdminID, nil
}

// ClearOperatorAdminID clears the value of the "operator_admin_id" field.
func (m *TkQuestionErrorFeedbackMutation) ClearOperatorAdminID() {
	m.admin = nil
	m.clearedFields[tkquestionerrorfeedback.FieldOperatorAdminID] = struct{}{}
}

// OperatorAdminIDCleared returns if the "operator_admin_id" field was cleared in this mutation.
func (m *TkQuestionErrorFeedbackMutation) OperatorAdminIDCleared() bool {
	_, ok := m.clearedFields[tkquestionerrorfeedback.FieldOperatorAdminID]
	return ok
}

// ResetOperatorAdminID resets all changes to the "operator_admin_id" field.
func (m *TkQuestionErrorFeedbackMutation) ResetOperatorAdminID() {
	m.admin = nil
	delete(m.clearedFields, tkquestionerrorfeedback.FieldOperatorAdminID)
}

// SetQuestionID sets the "question_id" field.
func (m *TkQuestionErrorFeedbackMutation) SetQuestionID(i int) {
	m.question = &i
}

// QuestionID returns the value of the "question_id" field in the mutation.
func (m *TkQuestionErrorFeedbackMutation) QuestionID() (r int, exists bool) {
	v := m.question
	if v == nil {
		return
	}
	return *v, true
}

// OldQuestionID returns the old "question_id" field's value of the TkQuestionErrorFeedback entity.
// If the TkQuestionErrorFeedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkQuestionErrorFeedbackMutation) OldQuestionID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldQuestionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldQuestionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuestionID: %w", err)
	}
	return oldValue.QuestionID, nil
}

// ClearQuestionID clears the value of the "question_id" field.
func (m *TkQuestionErrorFeedbackMutation) ClearQuestionID() {
	m.question = nil
	m.clearedFields[tkquestionerrorfeedback.FieldQuestionID] = struct{}{}
}

// QuestionIDCleared returns if the "question_id" field was cleared in this mutation.
func (m *TkQuestionErrorFeedbackMutation) QuestionIDCleared() bool {
	_, ok := m.clearedFields[tkquestionerrorfeedback.FieldQuestionID]
	return ok
}

// ResetQuestionID resets all changes to the "question_id" field.
func (m *TkQuestionErrorFeedbackMutation) ResetQuestionID() {
	m.question = nil
	delete(m.clearedFields, tkquestionerrorfeedback.FieldQuestionID)
}

// ClearQuestion clears the "question" edge to the TkQuestion entity.
func (m *TkQuestionErrorFeedbackMutation) ClearQuestion() {
	m.clearedquestion = true
}

// QuestionCleared reports if the "question" edge to the TkQuestion entity was cleared.
func (m *TkQuestionErrorFeedbackMutation) QuestionCleared() bool {
	return m.QuestionIDCleared() || m.clearedquestion
}

// QuestionIDs returns the "question" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// QuestionID instead. It exists only for internal usage by the builders.
func (m *TkQuestionErrorFeedbackMutation) QuestionIDs() (ids []int) {
	if id := m.question; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetQuestion resets all changes to the "question" edge.
func (m *TkQuestionErrorFeedbackMutation) ResetQuestion() {
	m.question = nil
	m.clearedquestion = false
}

// SetAdminID sets the "admin" edge to the Admin entity by id.
func (m *TkQuestionErrorFeedbackMutation) SetAdminID(id int) {
	m.admin = &id
}

// ClearAdmin clears the "admin" edge to the Admin entity.
func (m *TkQuestionErrorFeedbackMutation) ClearAdmin() {
	m.clearedadmin = true
}

// AdminCleared reports if the "admin" edge to the Admin entity was cleared.
func (m *TkQuestionErrorFeedbackMutation) AdminCleared() bool {
	return m.OperatorAdminIDCleared() || m.clearedadmin
}

// AdminID returns the "admin" edge ID in the mutation.
func (m *TkQuestionErrorFeedbackMutation) AdminID() (id int, exists bool) {
	if m.admin != nil {
		return *m.admin, true
	}
	return
}

// AdminIDs returns the "admin" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AdminID instead. It exists only for internal usage by the builders.
func (m *TkQuestionErrorFeedbackMutation) AdminIDs() (ids []int) {
	if id := m.admin; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAdmin resets all changes to the "admin" edge.
func (m *TkQuestionErrorFeedbackMutation) ResetAdmin() {
	m.admin = nil
	m.clearedadmin = false
}

// Op returns the operation name.
func (m *TkQuestionErrorFeedbackMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TkQuestionErrorFeedback).
func (m *TkQuestionErrorFeedbackMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TkQuestionErrorFeedbackMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.uuid != nil {
		fields = append(fields, tkquestionerrorfeedback.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, tkquestionerrorfeedback.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tkquestionerrorfeedback.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, tkquestionerrorfeedback.FieldDeletedAt)
	}
	if m.username != nil {
		fields = append(fields, tkquestionerrorfeedback.FieldUsername)
	}
	if m.phone != nil {
		fields = append(fields, tkquestionerrorfeedback.FieldPhone)
	}
	if m.error_desc != nil {
		fields = append(fields, tkquestionerrorfeedback.FieldErrorDesc)
	}
	if m.error_type != nil {
		fields = append(fields, tkquestionerrorfeedback.FieldErrorType)
	}
	if m.status != nil {
		fields = append(fields, tkquestionerrorfeedback.FieldStatus)
	}
	if m.deal_remark != nil {
		fields = append(fields, tkquestionerrorfeedback.FieldDealRemark)
	}
	if m.admin != nil {
		fields = append(fields, tkquestionerrorfeedback.FieldOperatorAdminID)
	}
	if m.question != nil {
		fields = append(fields, tkquestionerrorfeedback.FieldQuestionID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TkQuestionErrorFeedbackMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tkquestionerrorfeedback.FieldUUID:
		return m.UUID()
	case tkquestionerrorfeedback.FieldCreatedAt:
		return m.CreatedAt()
	case tkquestionerrorfeedback.FieldUpdatedAt:
		return m.UpdatedAt()
	case tkquestionerrorfeedback.FieldDeletedAt:
		return m.DeletedAt()
	case tkquestionerrorfeedback.FieldUsername:
		return m.Username()
	case tkquestionerrorfeedback.FieldPhone:
		return m.Phone()
	case tkquestionerrorfeedback.FieldErrorDesc:
		return m.ErrorDesc()
	case tkquestionerrorfeedback.FieldErrorType:
		return m.ErrorType()
	case tkquestionerrorfeedback.FieldStatus:
		return m.Status()
	case tkquestionerrorfeedback.FieldDealRemark:
		return m.DealRemark()
	case tkquestionerrorfeedback.FieldOperatorAdminID:
		return m.OperatorAdminID()
	case tkquestionerrorfeedback.FieldQuestionID:
		return m.QuestionID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TkQuestionErrorFeedbackMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tkquestionerrorfeedback.FieldUUID:
		return m.OldUUID(ctx)
	case tkquestionerrorfeedback.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tkquestionerrorfeedback.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tkquestionerrorfeedback.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case tkquestionerrorfeedback.FieldUsername:
		return m.OldUsername(ctx)
	case tkquestionerrorfeedback.FieldPhone:
		return m.OldPhone(ctx)
	case tkquestionerrorfeedback.FieldErrorDesc:
		return m.OldErrorDesc(ctx)
	case tkquestionerrorfeedback.FieldErrorType:
		return m.OldErrorType(ctx)
	case tkquestionerrorfeedback.FieldStatus:
		return m.OldStatus(ctx)
	case tkquestionerrorfeedback.FieldDealRemark:
		return m.OldDealRemark(ctx)
	case tkquestionerrorfeedback.FieldOperatorAdminID:
		return m.OldOperatorAdminID(ctx)
	case tkquestionerrorfeedback.FieldQuestionID:
		return m.OldQuestionID(ctx)
	}
	return nil, fmt.Errorf("unknown TkQuestionErrorFeedback field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TkQuestionErrorFeedbackMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tkquestionerrorfeedback.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case tkquestionerrorfeedback.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tkquestionerrorfeedback.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tkquestionerrorfeedback.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case tkquestionerrorfeedback.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case tkquestionerrorfeedback.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case tkquestionerrorfeedback.FieldErrorDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorDesc(v)
		return nil
	case tkquestionerrorfeedback.FieldErrorType:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorType(v)
		return nil
	case tkquestionerrorfeedback.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case tkquestionerrorfeedback.FieldDealRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDealRemark(v)
		return nil
	case tkquestionerrorfeedback.FieldOperatorAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperatorAdminID(v)
		return nil
	case tkquestionerrorfeedback.FieldQuestionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuestionID(v)
		return nil
	}
	return fmt.Errorf("unknown TkQuestionErrorFeedback field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TkQuestionErrorFeedbackMutation) AddedFields() []string {
	var fields []string
	if m.adderror_type != nil {
		fields = append(fields, tkquestionerrorfeedback.FieldErrorType)
	}
	if m.addstatus != nil {
		fields = append(fields, tkquestionerrorfeedback.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TkQuestionErrorFeedbackMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tkquestionerrorfeedback.FieldErrorType:
		return m.AddedErrorType()
	case tkquestionerrorfeedback.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TkQuestionErrorFeedbackMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tkquestionerrorfeedback.FieldErrorType:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddErrorType(v)
		return nil
	case tkquestionerrorfeedback.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown TkQuestionErrorFeedback numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TkQuestionErrorFeedbackMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tkquestionerrorfeedback.FieldCreatedAt) {
		fields = append(fields, tkquestionerrorfeedback.FieldCreatedAt)
	}
	if m.FieldCleared(tkquestionerrorfeedback.FieldUpdatedAt) {
		fields = append(fields, tkquestionerrorfeedback.FieldUpdatedAt)
	}
	if m.FieldCleared(tkquestionerrorfeedback.FieldDeletedAt) {
		fields = append(fields, tkquestionerrorfeedback.FieldDeletedAt)
	}
	if m.FieldCleared(tkquestionerrorfeedback.FieldOperatorAdminID) {
		fields = append(fields, tkquestionerrorfeedback.FieldOperatorAdminID)
	}
	if m.FieldCleared(tkquestionerrorfeedback.FieldQuestionID) {
		fields = append(fields, tkquestionerrorfeedback.FieldQuestionID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TkQuestionErrorFeedbackMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TkQuestionErrorFeedbackMutation) ClearField(name string) error {
	switch name {
	case tkquestionerrorfeedback.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case tkquestionerrorfeedback.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case tkquestionerrorfeedback.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case tkquestionerrorfeedback.FieldOperatorAdminID:
		m.ClearOperatorAdminID()
		return nil
	case tkquestionerrorfeedback.FieldQuestionID:
		m.ClearQuestionID()
		return nil
	}
	return fmt.Errorf("unknown TkQuestionErrorFeedback nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TkQuestionErrorFeedbackMutation) ResetField(name string) error {
	switch name {
	case tkquestionerrorfeedback.FieldUUID:
		m.ResetUUID()
		return nil
	case tkquestionerrorfeedback.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tkquestionerrorfeedback.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tkquestionerrorfeedback.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case tkquestionerrorfeedback.FieldUsername:
		m.ResetUsername()
		return nil
	case tkquestionerrorfeedback.FieldPhone:
		m.ResetPhone()
		return nil
	case tkquestionerrorfeedback.FieldErrorDesc:
		m.ResetErrorDesc()
		return nil
	case tkquestionerrorfeedback.FieldErrorType:
		m.ResetErrorType()
		return nil
	case tkquestionerrorfeedback.FieldStatus:
		m.ResetStatus()
		return nil
	case tkquestionerrorfeedback.FieldDealRemark:
		m.ResetDealRemark()
		return nil
	case tkquestionerrorfeedback.FieldOperatorAdminID:
		m.ResetOperatorAdminID()
		return nil
	case tkquestionerrorfeedback.FieldQuestionID:
		m.ResetQuestionID()
		return nil
	}
	return fmt.Errorf("unknown TkQuestionErrorFeedback field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TkQuestionErrorFeedbackMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.question != nil {
		edges = append(edges, tkquestionerrorfeedback.EdgeQuestion)
	}
	if m.admin != nil {
		edges = append(edges, tkquestionerrorfeedback.EdgeAdmin)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TkQuestionErrorFeedbackMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tkquestionerrorfeedback.EdgeQuestion:
		if id := m.question; id != nil {
			return []ent.Value{*id}
		}
	case tkquestionerrorfeedback.EdgeAdmin:
		if id := m.admin; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TkQuestionErrorFeedbackMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TkQuestionErrorFeedbackMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TkQuestionErrorFeedbackMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedquestion {
		edges = append(edges, tkquestionerrorfeedback.EdgeQuestion)
	}
	if m.clearedadmin {
		edges = append(edges, tkquestionerrorfeedback.EdgeAdmin)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TkQuestionErrorFeedbackMutation) EdgeCleared(name string) bool {
	switch name {
	case tkquestionerrorfeedback.EdgeQuestion:
		return m.clearedquestion
	case tkquestionerrorfeedback.EdgeAdmin:
		return m.clearedadmin
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TkQuestionErrorFeedbackMutation) ClearEdge(name string) error {
	switch name {
	case tkquestionerrorfeedback.EdgeQuestion:
		m.ClearQuestion()
		return nil
	case tkquestionerrorfeedback.EdgeAdmin:
		m.ClearAdmin()
		return nil
	}
	return fmt.Errorf("unknown TkQuestionErrorFeedback unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TkQuestionErrorFeedbackMutation) ResetEdge(name string) error {
	switch name {
	case tkquestionerrorfeedback.EdgeQuestion:
		m.ResetQuestion()
		return nil
	case tkquestionerrorfeedback.EdgeAdmin:
		m.ResetAdmin()
		return nil
	}
	return fmt.Errorf("unknown TkQuestionErrorFeedback edge %s", name)
}

// TkQuestionSectionMutation represents an operation that mutates the TkQuestionSection nodes in the graph.
type TkQuestionSectionMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	uuid                    *string
	created_at              *time.Time
	updated_at              *time.Time
	deleted_at              *time.Time
	clearedFields           map[string]struct{}
	question_section        *int
	clearedquestion_section bool
	section_question        *int
	clearedsection_question bool
	done                    bool
	oldValue                func(context.Context) (*TkQuestionSection, error)
	predicates              []predicate.TkQuestionSection
}

var _ ent.Mutation = (*TkQuestionSectionMutation)(nil)

// tkquestionsectionOption allows management of the mutation configuration using functional options.
type tkquestionsectionOption func(*TkQuestionSectionMutation)

// newTkQuestionSectionMutation creates new mutation for the TkQuestionSection entity.
func newTkQuestionSectionMutation(c config, op Op, opts ...tkquestionsectionOption) *TkQuestionSectionMutation {
	m := &TkQuestionSectionMutation{
		config:        c,
		op:            op,
		typ:           TypeTkQuestionSection,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTkQuestionSectionID sets the ID field of the mutation.
func withTkQuestionSectionID(id int) tkquestionsectionOption {
	return func(m *TkQuestionSectionMutation) {
		var (
			err   error
			once  sync.Once
			value *TkQuestionSection
		)
		m.oldValue = func(ctx context.Context) (*TkQuestionSection, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TkQuestionSection.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTkQuestionSection sets the old TkQuestionSection of the mutation.
func withTkQuestionSection(node *TkQuestionSection) tkquestionsectionOption {
	return func(m *TkQuestionSectionMutation) {
		m.oldValue = func(context.Context) (*TkQuestionSection, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TkQuestionSectionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TkQuestionSectionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *TkQuestionSectionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *TkQuestionSectionMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *TkQuestionSectionMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the TkQuestionSection entity.
// If the TkQuestionSection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkQuestionSectionMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *TkQuestionSectionMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TkQuestionSectionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TkQuestionSectionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TkQuestionSection entity.
// If the TkQuestionSection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkQuestionSectionMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *TkQuestionSectionMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[tkquestionsection.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *TkQuestionSectionMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[tkquestionsection.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TkQuestionSectionMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, tkquestionsection.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TkQuestionSectionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TkQuestionSectionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TkQuestionSection entity.
// If the TkQuestionSection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkQuestionSectionMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TkQuestionSectionMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[tkquestionsection.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TkQuestionSectionMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[tkquestionsection.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TkQuestionSectionMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, tkquestionsection.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TkQuestionSectionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TkQuestionSectionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TkQuestionSection entity.
// If the TkQuestionSection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkQuestionSectionMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TkQuestionSectionMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[tkquestionsection.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TkQuestionSectionMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[tkquestionsection.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TkQuestionSectionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, tkquestionsection.FieldDeletedAt)
}

// SetSectionID sets the "section_id" field.
func (m *TkQuestionSectionMutation) SetSectionID(i int) {
	m.question_section = &i
}

// SectionID returns the value of the "section_id" field in the mutation.
func (m *TkQuestionSectionMutation) SectionID() (r int, exists bool) {
	v := m.question_section
	if v == nil {
		return
	}
	return *v, true
}

// OldSectionID returns the old "section_id" field's value of the TkQuestionSection entity.
// If the TkQuestionSection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkQuestionSectionMutation) OldSectionID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSectionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSectionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSectionID: %w", err)
	}
	return oldValue.SectionID, nil
}

// ClearSectionID clears the value of the "section_id" field.
func (m *TkQuestionSectionMutation) ClearSectionID() {
	m.question_section = nil
	m.clearedFields[tkquestionsection.FieldSectionID] = struct{}{}
}

// SectionIDCleared returns if the "section_id" field was cleared in this mutation.
func (m *TkQuestionSectionMutation) SectionIDCleared() bool {
	_, ok := m.clearedFields[tkquestionsection.FieldSectionID]
	return ok
}

// ResetSectionID resets all changes to the "section_id" field.
func (m *TkQuestionSectionMutation) ResetSectionID() {
	m.question_section = nil
	delete(m.clearedFields, tkquestionsection.FieldSectionID)
}

// SetQuestionID sets the "question_id" field.
func (m *TkQuestionSectionMutation) SetQuestionID(i int) {
	m.section_question = &i
}

// QuestionID returns the value of the "question_id" field in the mutation.
func (m *TkQuestionSectionMutation) QuestionID() (r int, exists bool) {
	v := m.section_question
	if v == nil {
		return
	}
	return *v, true
}

// OldQuestionID returns the old "question_id" field's value of the TkQuestionSection entity.
// If the TkQuestionSection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkQuestionSectionMutation) OldQuestionID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldQuestionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldQuestionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuestionID: %w", err)
	}
	return oldValue.QuestionID, nil
}

// ClearQuestionID clears the value of the "question_id" field.
func (m *TkQuestionSectionMutation) ClearQuestionID() {
	m.section_question = nil
	m.clearedFields[tkquestionsection.FieldQuestionID] = struct{}{}
}

// QuestionIDCleared returns if the "question_id" field was cleared in this mutation.
func (m *TkQuestionSectionMutation) QuestionIDCleared() bool {
	_, ok := m.clearedFields[tkquestionsection.FieldQuestionID]
	return ok
}

// ResetQuestionID resets all changes to the "question_id" field.
func (m *TkQuestionSectionMutation) ResetQuestionID() {
	m.section_question = nil
	delete(m.clearedFields, tkquestionsection.FieldQuestionID)
}

// SetQuestionSectionID sets the "question_section" edge to the TkSection entity by id.
func (m *TkQuestionSectionMutation) SetQuestionSectionID(id int) {
	m.question_section = &id
}

// ClearQuestionSection clears the "question_section" edge to the TkSection entity.
func (m *TkQuestionSectionMutation) ClearQuestionSection() {
	m.clearedquestion_section = true
}

// QuestionSectionCleared reports if the "question_section" edge to the TkSection entity was cleared.
func (m *TkQuestionSectionMutation) QuestionSectionCleared() bool {
	return m.SectionIDCleared() || m.clearedquestion_section
}

// QuestionSectionID returns the "question_section" edge ID in the mutation.
func (m *TkQuestionSectionMutation) QuestionSectionID() (id int, exists bool) {
	if m.question_section != nil {
		return *m.question_section, true
	}
	return
}

// QuestionSectionIDs returns the "question_section" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// QuestionSectionID instead. It exists only for internal usage by the builders.
func (m *TkQuestionSectionMutation) QuestionSectionIDs() (ids []int) {
	if id := m.question_section; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetQuestionSection resets all changes to the "question_section" edge.
func (m *TkQuestionSectionMutation) ResetQuestionSection() {
	m.question_section = nil
	m.clearedquestion_section = false
}

// SetSectionQuestionID sets the "section_question" edge to the TkQuestion entity by id.
func (m *TkQuestionSectionMutation) SetSectionQuestionID(id int) {
	m.section_question = &id
}

// ClearSectionQuestion clears the "section_question" edge to the TkQuestion entity.
func (m *TkQuestionSectionMutation) ClearSectionQuestion() {
	m.clearedsection_question = true
}

// SectionQuestionCleared reports if the "section_question" edge to the TkQuestion entity was cleared.
func (m *TkQuestionSectionMutation) SectionQuestionCleared() bool {
	return m.QuestionIDCleared() || m.clearedsection_question
}

// SectionQuestionID returns the "section_question" edge ID in the mutation.
func (m *TkQuestionSectionMutation) SectionQuestionID() (id int, exists bool) {
	if m.section_question != nil {
		return *m.section_question, true
	}
	return
}

// SectionQuestionIDs returns the "section_question" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SectionQuestionID instead. It exists only for internal usage by the builders.
func (m *TkQuestionSectionMutation) SectionQuestionIDs() (ids []int) {
	if id := m.section_question; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSectionQuestion resets all changes to the "section_question" edge.
func (m *TkQuestionSectionMutation) ResetSectionQuestion() {
	m.section_question = nil
	m.clearedsection_question = false
}

// Op returns the operation name.
func (m *TkQuestionSectionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TkQuestionSection).
func (m *TkQuestionSectionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TkQuestionSectionMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.uuid != nil {
		fields = append(fields, tkquestionsection.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, tkquestionsection.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tkquestionsection.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, tkquestionsection.FieldDeletedAt)
	}
	if m.question_section != nil {
		fields = append(fields, tkquestionsection.FieldSectionID)
	}
	if m.section_question != nil {
		fields = append(fields, tkquestionsection.FieldQuestionID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TkQuestionSectionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tkquestionsection.FieldUUID:
		return m.UUID()
	case tkquestionsection.FieldCreatedAt:
		return m.CreatedAt()
	case tkquestionsection.FieldUpdatedAt:
		return m.UpdatedAt()
	case tkquestionsection.FieldDeletedAt:
		return m.DeletedAt()
	case tkquestionsection.FieldSectionID:
		return m.SectionID()
	case tkquestionsection.FieldQuestionID:
		return m.QuestionID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TkQuestionSectionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tkquestionsection.FieldUUID:
		return m.OldUUID(ctx)
	case tkquestionsection.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tkquestionsection.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tkquestionsection.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case tkquestionsection.FieldSectionID:
		return m.OldSectionID(ctx)
	case tkquestionsection.FieldQuestionID:
		return m.OldQuestionID(ctx)
	}
	return nil, fmt.Errorf("unknown TkQuestionSection field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TkQuestionSectionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tkquestionsection.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case tkquestionsection.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tkquestionsection.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tkquestionsection.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case tkquestionsection.FieldSectionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSectionID(v)
		return nil
	case tkquestionsection.FieldQuestionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuestionID(v)
		return nil
	}
	return fmt.Errorf("unknown TkQuestionSection field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TkQuestionSectionMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TkQuestionSectionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TkQuestionSectionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TkQuestionSection numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TkQuestionSectionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tkquestionsection.FieldCreatedAt) {
		fields = append(fields, tkquestionsection.FieldCreatedAt)
	}
	if m.FieldCleared(tkquestionsection.FieldUpdatedAt) {
		fields = append(fields, tkquestionsection.FieldUpdatedAt)
	}
	if m.FieldCleared(tkquestionsection.FieldDeletedAt) {
		fields = append(fields, tkquestionsection.FieldDeletedAt)
	}
	if m.FieldCleared(tkquestionsection.FieldSectionID) {
		fields = append(fields, tkquestionsection.FieldSectionID)
	}
	if m.FieldCleared(tkquestionsection.FieldQuestionID) {
		fields = append(fields, tkquestionsection.FieldQuestionID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TkQuestionSectionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TkQuestionSectionMutation) ClearField(name string) error {
	switch name {
	case tkquestionsection.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case tkquestionsection.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case tkquestionsection.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case tkquestionsection.FieldSectionID:
		m.ClearSectionID()
		return nil
	case tkquestionsection.FieldQuestionID:
		m.ClearQuestionID()
		return nil
	}
	return fmt.Errorf("unknown TkQuestionSection nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TkQuestionSectionMutation) ResetField(name string) error {
	switch name {
	case tkquestionsection.FieldUUID:
		m.ResetUUID()
		return nil
	case tkquestionsection.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tkquestionsection.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tkquestionsection.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case tkquestionsection.FieldSectionID:
		m.ResetSectionID()
		return nil
	case tkquestionsection.FieldQuestionID:
		m.ResetQuestionID()
		return nil
	}
	return fmt.Errorf("unknown TkQuestionSection field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TkQuestionSectionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.question_section != nil {
		edges = append(edges, tkquestionsection.EdgeQuestionSection)
	}
	if m.section_question != nil {
		edges = append(edges, tkquestionsection.EdgeSectionQuestion)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TkQuestionSectionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tkquestionsection.EdgeQuestionSection:
		if id := m.question_section; id != nil {
			return []ent.Value{*id}
		}
	case tkquestionsection.EdgeSectionQuestion:
		if id := m.section_question; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TkQuestionSectionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TkQuestionSectionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TkQuestionSectionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedquestion_section {
		edges = append(edges, tkquestionsection.EdgeQuestionSection)
	}
	if m.clearedsection_question {
		edges = append(edges, tkquestionsection.EdgeSectionQuestion)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TkQuestionSectionMutation) EdgeCleared(name string) bool {
	switch name {
	case tkquestionsection.EdgeQuestionSection:
		return m.clearedquestion_section
	case tkquestionsection.EdgeSectionQuestion:
		return m.clearedsection_question
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TkQuestionSectionMutation) ClearEdge(name string) error {
	switch name {
	case tkquestionsection.EdgeQuestionSection:
		m.ClearQuestionSection()
		return nil
	case tkquestionsection.EdgeSectionQuestion:
		m.ClearSectionQuestion()
		return nil
	}
	return fmt.Errorf("unknown TkQuestionSection unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TkQuestionSectionMutation) ResetEdge(name string) error {
	switch name {
	case tkquestionsection.EdgeQuestionSection:
		m.ResetQuestionSection()
		return nil
	case tkquestionsection.EdgeSectionQuestion:
		m.ResetSectionQuestion()
		return nil
	}
	return fmt.Errorf("unknown TkQuestionSection edge %s", name)
}

// TkSectionMutation represents an operation that mutates the TkSection nodes in the graph.
type TkSectionMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int
	uuid                          *string
	created_at                    *time.Time
	updated_at                    *time.Time
	deleted_at                    *time.Time
	name                          *string
	question_count                *int
	addquestion_count             *int
	clearedFields                 map[string]struct{}
	chapter                       *int
	clearedchapter                bool
	tk_section_links              map[int]struct{}
	removedtk_section_links       map[int]struct{}
	clearedtk_section_links       bool
	section_records               map[int]struct{}
	removedsection_records        map[int]struct{}
	clearedsection_records        bool
	user_section_exam             map[int]struct{}
	removeduser_section_exam      map[int]struct{}
	cleareduser_section_exam      bool
	make_user_question_sec        map[int]struct{}
	removedmake_user_question_sec map[int]struct{}
	clearedmake_user_question_sec bool
	done                          bool
	oldValue                      func(context.Context) (*TkSection, error)
	predicates                    []predicate.TkSection
}

var _ ent.Mutation = (*TkSectionMutation)(nil)

// tksectionOption allows management of the mutation configuration using functional options.
type tksectionOption func(*TkSectionMutation)

// newTkSectionMutation creates new mutation for the TkSection entity.
func newTkSectionMutation(c config, op Op, opts ...tksectionOption) *TkSectionMutation {
	m := &TkSectionMutation{
		config:        c,
		op:            op,
		typ:           TypeTkSection,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTkSectionID sets the ID field of the mutation.
func withTkSectionID(id int) tksectionOption {
	return func(m *TkSectionMutation) {
		var (
			err   error
			once  sync.Once
			value *TkSection
		)
		m.oldValue = func(ctx context.Context) (*TkSection, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TkSection.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTkSection sets the old TkSection of the mutation.
func withTkSection(node *TkSection) tksectionOption {
	return func(m *TkSectionMutation) {
		m.oldValue = func(context.Context) (*TkSection, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TkSectionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TkSectionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *TkSectionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *TkSectionMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *TkSectionMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the TkSection entity.
// If the TkSection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkSectionMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *TkSectionMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TkSectionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TkSectionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TkSection entity.
// If the TkSection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkSectionMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *TkSectionMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[tksection.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *TkSectionMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[tksection.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TkSectionMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, tksection.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TkSectionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TkSectionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TkSection entity.
// If the TkSection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkSectionMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TkSectionMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[tksection.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TkSectionMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[tksection.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TkSectionMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, tksection.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TkSectionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TkSectionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TkSection entity.
// If the TkSection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkSectionMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TkSectionMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[tksection.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TkSectionMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[tksection.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TkSectionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, tksection.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *TkSectionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TkSectionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TkSection entity.
// If the TkSection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkSectionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TkSectionMutation) ResetName() {
	m.name = nil
}

// SetChapterID sets the "chapter_id" field.
func (m *TkSectionMutation) SetChapterID(i int) {
	m.chapter = &i
}

// ChapterID returns the value of the "chapter_id" field in the mutation.
func (m *TkSectionMutation) ChapterID() (r int, exists bool) {
	v := m.chapter
	if v == nil {
		return
	}
	return *v, true
}

// OldChapterID returns the old "chapter_id" field's value of the TkSection entity.
// If the TkSection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkSectionMutation) OldChapterID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldChapterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldChapterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChapterID: %w", err)
	}
	return oldValue.ChapterID, nil
}

// ClearChapterID clears the value of the "chapter_id" field.
func (m *TkSectionMutation) ClearChapterID() {
	m.chapter = nil
	m.clearedFields[tksection.FieldChapterID] = struct{}{}
}

// ChapterIDCleared returns if the "chapter_id" field was cleared in this mutation.
func (m *TkSectionMutation) ChapterIDCleared() bool {
	_, ok := m.clearedFields[tksection.FieldChapterID]
	return ok
}

// ResetChapterID resets all changes to the "chapter_id" field.
func (m *TkSectionMutation) ResetChapterID() {
	m.chapter = nil
	delete(m.clearedFields, tksection.FieldChapterID)
}

// SetQuestionCount sets the "question_count" field.
func (m *TkSectionMutation) SetQuestionCount(i int) {
	m.question_count = &i
	m.addquestion_count = nil
}

// QuestionCount returns the value of the "question_count" field in the mutation.
func (m *TkSectionMutation) QuestionCount() (r int, exists bool) {
	v := m.question_count
	if v == nil {
		return
	}
	return *v, true
}

// OldQuestionCount returns the old "question_count" field's value of the TkSection entity.
// If the TkSection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkSectionMutation) OldQuestionCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldQuestionCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldQuestionCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuestionCount: %w", err)
	}
	return oldValue.QuestionCount, nil
}

// AddQuestionCount adds i to the "question_count" field.
func (m *TkSectionMutation) AddQuestionCount(i int) {
	if m.addquestion_count != nil {
		*m.addquestion_count += i
	} else {
		m.addquestion_count = &i
	}
}

// AddedQuestionCount returns the value that was added to the "question_count" field in this mutation.
func (m *TkSectionMutation) AddedQuestionCount() (r int, exists bool) {
	v := m.addquestion_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuestionCount resets all changes to the "question_count" field.
func (m *TkSectionMutation) ResetQuestionCount() {
	m.question_count = nil
	m.addquestion_count = nil
}

// ClearChapter clears the "chapter" edge to the TkChapter entity.
func (m *TkSectionMutation) ClearChapter() {
	m.clearedchapter = true
}

// ChapterCleared reports if the "chapter" edge to the TkChapter entity was cleared.
func (m *TkSectionMutation) ChapterCleared() bool {
	return m.ChapterIDCleared() || m.clearedchapter
}

// ChapterIDs returns the "chapter" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChapterID instead. It exists only for internal usage by the builders.
func (m *TkSectionMutation) ChapterIDs() (ids []int) {
	if id := m.chapter; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChapter resets all changes to the "chapter" edge.
func (m *TkSectionMutation) ResetChapter() {
	m.chapter = nil
	m.clearedchapter = false
}

// AddTkSectionLinkIDs adds the "tk_section_links" edge to the TkQuestionSection entity by ids.
func (m *TkSectionMutation) AddTkSectionLinkIDs(ids ...int) {
	if m.tk_section_links == nil {
		m.tk_section_links = make(map[int]struct{})
	}
	for i := range ids {
		m.tk_section_links[ids[i]] = struct{}{}
	}
}

// ClearTkSectionLinks clears the "tk_section_links" edge to the TkQuestionSection entity.
func (m *TkSectionMutation) ClearTkSectionLinks() {
	m.clearedtk_section_links = true
}

// TkSectionLinksCleared reports if the "tk_section_links" edge to the TkQuestionSection entity was cleared.
func (m *TkSectionMutation) TkSectionLinksCleared() bool {
	return m.clearedtk_section_links
}

// RemoveTkSectionLinkIDs removes the "tk_section_links" edge to the TkQuestionSection entity by IDs.
func (m *TkSectionMutation) RemoveTkSectionLinkIDs(ids ...int) {
	if m.removedtk_section_links == nil {
		m.removedtk_section_links = make(map[int]struct{})
	}
	for i := range ids {
		m.removedtk_section_links[ids[i]] = struct{}{}
	}
}

// RemovedTkSectionLinks returns the removed IDs of the "tk_section_links" edge to the TkQuestionSection entity.
func (m *TkSectionMutation) RemovedTkSectionLinksIDs() (ids []int) {
	for id := range m.removedtk_section_links {
		ids = append(ids, id)
	}
	return
}

// TkSectionLinksIDs returns the "tk_section_links" edge IDs in the mutation.
func (m *TkSectionMutation) TkSectionLinksIDs() (ids []int) {
	for id := range m.tk_section_links {
		ids = append(ids, id)
	}
	return
}

// ResetTkSectionLinks resets all changes to the "tk_section_links" edge.
func (m *TkSectionMutation) ResetTkSectionLinks() {
	m.tk_section_links = nil
	m.clearedtk_section_links = false
	m.removedtk_section_links = nil
}

// AddSectionRecordIDs adds the "section_records" edge to the TkUserQuestionRecord entity by ids.
func (m *TkSectionMutation) AddSectionRecordIDs(ids ...int) {
	if m.section_records == nil {
		m.section_records = make(map[int]struct{})
	}
	for i := range ids {
		m.section_records[ids[i]] = struct{}{}
	}
}

// ClearSectionRecords clears the "section_records" edge to the TkUserQuestionRecord entity.
func (m *TkSectionMutation) ClearSectionRecords() {
	m.clearedsection_records = true
}

// SectionRecordsCleared reports if the "section_records" edge to the TkUserQuestionRecord entity was cleared.
func (m *TkSectionMutation) SectionRecordsCleared() bool {
	return m.clearedsection_records
}

// RemoveSectionRecordIDs removes the "section_records" edge to the TkUserQuestionRecord entity by IDs.
func (m *TkSectionMutation) RemoveSectionRecordIDs(ids ...int) {
	if m.removedsection_records == nil {
		m.removedsection_records = make(map[int]struct{})
	}
	for i := range ids {
		m.removedsection_records[ids[i]] = struct{}{}
	}
}

// RemovedSectionRecords returns the removed IDs of the "section_records" edge to the TkUserQuestionRecord entity.
func (m *TkSectionMutation) RemovedSectionRecordsIDs() (ids []int) {
	for id := range m.removedsection_records {
		ids = append(ids, id)
	}
	return
}

// SectionRecordsIDs returns the "section_records" edge IDs in the mutation.
func (m *TkSectionMutation) SectionRecordsIDs() (ids []int) {
	for id := range m.section_records {
		ids = append(ids, id)
	}
	return
}

// ResetSectionRecords resets all changes to the "section_records" edge.
func (m *TkSectionMutation) ResetSectionRecords() {
	m.section_records = nil
	m.clearedsection_records = false
	m.removedsection_records = nil
}

// AddUserSectionExamIDs adds the "user_section_exam" edge to the TkUserExamScoreRecord entity by ids.
func (m *TkSectionMutation) AddUserSectionExamIDs(ids ...int) {
	if m.user_section_exam == nil {
		m.user_section_exam = make(map[int]struct{})
	}
	for i := range ids {
		m.user_section_exam[ids[i]] = struct{}{}
	}
}

// ClearUserSectionExam clears the "user_section_exam" edge to the TkUserExamScoreRecord entity.
func (m *TkSectionMutation) ClearUserSectionExam() {
	m.cleareduser_section_exam = true
}

// UserSectionExamCleared reports if the "user_section_exam" edge to the TkUserExamScoreRecord entity was cleared.
func (m *TkSectionMutation) UserSectionExamCleared() bool {
	return m.cleareduser_section_exam
}

// RemoveUserSectionExamIDs removes the "user_section_exam" edge to the TkUserExamScoreRecord entity by IDs.
func (m *TkSectionMutation) RemoveUserSectionExamIDs(ids ...int) {
	if m.removeduser_section_exam == nil {
		m.removeduser_section_exam = make(map[int]struct{})
	}
	for i := range ids {
		m.removeduser_section_exam[ids[i]] = struct{}{}
	}
}

// RemovedUserSectionExam returns the removed IDs of the "user_section_exam" edge to the TkUserExamScoreRecord entity.
func (m *TkSectionMutation) RemovedUserSectionExamIDs() (ids []int) {
	for id := range m.removeduser_section_exam {
		ids = append(ids, id)
	}
	return
}

// UserSectionExamIDs returns the "user_section_exam" edge IDs in the mutation.
func (m *TkSectionMutation) UserSectionExamIDs() (ids []int) {
	for id := range m.user_section_exam {
		ids = append(ids, id)
	}
	return
}

// ResetUserSectionExam resets all changes to the "user_section_exam" edge.
func (m *TkSectionMutation) ResetUserSectionExam() {
	m.user_section_exam = nil
	m.cleareduser_section_exam = false
	m.removeduser_section_exam = nil
}

// AddMakeUserQuestionSecIDs adds the "make_user_question_sec" edge to the MakeUserQuestionRecord entity by ids.
func (m *TkSectionMutation) AddMakeUserQuestionSecIDs(ids ...int) {
	if m.make_user_question_sec == nil {
		m.make_user_question_sec = make(map[int]struct{})
	}
	for i := range ids {
		m.make_user_question_sec[ids[i]] = struct{}{}
	}
}

// ClearMakeUserQuestionSec clears the "make_user_question_sec" edge to the MakeUserQuestionRecord entity.
func (m *TkSectionMutation) ClearMakeUserQuestionSec() {
	m.clearedmake_user_question_sec = true
}

// MakeUserQuestionSecCleared reports if the "make_user_question_sec" edge to the MakeUserQuestionRecord entity was cleared.
func (m *TkSectionMutation) MakeUserQuestionSecCleared() bool {
	return m.clearedmake_user_question_sec
}

// RemoveMakeUserQuestionSecIDs removes the "make_user_question_sec" edge to the MakeUserQuestionRecord entity by IDs.
func (m *TkSectionMutation) RemoveMakeUserQuestionSecIDs(ids ...int) {
	if m.removedmake_user_question_sec == nil {
		m.removedmake_user_question_sec = make(map[int]struct{})
	}
	for i := range ids {
		m.removedmake_user_question_sec[ids[i]] = struct{}{}
	}
}

// RemovedMakeUserQuestionSec returns the removed IDs of the "make_user_question_sec" edge to the MakeUserQuestionRecord entity.
func (m *TkSectionMutation) RemovedMakeUserQuestionSecIDs() (ids []int) {
	for id := range m.removedmake_user_question_sec {
		ids = append(ids, id)
	}
	return
}

// MakeUserQuestionSecIDs returns the "make_user_question_sec" edge IDs in the mutation.
func (m *TkSectionMutation) MakeUserQuestionSecIDs() (ids []int) {
	for id := range m.make_user_question_sec {
		ids = append(ids, id)
	}
	return
}

// ResetMakeUserQuestionSec resets all changes to the "make_user_question_sec" edge.
func (m *TkSectionMutation) ResetMakeUserQuestionSec() {
	m.make_user_question_sec = nil
	m.clearedmake_user_question_sec = false
	m.removedmake_user_question_sec = nil
}

// Op returns the operation name.
func (m *TkSectionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TkSection).
func (m *TkSectionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TkSectionMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.uuid != nil {
		fields = append(fields, tksection.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, tksection.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tksection.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, tksection.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, tksection.FieldName)
	}
	if m.chapter != nil {
		fields = append(fields, tksection.FieldChapterID)
	}
	if m.question_count != nil {
		fields = append(fields, tksection.FieldQuestionCount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TkSectionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tksection.FieldUUID:
		return m.UUID()
	case tksection.FieldCreatedAt:
		return m.CreatedAt()
	case tksection.FieldUpdatedAt:
		return m.UpdatedAt()
	case tksection.FieldDeletedAt:
		return m.DeletedAt()
	case tksection.FieldName:
		return m.Name()
	case tksection.FieldChapterID:
		return m.ChapterID()
	case tksection.FieldQuestionCount:
		return m.QuestionCount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TkSectionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tksection.FieldUUID:
		return m.OldUUID(ctx)
	case tksection.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tksection.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tksection.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case tksection.FieldName:
		return m.OldName(ctx)
	case tksection.FieldChapterID:
		return m.OldChapterID(ctx)
	case tksection.FieldQuestionCount:
		return m.OldQuestionCount(ctx)
	}
	return nil, fmt.Errorf("unknown TkSection field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TkSectionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tksection.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case tksection.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tksection.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tksection.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case tksection.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tksection.FieldChapterID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChapterID(v)
		return nil
	case tksection.FieldQuestionCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuestionCount(v)
		return nil
	}
	return fmt.Errorf("unknown TkSection field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TkSectionMutation) AddedFields() []string {
	var fields []string
	if m.addquestion_count != nil {
		fields = append(fields, tksection.FieldQuestionCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TkSectionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tksection.FieldQuestionCount:
		return m.AddedQuestionCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TkSectionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tksection.FieldQuestionCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuestionCount(v)
		return nil
	}
	return fmt.Errorf("unknown TkSection numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TkSectionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tksection.FieldCreatedAt) {
		fields = append(fields, tksection.FieldCreatedAt)
	}
	if m.FieldCleared(tksection.FieldUpdatedAt) {
		fields = append(fields, tksection.FieldUpdatedAt)
	}
	if m.FieldCleared(tksection.FieldDeletedAt) {
		fields = append(fields, tksection.FieldDeletedAt)
	}
	if m.FieldCleared(tksection.FieldChapterID) {
		fields = append(fields, tksection.FieldChapterID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TkSectionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TkSectionMutation) ClearField(name string) error {
	switch name {
	case tksection.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case tksection.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case tksection.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case tksection.FieldChapterID:
		m.ClearChapterID()
		return nil
	}
	return fmt.Errorf("unknown TkSection nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TkSectionMutation) ResetField(name string) error {
	switch name {
	case tksection.FieldUUID:
		m.ResetUUID()
		return nil
	case tksection.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tksection.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tksection.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case tksection.FieldName:
		m.ResetName()
		return nil
	case tksection.FieldChapterID:
		m.ResetChapterID()
		return nil
	case tksection.FieldQuestionCount:
		m.ResetQuestionCount()
		return nil
	}
	return fmt.Errorf("unknown TkSection field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TkSectionMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.chapter != nil {
		edges = append(edges, tksection.EdgeChapter)
	}
	if m.tk_section_links != nil {
		edges = append(edges, tksection.EdgeTkSectionLinks)
	}
	if m.section_records != nil {
		edges = append(edges, tksection.EdgeSectionRecords)
	}
	if m.user_section_exam != nil {
		edges = append(edges, tksection.EdgeUserSectionExam)
	}
	if m.make_user_question_sec != nil {
		edges = append(edges, tksection.EdgeMakeUserQuestionSec)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TkSectionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tksection.EdgeChapter:
		if id := m.chapter; id != nil {
			return []ent.Value{*id}
		}
	case tksection.EdgeTkSectionLinks:
		ids := make([]ent.Value, 0, len(m.tk_section_links))
		for id := range m.tk_section_links {
			ids = append(ids, id)
		}
		return ids
	case tksection.EdgeSectionRecords:
		ids := make([]ent.Value, 0, len(m.section_records))
		for id := range m.section_records {
			ids = append(ids, id)
		}
		return ids
	case tksection.EdgeUserSectionExam:
		ids := make([]ent.Value, 0, len(m.user_section_exam))
		for id := range m.user_section_exam {
			ids = append(ids, id)
		}
		return ids
	case tksection.EdgeMakeUserQuestionSec:
		ids := make([]ent.Value, 0, len(m.make_user_question_sec))
		for id := range m.make_user_question_sec {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TkSectionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedtk_section_links != nil {
		edges = append(edges, tksection.EdgeTkSectionLinks)
	}
	if m.removedsection_records != nil {
		edges = append(edges, tksection.EdgeSectionRecords)
	}
	if m.removeduser_section_exam != nil {
		edges = append(edges, tksection.EdgeUserSectionExam)
	}
	if m.removedmake_user_question_sec != nil {
		edges = append(edges, tksection.EdgeMakeUserQuestionSec)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TkSectionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tksection.EdgeTkSectionLinks:
		ids := make([]ent.Value, 0, len(m.removedtk_section_links))
		for id := range m.removedtk_section_links {
			ids = append(ids, id)
		}
		return ids
	case tksection.EdgeSectionRecords:
		ids := make([]ent.Value, 0, len(m.removedsection_records))
		for id := range m.removedsection_records {
			ids = append(ids, id)
		}
		return ids
	case tksection.EdgeUserSectionExam:
		ids := make([]ent.Value, 0, len(m.removeduser_section_exam))
		for id := range m.removeduser_section_exam {
			ids = append(ids, id)
		}
		return ids
	case tksection.EdgeMakeUserQuestionSec:
		ids := make([]ent.Value, 0, len(m.removedmake_user_question_sec))
		for id := range m.removedmake_user_question_sec {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TkSectionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedchapter {
		edges = append(edges, tksection.EdgeChapter)
	}
	if m.clearedtk_section_links {
		edges = append(edges, tksection.EdgeTkSectionLinks)
	}
	if m.clearedsection_records {
		edges = append(edges, tksection.EdgeSectionRecords)
	}
	if m.cleareduser_section_exam {
		edges = append(edges, tksection.EdgeUserSectionExam)
	}
	if m.clearedmake_user_question_sec {
		edges = append(edges, tksection.EdgeMakeUserQuestionSec)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TkSectionMutation) EdgeCleared(name string) bool {
	switch name {
	case tksection.EdgeChapter:
		return m.clearedchapter
	case tksection.EdgeTkSectionLinks:
		return m.clearedtk_section_links
	case tksection.EdgeSectionRecords:
		return m.clearedsection_records
	case tksection.EdgeUserSectionExam:
		return m.cleareduser_section_exam
	case tksection.EdgeMakeUserQuestionSec:
		return m.clearedmake_user_question_sec
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TkSectionMutation) ClearEdge(name string) error {
	switch name {
	case tksection.EdgeChapter:
		m.ClearChapter()
		return nil
	}
	return fmt.Errorf("unknown TkSection unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TkSectionMutation) ResetEdge(name string) error {
	switch name {
	case tksection.EdgeChapter:
		m.ResetChapter()
		return nil
	case tksection.EdgeTkSectionLinks:
		m.ResetTkSectionLinks()
		return nil
	case tksection.EdgeSectionRecords:
		m.ResetSectionRecords()
		return nil
	case tksection.EdgeUserSectionExam:
		m.ResetUserSectionExam()
		return nil
	case tksection.EdgeMakeUserQuestionSec:
		m.ResetMakeUserQuestionSec()
		return nil
	}
	return fmt.Errorf("unknown TkSection edge %s", name)
}

// TkUserExamScoreRecordMutation represents an operation that mutates the TkUserExamScoreRecord nodes in the graph.
type TkUserExamScoreRecordMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	uuid                         *string
	created_at                   *time.Time
	updated_at                   *time.Time
	deleted_at                   *time.Time
	subjective_question_score    *uint8
	addsubjective_question_score *uint8
	objective_question_score     *uint8
	addobjective_question_score  *uint8
	total_score                  *uint8
	addtotal_score               *uint8
	duration                     *int
	addduration                  *int
	right_count                  *int
	addright_count               *int
	wrong_count                  *int
	addwrong_count               *int
	total_count                  *int
	addtotal_count               *int
	no_answer_count              *int
	addno_answer_count           *int
	rank                         *int
	addrank                      *int
	status                       *uint8
	addstatus                    *uint8
	order_status                 *uint8
	addorder_status              *uint8
	clearedFields                map[string]struct{}
	exam_paper                   *int
	clearedexam_paper            bool
	section                      *int
	clearedsection               bool
	teacher                      *int
	clearedteacher               bool
	user                         *int
	cleareduser                  bool
	user_exam_details            map[int]struct{}
	removeduser_exam_details     map[int]struct{}
	cleareduser_exam_details     bool
	done                         bool
	oldValue                     func(context.Context) (*TkUserExamScoreRecord, error)
	predicates                   []predicate.TkUserExamScoreRecord
}

var _ ent.Mutation = (*TkUserExamScoreRecordMutation)(nil)

// tkuserexamscorerecordOption allows management of the mutation configuration using functional options.
type tkuserexamscorerecordOption func(*TkUserExamScoreRecordMutation)

// newTkUserExamScoreRecordMutation creates new mutation for the TkUserExamScoreRecord entity.
func newTkUserExamScoreRecordMutation(c config, op Op, opts ...tkuserexamscorerecordOption) *TkUserExamScoreRecordMutation {
	m := &TkUserExamScoreRecordMutation{
		config:        c,
		op:            op,
		typ:           TypeTkUserExamScoreRecord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTkUserExamScoreRecordID sets the ID field of the mutation.
func withTkUserExamScoreRecordID(id int) tkuserexamscorerecordOption {
	return func(m *TkUserExamScoreRecordMutation) {
		var (
			err   error
			once  sync.Once
			value *TkUserExamScoreRecord
		)
		m.oldValue = func(ctx context.Context) (*TkUserExamScoreRecord, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TkUserExamScoreRecord.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTkUserExamScoreRecord sets the old TkUserExamScoreRecord of the mutation.
func withTkUserExamScoreRecord(node *TkUserExamScoreRecord) tkuserexamscorerecordOption {
	return func(m *TkUserExamScoreRecordMutation) {
		m.oldValue = func(context.Context) (*TkUserExamScoreRecord, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TkUserExamScoreRecordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TkUserExamScoreRecordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *TkUserExamScoreRecordMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *TkUserExamScoreRecordMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *TkUserExamScoreRecordMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the TkUserExamScoreRecord entity.
// If the TkUserExamScoreRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserExamScoreRecordMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *TkUserExamScoreRecordMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TkUserExamScoreRecordMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TkUserExamScoreRecordMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TkUserExamScoreRecord entity.
// If the TkUserExamScoreRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserExamScoreRecordMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *TkUserExamScoreRecordMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[tkuserexamscorerecord.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *TkUserExamScoreRecordMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[tkuserexamscorerecord.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TkUserExamScoreRecordMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, tkuserexamscorerecord.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TkUserExamScoreRecordMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TkUserExamScoreRecordMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TkUserExamScoreRecord entity.
// If the TkUserExamScoreRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserExamScoreRecordMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TkUserExamScoreRecordMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[tkuserexamscorerecord.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TkUserExamScoreRecordMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[tkuserexamscorerecord.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TkUserExamScoreRecordMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, tkuserexamscorerecord.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TkUserExamScoreRecordMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TkUserExamScoreRecordMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TkUserExamScoreRecord entity.
// If the TkUserExamScoreRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserExamScoreRecordMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TkUserExamScoreRecordMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[tkuserexamscorerecord.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TkUserExamScoreRecordMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[tkuserexamscorerecord.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TkUserExamScoreRecordMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, tkuserexamscorerecord.FieldDeletedAt)
}

// SetSubjectiveQuestionScore sets the "subjective_question_score" field.
func (m *TkUserExamScoreRecordMutation) SetSubjectiveQuestionScore(u uint8) {
	m.subjective_question_score = &u
	m.addsubjective_question_score = nil
}

// SubjectiveQuestionScore returns the value of the "subjective_question_score" field in the mutation.
func (m *TkUserExamScoreRecordMutation) SubjectiveQuestionScore() (r uint8, exists bool) {
	v := m.subjective_question_score
	if v == nil {
		return
	}
	return *v, true
}

// OldSubjectiveQuestionScore returns the old "subjective_question_score" field's value of the TkUserExamScoreRecord entity.
// If the TkUserExamScoreRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserExamScoreRecordMutation) OldSubjectiveQuestionScore(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSubjectiveQuestionScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSubjectiveQuestionScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubjectiveQuestionScore: %w", err)
	}
	return oldValue.SubjectiveQuestionScore, nil
}

// AddSubjectiveQuestionScore adds u to the "subjective_question_score" field.
func (m *TkUserExamScoreRecordMutation) AddSubjectiveQuestionScore(u uint8) {
	if m.addsubjective_question_score != nil {
		*m.addsubjective_question_score += u
	} else {
		m.addsubjective_question_score = &u
	}
}

// AddedSubjectiveQuestionScore returns the value that was added to the "subjective_question_score" field in this mutation.
func (m *TkUserExamScoreRecordMutation) AddedSubjectiveQuestionScore() (r uint8, exists bool) {
	v := m.addsubjective_question_score
	if v == nil {
		return
	}
	return *v, true
}

// ResetSubjectiveQuestionScore resets all changes to the "subjective_question_score" field.
func (m *TkUserExamScoreRecordMutation) ResetSubjectiveQuestionScore() {
	m.subjective_question_score = nil
	m.addsubjective_question_score = nil
}

// SetObjectiveQuestionScore sets the "objective_question_score" field.
func (m *TkUserExamScoreRecordMutation) SetObjectiveQuestionScore(u uint8) {
	m.objective_question_score = &u
	m.addobjective_question_score = nil
}

// ObjectiveQuestionScore returns the value of the "objective_question_score" field in the mutation.
func (m *TkUserExamScoreRecordMutation) ObjectiveQuestionScore() (r uint8, exists bool) {
	v := m.objective_question_score
	if v == nil {
		return
	}
	return *v, true
}

// OldObjectiveQuestionScore returns the old "objective_question_score" field's value of the TkUserExamScoreRecord entity.
// If the TkUserExamScoreRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserExamScoreRecordMutation) OldObjectiveQuestionScore(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldObjectiveQuestionScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldObjectiveQuestionScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldObjectiveQuestionScore: %w", err)
	}
	return oldValue.ObjectiveQuestionScore, nil
}

// AddObjectiveQuestionScore adds u to the "objective_question_score" field.
func (m *TkUserExamScoreRecordMutation) AddObjectiveQuestionScore(u uint8) {
	if m.addobjective_question_score != nil {
		*m.addobjective_question_score += u
	} else {
		m.addobjective_question_score = &u
	}
}

// AddedObjectiveQuestionScore returns the value that was added to the "objective_question_score" field in this mutation.
func (m *TkUserExamScoreRecordMutation) AddedObjectiveQuestionScore() (r uint8, exists bool) {
	v := m.addobjective_question_score
	if v == nil {
		return
	}
	return *v, true
}

// ResetObjectiveQuestionScore resets all changes to the "objective_question_score" field.
func (m *TkUserExamScoreRecordMutation) ResetObjectiveQuestionScore() {
	m.objective_question_score = nil
	m.addobjective_question_score = nil
}

// SetTotalScore sets the "total_score" field.
func (m *TkUserExamScoreRecordMutation) SetTotalScore(u uint8) {
	m.total_score = &u
	m.addtotal_score = nil
}

// TotalScore returns the value of the "total_score" field in the mutation.
func (m *TkUserExamScoreRecordMutation) TotalScore() (r uint8, exists bool) {
	v := m.total_score
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalScore returns the old "total_score" field's value of the TkUserExamScoreRecord entity.
// If the TkUserExamScoreRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserExamScoreRecordMutation) OldTotalScore(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTotalScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTotalScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalScore: %w", err)
	}
	return oldValue.TotalScore, nil
}

// AddTotalScore adds u to the "total_score" field.
func (m *TkUserExamScoreRecordMutation) AddTotalScore(u uint8) {
	if m.addtotal_score != nil {
		*m.addtotal_score += u
	} else {
		m.addtotal_score = &u
	}
}

// AddedTotalScore returns the value that was added to the "total_score" field in this mutation.
func (m *TkUserExamScoreRecordMutation) AddedTotalScore() (r uint8, exists bool) {
	v := m.addtotal_score
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalScore resets all changes to the "total_score" field.
func (m *TkUserExamScoreRecordMutation) ResetTotalScore() {
	m.total_score = nil
	m.addtotal_score = nil
}

// SetDuration sets the "duration" field.
func (m *TkUserExamScoreRecordMutation) SetDuration(i int) {
	m.duration = &i
	m.addduration = nil
}

// Duration returns the value of the "duration" field in the mutation.
func (m *TkUserExamScoreRecordMutation) Duration() (r int, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old "duration" field's value of the TkUserExamScoreRecord entity.
// If the TkUserExamScoreRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserExamScoreRecordMutation) OldDuration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// AddDuration adds i to the "duration" field.
func (m *TkUserExamScoreRecordMutation) AddDuration(i int) {
	if m.addduration != nil {
		*m.addduration += i
	} else {
		m.addduration = &i
	}
}

// AddedDuration returns the value that was added to the "duration" field in this mutation.
func (m *TkUserExamScoreRecordMutation) AddedDuration() (r int, exists bool) {
	v := m.addduration
	if v == nil {
		return
	}
	return *v, true
}

// ResetDuration resets all changes to the "duration" field.
func (m *TkUserExamScoreRecordMutation) ResetDuration() {
	m.duration = nil
	m.addduration = nil
}

// SetRightCount sets the "right_count" field.
func (m *TkUserExamScoreRecordMutation) SetRightCount(i int) {
	m.right_count = &i
	m.addright_count = nil
}

// RightCount returns the value of the "right_count" field in the mutation.
func (m *TkUserExamScoreRecordMutation) RightCount() (r int, exists bool) {
	v := m.right_count
	if v == nil {
		return
	}
	return *v, true
}

// OldRightCount returns the old "right_count" field's value of the TkUserExamScoreRecord entity.
// If the TkUserExamScoreRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserExamScoreRecordMutation) OldRightCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRightCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRightCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRightCount: %w", err)
	}
	return oldValue.RightCount, nil
}

// AddRightCount adds i to the "right_count" field.
func (m *TkUserExamScoreRecordMutation) AddRightCount(i int) {
	if m.addright_count != nil {
		*m.addright_count += i
	} else {
		m.addright_count = &i
	}
}

// AddedRightCount returns the value that was added to the "right_count" field in this mutation.
func (m *TkUserExamScoreRecordMutation) AddedRightCount() (r int, exists bool) {
	v := m.addright_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetRightCount resets all changes to the "right_count" field.
func (m *TkUserExamScoreRecordMutation) ResetRightCount() {
	m.right_count = nil
	m.addright_count = nil
}

// SetWrongCount sets the "wrong_count" field.
func (m *TkUserExamScoreRecordMutation) SetWrongCount(i int) {
	m.wrong_count = &i
	m.addwrong_count = nil
}

// WrongCount returns the value of the "wrong_count" field in the mutation.
func (m *TkUserExamScoreRecordMutation) WrongCount() (r int, exists bool) {
	v := m.wrong_count
	if v == nil {
		return
	}
	return *v, true
}

// OldWrongCount returns the old "wrong_count" field's value of the TkUserExamScoreRecord entity.
// If the TkUserExamScoreRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserExamScoreRecordMutation) OldWrongCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWrongCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWrongCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWrongCount: %w", err)
	}
	return oldValue.WrongCount, nil
}

// AddWrongCount adds i to the "wrong_count" field.
func (m *TkUserExamScoreRecordMutation) AddWrongCount(i int) {
	if m.addwrong_count != nil {
		*m.addwrong_count += i
	} else {
		m.addwrong_count = &i
	}
}

// AddedWrongCount returns the value that was added to the "wrong_count" field in this mutation.
func (m *TkUserExamScoreRecordMutation) AddedWrongCount() (r int, exists bool) {
	v := m.addwrong_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetWrongCount resets all changes to the "wrong_count" field.
func (m *TkUserExamScoreRecordMutation) ResetWrongCount() {
	m.wrong_count = nil
	m.addwrong_count = nil
}

// SetTotalCount sets the "total_count" field.
func (m *TkUserExamScoreRecordMutation) SetTotalCount(i int) {
	m.total_count = &i
	m.addtotal_count = nil
}

// TotalCount returns the value of the "total_count" field in the mutation.
func (m *TkUserExamScoreRecordMutation) TotalCount() (r int, exists bool) {
	v := m.total_count
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalCount returns the old "total_count" field's value of the TkUserExamScoreRecord entity.
// If the TkUserExamScoreRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserExamScoreRecordMutation) OldTotalCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTotalCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTotalCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalCount: %w", err)
	}
	return oldValue.TotalCount, nil
}

// AddTotalCount adds i to the "total_count" field.
func (m *TkUserExamScoreRecordMutation) AddTotalCount(i int) {
	if m.addtotal_count != nil {
		*m.addtotal_count += i
	} else {
		m.addtotal_count = &i
	}
}

// AddedTotalCount returns the value that was added to the "total_count" field in this mutation.
func (m *TkUserExamScoreRecordMutation) AddedTotalCount() (r int, exists bool) {
	v := m.addtotal_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalCount resets all changes to the "total_count" field.
func (m *TkUserExamScoreRecordMutation) ResetTotalCount() {
	m.total_count = nil
	m.addtotal_count = nil
}

// SetNoAnswerCount sets the "no_answer_count" field.
func (m *TkUserExamScoreRecordMutation) SetNoAnswerCount(i int) {
	m.no_answer_count = &i
	m.addno_answer_count = nil
}

// NoAnswerCount returns the value of the "no_answer_count" field in the mutation.
func (m *TkUserExamScoreRecordMutation) NoAnswerCount() (r int, exists bool) {
	v := m.no_answer_count
	if v == nil {
		return
	}
	return *v, true
}

// OldNoAnswerCount returns the old "no_answer_count" field's value of the TkUserExamScoreRecord entity.
// If the TkUserExamScoreRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserExamScoreRecordMutation) OldNoAnswerCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNoAnswerCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNoAnswerCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNoAnswerCount: %w", err)
	}
	return oldValue.NoAnswerCount, nil
}

// AddNoAnswerCount adds i to the "no_answer_count" field.
func (m *TkUserExamScoreRecordMutation) AddNoAnswerCount(i int) {
	if m.addno_answer_count != nil {
		*m.addno_answer_count += i
	} else {
		m.addno_answer_count = &i
	}
}

// AddedNoAnswerCount returns the value that was added to the "no_answer_count" field in this mutation.
func (m *TkUserExamScoreRecordMutation) AddedNoAnswerCount() (r int, exists bool) {
	v := m.addno_answer_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetNoAnswerCount resets all changes to the "no_answer_count" field.
func (m *TkUserExamScoreRecordMutation) ResetNoAnswerCount() {
	m.no_answer_count = nil
	m.addno_answer_count = nil
}

// SetRank sets the "rank" field.
func (m *TkUserExamScoreRecordMutation) SetRank(i int) {
	m.rank = &i
	m.addrank = nil
}

// Rank returns the value of the "rank" field in the mutation.
func (m *TkUserExamScoreRecordMutation) Rank() (r int, exists bool) {
	v := m.rank
	if v == nil {
		return
	}
	return *v, true
}

// OldRank returns the old "rank" field's value of the TkUserExamScoreRecord entity.
// If the TkUserExamScoreRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserExamScoreRecordMutation) OldRank(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRank is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRank requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRank: %w", err)
	}
	return oldValue.Rank, nil
}

// AddRank adds i to the "rank" field.
func (m *TkUserExamScoreRecordMutation) AddRank(i int) {
	if m.addrank != nil {
		*m.addrank += i
	} else {
		m.addrank = &i
	}
}

// AddedRank returns the value that was added to the "rank" field in this mutation.
func (m *TkUserExamScoreRecordMutation) AddedRank() (r int, exists bool) {
	v := m.addrank
	if v == nil {
		return
	}
	return *v, true
}

// ResetRank resets all changes to the "rank" field.
func (m *TkUserExamScoreRecordMutation) ResetRank() {
	m.rank = nil
	m.addrank = nil
}

// SetStatus sets the "status" field.
func (m *TkUserExamScoreRecordMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *TkUserExamScoreRecordMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the TkUserExamScoreRecord entity.
// If the TkUserExamScoreRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserExamScoreRecordMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *TkUserExamScoreRecordMutation) AddStatus(u uint8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *TkUserExamScoreRecordMutation) AddedStatus() (r uint8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *TkUserExamScoreRecordMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetOrderStatus sets the "order_status" field.
func (m *TkUserExamScoreRecordMutation) SetOrderStatus(u uint8) {
	m.order_status = &u
	m.addorder_status = nil
}

// OrderStatus returns the value of the "order_status" field in the mutation.
func (m *TkUserExamScoreRecordMutation) OrderStatus() (r uint8, exists bool) {
	v := m.order_status
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderStatus returns the old "order_status" field's value of the TkUserExamScoreRecord entity.
// If the TkUserExamScoreRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserExamScoreRecordMutation) OldOrderStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOrderStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOrderStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderStatus: %w", err)
	}
	return oldValue.OrderStatus, nil
}

// AddOrderStatus adds u to the "order_status" field.
func (m *TkUserExamScoreRecordMutation) AddOrderStatus(u uint8) {
	if m.addorder_status != nil {
		*m.addorder_status += u
	} else {
		m.addorder_status = &u
	}
}

// AddedOrderStatus returns the value that was added to the "order_status" field in this mutation.
func (m *TkUserExamScoreRecordMutation) AddedOrderStatus() (r uint8, exists bool) {
	v := m.addorder_status
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderStatus resets all changes to the "order_status" field.
func (m *TkUserExamScoreRecordMutation) ResetOrderStatus() {
	m.order_status = nil
	m.addorder_status = nil
}

// SetExamPaperID sets the "exam_paper_id" field.
func (m *TkUserExamScoreRecordMutation) SetExamPaperID(i int) {
	m.exam_paper = &i
}

// ExamPaperID returns the value of the "exam_paper_id" field in the mutation.
func (m *TkUserExamScoreRecordMutation) ExamPaperID() (r int, exists bool) {
	v := m.exam_paper
	if v == nil {
		return
	}
	return *v, true
}

// OldExamPaperID returns the old "exam_paper_id" field's value of the TkUserExamScoreRecord entity.
// If the TkUserExamScoreRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserExamScoreRecordMutation) OldExamPaperID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExamPaperID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExamPaperID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamPaperID: %w", err)
	}
	return oldValue.ExamPaperID, nil
}

// ClearExamPaperID clears the value of the "exam_paper_id" field.
func (m *TkUserExamScoreRecordMutation) ClearExamPaperID() {
	m.exam_paper = nil
	m.clearedFields[tkuserexamscorerecord.FieldExamPaperID] = struct{}{}
}

// ExamPaperIDCleared returns if the "exam_paper_id" field was cleared in this mutation.
func (m *TkUserExamScoreRecordMutation) ExamPaperIDCleared() bool {
	_, ok := m.clearedFields[tkuserexamscorerecord.FieldExamPaperID]
	return ok
}

// ResetExamPaperID resets all changes to the "exam_paper_id" field.
func (m *TkUserExamScoreRecordMutation) ResetExamPaperID() {
	m.exam_paper = nil
	delete(m.clearedFields, tkuserexamscorerecord.FieldExamPaperID)
}

// SetSectionID sets the "section_id" field.
func (m *TkUserExamScoreRecordMutation) SetSectionID(i int) {
	m.section = &i
}

// SectionID returns the value of the "section_id" field in the mutation.
func (m *TkUserExamScoreRecordMutation) SectionID() (r int, exists bool) {
	v := m.section
	if v == nil {
		return
	}
	return *v, true
}

// OldSectionID returns the old "section_id" field's value of the TkUserExamScoreRecord entity.
// If the TkUserExamScoreRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserExamScoreRecordMutation) OldSectionID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSectionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSectionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSectionID: %w", err)
	}
	return oldValue.SectionID, nil
}

// ClearSectionID clears the value of the "section_id" field.
func (m *TkUserExamScoreRecordMutation) ClearSectionID() {
	m.section = nil
	m.clearedFields[tkuserexamscorerecord.FieldSectionID] = struct{}{}
}

// SectionIDCleared returns if the "section_id" field was cleared in this mutation.
func (m *TkUserExamScoreRecordMutation) SectionIDCleared() bool {
	_, ok := m.clearedFields[tkuserexamscorerecord.FieldSectionID]
	return ok
}

// ResetSectionID resets all changes to the "section_id" field.
func (m *TkUserExamScoreRecordMutation) ResetSectionID() {
	m.section = nil
	delete(m.clearedFields, tkuserexamscorerecord.FieldSectionID)
}

// SetUserID sets the "user_id" field.
func (m *TkUserExamScoreRecordMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *TkUserExamScoreRecordMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the TkUserExamScoreRecord entity.
// If the TkUserExamScoreRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserExamScoreRecordMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *TkUserExamScoreRecordMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[tkuserexamscorerecord.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *TkUserExamScoreRecordMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[tkuserexamscorerecord.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *TkUserExamScoreRecordMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, tkuserexamscorerecord.FieldUserID)
}

// SetOperationTeacherID sets the "operation_teacher_id" field.
func (m *TkUserExamScoreRecordMutation) SetOperationTeacherID(i int) {
	m.teacher = &i
}

// OperationTeacherID returns the value of the "operation_teacher_id" field in the mutation.
func (m *TkUserExamScoreRecordMutation) OperationTeacherID() (r int, exists bool) {
	v := m.teacher
	if v == nil {
		return
	}
	return *v, true
}

// OldOperationTeacherID returns the old "operation_teacher_id" field's value of the TkUserExamScoreRecord entity.
// If the TkUserExamScoreRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserExamScoreRecordMutation) OldOperationTeacherID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOperationTeacherID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOperationTeacherID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperationTeacherID: %w", err)
	}
	return oldValue.OperationTeacherID, nil
}

// ClearOperationTeacherID clears the value of the "operation_teacher_id" field.
func (m *TkUserExamScoreRecordMutation) ClearOperationTeacherID() {
	m.teacher = nil
	m.clearedFields[tkuserexamscorerecord.FieldOperationTeacherID] = struct{}{}
}

// OperationTeacherIDCleared returns if the "operation_teacher_id" field was cleared in this mutation.
func (m *TkUserExamScoreRecordMutation) OperationTeacherIDCleared() bool {
	_, ok := m.clearedFields[tkuserexamscorerecord.FieldOperationTeacherID]
	return ok
}

// ResetOperationTeacherID resets all changes to the "operation_teacher_id" field.
func (m *TkUserExamScoreRecordMutation) ResetOperationTeacherID() {
	m.teacher = nil
	delete(m.clearedFields, tkuserexamscorerecord.FieldOperationTeacherID)
}

// ClearExamPaper clears the "exam_paper" edge to the TkExamPaper entity.
func (m *TkUserExamScoreRecordMutation) ClearExamPaper() {
	m.clearedexam_paper = true
}

// ExamPaperCleared reports if the "exam_paper" edge to the TkExamPaper entity was cleared.
func (m *TkUserExamScoreRecordMutation) ExamPaperCleared() bool {
	return m.ExamPaperIDCleared() || m.clearedexam_paper
}

// ExamPaperIDs returns the "exam_paper" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ExamPaperID instead. It exists only for internal usage by the builders.
func (m *TkUserExamScoreRecordMutation) ExamPaperIDs() (ids []int) {
	if id := m.exam_paper; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExamPaper resets all changes to the "exam_paper" edge.
func (m *TkUserExamScoreRecordMutation) ResetExamPaper() {
	m.exam_paper = nil
	m.clearedexam_paper = false
}

// ClearSection clears the "section" edge to the TkSection entity.
func (m *TkUserExamScoreRecordMutation) ClearSection() {
	m.clearedsection = true
}

// SectionCleared reports if the "section" edge to the TkSection entity was cleared.
func (m *TkUserExamScoreRecordMutation) SectionCleared() bool {
	return m.SectionIDCleared() || m.clearedsection
}

// SectionIDs returns the "section" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SectionID instead. It exists only for internal usage by the builders.
func (m *TkUserExamScoreRecordMutation) SectionIDs() (ids []int) {
	if id := m.section; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSection resets all changes to the "section" edge.
func (m *TkUserExamScoreRecordMutation) ResetSection() {
	m.section = nil
	m.clearedsection = false
}

// SetTeacherID sets the "teacher" edge to the Teacher entity by id.
func (m *TkUserExamScoreRecordMutation) SetTeacherID(id int) {
	m.teacher = &id
}

// ClearTeacher clears the "teacher" edge to the Teacher entity.
func (m *TkUserExamScoreRecordMutation) ClearTeacher() {
	m.clearedteacher = true
}

// TeacherCleared reports if the "teacher" edge to the Teacher entity was cleared.
func (m *TkUserExamScoreRecordMutation) TeacherCleared() bool {
	return m.OperationTeacherIDCleared() || m.clearedteacher
}

// TeacherID returns the "teacher" edge ID in the mutation.
func (m *TkUserExamScoreRecordMutation) TeacherID() (id int, exists bool) {
	if m.teacher != nil {
		return *m.teacher, true
	}
	return
}

// TeacherIDs returns the "teacher" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeacherID instead. It exists only for internal usage by the builders.
func (m *TkUserExamScoreRecordMutation) TeacherIDs() (ids []int) {
	if id := m.teacher; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeacher resets all changes to the "teacher" edge.
func (m *TkUserExamScoreRecordMutation) ResetTeacher() {
	m.teacher = nil
	m.clearedteacher = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *TkUserExamScoreRecordMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *TkUserExamScoreRecordMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *TkUserExamScoreRecordMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *TkUserExamScoreRecordMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddUserExamDetailIDs adds the "user_exam_details" edge to the TkUserSimulationTeacherMark entity by ids.
func (m *TkUserExamScoreRecordMutation) AddUserExamDetailIDs(ids ...int) {
	if m.user_exam_details == nil {
		m.user_exam_details = make(map[int]struct{})
	}
	for i := range ids {
		m.user_exam_details[ids[i]] = struct{}{}
	}
}

// ClearUserExamDetails clears the "user_exam_details" edge to the TkUserSimulationTeacherMark entity.
func (m *TkUserExamScoreRecordMutation) ClearUserExamDetails() {
	m.cleareduser_exam_details = true
}

// UserExamDetailsCleared reports if the "user_exam_details" edge to the TkUserSimulationTeacherMark entity was cleared.
func (m *TkUserExamScoreRecordMutation) UserExamDetailsCleared() bool {
	return m.cleareduser_exam_details
}

// RemoveUserExamDetailIDs removes the "user_exam_details" edge to the TkUserSimulationTeacherMark entity by IDs.
func (m *TkUserExamScoreRecordMutation) RemoveUserExamDetailIDs(ids ...int) {
	if m.removeduser_exam_details == nil {
		m.removeduser_exam_details = make(map[int]struct{})
	}
	for i := range ids {
		m.removeduser_exam_details[ids[i]] = struct{}{}
	}
}

// RemovedUserExamDetails returns the removed IDs of the "user_exam_details" edge to the TkUserSimulationTeacherMark entity.
func (m *TkUserExamScoreRecordMutation) RemovedUserExamDetailsIDs() (ids []int) {
	for id := range m.removeduser_exam_details {
		ids = append(ids, id)
	}
	return
}

// UserExamDetailsIDs returns the "user_exam_details" edge IDs in the mutation.
func (m *TkUserExamScoreRecordMutation) UserExamDetailsIDs() (ids []int) {
	for id := range m.user_exam_details {
		ids = append(ids, id)
	}
	return
}

// ResetUserExamDetails resets all changes to the "user_exam_details" edge.
func (m *TkUserExamScoreRecordMutation) ResetUserExamDetails() {
	m.user_exam_details = nil
	m.cleareduser_exam_details = false
	m.removeduser_exam_details = nil
}

// Op returns the operation name.
func (m *TkUserExamScoreRecordMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TkUserExamScoreRecord).
func (m *TkUserExamScoreRecordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TkUserExamScoreRecordMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.uuid != nil {
		fields = append(fields, tkuserexamscorerecord.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, tkuserexamscorerecord.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tkuserexamscorerecord.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, tkuserexamscorerecord.FieldDeletedAt)
	}
	if m.subjective_question_score != nil {
		fields = append(fields, tkuserexamscorerecord.FieldSubjectiveQuestionScore)
	}
	if m.objective_question_score != nil {
		fields = append(fields, tkuserexamscorerecord.FieldObjectiveQuestionScore)
	}
	if m.total_score != nil {
		fields = append(fields, tkuserexamscorerecord.FieldTotalScore)
	}
	if m.duration != nil {
		fields = append(fields, tkuserexamscorerecord.FieldDuration)
	}
	if m.right_count != nil {
		fields = append(fields, tkuserexamscorerecord.FieldRightCount)
	}
	if m.wrong_count != nil {
		fields = append(fields, tkuserexamscorerecord.FieldWrongCount)
	}
	if m.total_count != nil {
		fields = append(fields, tkuserexamscorerecord.FieldTotalCount)
	}
	if m.no_answer_count != nil {
		fields = append(fields, tkuserexamscorerecord.FieldNoAnswerCount)
	}
	if m.rank != nil {
		fields = append(fields, tkuserexamscorerecord.FieldRank)
	}
	if m.status != nil {
		fields = append(fields, tkuserexamscorerecord.FieldStatus)
	}
	if m.order_status != nil {
		fields = append(fields, tkuserexamscorerecord.FieldOrderStatus)
	}
	if m.exam_paper != nil {
		fields = append(fields, tkuserexamscorerecord.FieldExamPaperID)
	}
	if m.section != nil {
		fields = append(fields, tkuserexamscorerecord.FieldSectionID)
	}
	if m.user != nil {
		fields = append(fields, tkuserexamscorerecord.FieldUserID)
	}
	if m.teacher != nil {
		fields = append(fields, tkuserexamscorerecord.FieldOperationTeacherID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TkUserExamScoreRecordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tkuserexamscorerecord.FieldUUID:
		return m.UUID()
	case tkuserexamscorerecord.FieldCreatedAt:
		return m.CreatedAt()
	case tkuserexamscorerecord.FieldUpdatedAt:
		return m.UpdatedAt()
	case tkuserexamscorerecord.FieldDeletedAt:
		return m.DeletedAt()
	case tkuserexamscorerecord.FieldSubjectiveQuestionScore:
		return m.SubjectiveQuestionScore()
	case tkuserexamscorerecord.FieldObjectiveQuestionScore:
		return m.ObjectiveQuestionScore()
	case tkuserexamscorerecord.FieldTotalScore:
		return m.TotalScore()
	case tkuserexamscorerecord.FieldDuration:
		return m.Duration()
	case tkuserexamscorerecord.FieldRightCount:
		return m.RightCount()
	case tkuserexamscorerecord.FieldWrongCount:
		return m.WrongCount()
	case tkuserexamscorerecord.FieldTotalCount:
		return m.TotalCount()
	case tkuserexamscorerecord.FieldNoAnswerCount:
		return m.NoAnswerCount()
	case tkuserexamscorerecord.FieldRank:
		return m.Rank()
	case tkuserexamscorerecord.FieldStatus:
		return m.Status()
	case tkuserexamscorerecord.FieldOrderStatus:
		return m.OrderStatus()
	case tkuserexamscorerecord.FieldExamPaperID:
		return m.ExamPaperID()
	case tkuserexamscorerecord.FieldSectionID:
		return m.SectionID()
	case tkuserexamscorerecord.FieldUserID:
		return m.UserID()
	case tkuserexamscorerecord.FieldOperationTeacherID:
		return m.OperationTeacherID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TkUserExamScoreRecordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tkuserexamscorerecord.FieldUUID:
		return m.OldUUID(ctx)
	case tkuserexamscorerecord.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tkuserexamscorerecord.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tkuserexamscorerecord.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case tkuserexamscorerecord.FieldSubjectiveQuestionScore:
		return m.OldSubjectiveQuestionScore(ctx)
	case tkuserexamscorerecord.FieldObjectiveQuestionScore:
		return m.OldObjectiveQuestionScore(ctx)
	case tkuserexamscorerecord.FieldTotalScore:
		return m.OldTotalScore(ctx)
	case tkuserexamscorerecord.FieldDuration:
		return m.OldDuration(ctx)
	case tkuserexamscorerecord.FieldRightCount:
		return m.OldRightCount(ctx)
	case tkuserexamscorerecord.FieldWrongCount:
		return m.OldWrongCount(ctx)
	case tkuserexamscorerecord.FieldTotalCount:
		return m.OldTotalCount(ctx)
	case tkuserexamscorerecord.FieldNoAnswerCount:
		return m.OldNoAnswerCount(ctx)
	case tkuserexamscorerecord.FieldRank:
		return m.OldRank(ctx)
	case tkuserexamscorerecord.FieldStatus:
		return m.OldStatus(ctx)
	case tkuserexamscorerecord.FieldOrderStatus:
		return m.OldOrderStatus(ctx)
	case tkuserexamscorerecord.FieldExamPaperID:
		return m.OldExamPaperID(ctx)
	case tkuserexamscorerecord.FieldSectionID:
		return m.OldSectionID(ctx)
	case tkuserexamscorerecord.FieldUserID:
		return m.OldUserID(ctx)
	case tkuserexamscorerecord.FieldOperationTeacherID:
		return m.OldOperationTeacherID(ctx)
	}
	return nil, fmt.Errorf("unknown TkUserExamScoreRecord field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TkUserExamScoreRecordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tkuserexamscorerecord.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case tkuserexamscorerecord.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tkuserexamscorerecord.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tkuserexamscorerecord.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case tkuserexamscorerecord.FieldSubjectiveQuestionScore:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubjectiveQuestionScore(v)
		return nil
	case tkuserexamscorerecord.FieldObjectiveQuestionScore:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetObjectiveQuestionScore(v)
		return nil
	case tkuserexamscorerecord.FieldTotalScore:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalScore(v)
		return nil
	case tkuserexamscorerecord.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	case tkuserexamscorerecord.FieldRightCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRightCount(v)
		return nil
	case tkuserexamscorerecord.FieldWrongCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWrongCount(v)
		return nil
	case tkuserexamscorerecord.FieldTotalCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalCount(v)
		return nil
	case tkuserexamscorerecord.FieldNoAnswerCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNoAnswerCount(v)
		return nil
	case tkuserexamscorerecord.FieldRank:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRank(v)
		return nil
	case tkuserexamscorerecord.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case tkuserexamscorerecord.FieldOrderStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderStatus(v)
		return nil
	case tkuserexamscorerecord.FieldExamPaperID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamPaperID(v)
		return nil
	case tkuserexamscorerecord.FieldSectionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSectionID(v)
		return nil
	case tkuserexamscorerecord.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case tkuserexamscorerecord.FieldOperationTeacherID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperationTeacherID(v)
		return nil
	}
	return fmt.Errorf("unknown TkUserExamScoreRecord field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TkUserExamScoreRecordMutation) AddedFields() []string {
	var fields []string
	if m.addsubjective_question_score != nil {
		fields = append(fields, tkuserexamscorerecord.FieldSubjectiveQuestionScore)
	}
	if m.addobjective_question_score != nil {
		fields = append(fields, tkuserexamscorerecord.FieldObjectiveQuestionScore)
	}
	if m.addtotal_score != nil {
		fields = append(fields, tkuserexamscorerecord.FieldTotalScore)
	}
	if m.addduration != nil {
		fields = append(fields, tkuserexamscorerecord.FieldDuration)
	}
	if m.addright_count != nil {
		fields = append(fields, tkuserexamscorerecord.FieldRightCount)
	}
	if m.addwrong_count != nil {
		fields = append(fields, tkuserexamscorerecord.FieldWrongCount)
	}
	if m.addtotal_count != nil {
		fields = append(fields, tkuserexamscorerecord.FieldTotalCount)
	}
	if m.addno_answer_count != nil {
		fields = append(fields, tkuserexamscorerecord.FieldNoAnswerCount)
	}
	if m.addrank != nil {
		fields = append(fields, tkuserexamscorerecord.FieldRank)
	}
	if m.addstatus != nil {
		fields = append(fields, tkuserexamscorerecord.FieldStatus)
	}
	if m.addorder_status != nil {
		fields = append(fields, tkuserexamscorerecord.FieldOrderStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TkUserExamScoreRecordMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tkuserexamscorerecord.FieldSubjectiveQuestionScore:
		return m.AddedSubjectiveQuestionScore()
	case tkuserexamscorerecord.FieldObjectiveQuestionScore:
		return m.AddedObjectiveQuestionScore()
	case tkuserexamscorerecord.FieldTotalScore:
		return m.AddedTotalScore()
	case tkuserexamscorerecord.FieldDuration:
		return m.AddedDuration()
	case tkuserexamscorerecord.FieldRightCount:
		return m.AddedRightCount()
	case tkuserexamscorerecord.FieldWrongCount:
		return m.AddedWrongCount()
	case tkuserexamscorerecord.FieldTotalCount:
		return m.AddedTotalCount()
	case tkuserexamscorerecord.FieldNoAnswerCount:
		return m.AddedNoAnswerCount()
	case tkuserexamscorerecord.FieldRank:
		return m.AddedRank()
	case tkuserexamscorerecord.FieldStatus:
		return m.AddedStatus()
	case tkuserexamscorerecord.FieldOrderStatus:
		return m.AddedOrderStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TkUserExamScoreRecordMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tkuserexamscorerecord.FieldSubjectiveQuestionScore:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSubjectiveQuestionScore(v)
		return nil
	case tkuserexamscorerecord.FieldObjectiveQuestionScore:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddObjectiveQuestionScore(v)
		return nil
	case tkuserexamscorerecord.FieldTotalScore:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalScore(v)
		return nil
	case tkuserexamscorerecord.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDuration(v)
		return nil
	case tkuserexamscorerecord.FieldRightCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRightCount(v)
		return nil
	case tkuserexamscorerecord.FieldWrongCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWrongCount(v)
		return nil
	case tkuserexamscorerecord.FieldTotalCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalCount(v)
		return nil
	case tkuserexamscorerecord.FieldNoAnswerCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNoAnswerCount(v)
		return nil
	case tkuserexamscorerecord.FieldRank:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRank(v)
		return nil
	case tkuserexamscorerecord.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case tkuserexamscorerecord.FieldOrderStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderStatus(v)
		return nil
	}
	return fmt.Errorf("unknown TkUserExamScoreRecord numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TkUserExamScoreRecordMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tkuserexamscorerecord.FieldCreatedAt) {
		fields = append(fields, tkuserexamscorerecord.FieldCreatedAt)
	}
	if m.FieldCleared(tkuserexamscorerecord.FieldUpdatedAt) {
		fields = append(fields, tkuserexamscorerecord.FieldUpdatedAt)
	}
	if m.FieldCleared(tkuserexamscorerecord.FieldDeletedAt) {
		fields = append(fields, tkuserexamscorerecord.FieldDeletedAt)
	}
	if m.FieldCleared(tkuserexamscorerecord.FieldExamPaperID) {
		fields = append(fields, tkuserexamscorerecord.FieldExamPaperID)
	}
	if m.FieldCleared(tkuserexamscorerecord.FieldSectionID) {
		fields = append(fields, tkuserexamscorerecord.FieldSectionID)
	}
	if m.FieldCleared(tkuserexamscorerecord.FieldUserID) {
		fields = append(fields, tkuserexamscorerecord.FieldUserID)
	}
	if m.FieldCleared(tkuserexamscorerecord.FieldOperationTeacherID) {
		fields = append(fields, tkuserexamscorerecord.FieldOperationTeacherID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TkUserExamScoreRecordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TkUserExamScoreRecordMutation) ClearField(name string) error {
	switch name {
	case tkuserexamscorerecord.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case tkuserexamscorerecord.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case tkuserexamscorerecord.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case tkuserexamscorerecord.FieldExamPaperID:
		m.ClearExamPaperID()
		return nil
	case tkuserexamscorerecord.FieldSectionID:
		m.ClearSectionID()
		return nil
	case tkuserexamscorerecord.FieldUserID:
		m.ClearUserID()
		return nil
	case tkuserexamscorerecord.FieldOperationTeacherID:
		m.ClearOperationTeacherID()
		return nil
	}
	return fmt.Errorf("unknown TkUserExamScoreRecord nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TkUserExamScoreRecordMutation) ResetField(name string) error {
	switch name {
	case tkuserexamscorerecord.FieldUUID:
		m.ResetUUID()
		return nil
	case tkuserexamscorerecord.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tkuserexamscorerecord.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tkuserexamscorerecord.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case tkuserexamscorerecord.FieldSubjectiveQuestionScore:
		m.ResetSubjectiveQuestionScore()
		return nil
	case tkuserexamscorerecord.FieldObjectiveQuestionScore:
		m.ResetObjectiveQuestionScore()
		return nil
	case tkuserexamscorerecord.FieldTotalScore:
		m.ResetTotalScore()
		return nil
	case tkuserexamscorerecord.FieldDuration:
		m.ResetDuration()
		return nil
	case tkuserexamscorerecord.FieldRightCount:
		m.ResetRightCount()
		return nil
	case tkuserexamscorerecord.FieldWrongCount:
		m.ResetWrongCount()
		return nil
	case tkuserexamscorerecord.FieldTotalCount:
		m.ResetTotalCount()
		return nil
	case tkuserexamscorerecord.FieldNoAnswerCount:
		m.ResetNoAnswerCount()
		return nil
	case tkuserexamscorerecord.FieldRank:
		m.ResetRank()
		return nil
	case tkuserexamscorerecord.FieldStatus:
		m.ResetStatus()
		return nil
	case tkuserexamscorerecord.FieldOrderStatus:
		m.ResetOrderStatus()
		return nil
	case tkuserexamscorerecord.FieldExamPaperID:
		m.ResetExamPaperID()
		return nil
	case tkuserexamscorerecord.FieldSectionID:
		m.ResetSectionID()
		return nil
	case tkuserexamscorerecord.FieldUserID:
		m.ResetUserID()
		return nil
	case tkuserexamscorerecord.FieldOperationTeacherID:
		m.ResetOperationTeacherID()
		return nil
	}
	return fmt.Errorf("unknown TkUserExamScoreRecord field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TkUserExamScoreRecordMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.exam_paper != nil {
		edges = append(edges, tkuserexamscorerecord.EdgeExamPaper)
	}
	if m.section != nil {
		edges = append(edges, tkuserexamscorerecord.EdgeSection)
	}
	if m.teacher != nil {
		edges = append(edges, tkuserexamscorerecord.EdgeTeacher)
	}
	if m.user != nil {
		edges = append(edges, tkuserexamscorerecord.EdgeUser)
	}
	if m.user_exam_details != nil {
		edges = append(edges, tkuserexamscorerecord.EdgeUserExamDetails)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TkUserExamScoreRecordMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tkuserexamscorerecord.EdgeExamPaper:
		if id := m.exam_paper; id != nil {
			return []ent.Value{*id}
		}
	case tkuserexamscorerecord.EdgeSection:
		if id := m.section; id != nil {
			return []ent.Value{*id}
		}
	case tkuserexamscorerecord.EdgeTeacher:
		if id := m.teacher; id != nil {
			return []ent.Value{*id}
		}
	case tkuserexamscorerecord.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case tkuserexamscorerecord.EdgeUserExamDetails:
		ids := make([]ent.Value, 0, len(m.user_exam_details))
		for id := range m.user_exam_details {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TkUserExamScoreRecordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removeduser_exam_details != nil {
		edges = append(edges, tkuserexamscorerecord.EdgeUserExamDetails)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TkUserExamScoreRecordMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tkuserexamscorerecord.EdgeUserExamDetails:
		ids := make([]ent.Value, 0, len(m.removeduser_exam_details))
		for id := range m.removeduser_exam_details {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TkUserExamScoreRecordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedexam_paper {
		edges = append(edges, tkuserexamscorerecord.EdgeExamPaper)
	}
	if m.clearedsection {
		edges = append(edges, tkuserexamscorerecord.EdgeSection)
	}
	if m.clearedteacher {
		edges = append(edges, tkuserexamscorerecord.EdgeTeacher)
	}
	if m.cleareduser {
		edges = append(edges, tkuserexamscorerecord.EdgeUser)
	}
	if m.cleareduser_exam_details {
		edges = append(edges, tkuserexamscorerecord.EdgeUserExamDetails)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TkUserExamScoreRecordMutation) EdgeCleared(name string) bool {
	switch name {
	case tkuserexamscorerecord.EdgeExamPaper:
		return m.clearedexam_paper
	case tkuserexamscorerecord.EdgeSection:
		return m.clearedsection
	case tkuserexamscorerecord.EdgeTeacher:
		return m.clearedteacher
	case tkuserexamscorerecord.EdgeUser:
		return m.cleareduser
	case tkuserexamscorerecord.EdgeUserExamDetails:
		return m.cleareduser_exam_details
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TkUserExamScoreRecordMutation) ClearEdge(name string) error {
	switch name {
	case tkuserexamscorerecord.EdgeExamPaper:
		m.ClearExamPaper()
		return nil
	case tkuserexamscorerecord.EdgeSection:
		m.ClearSection()
		return nil
	case tkuserexamscorerecord.EdgeTeacher:
		m.ClearTeacher()
		return nil
	case tkuserexamscorerecord.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown TkUserExamScoreRecord unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TkUserExamScoreRecordMutation) ResetEdge(name string) error {
	switch name {
	case tkuserexamscorerecord.EdgeExamPaper:
		m.ResetExamPaper()
		return nil
	case tkuserexamscorerecord.EdgeSection:
		m.ResetSection()
		return nil
	case tkuserexamscorerecord.EdgeTeacher:
		m.ResetTeacher()
		return nil
	case tkuserexamscorerecord.EdgeUser:
		m.ResetUser()
		return nil
	case tkuserexamscorerecord.EdgeUserExamDetails:
		m.ResetUserExamDetails()
		return nil
	}
	return fmt.Errorf("unknown TkUserExamScoreRecord edge %s", name)
}

// TkUserQuestionBankRecordMutation represents an operation that mutates the TkUserQuestionBankRecord nodes in the graph.
type TkUserQuestionBankRecordMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	uuid                 *string
	created_at           *time.Time
	updated_at           *time.Time
	deleted_at           *time.Time
	record_count         *int
	addrecord_count      *int
	correct_count        *int
	addcorrect_count     *int
	wrong_count          *int
	addwrong_count       *int
	correct_rate         *float64
	addcorrect_rate      *float64
	finish_rate          *float64
	addfinish_rate       *float64
	clearedFields        map[string]struct{}
	question_bank        *int
	clearedquestion_bank bool
	user                 *int
	cleareduser          bool
	done                 bool
	oldValue             func(context.Context) (*TkUserQuestionBankRecord, error)
	predicates           []predicate.TkUserQuestionBankRecord
}

var _ ent.Mutation = (*TkUserQuestionBankRecordMutation)(nil)

// tkuserquestionbankrecordOption allows management of the mutation configuration using functional options.
type tkuserquestionbankrecordOption func(*TkUserQuestionBankRecordMutation)

// newTkUserQuestionBankRecordMutation creates new mutation for the TkUserQuestionBankRecord entity.
func newTkUserQuestionBankRecordMutation(c config, op Op, opts ...tkuserquestionbankrecordOption) *TkUserQuestionBankRecordMutation {
	m := &TkUserQuestionBankRecordMutation{
		config:        c,
		op:            op,
		typ:           TypeTkUserQuestionBankRecord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTkUserQuestionBankRecordID sets the ID field of the mutation.
func withTkUserQuestionBankRecordID(id int) tkuserquestionbankrecordOption {
	return func(m *TkUserQuestionBankRecordMutation) {
		var (
			err   error
			once  sync.Once
			value *TkUserQuestionBankRecord
		)
		m.oldValue = func(ctx context.Context) (*TkUserQuestionBankRecord, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TkUserQuestionBankRecord.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTkUserQuestionBankRecord sets the old TkUserQuestionBankRecord of the mutation.
func withTkUserQuestionBankRecord(node *TkUserQuestionBankRecord) tkuserquestionbankrecordOption {
	return func(m *TkUserQuestionBankRecordMutation) {
		m.oldValue = func(context.Context) (*TkUserQuestionBankRecord, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TkUserQuestionBankRecordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TkUserQuestionBankRecordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *TkUserQuestionBankRecordMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *TkUserQuestionBankRecordMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *TkUserQuestionBankRecordMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the TkUserQuestionBankRecord entity.
// If the TkUserQuestionBankRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserQuestionBankRecordMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *TkUserQuestionBankRecordMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TkUserQuestionBankRecordMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TkUserQuestionBankRecordMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TkUserQuestionBankRecord entity.
// If the TkUserQuestionBankRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserQuestionBankRecordMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *TkUserQuestionBankRecordMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[tkuserquestionbankrecord.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *TkUserQuestionBankRecordMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[tkuserquestionbankrecord.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TkUserQuestionBankRecordMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, tkuserquestionbankrecord.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TkUserQuestionBankRecordMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TkUserQuestionBankRecordMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TkUserQuestionBankRecord entity.
// If the TkUserQuestionBankRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserQuestionBankRecordMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TkUserQuestionBankRecordMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[tkuserquestionbankrecord.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TkUserQuestionBankRecordMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[tkuserquestionbankrecord.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TkUserQuestionBankRecordMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, tkuserquestionbankrecord.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TkUserQuestionBankRecordMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TkUserQuestionBankRecordMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TkUserQuestionBankRecord entity.
// If the TkUserQuestionBankRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserQuestionBankRecordMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TkUserQuestionBankRecordMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[tkuserquestionbankrecord.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TkUserQuestionBankRecordMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[tkuserquestionbankrecord.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TkUserQuestionBankRecordMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, tkuserquestionbankrecord.FieldDeletedAt)
}

// SetRecordCount sets the "record_count" field.
func (m *TkUserQuestionBankRecordMutation) SetRecordCount(i int) {
	m.record_count = &i
	m.addrecord_count = nil
}

// RecordCount returns the value of the "record_count" field in the mutation.
func (m *TkUserQuestionBankRecordMutation) RecordCount() (r int, exists bool) {
	v := m.record_count
	if v == nil {
		return
	}
	return *v, true
}

// OldRecordCount returns the old "record_count" field's value of the TkUserQuestionBankRecord entity.
// If the TkUserQuestionBankRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserQuestionBankRecordMutation) OldRecordCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRecordCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRecordCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecordCount: %w", err)
	}
	return oldValue.RecordCount, nil
}

// AddRecordCount adds i to the "record_count" field.
func (m *TkUserQuestionBankRecordMutation) AddRecordCount(i int) {
	if m.addrecord_count != nil {
		*m.addrecord_count += i
	} else {
		m.addrecord_count = &i
	}
}

// AddedRecordCount returns the value that was added to the "record_count" field in this mutation.
func (m *TkUserQuestionBankRecordMutation) AddedRecordCount() (r int, exists bool) {
	v := m.addrecord_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetRecordCount resets all changes to the "record_count" field.
func (m *TkUserQuestionBankRecordMutation) ResetRecordCount() {
	m.record_count = nil
	m.addrecord_count = nil
}

// SetCorrectCount sets the "correct_count" field.
func (m *TkUserQuestionBankRecordMutation) SetCorrectCount(i int) {
	m.correct_count = &i
	m.addcorrect_count = nil
}

// CorrectCount returns the value of the "correct_count" field in the mutation.
func (m *TkUserQuestionBankRecordMutation) CorrectCount() (r int, exists bool) {
	v := m.correct_count
	if v == nil {
		return
	}
	return *v, true
}

// OldCorrectCount returns the old "correct_count" field's value of the TkUserQuestionBankRecord entity.
// If the TkUserQuestionBankRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserQuestionBankRecordMutation) OldCorrectCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCorrectCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCorrectCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCorrectCount: %w", err)
	}
	return oldValue.CorrectCount, nil
}

// AddCorrectCount adds i to the "correct_count" field.
func (m *TkUserQuestionBankRecordMutation) AddCorrectCount(i int) {
	if m.addcorrect_count != nil {
		*m.addcorrect_count += i
	} else {
		m.addcorrect_count = &i
	}
}

// AddedCorrectCount returns the value that was added to the "correct_count" field in this mutation.
func (m *TkUserQuestionBankRecordMutation) AddedCorrectCount() (r int, exists bool) {
	v := m.addcorrect_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetCorrectCount resets all changes to the "correct_count" field.
func (m *TkUserQuestionBankRecordMutation) ResetCorrectCount() {
	m.correct_count = nil
	m.addcorrect_count = nil
}

// SetWrongCount sets the "wrong_count" field.
func (m *TkUserQuestionBankRecordMutation) SetWrongCount(i int) {
	m.wrong_count = &i
	m.addwrong_count = nil
}

// WrongCount returns the value of the "wrong_count" field in the mutation.
func (m *TkUserQuestionBankRecordMutation) WrongCount() (r int, exists bool) {
	v := m.wrong_count
	if v == nil {
		return
	}
	return *v, true
}

// OldWrongCount returns the old "wrong_count" field's value of the TkUserQuestionBankRecord entity.
// If the TkUserQuestionBankRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserQuestionBankRecordMutation) OldWrongCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWrongCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWrongCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWrongCount: %w", err)
	}
	return oldValue.WrongCount, nil
}

// AddWrongCount adds i to the "wrong_count" field.
func (m *TkUserQuestionBankRecordMutation) AddWrongCount(i int) {
	if m.addwrong_count != nil {
		*m.addwrong_count += i
	} else {
		m.addwrong_count = &i
	}
}

// AddedWrongCount returns the value that was added to the "wrong_count" field in this mutation.
func (m *TkUserQuestionBankRecordMutation) AddedWrongCount() (r int, exists bool) {
	v := m.addwrong_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetWrongCount resets all changes to the "wrong_count" field.
func (m *TkUserQuestionBankRecordMutation) ResetWrongCount() {
	m.wrong_count = nil
	m.addwrong_count = nil
}

// SetCorrectRate sets the "correct_rate" field.
func (m *TkUserQuestionBankRecordMutation) SetCorrectRate(f float64) {
	m.correct_rate = &f
	m.addcorrect_rate = nil
}

// CorrectRate returns the value of the "correct_rate" field in the mutation.
func (m *TkUserQuestionBankRecordMutation) CorrectRate() (r float64, exists bool) {
	v := m.correct_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldCorrectRate returns the old "correct_rate" field's value of the TkUserQuestionBankRecord entity.
// If the TkUserQuestionBankRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserQuestionBankRecordMutation) OldCorrectRate(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCorrectRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCorrectRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCorrectRate: %w", err)
	}
	return oldValue.CorrectRate, nil
}

// AddCorrectRate adds f to the "correct_rate" field.
func (m *TkUserQuestionBankRecordMutation) AddCorrectRate(f float64) {
	if m.addcorrect_rate != nil {
		*m.addcorrect_rate += f
	} else {
		m.addcorrect_rate = &f
	}
}

// AddedCorrectRate returns the value that was added to the "correct_rate" field in this mutation.
func (m *TkUserQuestionBankRecordMutation) AddedCorrectRate() (r float64, exists bool) {
	v := m.addcorrect_rate
	if v == nil {
		return
	}
	return *v, true
}

// ResetCorrectRate resets all changes to the "correct_rate" field.
func (m *TkUserQuestionBankRecordMutation) ResetCorrectRate() {
	m.correct_rate = nil
	m.addcorrect_rate = nil
}

// SetFinishRate sets the "finish_rate" field.
func (m *TkUserQuestionBankRecordMutation) SetFinishRate(f float64) {
	m.finish_rate = &f
	m.addfinish_rate = nil
}

// FinishRate returns the value of the "finish_rate" field in the mutation.
func (m *TkUserQuestionBankRecordMutation) FinishRate() (r float64, exists bool) {
	v := m.finish_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldFinishRate returns the old "finish_rate" field's value of the TkUserQuestionBankRecord entity.
// If the TkUserQuestionBankRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserQuestionBankRecordMutation) OldFinishRate(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFinishRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFinishRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinishRate: %w", err)
	}
	return oldValue.FinishRate, nil
}

// AddFinishRate adds f to the "finish_rate" field.
func (m *TkUserQuestionBankRecordMutation) AddFinishRate(f float64) {
	if m.addfinish_rate != nil {
		*m.addfinish_rate += f
	} else {
		m.addfinish_rate = &f
	}
}

// AddedFinishRate returns the value that was added to the "finish_rate" field in this mutation.
func (m *TkUserQuestionBankRecordMutation) AddedFinishRate() (r float64, exists bool) {
	v := m.addfinish_rate
	if v == nil {
		return
	}
	return *v, true
}

// ResetFinishRate resets all changes to the "finish_rate" field.
func (m *TkUserQuestionBankRecordMutation) ResetFinishRate() {
	m.finish_rate = nil
	m.addfinish_rate = nil
}

// SetUserID sets the "user_id" field.
func (m *TkUserQuestionBankRecordMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *TkUserQuestionBankRecordMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the TkUserQuestionBankRecord entity.
// If the TkUserQuestionBankRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserQuestionBankRecordMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *TkUserQuestionBankRecordMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[tkuserquestionbankrecord.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *TkUserQuestionBankRecordMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[tkuserquestionbankrecord.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *TkUserQuestionBankRecordMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, tkuserquestionbankrecord.FieldUserID)
}

// SetQuestionBankID sets the "question_bank_id" field.
func (m *TkUserQuestionBankRecordMutation) SetQuestionBankID(i int) {
	m.question_bank = &i
}

// QuestionBankID returns the value of the "question_bank_id" field in the mutation.
func (m *TkUserQuestionBankRecordMutation) QuestionBankID() (r int, exists bool) {
	v := m.question_bank
	if v == nil {
		return
	}
	return *v, true
}

// OldQuestionBankID returns the old "question_bank_id" field's value of the TkUserQuestionBankRecord entity.
// If the TkUserQuestionBankRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserQuestionBankRecordMutation) OldQuestionBankID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldQuestionBankID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldQuestionBankID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuestionBankID: %w", err)
	}
	return oldValue.QuestionBankID, nil
}

// ClearQuestionBankID clears the value of the "question_bank_id" field.
func (m *TkUserQuestionBankRecordMutation) ClearQuestionBankID() {
	m.question_bank = nil
	m.clearedFields[tkuserquestionbankrecord.FieldQuestionBankID] = struct{}{}
}

// QuestionBankIDCleared returns if the "question_bank_id" field was cleared in this mutation.
func (m *TkUserQuestionBankRecordMutation) QuestionBankIDCleared() bool {
	_, ok := m.clearedFields[tkuserquestionbankrecord.FieldQuestionBankID]
	return ok
}

// ResetQuestionBankID resets all changes to the "question_bank_id" field.
func (m *TkUserQuestionBankRecordMutation) ResetQuestionBankID() {
	m.question_bank = nil
	delete(m.clearedFields, tkuserquestionbankrecord.FieldQuestionBankID)
}

// ClearQuestionBank clears the "question_bank" edge to the TkQuestionBank entity.
func (m *TkUserQuestionBankRecordMutation) ClearQuestionBank() {
	m.clearedquestion_bank = true
}

// QuestionBankCleared reports if the "question_bank" edge to the TkQuestionBank entity was cleared.
func (m *TkUserQuestionBankRecordMutation) QuestionBankCleared() bool {
	return m.QuestionBankIDCleared() || m.clearedquestion_bank
}

// QuestionBankIDs returns the "question_bank" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// QuestionBankID instead. It exists only for internal usage by the builders.
func (m *TkUserQuestionBankRecordMutation) QuestionBankIDs() (ids []int) {
	if id := m.question_bank; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetQuestionBank resets all changes to the "question_bank" edge.
func (m *TkUserQuestionBankRecordMutation) ResetQuestionBank() {
	m.question_bank = nil
	m.clearedquestion_bank = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *TkUserQuestionBankRecordMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *TkUserQuestionBankRecordMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *TkUserQuestionBankRecordMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *TkUserQuestionBankRecordMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Op returns the operation name.
func (m *TkUserQuestionBankRecordMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TkUserQuestionBankRecord).
func (m *TkUserQuestionBankRecordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TkUserQuestionBankRecordMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.uuid != nil {
		fields = append(fields, tkuserquestionbankrecord.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, tkuserquestionbankrecord.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tkuserquestionbankrecord.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, tkuserquestionbankrecord.FieldDeletedAt)
	}
	if m.record_count != nil {
		fields = append(fields, tkuserquestionbankrecord.FieldRecordCount)
	}
	if m.correct_count != nil {
		fields = append(fields, tkuserquestionbankrecord.FieldCorrectCount)
	}
	if m.wrong_count != nil {
		fields = append(fields, tkuserquestionbankrecord.FieldWrongCount)
	}
	if m.correct_rate != nil {
		fields = append(fields, tkuserquestionbankrecord.FieldCorrectRate)
	}
	if m.finish_rate != nil {
		fields = append(fields, tkuserquestionbankrecord.FieldFinishRate)
	}
	if m.user != nil {
		fields = append(fields, tkuserquestionbankrecord.FieldUserID)
	}
	if m.question_bank != nil {
		fields = append(fields, tkuserquestionbankrecord.FieldQuestionBankID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TkUserQuestionBankRecordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tkuserquestionbankrecord.FieldUUID:
		return m.UUID()
	case tkuserquestionbankrecord.FieldCreatedAt:
		return m.CreatedAt()
	case tkuserquestionbankrecord.FieldUpdatedAt:
		return m.UpdatedAt()
	case tkuserquestionbankrecord.FieldDeletedAt:
		return m.DeletedAt()
	case tkuserquestionbankrecord.FieldRecordCount:
		return m.RecordCount()
	case tkuserquestionbankrecord.FieldCorrectCount:
		return m.CorrectCount()
	case tkuserquestionbankrecord.FieldWrongCount:
		return m.WrongCount()
	case tkuserquestionbankrecord.FieldCorrectRate:
		return m.CorrectRate()
	case tkuserquestionbankrecord.FieldFinishRate:
		return m.FinishRate()
	case tkuserquestionbankrecord.FieldUserID:
		return m.UserID()
	case tkuserquestionbankrecord.FieldQuestionBankID:
		return m.QuestionBankID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TkUserQuestionBankRecordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tkuserquestionbankrecord.FieldUUID:
		return m.OldUUID(ctx)
	case tkuserquestionbankrecord.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tkuserquestionbankrecord.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tkuserquestionbankrecord.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case tkuserquestionbankrecord.FieldRecordCount:
		return m.OldRecordCount(ctx)
	case tkuserquestionbankrecord.FieldCorrectCount:
		return m.OldCorrectCount(ctx)
	case tkuserquestionbankrecord.FieldWrongCount:
		return m.OldWrongCount(ctx)
	case tkuserquestionbankrecord.FieldCorrectRate:
		return m.OldCorrectRate(ctx)
	case tkuserquestionbankrecord.FieldFinishRate:
		return m.OldFinishRate(ctx)
	case tkuserquestionbankrecord.FieldUserID:
		return m.OldUserID(ctx)
	case tkuserquestionbankrecord.FieldQuestionBankID:
		return m.OldQuestionBankID(ctx)
	}
	return nil, fmt.Errorf("unknown TkUserQuestionBankRecord field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TkUserQuestionBankRecordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tkuserquestionbankrecord.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case tkuserquestionbankrecord.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tkuserquestionbankrecord.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tkuserquestionbankrecord.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case tkuserquestionbankrecord.FieldRecordCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecordCount(v)
		return nil
	case tkuserquestionbankrecord.FieldCorrectCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCorrectCount(v)
		return nil
	case tkuserquestionbankrecord.FieldWrongCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWrongCount(v)
		return nil
	case tkuserquestionbankrecord.FieldCorrectRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCorrectRate(v)
		return nil
	case tkuserquestionbankrecord.FieldFinishRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinishRate(v)
		return nil
	case tkuserquestionbankrecord.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case tkuserquestionbankrecord.FieldQuestionBankID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuestionBankID(v)
		return nil
	}
	return fmt.Errorf("unknown TkUserQuestionBankRecord field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TkUserQuestionBankRecordMutation) AddedFields() []string {
	var fields []string
	if m.addrecord_count != nil {
		fields = append(fields, tkuserquestionbankrecord.FieldRecordCount)
	}
	if m.addcorrect_count != nil {
		fields = append(fields, tkuserquestionbankrecord.FieldCorrectCount)
	}
	if m.addwrong_count != nil {
		fields = append(fields, tkuserquestionbankrecord.FieldWrongCount)
	}
	if m.addcorrect_rate != nil {
		fields = append(fields, tkuserquestionbankrecord.FieldCorrectRate)
	}
	if m.addfinish_rate != nil {
		fields = append(fields, tkuserquestionbankrecord.FieldFinishRate)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TkUserQuestionBankRecordMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tkuserquestionbankrecord.FieldRecordCount:
		return m.AddedRecordCount()
	case tkuserquestionbankrecord.FieldCorrectCount:
		return m.AddedCorrectCount()
	case tkuserquestionbankrecord.FieldWrongCount:
		return m.AddedWrongCount()
	case tkuserquestionbankrecord.FieldCorrectRate:
		return m.AddedCorrectRate()
	case tkuserquestionbankrecord.FieldFinishRate:
		return m.AddedFinishRate()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TkUserQuestionBankRecordMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tkuserquestionbankrecord.FieldRecordCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRecordCount(v)
		return nil
	case tkuserquestionbankrecord.FieldCorrectCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCorrectCount(v)
		return nil
	case tkuserquestionbankrecord.FieldWrongCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWrongCount(v)
		return nil
	case tkuserquestionbankrecord.FieldCorrectRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCorrectRate(v)
		return nil
	case tkuserquestionbankrecord.FieldFinishRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFinishRate(v)
		return nil
	}
	return fmt.Errorf("unknown TkUserQuestionBankRecord numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TkUserQuestionBankRecordMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tkuserquestionbankrecord.FieldCreatedAt) {
		fields = append(fields, tkuserquestionbankrecord.FieldCreatedAt)
	}
	if m.FieldCleared(tkuserquestionbankrecord.FieldUpdatedAt) {
		fields = append(fields, tkuserquestionbankrecord.FieldUpdatedAt)
	}
	if m.FieldCleared(tkuserquestionbankrecord.FieldDeletedAt) {
		fields = append(fields, tkuserquestionbankrecord.FieldDeletedAt)
	}
	if m.FieldCleared(tkuserquestionbankrecord.FieldUserID) {
		fields = append(fields, tkuserquestionbankrecord.FieldUserID)
	}
	if m.FieldCleared(tkuserquestionbankrecord.FieldQuestionBankID) {
		fields = append(fields, tkuserquestionbankrecord.FieldQuestionBankID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TkUserQuestionBankRecordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TkUserQuestionBankRecordMutation) ClearField(name string) error {
	switch name {
	case tkuserquestionbankrecord.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case tkuserquestionbankrecord.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case tkuserquestionbankrecord.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case tkuserquestionbankrecord.FieldUserID:
		m.ClearUserID()
		return nil
	case tkuserquestionbankrecord.FieldQuestionBankID:
		m.ClearQuestionBankID()
		return nil
	}
	return fmt.Errorf("unknown TkUserQuestionBankRecord nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TkUserQuestionBankRecordMutation) ResetField(name string) error {
	switch name {
	case tkuserquestionbankrecord.FieldUUID:
		m.ResetUUID()
		return nil
	case tkuserquestionbankrecord.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tkuserquestionbankrecord.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tkuserquestionbankrecord.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case tkuserquestionbankrecord.FieldRecordCount:
		m.ResetRecordCount()
		return nil
	case tkuserquestionbankrecord.FieldCorrectCount:
		m.ResetCorrectCount()
		return nil
	case tkuserquestionbankrecord.FieldWrongCount:
		m.ResetWrongCount()
		return nil
	case tkuserquestionbankrecord.FieldCorrectRate:
		m.ResetCorrectRate()
		return nil
	case tkuserquestionbankrecord.FieldFinishRate:
		m.ResetFinishRate()
		return nil
	case tkuserquestionbankrecord.FieldUserID:
		m.ResetUserID()
		return nil
	case tkuserquestionbankrecord.FieldQuestionBankID:
		m.ResetQuestionBankID()
		return nil
	}
	return fmt.Errorf("unknown TkUserQuestionBankRecord field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TkUserQuestionBankRecordMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.question_bank != nil {
		edges = append(edges, tkuserquestionbankrecord.EdgeQuestionBank)
	}
	if m.user != nil {
		edges = append(edges, tkuserquestionbankrecord.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TkUserQuestionBankRecordMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tkuserquestionbankrecord.EdgeQuestionBank:
		if id := m.question_bank; id != nil {
			return []ent.Value{*id}
		}
	case tkuserquestionbankrecord.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TkUserQuestionBankRecordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TkUserQuestionBankRecordMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TkUserQuestionBankRecordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedquestion_bank {
		edges = append(edges, tkuserquestionbankrecord.EdgeQuestionBank)
	}
	if m.cleareduser {
		edges = append(edges, tkuserquestionbankrecord.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TkUserQuestionBankRecordMutation) EdgeCleared(name string) bool {
	switch name {
	case tkuserquestionbankrecord.EdgeQuestionBank:
		return m.clearedquestion_bank
	case tkuserquestionbankrecord.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TkUserQuestionBankRecordMutation) ClearEdge(name string) error {
	switch name {
	case tkuserquestionbankrecord.EdgeQuestionBank:
		m.ClearQuestionBank()
		return nil
	case tkuserquestionbankrecord.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown TkUserQuestionBankRecord unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TkUserQuestionBankRecordMutation) ResetEdge(name string) error {
	switch name {
	case tkuserquestionbankrecord.EdgeQuestionBank:
		m.ResetQuestionBank()
		return nil
	case tkuserquestionbankrecord.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown TkUserQuestionBankRecord edge %s", name)
}

// TkUserQuestionRecordMutation represents an operation that mutates the TkUserQuestionRecord nodes in the graph.
type TkUserQuestionRecordMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	uuid                  *string
	created_at            *time.Time
	updated_at            *time.Time
	deleted_at            *time.Time
	correct_count         *int
	addcorrect_count      *int
	answer_count          *int
	addanswer_count       *int
	answer                *string
	is_right              *uint8
	addis_right           *uint8
	exam_question_type    *uint8
	addexam_question_type *uint8
	question_type         *uint8
	addquestion_type      *uint8
	clearedFields         map[string]struct{}
	question_bank         *int
	clearedquestion_bank  bool
	user                  *int
	cleareduser           bool
	question              *int
	clearedquestion       bool
	exam_paper            *int
	clearedexam_paper     bool
	section               *int
	clearedsection        bool
	done                  bool
	oldValue              func(context.Context) (*TkUserQuestionRecord, error)
	predicates            []predicate.TkUserQuestionRecord
}

var _ ent.Mutation = (*TkUserQuestionRecordMutation)(nil)

// tkuserquestionrecordOption allows management of the mutation configuration using functional options.
type tkuserquestionrecordOption func(*TkUserQuestionRecordMutation)

// newTkUserQuestionRecordMutation creates new mutation for the TkUserQuestionRecord entity.
func newTkUserQuestionRecordMutation(c config, op Op, opts ...tkuserquestionrecordOption) *TkUserQuestionRecordMutation {
	m := &TkUserQuestionRecordMutation{
		config:        c,
		op:            op,
		typ:           TypeTkUserQuestionRecord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTkUserQuestionRecordID sets the ID field of the mutation.
func withTkUserQuestionRecordID(id int) tkuserquestionrecordOption {
	return func(m *TkUserQuestionRecordMutation) {
		var (
			err   error
			once  sync.Once
			value *TkUserQuestionRecord
		)
		m.oldValue = func(ctx context.Context) (*TkUserQuestionRecord, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TkUserQuestionRecord.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTkUserQuestionRecord sets the old TkUserQuestionRecord of the mutation.
func withTkUserQuestionRecord(node *TkUserQuestionRecord) tkuserquestionrecordOption {
	return func(m *TkUserQuestionRecordMutation) {
		m.oldValue = func(context.Context) (*TkUserQuestionRecord, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TkUserQuestionRecordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TkUserQuestionRecordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *TkUserQuestionRecordMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *TkUserQuestionRecordMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *TkUserQuestionRecordMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the TkUserQuestionRecord entity.
// If the TkUserQuestionRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserQuestionRecordMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *TkUserQuestionRecordMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TkUserQuestionRecordMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TkUserQuestionRecordMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TkUserQuestionRecord entity.
// If the TkUserQuestionRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserQuestionRecordMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *TkUserQuestionRecordMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[tkuserquestionrecord.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *TkUserQuestionRecordMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[tkuserquestionrecord.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TkUserQuestionRecordMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, tkuserquestionrecord.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TkUserQuestionRecordMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TkUserQuestionRecordMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TkUserQuestionRecord entity.
// If the TkUserQuestionRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserQuestionRecordMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TkUserQuestionRecordMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[tkuserquestionrecord.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TkUserQuestionRecordMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[tkuserquestionrecord.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TkUserQuestionRecordMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, tkuserquestionrecord.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TkUserQuestionRecordMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TkUserQuestionRecordMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TkUserQuestionRecord entity.
// If the TkUserQuestionRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserQuestionRecordMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TkUserQuestionRecordMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[tkuserquestionrecord.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TkUserQuestionRecordMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[tkuserquestionrecord.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TkUserQuestionRecordMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, tkuserquestionrecord.FieldDeletedAt)
}

// SetCorrectCount sets the "correct_count" field.
func (m *TkUserQuestionRecordMutation) SetCorrectCount(i int) {
	m.correct_count = &i
	m.addcorrect_count = nil
}

// CorrectCount returns the value of the "correct_count" field in the mutation.
func (m *TkUserQuestionRecordMutation) CorrectCount() (r int, exists bool) {
	v := m.correct_count
	if v == nil {
		return
	}
	return *v, true
}

// OldCorrectCount returns the old "correct_count" field's value of the TkUserQuestionRecord entity.
// If the TkUserQuestionRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserQuestionRecordMutation) OldCorrectCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCorrectCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCorrectCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCorrectCount: %w", err)
	}
	return oldValue.CorrectCount, nil
}

// AddCorrectCount adds i to the "correct_count" field.
func (m *TkUserQuestionRecordMutation) AddCorrectCount(i int) {
	if m.addcorrect_count != nil {
		*m.addcorrect_count += i
	} else {
		m.addcorrect_count = &i
	}
}

// AddedCorrectCount returns the value that was added to the "correct_count" field in this mutation.
func (m *TkUserQuestionRecordMutation) AddedCorrectCount() (r int, exists bool) {
	v := m.addcorrect_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetCorrectCount resets all changes to the "correct_count" field.
func (m *TkUserQuestionRecordMutation) ResetCorrectCount() {
	m.correct_count = nil
	m.addcorrect_count = nil
}

// SetAnswerCount sets the "answer_count" field.
func (m *TkUserQuestionRecordMutation) SetAnswerCount(i int) {
	m.answer_count = &i
	m.addanswer_count = nil
}

// AnswerCount returns the value of the "answer_count" field in the mutation.
func (m *TkUserQuestionRecordMutation) AnswerCount() (r int, exists bool) {
	v := m.answer_count
	if v == nil {
		return
	}
	return *v, true
}

// OldAnswerCount returns the old "answer_count" field's value of the TkUserQuestionRecord entity.
// If the TkUserQuestionRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserQuestionRecordMutation) OldAnswerCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAnswerCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAnswerCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnswerCount: %w", err)
	}
	return oldValue.AnswerCount, nil
}

// AddAnswerCount adds i to the "answer_count" field.
func (m *TkUserQuestionRecordMutation) AddAnswerCount(i int) {
	if m.addanswer_count != nil {
		*m.addanswer_count += i
	} else {
		m.addanswer_count = &i
	}
}

// AddedAnswerCount returns the value that was added to the "answer_count" field in this mutation.
func (m *TkUserQuestionRecordMutation) AddedAnswerCount() (r int, exists bool) {
	v := m.addanswer_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetAnswerCount resets all changes to the "answer_count" field.
func (m *TkUserQuestionRecordMutation) ResetAnswerCount() {
	m.answer_count = nil
	m.addanswer_count = nil
}

// SetAnswer sets the "answer" field.
func (m *TkUserQuestionRecordMutation) SetAnswer(s string) {
	m.answer = &s
}

// Answer returns the value of the "answer" field in the mutation.
func (m *TkUserQuestionRecordMutation) Answer() (r string, exists bool) {
	v := m.answer
	if v == nil {
		return
	}
	return *v, true
}

// OldAnswer returns the old "answer" field's value of the TkUserQuestionRecord entity.
// If the TkUserQuestionRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserQuestionRecordMutation) OldAnswer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAnswer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAnswer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnswer: %w", err)
	}
	return oldValue.Answer, nil
}

// ResetAnswer resets all changes to the "answer" field.
func (m *TkUserQuestionRecordMutation) ResetAnswer() {
	m.answer = nil
}

// SetIsRight sets the "is_right" field.
func (m *TkUserQuestionRecordMutation) SetIsRight(u uint8) {
	m.is_right = &u
	m.addis_right = nil
}

// IsRight returns the value of the "is_right" field in the mutation.
func (m *TkUserQuestionRecordMutation) IsRight() (r uint8, exists bool) {
	v := m.is_right
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRight returns the old "is_right" field's value of the TkUserQuestionRecord entity.
// If the TkUserQuestionRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserQuestionRecordMutation) OldIsRight(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsRight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsRight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRight: %w", err)
	}
	return oldValue.IsRight, nil
}

// AddIsRight adds u to the "is_right" field.
func (m *TkUserQuestionRecordMutation) AddIsRight(u uint8) {
	if m.addis_right != nil {
		*m.addis_right += u
	} else {
		m.addis_right = &u
	}
}

// AddedIsRight returns the value that was added to the "is_right" field in this mutation.
func (m *TkUserQuestionRecordMutation) AddedIsRight() (r uint8, exists bool) {
	v := m.addis_right
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsRight resets all changes to the "is_right" field.
func (m *TkUserQuestionRecordMutation) ResetIsRight() {
	m.is_right = nil
	m.addis_right = nil
}

// SetExamQuestionType sets the "exam_question_type" field.
func (m *TkUserQuestionRecordMutation) SetExamQuestionType(u uint8) {
	m.exam_question_type = &u
	m.addexam_question_type = nil
}

// ExamQuestionType returns the value of the "exam_question_type" field in the mutation.
func (m *TkUserQuestionRecordMutation) ExamQuestionType() (r uint8, exists bool) {
	v := m.exam_question_type
	if v == nil {
		return
	}
	return *v, true
}

// OldExamQuestionType returns the old "exam_question_type" field's value of the TkUserQuestionRecord entity.
// If the TkUserQuestionRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserQuestionRecordMutation) OldExamQuestionType(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExamQuestionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExamQuestionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamQuestionType: %w", err)
	}
	return oldValue.ExamQuestionType, nil
}

// AddExamQuestionType adds u to the "exam_question_type" field.
func (m *TkUserQuestionRecordMutation) AddExamQuestionType(u uint8) {
	if m.addexam_question_type != nil {
		*m.addexam_question_type += u
	} else {
		m.addexam_question_type = &u
	}
}

// AddedExamQuestionType returns the value that was added to the "exam_question_type" field in this mutation.
func (m *TkUserQuestionRecordMutation) AddedExamQuestionType() (r uint8, exists bool) {
	v := m.addexam_question_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetExamQuestionType resets all changes to the "exam_question_type" field.
func (m *TkUserQuestionRecordMutation) ResetExamQuestionType() {
	m.exam_question_type = nil
	m.addexam_question_type = nil
}

// SetQuestionType sets the "question_type" field.
func (m *TkUserQuestionRecordMutation) SetQuestionType(u uint8) {
	m.question_type = &u
	m.addquestion_type = nil
}

// QuestionType returns the value of the "question_type" field in the mutation.
func (m *TkUserQuestionRecordMutation) QuestionType() (r uint8, exists bool) {
	v := m.question_type
	if v == nil {
		return
	}
	return *v, true
}

// OldQuestionType returns the old "question_type" field's value of the TkUserQuestionRecord entity.
// If the TkUserQuestionRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserQuestionRecordMutation) OldQuestionType(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldQuestionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldQuestionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuestionType: %w", err)
	}
	return oldValue.QuestionType, nil
}

// AddQuestionType adds u to the "question_type" field.
func (m *TkUserQuestionRecordMutation) AddQuestionType(u uint8) {
	if m.addquestion_type != nil {
		*m.addquestion_type += u
	} else {
		m.addquestion_type = &u
	}
}

// AddedQuestionType returns the value that was added to the "question_type" field in this mutation.
func (m *TkUserQuestionRecordMutation) AddedQuestionType() (r uint8, exists bool) {
	v := m.addquestion_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuestionType resets all changes to the "question_type" field.
func (m *TkUserQuestionRecordMutation) ResetQuestionType() {
	m.question_type = nil
	m.addquestion_type = nil
}

// SetUserID sets the "user_id" field.
func (m *TkUserQuestionRecordMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *TkUserQuestionRecordMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the TkUserQuestionRecord entity.
// If the TkUserQuestionRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserQuestionRecordMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *TkUserQuestionRecordMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[tkuserquestionrecord.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *TkUserQuestionRecordMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[tkuserquestionrecord.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *TkUserQuestionRecordMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, tkuserquestionrecord.FieldUserID)
}

// SetQuestionBankID sets the "question_bank_id" field.
func (m *TkUserQuestionRecordMutation) SetQuestionBankID(i int) {
	m.question_bank = &i
}

// QuestionBankID returns the value of the "question_bank_id" field in the mutation.
func (m *TkUserQuestionRecordMutation) QuestionBankID() (r int, exists bool) {
	v := m.question_bank
	if v == nil {
		return
	}
	return *v, true
}

// OldQuestionBankID returns the old "question_bank_id" field's value of the TkUserQuestionRecord entity.
// If the TkUserQuestionRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserQuestionRecordMutation) OldQuestionBankID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldQuestionBankID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldQuestionBankID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuestionBankID: %w", err)
	}
	return oldValue.QuestionBankID, nil
}

// ClearQuestionBankID clears the value of the "question_bank_id" field.
func (m *TkUserQuestionRecordMutation) ClearQuestionBankID() {
	m.question_bank = nil
	m.clearedFields[tkuserquestionrecord.FieldQuestionBankID] = struct{}{}
}

// QuestionBankIDCleared returns if the "question_bank_id" field was cleared in this mutation.
func (m *TkUserQuestionRecordMutation) QuestionBankIDCleared() bool {
	_, ok := m.clearedFields[tkuserquestionrecord.FieldQuestionBankID]
	return ok
}

// ResetQuestionBankID resets all changes to the "question_bank_id" field.
func (m *TkUserQuestionRecordMutation) ResetQuestionBankID() {
	m.question_bank = nil
	delete(m.clearedFields, tkuserquestionrecord.FieldQuestionBankID)
}

// SetQuestionID sets the "question_id" field.
func (m *TkUserQuestionRecordMutation) SetQuestionID(i int) {
	m.question = &i
}

// QuestionID returns the value of the "question_id" field in the mutation.
func (m *TkUserQuestionRecordMutation) QuestionID() (r int, exists bool) {
	v := m.question
	if v == nil {
		return
	}
	return *v, true
}

// OldQuestionID returns the old "question_id" field's value of the TkUserQuestionRecord entity.
// If the TkUserQuestionRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserQuestionRecordMutation) OldQuestionID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldQuestionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldQuestionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuestionID: %w", err)
	}
	return oldValue.QuestionID, nil
}

// ClearQuestionID clears the value of the "question_id" field.
func (m *TkUserQuestionRecordMutation) ClearQuestionID() {
	m.question = nil
	m.clearedFields[tkuserquestionrecord.FieldQuestionID] = struct{}{}
}

// QuestionIDCleared returns if the "question_id" field was cleared in this mutation.
func (m *TkUserQuestionRecordMutation) QuestionIDCleared() bool {
	_, ok := m.clearedFields[tkuserquestionrecord.FieldQuestionID]
	return ok
}

// ResetQuestionID resets all changes to the "question_id" field.
func (m *TkUserQuestionRecordMutation) ResetQuestionID() {
	m.question = nil
	delete(m.clearedFields, tkuserquestionrecord.FieldQuestionID)
}

// SetExamPaperID sets the "exam_paper_id" field.
func (m *TkUserQuestionRecordMutation) SetExamPaperID(i int) {
	m.exam_paper = &i
}

// ExamPaperID returns the value of the "exam_paper_id" field in the mutation.
func (m *TkUserQuestionRecordMutation) ExamPaperID() (r int, exists bool) {
	v := m.exam_paper
	if v == nil {
		return
	}
	return *v, true
}

// OldExamPaperID returns the old "exam_paper_id" field's value of the TkUserQuestionRecord entity.
// If the TkUserQuestionRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserQuestionRecordMutation) OldExamPaperID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExamPaperID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExamPaperID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamPaperID: %w", err)
	}
	return oldValue.ExamPaperID, nil
}

// ClearExamPaperID clears the value of the "exam_paper_id" field.
func (m *TkUserQuestionRecordMutation) ClearExamPaperID() {
	m.exam_paper = nil
	m.clearedFields[tkuserquestionrecord.FieldExamPaperID] = struct{}{}
}

// ExamPaperIDCleared returns if the "exam_paper_id" field was cleared in this mutation.
func (m *TkUserQuestionRecordMutation) ExamPaperIDCleared() bool {
	_, ok := m.clearedFields[tkuserquestionrecord.FieldExamPaperID]
	return ok
}

// ResetExamPaperID resets all changes to the "exam_paper_id" field.
func (m *TkUserQuestionRecordMutation) ResetExamPaperID() {
	m.exam_paper = nil
	delete(m.clearedFields, tkuserquestionrecord.FieldExamPaperID)
}

// SetSectionID sets the "section_id" field.
func (m *TkUserQuestionRecordMutation) SetSectionID(i int) {
	m.section = &i
}

// SectionID returns the value of the "section_id" field in the mutation.
func (m *TkUserQuestionRecordMutation) SectionID() (r int, exists bool) {
	v := m.section
	if v == nil {
		return
	}
	return *v, true
}

// OldSectionID returns the old "section_id" field's value of the TkUserQuestionRecord entity.
// If the TkUserQuestionRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserQuestionRecordMutation) OldSectionID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSectionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSectionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSectionID: %w", err)
	}
	return oldValue.SectionID, nil
}

// ClearSectionID clears the value of the "section_id" field.
func (m *TkUserQuestionRecordMutation) ClearSectionID() {
	m.section = nil
	m.clearedFields[tkuserquestionrecord.FieldSectionID] = struct{}{}
}

// SectionIDCleared returns if the "section_id" field was cleared in this mutation.
func (m *TkUserQuestionRecordMutation) SectionIDCleared() bool {
	_, ok := m.clearedFields[tkuserquestionrecord.FieldSectionID]
	return ok
}

// ResetSectionID resets all changes to the "section_id" field.
func (m *TkUserQuestionRecordMutation) ResetSectionID() {
	m.section = nil
	delete(m.clearedFields, tkuserquestionrecord.FieldSectionID)
}

// ClearQuestionBank clears the "question_bank" edge to the TkQuestionBank entity.
func (m *TkUserQuestionRecordMutation) ClearQuestionBank() {
	m.clearedquestion_bank = true
}

// QuestionBankCleared reports if the "question_bank" edge to the TkQuestionBank entity was cleared.
func (m *TkUserQuestionRecordMutation) QuestionBankCleared() bool {
	return m.QuestionBankIDCleared() || m.clearedquestion_bank
}

// QuestionBankIDs returns the "question_bank" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// QuestionBankID instead. It exists only for internal usage by the builders.
func (m *TkUserQuestionRecordMutation) QuestionBankIDs() (ids []int) {
	if id := m.question_bank; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetQuestionBank resets all changes to the "question_bank" edge.
func (m *TkUserQuestionRecordMutation) ResetQuestionBank() {
	m.question_bank = nil
	m.clearedquestion_bank = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *TkUserQuestionRecordMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *TkUserQuestionRecordMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *TkUserQuestionRecordMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *TkUserQuestionRecordMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearQuestion clears the "question" edge to the TkQuestion entity.
func (m *TkUserQuestionRecordMutation) ClearQuestion() {
	m.clearedquestion = true
}

// QuestionCleared reports if the "question" edge to the TkQuestion entity was cleared.
func (m *TkUserQuestionRecordMutation) QuestionCleared() bool {
	return m.QuestionIDCleared() || m.clearedquestion
}

// QuestionIDs returns the "question" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// QuestionID instead. It exists only for internal usage by the builders.
func (m *TkUserQuestionRecordMutation) QuestionIDs() (ids []int) {
	if id := m.question; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetQuestion resets all changes to the "question" edge.
func (m *TkUserQuestionRecordMutation) ResetQuestion() {
	m.question = nil
	m.clearedquestion = false
}

// ClearExamPaper clears the "exam_paper" edge to the TkExamPaper entity.
func (m *TkUserQuestionRecordMutation) ClearExamPaper() {
	m.clearedexam_paper = true
}

// ExamPaperCleared reports if the "exam_paper" edge to the TkExamPaper entity was cleared.
func (m *TkUserQuestionRecordMutation) ExamPaperCleared() bool {
	return m.ExamPaperIDCleared() || m.clearedexam_paper
}

// ExamPaperIDs returns the "exam_paper" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ExamPaperID instead. It exists only for internal usage by the builders.
func (m *TkUserQuestionRecordMutation) ExamPaperIDs() (ids []int) {
	if id := m.exam_paper; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExamPaper resets all changes to the "exam_paper" edge.
func (m *TkUserQuestionRecordMutation) ResetExamPaper() {
	m.exam_paper = nil
	m.clearedexam_paper = false
}

// ClearSection clears the "section" edge to the TkSection entity.
func (m *TkUserQuestionRecordMutation) ClearSection() {
	m.clearedsection = true
}

// SectionCleared reports if the "section" edge to the TkSection entity was cleared.
func (m *TkUserQuestionRecordMutation) SectionCleared() bool {
	return m.SectionIDCleared() || m.clearedsection
}

// SectionIDs returns the "section" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SectionID instead. It exists only for internal usage by the builders.
func (m *TkUserQuestionRecordMutation) SectionIDs() (ids []int) {
	if id := m.section; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSection resets all changes to the "section" edge.
func (m *TkUserQuestionRecordMutation) ResetSection() {
	m.section = nil
	m.clearedsection = false
}

// Op returns the operation name.
func (m *TkUserQuestionRecordMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TkUserQuestionRecord).
func (m *TkUserQuestionRecordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TkUserQuestionRecordMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.uuid != nil {
		fields = append(fields, tkuserquestionrecord.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, tkuserquestionrecord.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tkuserquestionrecord.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, tkuserquestionrecord.FieldDeletedAt)
	}
	if m.correct_count != nil {
		fields = append(fields, tkuserquestionrecord.FieldCorrectCount)
	}
	if m.answer_count != nil {
		fields = append(fields, tkuserquestionrecord.FieldAnswerCount)
	}
	if m.answer != nil {
		fields = append(fields, tkuserquestionrecord.FieldAnswer)
	}
	if m.is_right != nil {
		fields = append(fields, tkuserquestionrecord.FieldIsRight)
	}
	if m.exam_question_type != nil {
		fields = append(fields, tkuserquestionrecord.FieldExamQuestionType)
	}
	if m.question_type != nil {
		fields = append(fields, tkuserquestionrecord.FieldQuestionType)
	}
	if m.user != nil {
		fields = append(fields, tkuserquestionrecord.FieldUserID)
	}
	if m.question_bank != nil {
		fields = append(fields, tkuserquestionrecord.FieldQuestionBankID)
	}
	if m.question != nil {
		fields = append(fields, tkuserquestionrecord.FieldQuestionID)
	}
	if m.exam_paper != nil {
		fields = append(fields, tkuserquestionrecord.FieldExamPaperID)
	}
	if m.section != nil {
		fields = append(fields, tkuserquestionrecord.FieldSectionID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TkUserQuestionRecordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tkuserquestionrecord.FieldUUID:
		return m.UUID()
	case tkuserquestionrecord.FieldCreatedAt:
		return m.CreatedAt()
	case tkuserquestionrecord.FieldUpdatedAt:
		return m.UpdatedAt()
	case tkuserquestionrecord.FieldDeletedAt:
		return m.DeletedAt()
	case tkuserquestionrecord.FieldCorrectCount:
		return m.CorrectCount()
	case tkuserquestionrecord.FieldAnswerCount:
		return m.AnswerCount()
	case tkuserquestionrecord.FieldAnswer:
		return m.Answer()
	case tkuserquestionrecord.FieldIsRight:
		return m.IsRight()
	case tkuserquestionrecord.FieldExamQuestionType:
		return m.ExamQuestionType()
	case tkuserquestionrecord.FieldQuestionType:
		return m.QuestionType()
	case tkuserquestionrecord.FieldUserID:
		return m.UserID()
	case tkuserquestionrecord.FieldQuestionBankID:
		return m.QuestionBankID()
	case tkuserquestionrecord.FieldQuestionID:
		return m.QuestionID()
	case tkuserquestionrecord.FieldExamPaperID:
		return m.ExamPaperID()
	case tkuserquestionrecord.FieldSectionID:
		return m.SectionID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TkUserQuestionRecordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tkuserquestionrecord.FieldUUID:
		return m.OldUUID(ctx)
	case tkuserquestionrecord.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tkuserquestionrecord.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tkuserquestionrecord.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case tkuserquestionrecord.FieldCorrectCount:
		return m.OldCorrectCount(ctx)
	case tkuserquestionrecord.FieldAnswerCount:
		return m.OldAnswerCount(ctx)
	case tkuserquestionrecord.FieldAnswer:
		return m.OldAnswer(ctx)
	case tkuserquestionrecord.FieldIsRight:
		return m.OldIsRight(ctx)
	case tkuserquestionrecord.FieldExamQuestionType:
		return m.OldExamQuestionType(ctx)
	case tkuserquestionrecord.FieldQuestionType:
		return m.OldQuestionType(ctx)
	case tkuserquestionrecord.FieldUserID:
		return m.OldUserID(ctx)
	case tkuserquestionrecord.FieldQuestionBankID:
		return m.OldQuestionBankID(ctx)
	case tkuserquestionrecord.FieldQuestionID:
		return m.OldQuestionID(ctx)
	case tkuserquestionrecord.FieldExamPaperID:
		return m.OldExamPaperID(ctx)
	case tkuserquestionrecord.FieldSectionID:
		return m.OldSectionID(ctx)
	}
	return nil, fmt.Errorf("unknown TkUserQuestionRecord field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TkUserQuestionRecordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tkuserquestionrecord.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case tkuserquestionrecord.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tkuserquestionrecord.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tkuserquestionrecord.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case tkuserquestionrecord.FieldCorrectCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCorrectCount(v)
		return nil
	case tkuserquestionrecord.FieldAnswerCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnswerCount(v)
		return nil
	case tkuserquestionrecord.FieldAnswer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnswer(v)
		return nil
	case tkuserquestionrecord.FieldIsRight:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRight(v)
		return nil
	case tkuserquestionrecord.FieldExamQuestionType:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamQuestionType(v)
		return nil
	case tkuserquestionrecord.FieldQuestionType:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuestionType(v)
		return nil
	case tkuserquestionrecord.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case tkuserquestionrecord.FieldQuestionBankID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuestionBankID(v)
		return nil
	case tkuserquestionrecord.FieldQuestionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuestionID(v)
		return nil
	case tkuserquestionrecord.FieldExamPaperID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamPaperID(v)
		return nil
	case tkuserquestionrecord.FieldSectionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSectionID(v)
		return nil
	}
	return fmt.Errorf("unknown TkUserQuestionRecord field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TkUserQuestionRecordMutation) AddedFields() []string {
	var fields []string
	if m.addcorrect_count != nil {
		fields = append(fields, tkuserquestionrecord.FieldCorrectCount)
	}
	if m.addanswer_count != nil {
		fields = append(fields, tkuserquestionrecord.FieldAnswerCount)
	}
	if m.addis_right != nil {
		fields = append(fields, tkuserquestionrecord.FieldIsRight)
	}
	if m.addexam_question_type != nil {
		fields = append(fields, tkuserquestionrecord.FieldExamQuestionType)
	}
	if m.addquestion_type != nil {
		fields = append(fields, tkuserquestionrecord.FieldQuestionType)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TkUserQuestionRecordMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tkuserquestionrecord.FieldCorrectCount:
		return m.AddedCorrectCount()
	case tkuserquestionrecord.FieldAnswerCount:
		return m.AddedAnswerCount()
	case tkuserquestionrecord.FieldIsRight:
		return m.AddedIsRight()
	case tkuserquestionrecord.FieldExamQuestionType:
		return m.AddedExamQuestionType()
	case tkuserquestionrecord.FieldQuestionType:
		return m.AddedQuestionType()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TkUserQuestionRecordMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tkuserquestionrecord.FieldCorrectCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCorrectCount(v)
		return nil
	case tkuserquestionrecord.FieldAnswerCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAnswerCount(v)
		return nil
	case tkuserquestionrecord.FieldIsRight:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsRight(v)
		return nil
	case tkuserquestionrecord.FieldExamQuestionType:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExamQuestionType(v)
		return nil
	case tkuserquestionrecord.FieldQuestionType:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuestionType(v)
		return nil
	}
	return fmt.Errorf("unknown TkUserQuestionRecord numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TkUserQuestionRecordMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tkuserquestionrecord.FieldCreatedAt) {
		fields = append(fields, tkuserquestionrecord.FieldCreatedAt)
	}
	if m.FieldCleared(tkuserquestionrecord.FieldUpdatedAt) {
		fields = append(fields, tkuserquestionrecord.FieldUpdatedAt)
	}
	if m.FieldCleared(tkuserquestionrecord.FieldDeletedAt) {
		fields = append(fields, tkuserquestionrecord.FieldDeletedAt)
	}
	if m.FieldCleared(tkuserquestionrecord.FieldUserID) {
		fields = append(fields, tkuserquestionrecord.FieldUserID)
	}
	if m.FieldCleared(tkuserquestionrecord.FieldQuestionBankID) {
		fields = append(fields, tkuserquestionrecord.FieldQuestionBankID)
	}
	if m.FieldCleared(tkuserquestionrecord.FieldQuestionID) {
		fields = append(fields, tkuserquestionrecord.FieldQuestionID)
	}
	if m.FieldCleared(tkuserquestionrecord.FieldExamPaperID) {
		fields = append(fields, tkuserquestionrecord.FieldExamPaperID)
	}
	if m.FieldCleared(tkuserquestionrecord.FieldSectionID) {
		fields = append(fields, tkuserquestionrecord.FieldSectionID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TkUserQuestionRecordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TkUserQuestionRecordMutation) ClearField(name string) error {
	switch name {
	case tkuserquestionrecord.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case tkuserquestionrecord.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case tkuserquestionrecord.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case tkuserquestionrecord.FieldUserID:
		m.ClearUserID()
		return nil
	case tkuserquestionrecord.FieldQuestionBankID:
		m.ClearQuestionBankID()
		return nil
	case tkuserquestionrecord.FieldQuestionID:
		m.ClearQuestionID()
		return nil
	case tkuserquestionrecord.FieldExamPaperID:
		m.ClearExamPaperID()
		return nil
	case tkuserquestionrecord.FieldSectionID:
		m.ClearSectionID()
		return nil
	}
	return fmt.Errorf("unknown TkUserQuestionRecord nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TkUserQuestionRecordMutation) ResetField(name string) error {
	switch name {
	case tkuserquestionrecord.FieldUUID:
		m.ResetUUID()
		return nil
	case tkuserquestionrecord.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tkuserquestionrecord.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tkuserquestionrecord.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case tkuserquestionrecord.FieldCorrectCount:
		m.ResetCorrectCount()
		return nil
	case tkuserquestionrecord.FieldAnswerCount:
		m.ResetAnswerCount()
		return nil
	case tkuserquestionrecord.FieldAnswer:
		m.ResetAnswer()
		return nil
	case tkuserquestionrecord.FieldIsRight:
		m.ResetIsRight()
		return nil
	case tkuserquestionrecord.FieldExamQuestionType:
		m.ResetExamQuestionType()
		return nil
	case tkuserquestionrecord.FieldQuestionType:
		m.ResetQuestionType()
		return nil
	case tkuserquestionrecord.FieldUserID:
		m.ResetUserID()
		return nil
	case tkuserquestionrecord.FieldQuestionBankID:
		m.ResetQuestionBankID()
		return nil
	case tkuserquestionrecord.FieldQuestionID:
		m.ResetQuestionID()
		return nil
	case tkuserquestionrecord.FieldExamPaperID:
		m.ResetExamPaperID()
		return nil
	case tkuserquestionrecord.FieldSectionID:
		m.ResetSectionID()
		return nil
	}
	return fmt.Errorf("unknown TkUserQuestionRecord field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TkUserQuestionRecordMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.question_bank != nil {
		edges = append(edges, tkuserquestionrecord.EdgeQuestionBank)
	}
	if m.user != nil {
		edges = append(edges, tkuserquestionrecord.EdgeUser)
	}
	if m.question != nil {
		edges = append(edges, tkuserquestionrecord.EdgeQuestion)
	}
	if m.exam_paper != nil {
		edges = append(edges, tkuserquestionrecord.EdgeExamPaper)
	}
	if m.section != nil {
		edges = append(edges, tkuserquestionrecord.EdgeSection)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TkUserQuestionRecordMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tkuserquestionrecord.EdgeQuestionBank:
		if id := m.question_bank; id != nil {
			return []ent.Value{*id}
		}
	case tkuserquestionrecord.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case tkuserquestionrecord.EdgeQuestion:
		if id := m.question; id != nil {
			return []ent.Value{*id}
		}
	case tkuserquestionrecord.EdgeExamPaper:
		if id := m.exam_paper; id != nil {
			return []ent.Value{*id}
		}
	case tkuserquestionrecord.EdgeSection:
		if id := m.section; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TkUserQuestionRecordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TkUserQuestionRecordMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TkUserQuestionRecordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedquestion_bank {
		edges = append(edges, tkuserquestionrecord.EdgeQuestionBank)
	}
	if m.cleareduser {
		edges = append(edges, tkuserquestionrecord.EdgeUser)
	}
	if m.clearedquestion {
		edges = append(edges, tkuserquestionrecord.EdgeQuestion)
	}
	if m.clearedexam_paper {
		edges = append(edges, tkuserquestionrecord.EdgeExamPaper)
	}
	if m.clearedsection {
		edges = append(edges, tkuserquestionrecord.EdgeSection)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TkUserQuestionRecordMutation) EdgeCleared(name string) bool {
	switch name {
	case tkuserquestionrecord.EdgeQuestionBank:
		return m.clearedquestion_bank
	case tkuserquestionrecord.EdgeUser:
		return m.cleareduser
	case tkuserquestionrecord.EdgeQuestion:
		return m.clearedquestion
	case tkuserquestionrecord.EdgeExamPaper:
		return m.clearedexam_paper
	case tkuserquestionrecord.EdgeSection:
		return m.clearedsection
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TkUserQuestionRecordMutation) ClearEdge(name string) error {
	switch name {
	case tkuserquestionrecord.EdgeQuestionBank:
		m.ClearQuestionBank()
		return nil
	case tkuserquestionrecord.EdgeUser:
		m.ClearUser()
		return nil
	case tkuserquestionrecord.EdgeQuestion:
		m.ClearQuestion()
		return nil
	case tkuserquestionrecord.EdgeExamPaper:
		m.ClearExamPaper()
		return nil
	case tkuserquestionrecord.EdgeSection:
		m.ClearSection()
		return nil
	}
	return fmt.Errorf("unknown TkUserQuestionRecord unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TkUserQuestionRecordMutation) ResetEdge(name string) error {
	switch name {
	case tkuserquestionrecord.EdgeQuestionBank:
		m.ResetQuestionBank()
		return nil
	case tkuserquestionrecord.EdgeUser:
		m.ResetUser()
		return nil
	case tkuserquestionrecord.EdgeQuestion:
		m.ResetQuestion()
		return nil
	case tkuserquestionrecord.EdgeExamPaper:
		m.ResetExamPaper()
		return nil
	case tkuserquestionrecord.EdgeSection:
		m.ResetSection()
		return nil
	}
	return fmt.Errorf("unknown TkUserQuestionRecord edge %s", name)
}

// TkUserRandomExamRecodeMutation represents an operation that mutates the TkUserRandomExamRecode nodes in the graph.
type TkUserRandomExamRecodeMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int
	uuid                        *string
	created_at                  *time.Time
	updated_at                  *time.Time
	deleted_at                  *time.Time
	user_id                     *int
	adduser_id                  *int
	clearedFields               map[string]struct{}
	random_exam_question        map[int]struct{}
	removedrandom_exam_question map[int]struct{}
	clearedrandom_exam_question bool
	exam_info                   *int
	clearedexam_info            bool
	done                        bool
	oldValue                    func(context.Context) (*TkUserRandomExamRecode, error)
	predicates                  []predicate.TkUserRandomExamRecode
}

var _ ent.Mutation = (*TkUserRandomExamRecodeMutation)(nil)

// tkuserrandomexamrecodeOption allows management of the mutation configuration using functional options.
type tkuserrandomexamrecodeOption func(*TkUserRandomExamRecodeMutation)

// newTkUserRandomExamRecodeMutation creates new mutation for the TkUserRandomExamRecode entity.
func newTkUserRandomExamRecodeMutation(c config, op Op, opts ...tkuserrandomexamrecodeOption) *TkUserRandomExamRecodeMutation {
	m := &TkUserRandomExamRecodeMutation{
		config:        c,
		op:            op,
		typ:           TypeTkUserRandomExamRecode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTkUserRandomExamRecodeID sets the ID field of the mutation.
func withTkUserRandomExamRecodeID(id int) tkuserrandomexamrecodeOption {
	return func(m *TkUserRandomExamRecodeMutation) {
		var (
			err   error
			once  sync.Once
			value *TkUserRandomExamRecode
		)
		m.oldValue = func(ctx context.Context) (*TkUserRandomExamRecode, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TkUserRandomExamRecode.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTkUserRandomExamRecode sets the old TkUserRandomExamRecode of the mutation.
func withTkUserRandomExamRecode(node *TkUserRandomExamRecode) tkuserrandomexamrecodeOption {
	return func(m *TkUserRandomExamRecodeMutation) {
		m.oldValue = func(context.Context) (*TkUserRandomExamRecode, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TkUserRandomExamRecodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TkUserRandomExamRecodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *TkUserRandomExamRecodeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *TkUserRandomExamRecodeMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *TkUserRandomExamRecodeMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the TkUserRandomExamRecode entity.
// If the TkUserRandomExamRecode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserRandomExamRecodeMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *TkUserRandomExamRecodeMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TkUserRandomExamRecodeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TkUserRandomExamRecodeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TkUserRandomExamRecode entity.
// If the TkUserRandomExamRecode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserRandomExamRecodeMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *TkUserRandomExamRecodeMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[tkuserrandomexamrecode.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *TkUserRandomExamRecodeMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[tkuserrandomexamrecode.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TkUserRandomExamRecodeMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, tkuserrandomexamrecode.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TkUserRandomExamRecodeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TkUserRandomExamRecodeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TkUserRandomExamRecode entity.
// If the TkUserRandomExamRecode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserRandomExamRecodeMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TkUserRandomExamRecodeMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[tkuserrandomexamrecode.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TkUserRandomExamRecodeMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[tkuserrandomexamrecode.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TkUserRandomExamRecodeMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, tkuserrandomexamrecode.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TkUserRandomExamRecodeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TkUserRandomExamRecodeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TkUserRandomExamRecode entity.
// If the TkUserRandomExamRecode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserRandomExamRecodeMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TkUserRandomExamRecodeMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[tkuserrandomexamrecode.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TkUserRandomExamRecodeMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[tkuserrandomexamrecode.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TkUserRandomExamRecodeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, tkuserrandomexamrecode.FieldDeletedAt)
}

// SetUserID sets the "user_id" field.
func (m *TkUserRandomExamRecodeMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *TkUserRandomExamRecodeMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the TkUserRandomExamRecode entity.
// If the TkUserRandomExamRecode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserRandomExamRecodeMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *TkUserRandomExamRecodeMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *TkUserRandomExamRecodeMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearUserID clears the value of the "user_id" field.
func (m *TkUserRandomExamRecodeMutation) ClearUserID() {
	m.user_id = nil
	m.adduser_id = nil
	m.clearedFields[tkuserrandomexamrecode.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *TkUserRandomExamRecodeMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[tkuserrandomexamrecode.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *TkUserRandomExamRecodeMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
	delete(m.clearedFields, tkuserrandomexamrecode.FieldUserID)
}

// SetExamID sets the "exam_id" field.
func (m *TkUserRandomExamRecodeMutation) SetExamID(i int) {
	m.exam_info = &i
}

// ExamID returns the value of the "exam_id" field in the mutation.
func (m *TkUserRandomExamRecodeMutation) ExamID() (r int, exists bool) {
	v := m.exam_info
	if v == nil {
		return
	}
	return *v, true
}

// OldExamID returns the old "exam_id" field's value of the TkUserRandomExamRecode entity.
// If the TkUserRandomExamRecode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserRandomExamRecodeMutation) OldExamID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExamID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExamID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamID: %w", err)
	}
	return oldValue.ExamID, nil
}

// ClearExamID clears the value of the "exam_id" field.
func (m *TkUserRandomExamRecodeMutation) ClearExamID() {
	m.exam_info = nil
	m.clearedFields[tkuserrandomexamrecode.FieldExamID] = struct{}{}
}

// ExamIDCleared returns if the "exam_id" field was cleared in this mutation.
func (m *TkUserRandomExamRecodeMutation) ExamIDCleared() bool {
	_, ok := m.clearedFields[tkuserrandomexamrecode.FieldExamID]
	return ok
}

// ResetExamID resets all changes to the "exam_id" field.
func (m *TkUserRandomExamRecodeMutation) ResetExamID() {
	m.exam_info = nil
	delete(m.clearedFields, tkuserrandomexamrecode.FieldExamID)
}

// AddRandomExamQuestionIDs adds the "random_exam_question" edge to the TkQuestion entity by ids.
func (m *TkUserRandomExamRecodeMutation) AddRandomExamQuestionIDs(ids ...int) {
	if m.random_exam_question == nil {
		m.random_exam_question = make(map[int]struct{})
	}
	for i := range ids {
		m.random_exam_question[ids[i]] = struct{}{}
	}
}

// ClearRandomExamQuestion clears the "random_exam_question" edge to the TkQuestion entity.
func (m *TkUserRandomExamRecodeMutation) ClearRandomExamQuestion() {
	m.clearedrandom_exam_question = true
}

// RandomExamQuestionCleared reports if the "random_exam_question" edge to the TkQuestion entity was cleared.
func (m *TkUserRandomExamRecodeMutation) RandomExamQuestionCleared() bool {
	return m.clearedrandom_exam_question
}

// RemoveRandomExamQuestionIDs removes the "random_exam_question" edge to the TkQuestion entity by IDs.
func (m *TkUserRandomExamRecodeMutation) RemoveRandomExamQuestionIDs(ids ...int) {
	if m.removedrandom_exam_question == nil {
		m.removedrandom_exam_question = make(map[int]struct{})
	}
	for i := range ids {
		m.removedrandom_exam_question[ids[i]] = struct{}{}
	}
}

// RemovedRandomExamQuestion returns the removed IDs of the "random_exam_question" edge to the TkQuestion entity.
func (m *TkUserRandomExamRecodeMutation) RemovedRandomExamQuestionIDs() (ids []int) {
	for id := range m.removedrandom_exam_question {
		ids = append(ids, id)
	}
	return
}

// RandomExamQuestionIDs returns the "random_exam_question" edge IDs in the mutation.
func (m *TkUserRandomExamRecodeMutation) RandomExamQuestionIDs() (ids []int) {
	for id := range m.random_exam_question {
		ids = append(ids, id)
	}
	return
}

// ResetRandomExamQuestion resets all changes to the "random_exam_question" edge.
func (m *TkUserRandomExamRecodeMutation) ResetRandomExamQuestion() {
	m.random_exam_question = nil
	m.clearedrandom_exam_question = false
	m.removedrandom_exam_question = nil
}

// SetExamInfoID sets the "exam_info" edge to the TkExamPaper entity by id.
func (m *TkUserRandomExamRecodeMutation) SetExamInfoID(id int) {
	m.exam_info = &id
}

// ClearExamInfo clears the "exam_info" edge to the TkExamPaper entity.
func (m *TkUserRandomExamRecodeMutation) ClearExamInfo() {
	m.clearedexam_info = true
}

// ExamInfoCleared reports if the "exam_info" edge to the TkExamPaper entity was cleared.
func (m *TkUserRandomExamRecodeMutation) ExamInfoCleared() bool {
	return m.ExamIDCleared() || m.clearedexam_info
}

// ExamInfoID returns the "exam_info" edge ID in the mutation.
func (m *TkUserRandomExamRecodeMutation) ExamInfoID() (id int, exists bool) {
	if m.exam_info != nil {
		return *m.exam_info, true
	}
	return
}

// ExamInfoIDs returns the "exam_info" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ExamInfoID instead. It exists only for internal usage by the builders.
func (m *TkUserRandomExamRecodeMutation) ExamInfoIDs() (ids []int) {
	if id := m.exam_info; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExamInfo resets all changes to the "exam_info" edge.
func (m *TkUserRandomExamRecodeMutation) ResetExamInfo() {
	m.exam_info = nil
	m.clearedexam_info = false
}

// Op returns the operation name.
func (m *TkUserRandomExamRecodeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TkUserRandomExamRecode).
func (m *TkUserRandomExamRecodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TkUserRandomExamRecodeMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.uuid != nil {
		fields = append(fields, tkuserrandomexamrecode.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, tkuserrandomexamrecode.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tkuserrandomexamrecode.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, tkuserrandomexamrecode.FieldDeletedAt)
	}
	if m.user_id != nil {
		fields = append(fields, tkuserrandomexamrecode.FieldUserID)
	}
	if m.exam_info != nil {
		fields = append(fields, tkuserrandomexamrecode.FieldExamID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TkUserRandomExamRecodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tkuserrandomexamrecode.FieldUUID:
		return m.UUID()
	case tkuserrandomexamrecode.FieldCreatedAt:
		return m.CreatedAt()
	case tkuserrandomexamrecode.FieldUpdatedAt:
		return m.UpdatedAt()
	case tkuserrandomexamrecode.FieldDeletedAt:
		return m.DeletedAt()
	case tkuserrandomexamrecode.FieldUserID:
		return m.UserID()
	case tkuserrandomexamrecode.FieldExamID:
		return m.ExamID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TkUserRandomExamRecodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tkuserrandomexamrecode.FieldUUID:
		return m.OldUUID(ctx)
	case tkuserrandomexamrecode.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tkuserrandomexamrecode.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tkuserrandomexamrecode.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case tkuserrandomexamrecode.FieldUserID:
		return m.OldUserID(ctx)
	case tkuserrandomexamrecode.FieldExamID:
		return m.OldExamID(ctx)
	}
	return nil, fmt.Errorf("unknown TkUserRandomExamRecode field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TkUserRandomExamRecodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tkuserrandomexamrecode.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case tkuserrandomexamrecode.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tkuserrandomexamrecode.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tkuserrandomexamrecode.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case tkuserrandomexamrecode.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case tkuserrandomexamrecode.FieldExamID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamID(v)
		return nil
	}
	return fmt.Errorf("unknown TkUserRandomExamRecode field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TkUserRandomExamRecodeMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, tkuserrandomexamrecode.FieldUserID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TkUserRandomExamRecodeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tkuserrandomexamrecode.FieldUserID:
		return m.AddedUserID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TkUserRandomExamRecodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tkuserrandomexamrecode.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	}
	return fmt.Errorf("unknown TkUserRandomExamRecode numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TkUserRandomExamRecodeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tkuserrandomexamrecode.FieldCreatedAt) {
		fields = append(fields, tkuserrandomexamrecode.FieldCreatedAt)
	}
	if m.FieldCleared(tkuserrandomexamrecode.FieldUpdatedAt) {
		fields = append(fields, tkuserrandomexamrecode.FieldUpdatedAt)
	}
	if m.FieldCleared(tkuserrandomexamrecode.FieldDeletedAt) {
		fields = append(fields, tkuserrandomexamrecode.FieldDeletedAt)
	}
	if m.FieldCleared(tkuserrandomexamrecode.FieldUserID) {
		fields = append(fields, tkuserrandomexamrecode.FieldUserID)
	}
	if m.FieldCleared(tkuserrandomexamrecode.FieldExamID) {
		fields = append(fields, tkuserrandomexamrecode.FieldExamID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TkUserRandomExamRecodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TkUserRandomExamRecodeMutation) ClearField(name string) error {
	switch name {
	case tkuserrandomexamrecode.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case tkuserrandomexamrecode.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case tkuserrandomexamrecode.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case tkuserrandomexamrecode.FieldUserID:
		m.ClearUserID()
		return nil
	case tkuserrandomexamrecode.FieldExamID:
		m.ClearExamID()
		return nil
	}
	return fmt.Errorf("unknown TkUserRandomExamRecode nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TkUserRandomExamRecodeMutation) ResetField(name string) error {
	switch name {
	case tkuserrandomexamrecode.FieldUUID:
		m.ResetUUID()
		return nil
	case tkuserrandomexamrecode.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tkuserrandomexamrecode.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tkuserrandomexamrecode.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case tkuserrandomexamrecode.FieldUserID:
		m.ResetUserID()
		return nil
	case tkuserrandomexamrecode.FieldExamID:
		m.ResetExamID()
		return nil
	}
	return fmt.Errorf("unknown TkUserRandomExamRecode field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TkUserRandomExamRecodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.random_exam_question != nil {
		edges = append(edges, tkuserrandomexamrecode.EdgeRandomExamQuestion)
	}
	if m.exam_info != nil {
		edges = append(edges, tkuserrandomexamrecode.EdgeExamInfo)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TkUserRandomExamRecodeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tkuserrandomexamrecode.EdgeRandomExamQuestion:
		ids := make([]ent.Value, 0, len(m.random_exam_question))
		for id := range m.random_exam_question {
			ids = append(ids, id)
		}
		return ids
	case tkuserrandomexamrecode.EdgeExamInfo:
		if id := m.exam_info; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TkUserRandomExamRecodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedrandom_exam_question != nil {
		edges = append(edges, tkuserrandomexamrecode.EdgeRandomExamQuestion)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TkUserRandomExamRecodeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tkuserrandomexamrecode.EdgeRandomExamQuestion:
		ids := make([]ent.Value, 0, len(m.removedrandom_exam_question))
		for id := range m.removedrandom_exam_question {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TkUserRandomExamRecodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedrandom_exam_question {
		edges = append(edges, tkuserrandomexamrecode.EdgeRandomExamQuestion)
	}
	if m.clearedexam_info {
		edges = append(edges, tkuserrandomexamrecode.EdgeExamInfo)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TkUserRandomExamRecodeMutation) EdgeCleared(name string) bool {
	switch name {
	case tkuserrandomexamrecode.EdgeRandomExamQuestion:
		return m.clearedrandom_exam_question
	case tkuserrandomexamrecode.EdgeExamInfo:
		return m.clearedexam_info
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TkUserRandomExamRecodeMutation) ClearEdge(name string) error {
	switch name {
	case tkuserrandomexamrecode.EdgeExamInfo:
		m.ClearExamInfo()
		return nil
	}
	return fmt.Errorf("unknown TkUserRandomExamRecode unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TkUserRandomExamRecodeMutation) ResetEdge(name string) error {
	switch name {
	case tkuserrandomexamrecode.EdgeRandomExamQuestion:
		m.ResetRandomExamQuestion()
		return nil
	case tkuserrandomexamrecode.EdgeExamInfo:
		m.ResetExamInfo()
		return nil
	}
	return fmt.Errorf("unknown TkUserRandomExamRecode edge %s", name)
}

// TkUserSimulationTeacherMarkMutation represents an operation that mutates the TkUserSimulationTeacherMark nodes in the graph.
type TkUserSimulationTeacherMarkMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	uuid                    *string
	created_at              *time.Time
	updated_at              *time.Time
	deleted_at              *time.Time
	score                   *uint8
	addscore                *uint8
	desc                    *string
	clearedFields           map[string]struct{}
	question                *int
	clearedquestion         bool
	user_exam_record        *int
	cleareduser_exam_record bool
	done                    bool
	oldValue                func(context.Context) (*TkUserSimulationTeacherMark, error)
	predicates              []predicate.TkUserSimulationTeacherMark
}

var _ ent.Mutation = (*TkUserSimulationTeacherMarkMutation)(nil)

// tkusersimulationteachermarkOption allows management of the mutation configuration using functional options.
type tkusersimulationteachermarkOption func(*TkUserSimulationTeacherMarkMutation)

// newTkUserSimulationTeacherMarkMutation creates new mutation for the TkUserSimulationTeacherMark entity.
func newTkUserSimulationTeacherMarkMutation(c config, op Op, opts ...tkusersimulationteachermarkOption) *TkUserSimulationTeacherMarkMutation {
	m := &TkUserSimulationTeacherMarkMutation{
		config:        c,
		op:            op,
		typ:           TypeTkUserSimulationTeacherMark,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTkUserSimulationTeacherMarkID sets the ID field of the mutation.
func withTkUserSimulationTeacherMarkID(id int) tkusersimulationteachermarkOption {
	return func(m *TkUserSimulationTeacherMarkMutation) {
		var (
			err   error
			once  sync.Once
			value *TkUserSimulationTeacherMark
		)
		m.oldValue = func(ctx context.Context) (*TkUserSimulationTeacherMark, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TkUserSimulationTeacherMark.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTkUserSimulationTeacherMark sets the old TkUserSimulationTeacherMark of the mutation.
func withTkUserSimulationTeacherMark(node *TkUserSimulationTeacherMark) tkusersimulationteachermarkOption {
	return func(m *TkUserSimulationTeacherMarkMutation) {
		m.oldValue = func(context.Context) (*TkUserSimulationTeacherMark, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TkUserSimulationTeacherMarkMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TkUserSimulationTeacherMarkMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *TkUserSimulationTeacherMarkMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *TkUserSimulationTeacherMarkMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *TkUserSimulationTeacherMarkMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the TkUserSimulationTeacherMark entity.
// If the TkUserSimulationTeacherMark object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserSimulationTeacherMarkMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *TkUserSimulationTeacherMarkMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TkUserSimulationTeacherMarkMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TkUserSimulationTeacherMarkMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TkUserSimulationTeacherMark entity.
// If the TkUserSimulationTeacherMark object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserSimulationTeacherMarkMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *TkUserSimulationTeacherMarkMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[tkusersimulationteachermark.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *TkUserSimulationTeacherMarkMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[tkusersimulationteachermark.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TkUserSimulationTeacherMarkMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, tkusersimulationteachermark.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TkUserSimulationTeacherMarkMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TkUserSimulationTeacherMarkMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TkUserSimulationTeacherMark entity.
// If the TkUserSimulationTeacherMark object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserSimulationTeacherMarkMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TkUserSimulationTeacherMarkMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[tkusersimulationteachermark.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TkUserSimulationTeacherMarkMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[tkusersimulationteachermark.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TkUserSimulationTeacherMarkMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, tkusersimulationteachermark.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TkUserSimulationTeacherMarkMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TkUserSimulationTeacherMarkMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TkUserSimulationTeacherMark entity.
// If the TkUserSimulationTeacherMark object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserSimulationTeacherMarkMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TkUserSimulationTeacherMarkMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[tkusersimulationteachermark.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TkUserSimulationTeacherMarkMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[tkusersimulationteachermark.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TkUserSimulationTeacherMarkMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, tkusersimulationteachermark.FieldDeletedAt)
}

// SetScore sets the "score" field.
func (m *TkUserSimulationTeacherMarkMutation) SetScore(u uint8) {
	m.score = &u
	m.addscore = nil
}

// Score returns the value of the "score" field in the mutation.
func (m *TkUserSimulationTeacherMarkMutation) Score() (r uint8, exists bool) {
	v := m.score
	if v == nil {
		return
	}
	return *v, true
}

// OldScore returns the old "score" field's value of the TkUserSimulationTeacherMark entity.
// If the TkUserSimulationTeacherMark object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserSimulationTeacherMarkMutation) OldScore(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScore: %w", err)
	}
	return oldValue.Score, nil
}

// AddScore adds u to the "score" field.
func (m *TkUserSimulationTeacherMarkMutation) AddScore(u uint8) {
	if m.addscore != nil {
		*m.addscore += u
	} else {
		m.addscore = &u
	}
}

// AddedScore returns the value that was added to the "score" field in this mutation.
func (m *TkUserSimulationTeacherMarkMutation) AddedScore() (r uint8, exists bool) {
	v := m.addscore
	if v == nil {
		return
	}
	return *v, true
}

// ResetScore resets all changes to the "score" field.
func (m *TkUserSimulationTeacherMarkMutation) ResetScore() {
	m.score = nil
	m.addscore = nil
}

// SetDesc sets the "desc" field.
func (m *TkUserSimulationTeacherMarkMutation) SetDesc(s string) {
	m.desc = &s
}

// Desc returns the value of the "desc" field in the mutation.
func (m *TkUserSimulationTeacherMarkMutation) Desc() (r string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the TkUserSimulationTeacherMark entity.
// If the TkUserSimulationTeacherMark object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserSimulationTeacherMarkMutation) OldDesc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// ClearDesc clears the value of the "desc" field.
func (m *TkUserSimulationTeacherMarkMutation) ClearDesc() {
	m.desc = nil
	m.clearedFields[tkusersimulationteachermark.FieldDesc] = struct{}{}
}

// DescCleared returns if the "desc" field was cleared in this mutation.
func (m *TkUserSimulationTeacherMarkMutation) DescCleared() bool {
	_, ok := m.clearedFields[tkusersimulationteachermark.FieldDesc]
	return ok
}

// ResetDesc resets all changes to the "desc" field.
func (m *TkUserSimulationTeacherMarkMutation) ResetDesc() {
	m.desc = nil
	delete(m.clearedFields, tkusersimulationteachermark.FieldDesc)
}

// SetQuestionID sets the "question_id" field.
func (m *TkUserSimulationTeacherMarkMutation) SetQuestionID(i int) {
	m.question = &i
}

// QuestionID returns the value of the "question_id" field in the mutation.
func (m *TkUserSimulationTeacherMarkMutation) QuestionID() (r int, exists bool) {
	v := m.question
	if v == nil {
		return
	}
	return *v, true
}

// OldQuestionID returns the old "question_id" field's value of the TkUserSimulationTeacherMark entity.
// If the TkUserSimulationTeacherMark object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserSimulationTeacherMarkMutation) OldQuestionID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldQuestionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldQuestionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuestionID: %w", err)
	}
	return oldValue.QuestionID, nil
}

// ClearQuestionID clears the value of the "question_id" field.
func (m *TkUserSimulationTeacherMarkMutation) ClearQuestionID() {
	m.question = nil
	m.clearedFields[tkusersimulationteachermark.FieldQuestionID] = struct{}{}
}

// QuestionIDCleared returns if the "question_id" field was cleared in this mutation.
func (m *TkUserSimulationTeacherMarkMutation) QuestionIDCleared() bool {
	_, ok := m.clearedFields[tkusersimulationteachermark.FieldQuestionID]
	return ok
}

// ResetQuestionID resets all changes to the "question_id" field.
func (m *TkUserSimulationTeacherMarkMutation) ResetQuestionID() {
	m.question = nil
	delete(m.clearedFields, tkusersimulationteachermark.FieldQuestionID)
}

// SetUserExamRecordID sets the "user_exam_record_id" field.
func (m *TkUserSimulationTeacherMarkMutation) SetUserExamRecordID(i int) {
	m.user_exam_record = &i
}

// UserExamRecordID returns the value of the "user_exam_record_id" field in the mutation.
func (m *TkUserSimulationTeacherMarkMutation) UserExamRecordID() (r int, exists bool) {
	v := m.user_exam_record
	if v == nil {
		return
	}
	return *v, true
}

// OldUserExamRecordID returns the old "user_exam_record_id" field's value of the TkUserSimulationTeacherMark entity.
// If the TkUserSimulationTeacherMark object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserSimulationTeacherMarkMutation) OldUserExamRecordID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserExamRecordID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserExamRecordID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserExamRecordID: %w", err)
	}
	return oldValue.UserExamRecordID, nil
}

// ClearUserExamRecordID clears the value of the "user_exam_record_id" field.
func (m *TkUserSimulationTeacherMarkMutation) ClearUserExamRecordID() {
	m.user_exam_record = nil
	m.clearedFields[tkusersimulationteachermark.FieldUserExamRecordID] = struct{}{}
}

// UserExamRecordIDCleared returns if the "user_exam_record_id" field was cleared in this mutation.
func (m *TkUserSimulationTeacherMarkMutation) UserExamRecordIDCleared() bool {
	_, ok := m.clearedFields[tkusersimulationteachermark.FieldUserExamRecordID]
	return ok
}

// ResetUserExamRecordID resets all changes to the "user_exam_record_id" field.
func (m *TkUserSimulationTeacherMarkMutation) ResetUserExamRecordID() {
	m.user_exam_record = nil
	delete(m.clearedFields, tkusersimulationteachermark.FieldUserExamRecordID)
}

// ClearQuestion clears the "question" edge to the TkQuestion entity.
func (m *TkUserSimulationTeacherMarkMutation) ClearQuestion() {
	m.clearedquestion = true
}

// QuestionCleared reports if the "question" edge to the TkQuestion entity was cleared.
func (m *TkUserSimulationTeacherMarkMutation) QuestionCleared() bool {
	return m.QuestionIDCleared() || m.clearedquestion
}

// QuestionIDs returns the "question" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// QuestionID instead. It exists only for internal usage by the builders.
func (m *TkUserSimulationTeacherMarkMutation) QuestionIDs() (ids []int) {
	if id := m.question; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetQuestion resets all changes to the "question" edge.
func (m *TkUserSimulationTeacherMarkMutation) ResetQuestion() {
	m.question = nil
	m.clearedquestion = false
}

// ClearUserExamRecord clears the "user_exam_record" edge to the TkUserExamScoreRecord entity.
func (m *TkUserSimulationTeacherMarkMutation) ClearUserExamRecord() {
	m.cleareduser_exam_record = true
}

// UserExamRecordCleared reports if the "user_exam_record" edge to the TkUserExamScoreRecord entity was cleared.
func (m *TkUserSimulationTeacherMarkMutation) UserExamRecordCleared() bool {
	return m.UserExamRecordIDCleared() || m.cleareduser_exam_record
}

// UserExamRecordIDs returns the "user_exam_record" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserExamRecordID instead. It exists only for internal usage by the builders.
func (m *TkUserSimulationTeacherMarkMutation) UserExamRecordIDs() (ids []int) {
	if id := m.user_exam_record; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUserExamRecord resets all changes to the "user_exam_record" edge.
func (m *TkUserSimulationTeacherMarkMutation) ResetUserExamRecord() {
	m.user_exam_record = nil
	m.cleareduser_exam_record = false
}

// Op returns the operation name.
func (m *TkUserSimulationTeacherMarkMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TkUserSimulationTeacherMark).
func (m *TkUserSimulationTeacherMarkMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TkUserSimulationTeacherMarkMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.uuid != nil {
		fields = append(fields, tkusersimulationteachermark.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, tkusersimulationteachermark.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tkusersimulationteachermark.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, tkusersimulationteachermark.FieldDeletedAt)
	}
	if m.score != nil {
		fields = append(fields, tkusersimulationteachermark.FieldScore)
	}
	if m.desc != nil {
		fields = append(fields, tkusersimulationteachermark.FieldDesc)
	}
	if m.question != nil {
		fields = append(fields, tkusersimulationteachermark.FieldQuestionID)
	}
	if m.user_exam_record != nil {
		fields = append(fields, tkusersimulationteachermark.FieldUserExamRecordID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TkUserSimulationTeacherMarkMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tkusersimulationteachermark.FieldUUID:
		return m.UUID()
	case tkusersimulationteachermark.FieldCreatedAt:
		return m.CreatedAt()
	case tkusersimulationteachermark.FieldUpdatedAt:
		return m.UpdatedAt()
	case tkusersimulationteachermark.FieldDeletedAt:
		return m.DeletedAt()
	case tkusersimulationteachermark.FieldScore:
		return m.Score()
	case tkusersimulationteachermark.FieldDesc:
		return m.Desc()
	case tkusersimulationteachermark.FieldQuestionID:
		return m.QuestionID()
	case tkusersimulationteachermark.FieldUserExamRecordID:
		return m.UserExamRecordID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TkUserSimulationTeacherMarkMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tkusersimulationteachermark.FieldUUID:
		return m.OldUUID(ctx)
	case tkusersimulationteachermark.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tkusersimulationteachermark.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tkusersimulationteachermark.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case tkusersimulationteachermark.FieldScore:
		return m.OldScore(ctx)
	case tkusersimulationteachermark.FieldDesc:
		return m.OldDesc(ctx)
	case tkusersimulationteachermark.FieldQuestionID:
		return m.OldQuestionID(ctx)
	case tkusersimulationteachermark.FieldUserExamRecordID:
		return m.OldUserExamRecordID(ctx)
	}
	return nil, fmt.Errorf("unknown TkUserSimulationTeacherMark field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TkUserSimulationTeacherMarkMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tkusersimulationteachermark.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case tkusersimulationteachermark.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tkusersimulationteachermark.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tkusersimulationteachermark.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case tkusersimulationteachermark.FieldScore:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScore(v)
		return nil
	case tkusersimulationteachermark.FieldDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	case tkusersimulationteachermark.FieldQuestionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuestionID(v)
		return nil
	case tkusersimulationteachermark.FieldUserExamRecordID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserExamRecordID(v)
		return nil
	}
	return fmt.Errorf("unknown TkUserSimulationTeacherMark field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TkUserSimulationTeacherMarkMutation) AddedFields() []string {
	var fields []string
	if m.addscore != nil {
		fields = append(fields, tkusersimulationteachermark.FieldScore)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TkUserSimulationTeacherMarkMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tkusersimulationteachermark.FieldScore:
		return m.AddedScore()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TkUserSimulationTeacherMarkMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tkusersimulationteachermark.FieldScore:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScore(v)
		return nil
	}
	return fmt.Errorf("unknown TkUserSimulationTeacherMark numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TkUserSimulationTeacherMarkMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tkusersimulationteachermark.FieldCreatedAt) {
		fields = append(fields, tkusersimulationteachermark.FieldCreatedAt)
	}
	if m.FieldCleared(tkusersimulationteachermark.FieldUpdatedAt) {
		fields = append(fields, tkusersimulationteachermark.FieldUpdatedAt)
	}
	if m.FieldCleared(tkusersimulationteachermark.FieldDeletedAt) {
		fields = append(fields, tkusersimulationteachermark.FieldDeletedAt)
	}
	if m.FieldCleared(tkusersimulationteachermark.FieldDesc) {
		fields = append(fields, tkusersimulationteachermark.FieldDesc)
	}
	if m.FieldCleared(tkusersimulationteachermark.FieldQuestionID) {
		fields = append(fields, tkusersimulationteachermark.FieldQuestionID)
	}
	if m.FieldCleared(tkusersimulationteachermark.FieldUserExamRecordID) {
		fields = append(fields, tkusersimulationteachermark.FieldUserExamRecordID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TkUserSimulationTeacherMarkMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TkUserSimulationTeacherMarkMutation) ClearField(name string) error {
	switch name {
	case tkusersimulationteachermark.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case tkusersimulationteachermark.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case tkusersimulationteachermark.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case tkusersimulationteachermark.FieldDesc:
		m.ClearDesc()
		return nil
	case tkusersimulationteachermark.FieldQuestionID:
		m.ClearQuestionID()
		return nil
	case tkusersimulationteachermark.FieldUserExamRecordID:
		m.ClearUserExamRecordID()
		return nil
	}
	return fmt.Errorf("unknown TkUserSimulationTeacherMark nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TkUserSimulationTeacherMarkMutation) ResetField(name string) error {
	switch name {
	case tkusersimulationteachermark.FieldUUID:
		m.ResetUUID()
		return nil
	case tkusersimulationteachermark.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tkusersimulationteachermark.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tkusersimulationteachermark.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case tkusersimulationteachermark.FieldScore:
		m.ResetScore()
		return nil
	case tkusersimulationteachermark.FieldDesc:
		m.ResetDesc()
		return nil
	case tkusersimulationteachermark.FieldQuestionID:
		m.ResetQuestionID()
		return nil
	case tkusersimulationteachermark.FieldUserExamRecordID:
		m.ResetUserExamRecordID()
		return nil
	}
	return fmt.Errorf("unknown TkUserSimulationTeacherMark field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TkUserSimulationTeacherMarkMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.question != nil {
		edges = append(edges, tkusersimulationteachermark.EdgeQuestion)
	}
	if m.user_exam_record != nil {
		edges = append(edges, tkusersimulationteachermark.EdgeUserExamRecord)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TkUserSimulationTeacherMarkMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tkusersimulationteachermark.EdgeQuestion:
		if id := m.question; id != nil {
			return []ent.Value{*id}
		}
	case tkusersimulationteachermark.EdgeUserExamRecord:
		if id := m.user_exam_record; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TkUserSimulationTeacherMarkMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TkUserSimulationTeacherMarkMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TkUserSimulationTeacherMarkMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedquestion {
		edges = append(edges, tkusersimulationteachermark.EdgeQuestion)
	}
	if m.cleareduser_exam_record {
		edges = append(edges, tkusersimulationteachermark.EdgeUserExamRecord)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TkUserSimulationTeacherMarkMutation) EdgeCleared(name string) bool {
	switch name {
	case tkusersimulationteachermark.EdgeQuestion:
		return m.clearedquestion
	case tkusersimulationteachermark.EdgeUserExamRecord:
		return m.cleareduser_exam_record
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TkUserSimulationTeacherMarkMutation) ClearEdge(name string) error {
	switch name {
	case tkusersimulationteachermark.EdgeQuestion:
		m.ClearQuestion()
		return nil
	case tkusersimulationteachermark.EdgeUserExamRecord:
		m.ClearUserExamRecord()
		return nil
	}
	return fmt.Errorf("unknown TkUserSimulationTeacherMark unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TkUserSimulationTeacherMarkMutation) ResetEdge(name string) error {
	switch name {
	case tkusersimulationteachermark.EdgeQuestion:
		m.ResetQuestion()
		return nil
	case tkusersimulationteachermark.EdgeUserExamRecord:
		m.ResetUserExamRecord()
		return nil
	}
	return fmt.Errorf("unknown TkUserSimulationTeacherMark edge %s", name)
}

// TkUserWrongQuestionRecodeMutation represents an operation that mutates the TkUserWrongQuestionRecode nodes in the graph.
type TkUserWrongQuestionRecodeMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	uuid                   *string
	created_at             *time.Time
	updated_at             *time.Time
	deleted_at             *time.Time
	user_id                *int
	adduser_id             *int
	question_bank_id       *int
	addquestion_bank_id    *int
	answer                 *string
	wrong_exam_type        *int
	addwrong_exam_type     *int
	wrong_question_type    *int
	addwrong_question_type *int
	clearedFields          map[string]struct{}
	question_wrong         *int
	clearedquestion_wrong  bool
	done                   bool
	oldValue               func(context.Context) (*TkUserWrongQuestionRecode, error)
	predicates             []predicate.TkUserWrongQuestionRecode
}

var _ ent.Mutation = (*TkUserWrongQuestionRecodeMutation)(nil)

// tkuserwrongquestionrecodeOption allows management of the mutation configuration using functional options.
type tkuserwrongquestionrecodeOption func(*TkUserWrongQuestionRecodeMutation)

// newTkUserWrongQuestionRecodeMutation creates new mutation for the TkUserWrongQuestionRecode entity.
func newTkUserWrongQuestionRecodeMutation(c config, op Op, opts ...tkuserwrongquestionrecodeOption) *TkUserWrongQuestionRecodeMutation {
	m := &TkUserWrongQuestionRecodeMutation{
		config:        c,
		op:            op,
		typ:           TypeTkUserWrongQuestionRecode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTkUserWrongQuestionRecodeID sets the ID field of the mutation.
func withTkUserWrongQuestionRecodeID(id int) tkuserwrongquestionrecodeOption {
	return func(m *TkUserWrongQuestionRecodeMutation) {
		var (
			err   error
			once  sync.Once
			value *TkUserWrongQuestionRecode
		)
		m.oldValue = func(ctx context.Context) (*TkUserWrongQuestionRecode, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TkUserWrongQuestionRecode.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTkUserWrongQuestionRecode sets the old TkUserWrongQuestionRecode of the mutation.
func withTkUserWrongQuestionRecode(node *TkUserWrongQuestionRecode) tkuserwrongquestionrecodeOption {
	return func(m *TkUserWrongQuestionRecodeMutation) {
		m.oldValue = func(context.Context) (*TkUserWrongQuestionRecode, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TkUserWrongQuestionRecodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TkUserWrongQuestionRecodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *TkUserWrongQuestionRecodeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *TkUserWrongQuestionRecodeMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *TkUserWrongQuestionRecodeMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the TkUserWrongQuestionRecode entity.
// If the TkUserWrongQuestionRecode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserWrongQuestionRecodeMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *TkUserWrongQuestionRecodeMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TkUserWrongQuestionRecodeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TkUserWrongQuestionRecodeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TkUserWrongQuestionRecode entity.
// If the TkUserWrongQuestionRecode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserWrongQuestionRecodeMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *TkUserWrongQuestionRecodeMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[tkuserwrongquestionrecode.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *TkUserWrongQuestionRecodeMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[tkuserwrongquestionrecode.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TkUserWrongQuestionRecodeMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, tkuserwrongquestionrecode.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TkUserWrongQuestionRecodeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TkUserWrongQuestionRecodeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TkUserWrongQuestionRecode entity.
// If the TkUserWrongQuestionRecode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserWrongQuestionRecodeMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TkUserWrongQuestionRecodeMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[tkuserwrongquestionrecode.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TkUserWrongQuestionRecodeMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[tkuserwrongquestionrecode.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TkUserWrongQuestionRecodeMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, tkuserwrongquestionrecode.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TkUserWrongQuestionRecodeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TkUserWrongQuestionRecodeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TkUserWrongQuestionRecode entity.
// If the TkUserWrongQuestionRecode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserWrongQuestionRecodeMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TkUserWrongQuestionRecodeMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[tkuserwrongquestionrecode.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TkUserWrongQuestionRecodeMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[tkuserwrongquestionrecode.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TkUserWrongQuestionRecodeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, tkuserwrongquestionrecode.FieldDeletedAt)
}

// SetUserID sets the "user_id" field.
func (m *TkUserWrongQuestionRecodeMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *TkUserWrongQuestionRecodeMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the TkUserWrongQuestionRecode entity.
// If the TkUserWrongQuestionRecode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserWrongQuestionRecodeMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *TkUserWrongQuestionRecodeMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *TkUserWrongQuestionRecodeMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearUserID clears the value of the "user_id" field.
func (m *TkUserWrongQuestionRecodeMutation) ClearUserID() {
	m.user_id = nil
	m.adduser_id = nil
	m.clearedFields[tkuserwrongquestionrecode.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *TkUserWrongQuestionRecodeMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[tkuserwrongquestionrecode.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *TkUserWrongQuestionRecodeMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
	delete(m.clearedFields, tkuserwrongquestionrecode.FieldUserID)
}

// SetQuestionID sets the "question_id" field.
func (m *TkUserWrongQuestionRecodeMutation) SetQuestionID(i int) {
	m.question_wrong = &i
}

// QuestionID returns the value of the "question_id" field in the mutation.
func (m *TkUserWrongQuestionRecodeMutation) QuestionID() (r int, exists bool) {
	v := m.question_wrong
	if v == nil {
		return
	}
	return *v, true
}

// OldQuestionID returns the old "question_id" field's value of the TkUserWrongQuestionRecode entity.
// If the TkUserWrongQuestionRecode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserWrongQuestionRecodeMutation) OldQuestionID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldQuestionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldQuestionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuestionID: %w", err)
	}
	return oldValue.QuestionID, nil
}

// ClearQuestionID clears the value of the "question_id" field.
func (m *TkUserWrongQuestionRecodeMutation) ClearQuestionID() {
	m.question_wrong = nil
	m.clearedFields[tkuserwrongquestionrecode.FieldQuestionID] = struct{}{}
}

// QuestionIDCleared returns if the "question_id" field was cleared in this mutation.
func (m *TkUserWrongQuestionRecodeMutation) QuestionIDCleared() bool {
	_, ok := m.clearedFields[tkuserwrongquestionrecode.FieldQuestionID]
	return ok
}

// ResetQuestionID resets all changes to the "question_id" field.
func (m *TkUserWrongQuestionRecodeMutation) ResetQuestionID() {
	m.question_wrong = nil
	delete(m.clearedFields, tkuserwrongquestionrecode.FieldQuestionID)
}

// SetQuestionBankID sets the "question_bank_id" field.
func (m *TkUserWrongQuestionRecodeMutation) SetQuestionBankID(i int) {
	m.question_bank_id = &i
	m.addquestion_bank_id = nil
}

// QuestionBankID returns the value of the "question_bank_id" field in the mutation.
func (m *TkUserWrongQuestionRecodeMutation) QuestionBankID() (r int, exists bool) {
	v := m.question_bank_id
	if v == nil {
		return
	}
	return *v, true
}

// OldQuestionBankID returns the old "question_bank_id" field's value of the TkUserWrongQuestionRecode entity.
// If the TkUserWrongQuestionRecode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserWrongQuestionRecodeMutation) OldQuestionBankID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldQuestionBankID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldQuestionBankID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuestionBankID: %w", err)
	}
	return oldValue.QuestionBankID, nil
}

// AddQuestionBankID adds i to the "question_bank_id" field.
func (m *TkUserWrongQuestionRecodeMutation) AddQuestionBankID(i int) {
	if m.addquestion_bank_id != nil {
		*m.addquestion_bank_id += i
	} else {
		m.addquestion_bank_id = &i
	}
}

// AddedQuestionBankID returns the value that was added to the "question_bank_id" field in this mutation.
func (m *TkUserWrongQuestionRecodeMutation) AddedQuestionBankID() (r int, exists bool) {
	v := m.addquestion_bank_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearQuestionBankID clears the value of the "question_bank_id" field.
func (m *TkUserWrongQuestionRecodeMutation) ClearQuestionBankID() {
	m.question_bank_id = nil
	m.addquestion_bank_id = nil
	m.clearedFields[tkuserwrongquestionrecode.FieldQuestionBankID] = struct{}{}
}

// QuestionBankIDCleared returns if the "question_bank_id" field was cleared in this mutation.
func (m *TkUserWrongQuestionRecodeMutation) QuestionBankIDCleared() bool {
	_, ok := m.clearedFields[tkuserwrongquestionrecode.FieldQuestionBankID]
	return ok
}

// ResetQuestionBankID resets all changes to the "question_bank_id" field.
func (m *TkUserWrongQuestionRecodeMutation) ResetQuestionBankID() {
	m.question_bank_id = nil
	m.addquestion_bank_id = nil
	delete(m.clearedFields, tkuserwrongquestionrecode.FieldQuestionBankID)
}

// SetAnswer sets the "answer" field.
func (m *TkUserWrongQuestionRecodeMutation) SetAnswer(s string) {
	m.answer = &s
}

// Answer returns the value of the "answer" field in the mutation.
func (m *TkUserWrongQuestionRecodeMutation) Answer() (r string, exists bool) {
	v := m.answer
	if v == nil {
		return
	}
	return *v, true
}

// OldAnswer returns the old "answer" field's value of the TkUserWrongQuestionRecode entity.
// If the TkUserWrongQuestionRecode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserWrongQuestionRecodeMutation) OldAnswer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAnswer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAnswer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnswer: %w", err)
	}
	return oldValue.Answer, nil
}

// ClearAnswer clears the value of the "answer" field.
func (m *TkUserWrongQuestionRecodeMutation) ClearAnswer() {
	m.answer = nil
	m.clearedFields[tkuserwrongquestionrecode.FieldAnswer] = struct{}{}
}

// AnswerCleared returns if the "answer" field was cleared in this mutation.
func (m *TkUserWrongQuestionRecodeMutation) AnswerCleared() bool {
	_, ok := m.clearedFields[tkuserwrongquestionrecode.FieldAnswer]
	return ok
}

// ResetAnswer resets all changes to the "answer" field.
func (m *TkUserWrongQuestionRecodeMutation) ResetAnswer() {
	m.answer = nil
	delete(m.clearedFields, tkuserwrongquestionrecode.FieldAnswer)
}

// SetWrongExamType sets the "wrong_exam_type" field.
func (m *TkUserWrongQuestionRecodeMutation) SetWrongExamType(i int) {
	m.wrong_exam_type = &i
	m.addwrong_exam_type = nil
}

// WrongExamType returns the value of the "wrong_exam_type" field in the mutation.
func (m *TkUserWrongQuestionRecodeMutation) WrongExamType() (r int, exists bool) {
	v := m.wrong_exam_type
	if v == nil {
		return
	}
	return *v, true
}

// OldWrongExamType returns the old "wrong_exam_type" field's value of the TkUserWrongQuestionRecode entity.
// If the TkUserWrongQuestionRecode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserWrongQuestionRecodeMutation) OldWrongExamType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWrongExamType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWrongExamType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWrongExamType: %w", err)
	}
	return oldValue.WrongExamType, nil
}

// AddWrongExamType adds i to the "wrong_exam_type" field.
func (m *TkUserWrongQuestionRecodeMutation) AddWrongExamType(i int) {
	if m.addwrong_exam_type != nil {
		*m.addwrong_exam_type += i
	} else {
		m.addwrong_exam_type = &i
	}
}

// AddedWrongExamType returns the value that was added to the "wrong_exam_type" field in this mutation.
func (m *TkUserWrongQuestionRecodeMutation) AddedWrongExamType() (r int, exists bool) {
	v := m.addwrong_exam_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetWrongExamType resets all changes to the "wrong_exam_type" field.
func (m *TkUserWrongQuestionRecodeMutation) ResetWrongExamType() {
	m.wrong_exam_type = nil
	m.addwrong_exam_type = nil
}

// SetWrongQuestionType sets the "wrong_question_type" field.
func (m *TkUserWrongQuestionRecodeMutation) SetWrongQuestionType(i int) {
	m.wrong_question_type = &i
	m.addwrong_question_type = nil
}

// WrongQuestionType returns the value of the "wrong_question_type" field in the mutation.
func (m *TkUserWrongQuestionRecodeMutation) WrongQuestionType() (r int, exists bool) {
	v := m.wrong_question_type
	if v == nil {
		return
	}
	return *v, true
}

// OldWrongQuestionType returns the old "wrong_question_type" field's value of the TkUserWrongQuestionRecode entity.
// If the TkUserWrongQuestionRecode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TkUserWrongQuestionRecodeMutation) OldWrongQuestionType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWrongQuestionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWrongQuestionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWrongQuestionType: %w", err)
	}
	return oldValue.WrongQuestionType, nil
}

// AddWrongQuestionType adds i to the "wrong_question_type" field.
func (m *TkUserWrongQuestionRecodeMutation) AddWrongQuestionType(i int) {
	if m.addwrong_question_type != nil {
		*m.addwrong_question_type += i
	} else {
		m.addwrong_question_type = &i
	}
}

// AddedWrongQuestionType returns the value that was added to the "wrong_question_type" field in this mutation.
func (m *TkUserWrongQuestionRecodeMutation) AddedWrongQuestionType() (r int, exists bool) {
	v := m.addwrong_question_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetWrongQuestionType resets all changes to the "wrong_question_type" field.
func (m *TkUserWrongQuestionRecodeMutation) ResetWrongQuestionType() {
	m.wrong_question_type = nil
	m.addwrong_question_type = nil
}

// SetQuestionWrongID sets the "question_wrong" edge to the TkQuestion entity by id.
func (m *TkUserWrongQuestionRecodeMutation) SetQuestionWrongID(id int) {
	m.question_wrong = &id
}

// ClearQuestionWrong clears the "question_wrong" edge to the TkQuestion entity.
func (m *TkUserWrongQuestionRecodeMutation) ClearQuestionWrong() {
	m.clearedquestion_wrong = true
}

// QuestionWrongCleared reports if the "question_wrong" edge to the TkQuestion entity was cleared.
func (m *TkUserWrongQuestionRecodeMutation) QuestionWrongCleared() bool {
	return m.QuestionIDCleared() || m.clearedquestion_wrong
}

// QuestionWrongID returns the "question_wrong" edge ID in the mutation.
func (m *TkUserWrongQuestionRecodeMutation) QuestionWrongID() (id int, exists bool) {
	if m.question_wrong != nil {
		return *m.question_wrong, true
	}
	return
}

// QuestionWrongIDs returns the "question_wrong" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// QuestionWrongID instead. It exists only for internal usage by the builders.
func (m *TkUserWrongQuestionRecodeMutation) QuestionWrongIDs() (ids []int) {
	if id := m.question_wrong; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetQuestionWrong resets all changes to the "question_wrong" edge.
func (m *TkUserWrongQuestionRecodeMutation) ResetQuestionWrong() {
	m.question_wrong = nil
	m.clearedquestion_wrong = false
}

// Op returns the operation name.
func (m *TkUserWrongQuestionRecodeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TkUserWrongQuestionRecode).
func (m *TkUserWrongQuestionRecodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TkUserWrongQuestionRecodeMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.uuid != nil {
		fields = append(fields, tkuserwrongquestionrecode.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, tkuserwrongquestionrecode.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tkuserwrongquestionrecode.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, tkuserwrongquestionrecode.FieldDeletedAt)
	}
	if m.user_id != nil {
		fields = append(fields, tkuserwrongquestionrecode.FieldUserID)
	}
	if m.question_wrong != nil {
		fields = append(fields, tkuserwrongquestionrecode.FieldQuestionID)
	}
	if m.question_bank_id != nil {
		fields = append(fields, tkuserwrongquestionrecode.FieldQuestionBankID)
	}
	if m.answer != nil {
		fields = append(fields, tkuserwrongquestionrecode.FieldAnswer)
	}
	if m.wrong_exam_type != nil {
		fields = append(fields, tkuserwrongquestionrecode.FieldWrongExamType)
	}
	if m.wrong_question_type != nil {
		fields = append(fields, tkuserwrongquestionrecode.FieldWrongQuestionType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TkUserWrongQuestionRecodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tkuserwrongquestionrecode.FieldUUID:
		return m.UUID()
	case tkuserwrongquestionrecode.FieldCreatedAt:
		return m.CreatedAt()
	case tkuserwrongquestionrecode.FieldUpdatedAt:
		return m.UpdatedAt()
	case tkuserwrongquestionrecode.FieldDeletedAt:
		return m.DeletedAt()
	case tkuserwrongquestionrecode.FieldUserID:
		return m.UserID()
	case tkuserwrongquestionrecode.FieldQuestionID:
		return m.QuestionID()
	case tkuserwrongquestionrecode.FieldQuestionBankID:
		return m.QuestionBankID()
	case tkuserwrongquestionrecode.FieldAnswer:
		return m.Answer()
	case tkuserwrongquestionrecode.FieldWrongExamType:
		return m.WrongExamType()
	case tkuserwrongquestionrecode.FieldWrongQuestionType:
		return m.WrongQuestionType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TkUserWrongQuestionRecodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tkuserwrongquestionrecode.FieldUUID:
		return m.OldUUID(ctx)
	case tkuserwrongquestionrecode.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tkuserwrongquestionrecode.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tkuserwrongquestionrecode.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case tkuserwrongquestionrecode.FieldUserID:
		return m.OldUserID(ctx)
	case tkuserwrongquestionrecode.FieldQuestionID:
		return m.OldQuestionID(ctx)
	case tkuserwrongquestionrecode.FieldQuestionBankID:
		return m.OldQuestionBankID(ctx)
	case tkuserwrongquestionrecode.FieldAnswer:
		return m.OldAnswer(ctx)
	case tkuserwrongquestionrecode.FieldWrongExamType:
		return m.OldWrongExamType(ctx)
	case tkuserwrongquestionrecode.FieldWrongQuestionType:
		return m.OldWrongQuestionType(ctx)
	}
	return nil, fmt.Errorf("unknown TkUserWrongQuestionRecode field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TkUserWrongQuestionRecodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tkuserwrongquestionrecode.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case tkuserwrongquestionrecode.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tkuserwrongquestionrecode.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tkuserwrongquestionrecode.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case tkuserwrongquestionrecode.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case tkuserwrongquestionrecode.FieldQuestionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuestionID(v)
		return nil
	case tkuserwrongquestionrecode.FieldQuestionBankID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuestionBankID(v)
		return nil
	case tkuserwrongquestionrecode.FieldAnswer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnswer(v)
		return nil
	case tkuserwrongquestionrecode.FieldWrongExamType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWrongExamType(v)
		return nil
	case tkuserwrongquestionrecode.FieldWrongQuestionType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWrongQuestionType(v)
		return nil
	}
	return fmt.Errorf("unknown TkUserWrongQuestionRecode field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TkUserWrongQuestionRecodeMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, tkuserwrongquestionrecode.FieldUserID)
	}
	if m.addquestion_bank_id != nil {
		fields = append(fields, tkuserwrongquestionrecode.FieldQuestionBankID)
	}
	if m.addwrong_exam_type != nil {
		fields = append(fields, tkuserwrongquestionrecode.FieldWrongExamType)
	}
	if m.addwrong_question_type != nil {
		fields = append(fields, tkuserwrongquestionrecode.FieldWrongQuestionType)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TkUserWrongQuestionRecodeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tkuserwrongquestionrecode.FieldUserID:
		return m.AddedUserID()
	case tkuserwrongquestionrecode.FieldQuestionBankID:
		return m.AddedQuestionBankID()
	case tkuserwrongquestionrecode.FieldWrongExamType:
		return m.AddedWrongExamType()
	case tkuserwrongquestionrecode.FieldWrongQuestionType:
		return m.AddedWrongQuestionType()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TkUserWrongQuestionRecodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tkuserwrongquestionrecode.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case tkuserwrongquestionrecode.FieldQuestionBankID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuestionBankID(v)
		return nil
	case tkuserwrongquestionrecode.FieldWrongExamType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWrongExamType(v)
		return nil
	case tkuserwrongquestionrecode.FieldWrongQuestionType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWrongQuestionType(v)
		return nil
	}
	return fmt.Errorf("unknown TkUserWrongQuestionRecode numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TkUserWrongQuestionRecodeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tkuserwrongquestionrecode.FieldCreatedAt) {
		fields = append(fields, tkuserwrongquestionrecode.FieldCreatedAt)
	}
	if m.FieldCleared(tkuserwrongquestionrecode.FieldUpdatedAt) {
		fields = append(fields, tkuserwrongquestionrecode.FieldUpdatedAt)
	}
	if m.FieldCleared(tkuserwrongquestionrecode.FieldDeletedAt) {
		fields = append(fields, tkuserwrongquestionrecode.FieldDeletedAt)
	}
	if m.FieldCleared(tkuserwrongquestionrecode.FieldUserID) {
		fields = append(fields, tkuserwrongquestionrecode.FieldUserID)
	}
	if m.FieldCleared(tkuserwrongquestionrecode.FieldQuestionID) {
		fields = append(fields, tkuserwrongquestionrecode.FieldQuestionID)
	}
	if m.FieldCleared(tkuserwrongquestionrecode.FieldQuestionBankID) {
		fields = append(fields, tkuserwrongquestionrecode.FieldQuestionBankID)
	}
	if m.FieldCleared(tkuserwrongquestionrecode.FieldAnswer) {
		fields = append(fields, tkuserwrongquestionrecode.FieldAnswer)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TkUserWrongQuestionRecodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TkUserWrongQuestionRecodeMutation) ClearField(name string) error {
	switch name {
	case tkuserwrongquestionrecode.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case tkuserwrongquestionrecode.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case tkuserwrongquestionrecode.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case tkuserwrongquestionrecode.FieldUserID:
		m.ClearUserID()
		return nil
	case tkuserwrongquestionrecode.FieldQuestionID:
		m.ClearQuestionID()
		return nil
	case tkuserwrongquestionrecode.FieldQuestionBankID:
		m.ClearQuestionBankID()
		return nil
	case tkuserwrongquestionrecode.FieldAnswer:
		m.ClearAnswer()
		return nil
	}
	return fmt.Errorf("unknown TkUserWrongQuestionRecode nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TkUserWrongQuestionRecodeMutation) ResetField(name string) error {
	switch name {
	case tkuserwrongquestionrecode.FieldUUID:
		m.ResetUUID()
		return nil
	case tkuserwrongquestionrecode.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tkuserwrongquestionrecode.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tkuserwrongquestionrecode.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case tkuserwrongquestionrecode.FieldUserID:
		m.ResetUserID()
		return nil
	case tkuserwrongquestionrecode.FieldQuestionID:
		m.ResetQuestionID()
		return nil
	case tkuserwrongquestionrecode.FieldQuestionBankID:
		m.ResetQuestionBankID()
		return nil
	case tkuserwrongquestionrecode.FieldAnswer:
		m.ResetAnswer()
		return nil
	case tkuserwrongquestionrecode.FieldWrongExamType:
		m.ResetWrongExamType()
		return nil
	case tkuserwrongquestionrecode.FieldWrongQuestionType:
		m.ResetWrongQuestionType()
		return nil
	}
	return fmt.Errorf("unknown TkUserWrongQuestionRecode field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TkUserWrongQuestionRecodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.question_wrong != nil {
		edges = append(edges, tkuserwrongquestionrecode.EdgeQuestionWrong)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TkUserWrongQuestionRecodeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tkuserwrongquestionrecode.EdgeQuestionWrong:
		if id := m.question_wrong; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TkUserWrongQuestionRecodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TkUserWrongQuestionRecodeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TkUserWrongQuestionRecodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedquestion_wrong {
		edges = append(edges, tkuserwrongquestionrecode.EdgeQuestionWrong)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TkUserWrongQuestionRecodeMutation) EdgeCleared(name string) bool {
	switch name {
	case tkuserwrongquestionrecode.EdgeQuestionWrong:
		return m.clearedquestion_wrong
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TkUserWrongQuestionRecodeMutation) ClearEdge(name string) error {
	switch name {
	case tkuserwrongquestionrecode.EdgeQuestionWrong:
		m.ClearQuestionWrong()
		return nil
	}
	return fmt.Errorf("unknown TkUserWrongQuestionRecode unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TkUserWrongQuestionRecodeMutation) ResetEdge(name string) error {
	switch name {
	case tkuserwrongquestionrecode.EdgeQuestionWrong:
		m.ResetQuestionWrong()
		return nil
	}
	return fmt.Errorf("unknown TkUserWrongQuestionRecode edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                                Op
	typ                               string
	id                                *int
	uuid                              *string
	created_at                        *time.Time
	updated_at                        *time.Time
	deleted_at                        *time.Time
	password                          *string
	salt                              *string
	boss_user_id                      *int
	addboss_user_id                   *int
	email                             *string
	phone                             *string
	nickname                          *string
	username                          *string
	status                            *uint8
	addstatus                         *uint8
	sex                               *uint8
	addsex                            *uint8
	reg_from                          *uint8
	addreg_from                       *uint8
	card_type                         *uint8
	addcard_type                      *uint8
	id_card                           *string
	birthday                          *time.Time
	sign_remark                       *string
	avatar                            *string
	clearedFields                     map[string]struct{}
	login_log                         map[int]struct{}
	removedlogin_log                  map[int]struct{}
	clearedlogin_log                  bool
	messages                          map[int]struct{}
	removedmessages                   map[int]struct{}
	clearedmessages                   bool
	user_courses                      map[int]struct{}
	removeduser_courses               map[int]struct{}
	cleareduser_courses               bool
	user_classes                      map[int]struct{}
	removeduser_classes               map[int]struct{}
	cleareduser_classes               bool
	user_exams_records                map[int]struct{}
	removeduser_exams_records         map[int]struct{}
	cleareduser_exams_records         bool
	user_question_bank_records        map[int]struct{}
	removeduser_question_bank_records map[int]struct{}
	cleareduser_question_bank_records bool
	user_question_records             map[int]struct{}
	removeduser_question_records      map[int]struct{}
	cleareduser_question_records      bool
	ask_users                         map[int]struct{}
	removedask_users                  map[int]struct{}
	clearedask_users                  bool
	course_appraise_users             map[int]struct{}
	removedcourse_appraise_users      map[int]struct{}
	clearedcourse_appraise_users      bool
	user_video_record                 map[int]struct{}
	removeduser_video_record          map[int]struct{}
	cleareduser_video_record          bool
	city                              *int
	clearedcity                       bool
	cate                              *int
	clearedcate                       bool
	done                              bool
	oldValue                          func(context.Context) (*User, error)
	predicates                        []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *UserMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *UserMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *UserMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *UserMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[user.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *UserMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, user.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *UserMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[user.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *UserMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, user.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[user.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, user.FieldDeletedAt)
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetSalt sets the "salt" field.
func (m *UserMutation) SetSalt(s string) {
	m.salt = &s
}

// Salt returns the value of the "salt" field in the mutation.
func (m *UserMutation) Salt() (r string, exists bool) {
	v := m.salt
	if v == nil {
		return
	}
	return *v, true
}

// OldSalt returns the old "salt" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSalt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSalt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSalt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSalt: %w", err)
	}
	return oldValue.Salt, nil
}

// ResetSalt resets all changes to the "salt" field.
func (m *UserMutation) ResetSalt() {
	m.salt = nil
}

// SetBossUserID sets the "boss_user_id" field.
func (m *UserMutation) SetBossUserID(i int) {
	m.boss_user_id = &i
	m.addboss_user_id = nil
}

// BossUserID returns the value of the "boss_user_id" field in the mutation.
func (m *UserMutation) BossUserID() (r int, exists bool) {
	v := m.boss_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldBossUserID returns the old "boss_user_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldBossUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBossUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBossUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBossUserID: %w", err)
	}
	return oldValue.BossUserID, nil
}

// AddBossUserID adds i to the "boss_user_id" field.
func (m *UserMutation) AddBossUserID(i int) {
	if m.addboss_user_id != nil {
		*m.addboss_user_id += i
	} else {
		m.addboss_user_id = &i
	}
}

// AddedBossUserID returns the value that was added to the "boss_user_id" field in this mutation.
func (m *UserMutation) AddedBossUserID() (r int, exists bool) {
	v := m.addboss_user_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetBossUserID resets all changes to the "boss_user_id" field.
func (m *UserMutation) ResetBossUserID() {
	m.boss_user_id = nil
	m.addboss_user_id = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPhone sets the "phone" field.
func (m *UserMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *UserMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *UserMutation) ResetPhone() {
	m.phone = nil
}

// SetNickname sets the "nickname" field.
func (m *UserMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the value of the "nickname" field in the mutation.
func (m *UserMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old "nickname" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ResetNickname resets all changes to the "nickname" field.
func (m *UserMutation) ResetNickname() {
	m.nickname = nil
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetStatus sets the "status" field.
func (m *UserMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *UserMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *UserMutation) AddStatus(u uint8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *UserMutation) AddedStatus() (r uint8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *UserMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetSex sets the "sex" field.
func (m *UserMutation) SetSex(u uint8) {
	m.sex = &u
	m.addsex = nil
}

// Sex returns the value of the "sex" field in the mutation.
func (m *UserMutation) Sex() (r uint8, exists bool) {
	v := m.sex
	if v == nil {
		return
	}
	return *v, true
}

// OldSex returns the old "sex" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSex(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSex: %w", err)
	}
	return oldValue.Sex, nil
}

// AddSex adds u to the "sex" field.
func (m *UserMutation) AddSex(u uint8) {
	if m.addsex != nil {
		*m.addsex += u
	} else {
		m.addsex = &u
	}
}

// AddedSex returns the value that was added to the "sex" field in this mutation.
func (m *UserMutation) AddedSex() (r uint8, exists bool) {
	v := m.addsex
	if v == nil {
		return
	}
	return *v, true
}

// ResetSex resets all changes to the "sex" field.
func (m *UserMutation) ResetSex() {
	m.sex = nil
	m.addsex = nil
}

// SetRegFrom sets the "reg_from" field.
func (m *UserMutation) SetRegFrom(u uint8) {
	m.reg_from = &u
	m.addreg_from = nil
}

// RegFrom returns the value of the "reg_from" field in the mutation.
func (m *UserMutation) RegFrom() (r uint8, exists bool) {
	v := m.reg_from
	if v == nil {
		return
	}
	return *v, true
}

// OldRegFrom returns the old "reg_from" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRegFrom(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRegFrom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRegFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegFrom: %w", err)
	}
	return oldValue.RegFrom, nil
}

// AddRegFrom adds u to the "reg_from" field.
func (m *UserMutation) AddRegFrom(u uint8) {
	if m.addreg_from != nil {
		*m.addreg_from += u
	} else {
		m.addreg_from = &u
	}
}

// AddedRegFrom returns the value that was added to the "reg_from" field in this mutation.
func (m *UserMutation) AddedRegFrom() (r uint8, exists bool) {
	v := m.addreg_from
	if v == nil {
		return
	}
	return *v, true
}

// ResetRegFrom resets all changes to the "reg_from" field.
func (m *UserMutation) ResetRegFrom() {
	m.reg_from = nil
	m.addreg_from = nil
}

// SetCardType sets the "card_type" field.
func (m *UserMutation) SetCardType(u uint8) {
	m.card_type = &u
	m.addcard_type = nil
}

// CardType returns the value of the "card_type" field in the mutation.
func (m *UserMutation) CardType() (r uint8, exists bool) {
	v := m.card_type
	if v == nil {
		return
	}
	return *v, true
}

// OldCardType returns the old "card_type" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCardType(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCardType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCardType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCardType: %w", err)
	}
	return oldValue.CardType, nil
}

// AddCardType adds u to the "card_type" field.
func (m *UserMutation) AddCardType(u uint8) {
	if m.addcard_type != nil {
		*m.addcard_type += u
	} else {
		m.addcard_type = &u
	}
}

// AddedCardType returns the value that was added to the "card_type" field in this mutation.
func (m *UserMutation) AddedCardType() (r uint8, exists bool) {
	v := m.addcard_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetCardType resets all changes to the "card_type" field.
func (m *UserMutation) ResetCardType() {
	m.card_type = nil
	m.addcard_type = nil
}

// SetIDCard sets the "id_card" field.
func (m *UserMutation) SetIDCard(s string) {
	m.id_card = &s
}

// IDCard returns the value of the "id_card" field in the mutation.
func (m *UserMutation) IDCard() (r string, exists bool) {
	v := m.id_card
	if v == nil {
		return
	}
	return *v, true
}

// OldIDCard returns the old "id_card" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIDCard(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIDCard is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIDCard requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIDCard: %w", err)
	}
	return oldValue.IDCard, nil
}

// ResetIDCard resets all changes to the "id_card" field.
func (m *UserMutation) ResetIDCard() {
	m.id_card = nil
}

// SetFromCityID sets the "from_city_id" field.
func (m *UserMutation) SetFromCityID(i int) {
	m.city = &i
}

// FromCityID returns the value of the "from_city_id" field in the mutation.
func (m *UserMutation) FromCityID() (r int, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldFromCityID returns the old "from_city_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFromCityID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFromCityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFromCityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromCityID: %w", err)
	}
	return oldValue.FromCityID, nil
}

// ClearFromCityID clears the value of the "from_city_id" field.
func (m *UserMutation) ClearFromCityID() {
	m.city = nil
	m.clearedFields[user.FieldFromCityID] = struct{}{}
}

// FromCityIDCleared returns if the "from_city_id" field was cleared in this mutation.
func (m *UserMutation) FromCityIDCleared() bool {
	_, ok := m.clearedFields[user.FieldFromCityID]
	return ok
}

// ResetFromCityID resets all changes to the "from_city_id" field.
func (m *UserMutation) ResetFromCityID() {
	m.city = nil
	delete(m.clearedFields, user.FieldFromCityID)
}

// SetFromItemCategoryID sets the "from_item_category_id" field.
func (m *UserMutation) SetFromItemCategoryID(i int) {
	m.cate = &i
}

// FromItemCategoryID returns the value of the "from_item_category_id" field in the mutation.
func (m *UserMutation) FromItemCategoryID() (r int, exists bool) {
	v := m.cate
	if v == nil {
		return
	}
	return *v, true
}

// OldFromItemCategoryID returns the old "from_item_category_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFromItemCategoryID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFromItemCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFromItemCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromItemCategoryID: %w", err)
	}
	return oldValue.FromItemCategoryID, nil
}

// ClearFromItemCategoryID clears the value of the "from_item_category_id" field.
func (m *UserMutation) ClearFromItemCategoryID() {
	m.cate = nil
	m.clearedFields[user.FieldFromItemCategoryID] = struct{}{}
}

// FromItemCategoryIDCleared returns if the "from_item_category_id" field was cleared in this mutation.
func (m *UserMutation) FromItemCategoryIDCleared() bool {
	_, ok := m.clearedFields[user.FieldFromItemCategoryID]
	return ok
}

// ResetFromItemCategoryID resets all changes to the "from_item_category_id" field.
func (m *UserMutation) ResetFromItemCategoryID() {
	m.cate = nil
	delete(m.clearedFields, user.FieldFromItemCategoryID)
}

// SetBirthday sets the "birthday" field.
func (m *UserMutation) SetBirthday(t time.Time) {
	m.birthday = &t
}

// Birthday returns the value of the "birthday" field in the mutation.
func (m *UserMutation) Birthday() (r time.Time, exists bool) {
	v := m.birthday
	if v == nil {
		return
	}
	return *v, true
}

// OldBirthday returns the old "birthday" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldBirthday(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBirthday is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBirthday requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirthday: %w", err)
	}
	return oldValue.Birthday, nil
}

// ClearBirthday clears the value of the "birthday" field.
func (m *UserMutation) ClearBirthday() {
	m.birthday = nil
	m.clearedFields[user.FieldBirthday] = struct{}{}
}

// BirthdayCleared returns if the "birthday" field was cleared in this mutation.
func (m *UserMutation) BirthdayCleared() bool {
	_, ok := m.clearedFields[user.FieldBirthday]
	return ok
}

// ResetBirthday resets all changes to the "birthday" field.
func (m *UserMutation) ResetBirthday() {
	m.birthday = nil
	delete(m.clearedFields, user.FieldBirthday)
}

// SetSignRemark sets the "sign_remark" field.
func (m *UserMutation) SetSignRemark(s string) {
	m.sign_remark = &s
}

// SignRemark returns the value of the "sign_remark" field in the mutation.
func (m *UserMutation) SignRemark() (r string, exists bool) {
	v := m.sign_remark
	if v == nil {
		return
	}
	return *v, true
}

// OldSignRemark returns the old "sign_remark" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSignRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSignRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSignRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignRemark: %w", err)
	}
	return oldValue.SignRemark, nil
}

// ClearSignRemark clears the value of the "sign_remark" field.
func (m *UserMutation) ClearSignRemark() {
	m.sign_remark = nil
	m.clearedFields[user.FieldSignRemark] = struct{}{}
}

// SignRemarkCleared returns if the "sign_remark" field was cleared in this mutation.
func (m *UserMutation) SignRemarkCleared() bool {
	_, ok := m.clearedFields[user.FieldSignRemark]
	return ok
}

// ResetSignRemark resets all changes to the "sign_remark" field.
func (m *UserMutation) ResetSignRemark() {
	m.sign_remark = nil
	delete(m.clearedFields, user.FieldSignRemark)
}

// SetAvatar sets the "avatar" field.
func (m *UserMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *UserMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *UserMutation) ResetAvatar() {
	m.avatar = nil
}

// AddLoginLogIDs adds the "login_log" edge to the UserLoginLog entity by ids.
func (m *UserMutation) AddLoginLogIDs(ids ...int) {
	if m.login_log == nil {
		m.login_log = make(map[int]struct{})
	}
	for i := range ids {
		m.login_log[ids[i]] = struct{}{}
	}
}

// ClearLoginLog clears the "login_log" edge to the UserLoginLog entity.
func (m *UserMutation) ClearLoginLog() {
	m.clearedlogin_log = true
}

// LoginLogCleared reports if the "login_log" edge to the UserLoginLog entity was cleared.
func (m *UserMutation) LoginLogCleared() bool {
	return m.clearedlogin_log
}

// RemoveLoginLogIDs removes the "login_log" edge to the UserLoginLog entity by IDs.
func (m *UserMutation) RemoveLoginLogIDs(ids ...int) {
	if m.removedlogin_log == nil {
		m.removedlogin_log = make(map[int]struct{})
	}
	for i := range ids {
		m.removedlogin_log[ids[i]] = struct{}{}
	}
}

// RemovedLoginLog returns the removed IDs of the "login_log" edge to the UserLoginLog entity.
func (m *UserMutation) RemovedLoginLogIDs() (ids []int) {
	for id := range m.removedlogin_log {
		ids = append(ids, id)
	}
	return
}

// LoginLogIDs returns the "login_log" edge IDs in the mutation.
func (m *UserMutation) LoginLogIDs() (ids []int) {
	for id := range m.login_log {
		ids = append(ids, id)
	}
	return
}

// ResetLoginLog resets all changes to the "login_log" edge.
func (m *UserMutation) ResetLoginLog() {
	m.login_log = nil
	m.clearedlogin_log = false
	m.removedlogin_log = nil
}

// AddMessageIDs adds the "messages" edge to the Message entity by ids.
func (m *UserMutation) AddMessageIDs(ids ...int) {
	if m.messages == nil {
		m.messages = make(map[int]struct{})
	}
	for i := range ids {
		m.messages[ids[i]] = struct{}{}
	}
}

// ClearMessages clears the "messages" edge to the Message entity.
func (m *UserMutation) ClearMessages() {
	m.clearedmessages = true
}

// MessagesCleared reports if the "messages" edge to the Message entity was cleared.
func (m *UserMutation) MessagesCleared() bool {
	return m.clearedmessages
}

// RemoveMessageIDs removes the "messages" edge to the Message entity by IDs.
func (m *UserMutation) RemoveMessageIDs(ids ...int) {
	if m.removedmessages == nil {
		m.removedmessages = make(map[int]struct{})
	}
	for i := range ids {
		m.removedmessages[ids[i]] = struct{}{}
	}
}

// RemovedMessages returns the removed IDs of the "messages" edge to the Message entity.
func (m *UserMutation) RemovedMessagesIDs() (ids []int) {
	for id := range m.removedmessages {
		ids = append(ids, id)
	}
	return
}

// MessagesIDs returns the "messages" edge IDs in the mutation.
func (m *UserMutation) MessagesIDs() (ids []int) {
	for id := range m.messages {
		ids = append(ids, id)
	}
	return
}

// ResetMessages resets all changes to the "messages" edge.
func (m *UserMutation) ResetMessages() {
	m.messages = nil
	m.clearedmessages = false
	m.removedmessages = nil
}

// AddUserCourseIDs adds the "user_courses" edge to the KcUserCourse entity by ids.
func (m *UserMutation) AddUserCourseIDs(ids ...int) {
	if m.user_courses == nil {
		m.user_courses = make(map[int]struct{})
	}
	for i := range ids {
		m.user_courses[ids[i]] = struct{}{}
	}
}

// ClearUserCourses clears the "user_courses" edge to the KcUserCourse entity.
func (m *UserMutation) ClearUserCourses() {
	m.cleareduser_courses = true
}

// UserCoursesCleared reports if the "user_courses" edge to the KcUserCourse entity was cleared.
func (m *UserMutation) UserCoursesCleared() bool {
	return m.cleareduser_courses
}

// RemoveUserCourseIDs removes the "user_courses" edge to the KcUserCourse entity by IDs.
func (m *UserMutation) RemoveUserCourseIDs(ids ...int) {
	if m.removeduser_courses == nil {
		m.removeduser_courses = make(map[int]struct{})
	}
	for i := range ids {
		m.removeduser_courses[ids[i]] = struct{}{}
	}
}

// RemovedUserCourses returns the removed IDs of the "user_courses" edge to the KcUserCourse entity.
func (m *UserMutation) RemovedUserCoursesIDs() (ids []int) {
	for id := range m.removeduser_courses {
		ids = append(ids, id)
	}
	return
}

// UserCoursesIDs returns the "user_courses" edge IDs in the mutation.
func (m *UserMutation) UserCoursesIDs() (ids []int) {
	for id := range m.user_courses {
		ids = append(ids, id)
	}
	return
}

// ResetUserCourses resets all changes to the "user_courses" edge.
func (m *UserMutation) ResetUserCourses() {
	m.user_courses = nil
	m.cleareduser_courses = false
	m.removeduser_courses = nil
}

// AddUserClassIDs adds the "user_classes" edge to the KcUserClass entity by ids.
func (m *UserMutation) AddUserClassIDs(ids ...int) {
	if m.user_classes == nil {
		m.user_classes = make(map[int]struct{})
	}
	for i := range ids {
		m.user_classes[ids[i]] = struct{}{}
	}
}

// ClearUserClasses clears the "user_classes" edge to the KcUserClass entity.
func (m *UserMutation) ClearUserClasses() {
	m.cleareduser_classes = true
}

// UserClassesCleared reports if the "user_classes" edge to the KcUserClass entity was cleared.
func (m *UserMutation) UserClassesCleared() bool {
	return m.cleareduser_classes
}

// RemoveUserClassIDs removes the "user_classes" edge to the KcUserClass entity by IDs.
func (m *UserMutation) RemoveUserClassIDs(ids ...int) {
	if m.removeduser_classes == nil {
		m.removeduser_classes = make(map[int]struct{})
	}
	for i := range ids {
		m.removeduser_classes[ids[i]] = struct{}{}
	}
}

// RemovedUserClasses returns the removed IDs of the "user_classes" edge to the KcUserClass entity.
func (m *UserMutation) RemovedUserClassesIDs() (ids []int) {
	for id := range m.removeduser_classes {
		ids = append(ids, id)
	}
	return
}

// UserClassesIDs returns the "user_classes" edge IDs in the mutation.
func (m *UserMutation) UserClassesIDs() (ids []int) {
	for id := range m.user_classes {
		ids = append(ids, id)
	}
	return
}

// ResetUserClasses resets all changes to the "user_classes" edge.
func (m *UserMutation) ResetUserClasses() {
	m.user_classes = nil
	m.cleareduser_classes = false
	m.removeduser_classes = nil
}

// AddUserExamsRecordIDs adds the "user_exams_records" edge to the TkUserExamScoreRecord entity by ids.
func (m *UserMutation) AddUserExamsRecordIDs(ids ...int) {
	if m.user_exams_records == nil {
		m.user_exams_records = make(map[int]struct{})
	}
	for i := range ids {
		m.user_exams_records[ids[i]] = struct{}{}
	}
}

// ClearUserExamsRecords clears the "user_exams_records" edge to the TkUserExamScoreRecord entity.
func (m *UserMutation) ClearUserExamsRecords() {
	m.cleareduser_exams_records = true
}

// UserExamsRecordsCleared reports if the "user_exams_records" edge to the TkUserExamScoreRecord entity was cleared.
func (m *UserMutation) UserExamsRecordsCleared() bool {
	return m.cleareduser_exams_records
}

// RemoveUserExamsRecordIDs removes the "user_exams_records" edge to the TkUserExamScoreRecord entity by IDs.
func (m *UserMutation) RemoveUserExamsRecordIDs(ids ...int) {
	if m.removeduser_exams_records == nil {
		m.removeduser_exams_records = make(map[int]struct{})
	}
	for i := range ids {
		m.removeduser_exams_records[ids[i]] = struct{}{}
	}
}

// RemovedUserExamsRecords returns the removed IDs of the "user_exams_records" edge to the TkUserExamScoreRecord entity.
func (m *UserMutation) RemovedUserExamsRecordsIDs() (ids []int) {
	for id := range m.removeduser_exams_records {
		ids = append(ids, id)
	}
	return
}

// UserExamsRecordsIDs returns the "user_exams_records" edge IDs in the mutation.
func (m *UserMutation) UserExamsRecordsIDs() (ids []int) {
	for id := range m.user_exams_records {
		ids = append(ids, id)
	}
	return
}

// ResetUserExamsRecords resets all changes to the "user_exams_records" edge.
func (m *UserMutation) ResetUserExamsRecords() {
	m.user_exams_records = nil
	m.cleareduser_exams_records = false
	m.removeduser_exams_records = nil
}

// AddUserQuestionBankRecordIDs adds the "user_question_bank_records" edge to the TkUserQuestionBankRecord entity by ids.
func (m *UserMutation) AddUserQuestionBankRecordIDs(ids ...int) {
	if m.user_question_bank_records == nil {
		m.user_question_bank_records = make(map[int]struct{})
	}
	for i := range ids {
		m.user_question_bank_records[ids[i]] = struct{}{}
	}
}

// ClearUserQuestionBankRecords clears the "user_question_bank_records" edge to the TkUserQuestionBankRecord entity.
func (m *UserMutation) ClearUserQuestionBankRecords() {
	m.cleareduser_question_bank_records = true
}

// UserQuestionBankRecordsCleared reports if the "user_question_bank_records" edge to the TkUserQuestionBankRecord entity was cleared.
func (m *UserMutation) UserQuestionBankRecordsCleared() bool {
	return m.cleareduser_question_bank_records
}

// RemoveUserQuestionBankRecordIDs removes the "user_question_bank_records" edge to the TkUserQuestionBankRecord entity by IDs.
func (m *UserMutation) RemoveUserQuestionBankRecordIDs(ids ...int) {
	if m.removeduser_question_bank_records == nil {
		m.removeduser_question_bank_records = make(map[int]struct{})
	}
	for i := range ids {
		m.removeduser_question_bank_records[ids[i]] = struct{}{}
	}
}

// RemovedUserQuestionBankRecords returns the removed IDs of the "user_question_bank_records" edge to the TkUserQuestionBankRecord entity.
func (m *UserMutation) RemovedUserQuestionBankRecordsIDs() (ids []int) {
	for id := range m.removeduser_question_bank_records {
		ids = append(ids, id)
	}
	return
}

// UserQuestionBankRecordsIDs returns the "user_question_bank_records" edge IDs in the mutation.
func (m *UserMutation) UserQuestionBankRecordsIDs() (ids []int) {
	for id := range m.user_question_bank_records {
		ids = append(ids, id)
	}
	return
}

// ResetUserQuestionBankRecords resets all changes to the "user_question_bank_records" edge.
func (m *UserMutation) ResetUserQuestionBankRecords() {
	m.user_question_bank_records = nil
	m.cleareduser_question_bank_records = false
	m.removeduser_question_bank_records = nil
}

// AddUserQuestionRecordIDs adds the "user_question_records" edge to the TkUserQuestionRecord entity by ids.
func (m *UserMutation) AddUserQuestionRecordIDs(ids ...int) {
	if m.user_question_records == nil {
		m.user_question_records = make(map[int]struct{})
	}
	for i := range ids {
		m.user_question_records[ids[i]] = struct{}{}
	}
}

// ClearUserQuestionRecords clears the "user_question_records" edge to the TkUserQuestionRecord entity.
func (m *UserMutation) ClearUserQuestionRecords() {
	m.cleareduser_question_records = true
}

// UserQuestionRecordsCleared reports if the "user_question_records" edge to the TkUserQuestionRecord entity was cleared.
func (m *UserMutation) UserQuestionRecordsCleared() bool {
	return m.cleareduser_question_records
}

// RemoveUserQuestionRecordIDs removes the "user_question_records" edge to the TkUserQuestionRecord entity by IDs.
func (m *UserMutation) RemoveUserQuestionRecordIDs(ids ...int) {
	if m.removeduser_question_records == nil {
		m.removeduser_question_records = make(map[int]struct{})
	}
	for i := range ids {
		m.removeduser_question_records[ids[i]] = struct{}{}
	}
}

// RemovedUserQuestionRecords returns the removed IDs of the "user_question_records" edge to the TkUserQuestionRecord entity.
func (m *UserMutation) RemovedUserQuestionRecordsIDs() (ids []int) {
	for id := range m.removeduser_question_records {
		ids = append(ids, id)
	}
	return
}

// UserQuestionRecordsIDs returns the "user_question_records" edge IDs in the mutation.
func (m *UserMutation) UserQuestionRecordsIDs() (ids []int) {
	for id := range m.user_question_records {
		ids = append(ids, id)
	}
	return
}

// ResetUserQuestionRecords resets all changes to the "user_question_records" edge.
func (m *UserMutation) ResetUserQuestionRecords() {
	m.user_question_records = nil
	m.cleareduser_question_records = false
	m.removeduser_question_records = nil
}

// AddAskUserIDs adds the "ask_users" edge to the UserAskAnswer entity by ids.
func (m *UserMutation) AddAskUserIDs(ids ...int) {
	if m.ask_users == nil {
		m.ask_users = make(map[int]struct{})
	}
	for i := range ids {
		m.ask_users[ids[i]] = struct{}{}
	}
}

// ClearAskUsers clears the "ask_users" edge to the UserAskAnswer entity.
func (m *UserMutation) ClearAskUsers() {
	m.clearedask_users = true
}

// AskUsersCleared reports if the "ask_users" edge to the UserAskAnswer entity was cleared.
func (m *UserMutation) AskUsersCleared() bool {
	return m.clearedask_users
}

// RemoveAskUserIDs removes the "ask_users" edge to the UserAskAnswer entity by IDs.
func (m *UserMutation) RemoveAskUserIDs(ids ...int) {
	if m.removedask_users == nil {
		m.removedask_users = make(map[int]struct{})
	}
	for i := range ids {
		m.removedask_users[ids[i]] = struct{}{}
	}
}

// RemovedAskUsers returns the removed IDs of the "ask_users" edge to the UserAskAnswer entity.
func (m *UserMutation) RemovedAskUsersIDs() (ids []int) {
	for id := range m.removedask_users {
		ids = append(ids, id)
	}
	return
}

// AskUsersIDs returns the "ask_users" edge IDs in the mutation.
func (m *UserMutation) AskUsersIDs() (ids []int) {
	for id := range m.ask_users {
		ids = append(ids, id)
	}
	return
}

// ResetAskUsers resets all changes to the "ask_users" edge.
func (m *UserMutation) ResetAskUsers() {
	m.ask_users = nil
	m.clearedask_users = false
	m.removedask_users = nil
}

// AddCourseAppraiseUserIDs adds the "course_appraise_users" edge to the UserCourseAppraise entity by ids.
func (m *UserMutation) AddCourseAppraiseUserIDs(ids ...int) {
	if m.course_appraise_users == nil {
		m.course_appraise_users = make(map[int]struct{})
	}
	for i := range ids {
		m.course_appraise_users[ids[i]] = struct{}{}
	}
}

// ClearCourseAppraiseUsers clears the "course_appraise_users" edge to the UserCourseAppraise entity.
func (m *UserMutation) ClearCourseAppraiseUsers() {
	m.clearedcourse_appraise_users = true
}

// CourseAppraiseUsersCleared reports if the "course_appraise_users" edge to the UserCourseAppraise entity was cleared.
func (m *UserMutation) CourseAppraiseUsersCleared() bool {
	return m.clearedcourse_appraise_users
}

// RemoveCourseAppraiseUserIDs removes the "course_appraise_users" edge to the UserCourseAppraise entity by IDs.
func (m *UserMutation) RemoveCourseAppraiseUserIDs(ids ...int) {
	if m.removedcourse_appraise_users == nil {
		m.removedcourse_appraise_users = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcourse_appraise_users[ids[i]] = struct{}{}
	}
}

// RemovedCourseAppraiseUsers returns the removed IDs of the "course_appraise_users" edge to the UserCourseAppraise entity.
func (m *UserMutation) RemovedCourseAppraiseUsersIDs() (ids []int) {
	for id := range m.removedcourse_appraise_users {
		ids = append(ids, id)
	}
	return
}

// CourseAppraiseUsersIDs returns the "course_appraise_users" edge IDs in the mutation.
func (m *UserMutation) CourseAppraiseUsersIDs() (ids []int) {
	for id := range m.course_appraise_users {
		ids = append(ids, id)
	}
	return
}

// ResetCourseAppraiseUsers resets all changes to the "course_appraise_users" edge.
func (m *UserMutation) ResetCourseAppraiseUsers() {
	m.course_appraise_users = nil
	m.clearedcourse_appraise_users = false
	m.removedcourse_appraise_users = nil
}

// AddUserVideoRecordIDs adds the "user_video_record" edge to the VideoRecord entity by ids.
func (m *UserMutation) AddUserVideoRecordIDs(ids ...int) {
	if m.user_video_record == nil {
		m.user_video_record = make(map[int]struct{})
	}
	for i := range ids {
		m.user_video_record[ids[i]] = struct{}{}
	}
}

// ClearUserVideoRecord clears the "user_video_record" edge to the VideoRecord entity.
func (m *UserMutation) ClearUserVideoRecord() {
	m.cleareduser_video_record = true
}

// UserVideoRecordCleared reports if the "user_video_record" edge to the VideoRecord entity was cleared.
func (m *UserMutation) UserVideoRecordCleared() bool {
	return m.cleareduser_video_record
}

// RemoveUserVideoRecordIDs removes the "user_video_record" edge to the VideoRecord entity by IDs.
func (m *UserMutation) RemoveUserVideoRecordIDs(ids ...int) {
	if m.removeduser_video_record == nil {
		m.removeduser_video_record = make(map[int]struct{})
	}
	for i := range ids {
		m.removeduser_video_record[ids[i]] = struct{}{}
	}
}

// RemovedUserVideoRecord returns the removed IDs of the "user_video_record" edge to the VideoRecord entity.
func (m *UserMutation) RemovedUserVideoRecordIDs() (ids []int) {
	for id := range m.removeduser_video_record {
		ids = append(ids, id)
	}
	return
}

// UserVideoRecordIDs returns the "user_video_record" edge IDs in the mutation.
func (m *UserMutation) UserVideoRecordIDs() (ids []int) {
	for id := range m.user_video_record {
		ids = append(ids, id)
	}
	return
}

// ResetUserVideoRecord resets all changes to the "user_video_record" edge.
func (m *UserMutation) ResetUserVideoRecord() {
	m.user_video_record = nil
	m.cleareduser_video_record = false
	m.removeduser_video_record = nil
}

// SetCityID sets the "city" edge to the City entity by id.
func (m *UserMutation) SetCityID(id int) {
	m.city = &id
}

// ClearCity clears the "city" edge to the City entity.
func (m *UserMutation) ClearCity() {
	m.clearedcity = true
}

// CityCleared reports if the "city" edge to the City entity was cleared.
func (m *UserMutation) CityCleared() bool {
	return m.FromCityIDCleared() || m.clearedcity
}

// CityID returns the "city" edge ID in the mutation.
func (m *UserMutation) CityID() (id int, exists bool) {
	if m.city != nil {
		return *m.city, true
	}
	return
}

// CityIDs returns the "city" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CityID instead. It exists only for internal usage by the builders.
func (m *UserMutation) CityIDs() (ids []int) {
	if id := m.city; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCity resets all changes to the "city" edge.
func (m *UserMutation) ResetCity() {
	m.city = nil
	m.clearedcity = false
}

// SetCateID sets the "cate" edge to the ItemCategory entity by id.
func (m *UserMutation) SetCateID(id int) {
	m.cate = &id
}

// ClearCate clears the "cate" edge to the ItemCategory entity.
func (m *UserMutation) ClearCate() {
	m.clearedcate = true
}

// CateCleared reports if the "cate" edge to the ItemCategory entity was cleared.
func (m *UserMutation) CateCleared() bool {
	return m.FromItemCategoryIDCleared() || m.clearedcate
}

// CateID returns the "cate" edge ID in the mutation.
func (m *UserMutation) CateID() (id int, exists bool) {
	if m.cate != nil {
		return *m.cate, true
	}
	return
}

// CateIDs returns the "cate" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CateID instead. It exists only for internal usage by the builders.
func (m *UserMutation) CateIDs() (ids []int) {
	if id := m.cate; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCate resets all changes to the "cate" edge.
func (m *UserMutation) ResetCate() {
	m.cate = nil
	m.clearedcate = false
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.uuid != nil {
		fields = append(fields, user.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.salt != nil {
		fields = append(fields, user.FieldSalt)
	}
	if m.boss_user_id != nil {
		fields = append(fields, user.FieldBossUserID)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.phone != nil {
		fields = append(fields, user.FieldPhone)
	}
	if m.nickname != nil {
		fields = append(fields, user.FieldNickname)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.status != nil {
		fields = append(fields, user.FieldStatus)
	}
	if m.sex != nil {
		fields = append(fields, user.FieldSex)
	}
	if m.reg_from != nil {
		fields = append(fields, user.FieldRegFrom)
	}
	if m.card_type != nil {
		fields = append(fields, user.FieldCardType)
	}
	if m.id_card != nil {
		fields = append(fields, user.FieldIDCard)
	}
	if m.city != nil {
		fields = append(fields, user.FieldFromCityID)
	}
	if m.cate != nil {
		fields = append(fields, user.FieldFromItemCategoryID)
	}
	if m.birthday != nil {
		fields = append(fields, user.FieldBirthday)
	}
	if m.sign_remark != nil {
		fields = append(fields, user.FieldSignRemark)
	}
	if m.avatar != nil {
		fields = append(fields, user.FieldAvatar)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUUID:
		return m.UUID()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldDeletedAt:
		return m.DeletedAt()
	case user.FieldPassword:
		return m.Password()
	case user.FieldSalt:
		return m.Salt()
	case user.FieldBossUserID:
		return m.BossUserID()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPhone:
		return m.Phone()
	case user.FieldNickname:
		return m.Nickname()
	case user.FieldUsername:
		return m.Username()
	case user.FieldStatus:
		return m.Status()
	case user.FieldSex:
		return m.Sex()
	case user.FieldRegFrom:
		return m.RegFrom()
	case user.FieldCardType:
		return m.CardType()
	case user.FieldIDCard:
		return m.IDCard()
	case user.FieldFromCityID:
		return m.FromCityID()
	case user.FieldFromItemCategoryID:
		return m.FromItemCategoryID()
	case user.FieldBirthday:
		return m.Birthday()
	case user.FieldSignRemark:
		return m.SignRemark()
	case user.FieldAvatar:
		return m.Avatar()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUUID:
		return m.OldUUID(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldSalt:
		return m.OldSalt(ctx)
	case user.FieldBossUserID:
		return m.OldBossUserID(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPhone:
		return m.OldPhone(ctx)
	case user.FieldNickname:
		return m.OldNickname(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldStatus:
		return m.OldStatus(ctx)
	case user.FieldSex:
		return m.OldSex(ctx)
	case user.FieldRegFrom:
		return m.OldRegFrom(ctx)
	case user.FieldCardType:
		return m.OldCardType(ctx)
	case user.FieldIDCard:
		return m.OldIDCard(ctx)
	case user.FieldFromCityID:
		return m.OldFromCityID(ctx)
	case user.FieldFromItemCategoryID:
		return m.OldFromItemCategoryID(ctx)
	case user.FieldBirthday:
		return m.OldBirthday(ctx)
	case user.FieldSignRemark:
		return m.OldSignRemark(ctx)
	case user.FieldAvatar:
		return m.OldAvatar(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldSalt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSalt(v)
		return nil
	case user.FieldBossUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBossUserID(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case user.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case user.FieldSex:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSex(v)
		return nil
	case user.FieldRegFrom:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegFrom(v)
		return nil
	case user.FieldCardType:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCardType(v)
		return nil
	case user.FieldIDCard:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIDCard(v)
		return nil
	case user.FieldFromCityID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromCityID(v)
		return nil
	case user.FieldFromItemCategoryID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromItemCategoryID(v)
		return nil
	case user.FieldBirthday:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirthday(v)
		return nil
	case user.FieldSignRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignRemark(v)
		return nil
	case user.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addboss_user_id != nil {
		fields = append(fields, user.FieldBossUserID)
	}
	if m.addstatus != nil {
		fields = append(fields, user.FieldStatus)
	}
	if m.addsex != nil {
		fields = append(fields, user.FieldSex)
	}
	if m.addreg_from != nil {
		fields = append(fields, user.FieldRegFrom)
	}
	if m.addcard_type != nil {
		fields = append(fields, user.FieldCardType)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldBossUserID:
		return m.AddedBossUserID()
	case user.FieldStatus:
		return m.AddedStatus()
	case user.FieldSex:
		return m.AddedSex()
	case user.FieldRegFrom:
		return m.AddedRegFrom()
	case user.FieldCardType:
		return m.AddedCardType()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldBossUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBossUserID(v)
		return nil
	case user.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case user.FieldSex:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSex(v)
		return nil
	case user.FieldRegFrom:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRegFrom(v)
		return nil
	case user.FieldCardType:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCardType(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldCreatedAt) {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.FieldCleared(user.FieldUpdatedAt) {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.FieldCleared(user.FieldDeletedAt) {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.FieldCleared(user.FieldFromCityID) {
		fields = append(fields, user.FieldFromCityID)
	}
	if m.FieldCleared(user.FieldFromItemCategoryID) {
		fields = append(fields, user.FieldFromItemCategoryID)
	}
	if m.FieldCleared(user.FieldBirthday) {
		fields = append(fields, user.FieldBirthday)
	}
	if m.FieldCleared(user.FieldSignRemark) {
		fields = append(fields, user.FieldSignRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case user.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case user.FieldFromCityID:
		m.ClearFromCityID()
		return nil
	case user.FieldFromItemCategoryID:
		m.ClearFromItemCategoryID()
		return nil
	case user.FieldBirthday:
		m.ClearBirthday()
		return nil
	case user.FieldSignRemark:
		m.ClearSignRemark()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUUID:
		m.ResetUUID()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldSalt:
		m.ResetSalt()
		return nil
	case user.FieldBossUserID:
		m.ResetBossUserID()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPhone:
		m.ResetPhone()
		return nil
	case user.FieldNickname:
		m.ResetNickname()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldStatus:
		m.ResetStatus()
		return nil
	case user.FieldSex:
		m.ResetSex()
		return nil
	case user.FieldRegFrom:
		m.ResetRegFrom()
		return nil
	case user.FieldCardType:
		m.ResetCardType()
		return nil
	case user.FieldIDCard:
		m.ResetIDCard()
		return nil
	case user.FieldFromCityID:
		m.ResetFromCityID()
		return nil
	case user.FieldFromItemCategoryID:
		m.ResetFromItemCategoryID()
		return nil
	case user.FieldBirthday:
		m.ResetBirthday()
		return nil
	case user.FieldSignRemark:
		m.ResetSignRemark()
		return nil
	case user.FieldAvatar:
		m.ResetAvatar()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 12)
	if m.login_log != nil {
		edges = append(edges, user.EdgeLoginLog)
	}
	if m.messages != nil {
		edges = append(edges, user.EdgeMessages)
	}
	if m.user_courses != nil {
		edges = append(edges, user.EdgeUserCourses)
	}
	if m.user_classes != nil {
		edges = append(edges, user.EdgeUserClasses)
	}
	if m.user_exams_records != nil {
		edges = append(edges, user.EdgeUserExamsRecords)
	}
	if m.user_question_bank_records != nil {
		edges = append(edges, user.EdgeUserQuestionBankRecords)
	}
	if m.user_question_records != nil {
		edges = append(edges, user.EdgeUserQuestionRecords)
	}
	if m.ask_users != nil {
		edges = append(edges, user.EdgeAskUsers)
	}
	if m.course_appraise_users != nil {
		edges = append(edges, user.EdgeCourseAppraiseUsers)
	}
	if m.user_video_record != nil {
		edges = append(edges, user.EdgeUserVideoRecord)
	}
	if m.city != nil {
		edges = append(edges, user.EdgeCity)
	}
	if m.cate != nil {
		edges = append(edges, user.EdgeCate)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeLoginLog:
		ids := make([]ent.Value, 0, len(m.login_log))
		for id := range m.login_log {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMessages:
		ids := make([]ent.Value, 0, len(m.messages))
		for id := range m.messages {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserCourses:
		ids := make([]ent.Value, 0, len(m.user_courses))
		for id := range m.user_courses {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserClasses:
		ids := make([]ent.Value, 0, len(m.user_classes))
		for id := range m.user_classes {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserExamsRecords:
		ids := make([]ent.Value, 0, len(m.user_exams_records))
		for id := range m.user_exams_records {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserQuestionBankRecords:
		ids := make([]ent.Value, 0, len(m.user_question_bank_records))
		for id := range m.user_question_bank_records {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserQuestionRecords:
		ids := make([]ent.Value, 0, len(m.user_question_records))
		for id := range m.user_question_records {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAskUsers:
		ids := make([]ent.Value, 0, len(m.ask_users))
		for id := range m.ask_users {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCourseAppraiseUsers:
		ids := make([]ent.Value, 0, len(m.course_appraise_users))
		for id := range m.course_appraise_users {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserVideoRecord:
		ids := make([]ent.Value, 0, len(m.user_video_record))
		for id := range m.user_video_record {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCity:
		if id := m.city; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeCate:
		if id := m.cate; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 12)
	if m.removedlogin_log != nil {
		edges = append(edges, user.EdgeLoginLog)
	}
	if m.removedmessages != nil {
		edges = append(edges, user.EdgeMessages)
	}
	if m.removeduser_courses != nil {
		edges = append(edges, user.EdgeUserCourses)
	}
	if m.removeduser_classes != nil {
		edges = append(edges, user.EdgeUserClasses)
	}
	if m.removeduser_exams_records != nil {
		edges = append(edges, user.EdgeUserExamsRecords)
	}
	if m.removeduser_question_bank_records != nil {
		edges = append(edges, user.EdgeUserQuestionBankRecords)
	}
	if m.removeduser_question_records != nil {
		edges = append(edges, user.EdgeUserQuestionRecords)
	}
	if m.removedask_users != nil {
		edges = append(edges, user.EdgeAskUsers)
	}
	if m.removedcourse_appraise_users != nil {
		edges = append(edges, user.EdgeCourseAppraiseUsers)
	}
	if m.removeduser_video_record != nil {
		edges = append(edges, user.EdgeUserVideoRecord)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeLoginLog:
		ids := make([]ent.Value, 0, len(m.removedlogin_log))
		for id := range m.removedlogin_log {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMessages:
		ids := make([]ent.Value, 0, len(m.removedmessages))
		for id := range m.removedmessages {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserCourses:
		ids := make([]ent.Value, 0, len(m.removeduser_courses))
		for id := range m.removeduser_courses {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserClasses:
		ids := make([]ent.Value, 0, len(m.removeduser_classes))
		for id := range m.removeduser_classes {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserExamsRecords:
		ids := make([]ent.Value, 0, len(m.removeduser_exams_records))
		for id := range m.removeduser_exams_records {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserQuestionBankRecords:
		ids := make([]ent.Value, 0, len(m.removeduser_question_bank_records))
		for id := range m.removeduser_question_bank_records {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserQuestionRecords:
		ids := make([]ent.Value, 0, len(m.removeduser_question_records))
		for id := range m.removeduser_question_records {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAskUsers:
		ids := make([]ent.Value, 0, len(m.removedask_users))
		for id := range m.removedask_users {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCourseAppraiseUsers:
		ids := make([]ent.Value, 0, len(m.removedcourse_appraise_users))
		for id := range m.removedcourse_appraise_users {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserVideoRecord:
		ids := make([]ent.Value, 0, len(m.removeduser_video_record))
		for id := range m.removeduser_video_record {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 12)
	if m.clearedlogin_log {
		edges = append(edges, user.EdgeLoginLog)
	}
	if m.clearedmessages {
		edges = append(edges, user.EdgeMessages)
	}
	if m.cleareduser_courses {
		edges = append(edges, user.EdgeUserCourses)
	}
	if m.cleareduser_classes {
		edges = append(edges, user.EdgeUserClasses)
	}
	if m.cleareduser_exams_records {
		edges = append(edges, user.EdgeUserExamsRecords)
	}
	if m.cleareduser_question_bank_records {
		edges = append(edges, user.EdgeUserQuestionBankRecords)
	}
	if m.cleareduser_question_records {
		edges = append(edges, user.EdgeUserQuestionRecords)
	}
	if m.clearedask_users {
		edges = append(edges, user.EdgeAskUsers)
	}
	if m.clearedcourse_appraise_users {
		edges = append(edges, user.EdgeCourseAppraiseUsers)
	}
	if m.cleareduser_video_record {
		edges = append(edges, user.EdgeUserVideoRecord)
	}
	if m.clearedcity {
		edges = append(edges, user.EdgeCity)
	}
	if m.clearedcate {
		edges = append(edges, user.EdgeCate)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeLoginLog:
		return m.clearedlogin_log
	case user.EdgeMessages:
		return m.clearedmessages
	case user.EdgeUserCourses:
		return m.cleareduser_courses
	case user.EdgeUserClasses:
		return m.cleareduser_classes
	case user.EdgeUserExamsRecords:
		return m.cleareduser_exams_records
	case user.EdgeUserQuestionBankRecords:
		return m.cleareduser_question_bank_records
	case user.EdgeUserQuestionRecords:
		return m.cleareduser_question_records
	case user.EdgeAskUsers:
		return m.clearedask_users
	case user.EdgeCourseAppraiseUsers:
		return m.clearedcourse_appraise_users
	case user.EdgeUserVideoRecord:
		return m.cleareduser_video_record
	case user.EdgeCity:
		return m.clearedcity
	case user.EdgeCate:
		return m.clearedcate
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeCity:
		m.ClearCity()
		return nil
	case user.EdgeCate:
		m.ClearCate()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeLoginLog:
		m.ResetLoginLog()
		return nil
	case user.EdgeMessages:
		m.ResetMessages()
		return nil
	case user.EdgeUserCourses:
		m.ResetUserCourses()
		return nil
	case user.EdgeUserClasses:
		m.ResetUserClasses()
		return nil
	case user.EdgeUserExamsRecords:
		m.ResetUserExamsRecords()
		return nil
	case user.EdgeUserQuestionBankRecords:
		m.ResetUserQuestionBankRecords()
		return nil
	case user.EdgeUserQuestionRecords:
		m.ResetUserQuestionRecords()
		return nil
	case user.EdgeAskUsers:
		m.ResetAskUsers()
		return nil
	case user.EdgeCourseAppraiseUsers:
		m.ResetCourseAppraiseUsers()
		return nil
	case user.EdgeUserVideoRecord:
		m.ResetUserVideoRecord()
		return nil
	case user.EdgeCity:
		m.ResetCity()
		return nil
	case user.EdgeCate:
		m.ResetCate()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserAskAnswerMutation represents an operation that mutates the UserAskAnswer nodes in the graph.
type UserAskAnswerMutation struct {
	config
	op                             Op
	typ                            string
	id                             *int
	uuid                           *string
	created_at                     *time.Time
	updated_at                     *time.Time
	deleted_at                     *time.Time
	ask_desc                       *string
	answer_status                  *uint8
	addanswer_status               *uint8
	show_status                    *uint8
	addshow_status                 *uint8
	reply_show_status              *uint8
	addreply_show_status           *uint8
	answer_desc                    *string
	answer_at                      *time.Time
	clearedFields                  map[string]struct{}
	teacher                        *int
	clearedteacher                 bool
	user                           *int
	cleareduser                    bool
	ask_answers_attachments        map[int]struct{}
	removedask_answers_attachments map[int]struct{}
	clearedask_answers_attachments bool
	done                           bool
	oldValue                       func(context.Context) (*UserAskAnswer, error)
	predicates                     []predicate.UserAskAnswer
}

var _ ent.Mutation = (*UserAskAnswerMutation)(nil)

// useraskanswerOption allows management of the mutation configuration using functional options.
type useraskanswerOption func(*UserAskAnswerMutation)

// newUserAskAnswerMutation creates new mutation for the UserAskAnswer entity.
func newUserAskAnswerMutation(c config, op Op, opts ...useraskanswerOption) *UserAskAnswerMutation {
	m := &UserAskAnswerMutation{
		config:        c,
		op:            op,
		typ:           TypeUserAskAnswer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserAskAnswerID sets the ID field of the mutation.
func withUserAskAnswerID(id int) useraskanswerOption {
	return func(m *UserAskAnswerMutation) {
		var (
			err   error
			once  sync.Once
			value *UserAskAnswer
		)
		m.oldValue = func(ctx context.Context) (*UserAskAnswer, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserAskAnswer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserAskAnswer sets the old UserAskAnswer of the mutation.
func withUserAskAnswer(node *UserAskAnswer) useraskanswerOption {
	return func(m *UserAskAnswerMutation) {
		m.oldValue = func(context.Context) (*UserAskAnswer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserAskAnswerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserAskAnswerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *UserAskAnswerMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *UserAskAnswerMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *UserAskAnswerMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the UserAskAnswer entity.
// If the UserAskAnswer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAskAnswerMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *UserAskAnswerMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserAskAnswerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserAskAnswerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserAskAnswer entity.
// If the UserAskAnswer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAskAnswerMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *UserAskAnswerMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[useraskanswer.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *UserAskAnswerMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[useraskanswer.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserAskAnswerMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, useraskanswer.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserAskAnswerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserAskAnswerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserAskAnswer entity.
// If the UserAskAnswer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAskAnswerMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *UserAskAnswerMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[useraskanswer.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *UserAskAnswerMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[useraskanswer.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserAskAnswerMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, useraskanswer.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserAskAnswerMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserAskAnswerMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the UserAskAnswer entity.
// If the UserAskAnswer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAskAnswerMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserAskAnswerMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[useraskanswer.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserAskAnswerMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[useraskanswer.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserAskAnswerMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, useraskanswer.FieldDeletedAt)
}

// SetAskDesc sets the "ask_desc" field.
func (m *UserAskAnswerMutation) SetAskDesc(s string) {
	m.ask_desc = &s
}

// AskDesc returns the value of the "ask_desc" field in the mutation.
func (m *UserAskAnswerMutation) AskDesc() (r string, exists bool) {
	v := m.ask_desc
	if v == nil {
		return
	}
	return *v, true
}

// OldAskDesc returns the old "ask_desc" field's value of the UserAskAnswer entity.
// If the UserAskAnswer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAskAnswerMutation) OldAskDesc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAskDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAskDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAskDesc: %w", err)
	}
	return oldValue.AskDesc, nil
}

// ResetAskDesc resets all changes to the "ask_desc" field.
func (m *UserAskAnswerMutation) ResetAskDesc() {
	m.ask_desc = nil
}

// SetAnswerStatus sets the "answer_status" field.
func (m *UserAskAnswerMutation) SetAnswerStatus(u uint8) {
	m.answer_status = &u
	m.addanswer_status = nil
}

// AnswerStatus returns the value of the "answer_status" field in the mutation.
func (m *UserAskAnswerMutation) AnswerStatus() (r uint8, exists bool) {
	v := m.answer_status
	if v == nil {
		return
	}
	return *v, true
}

// OldAnswerStatus returns the old "answer_status" field's value of the UserAskAnswer entity.
// If the UserAskAnswer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAskAnswerMutation) OldAnswerStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAnswerStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAnswerStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnswerStatus: %w", err)
	}
	return oldValue.AnswerStatus, nil
}

// AddAnswerStatus adds u to the "answer_status" field.
func (m *UserAskAnswerMutation) AddAnswerStatus(u uint8) {
	if m.addanswer_status != nil {
		*m.addanswer_status += u
	} else {
		m.addanswer_status = &u
	}
}

// AddedAnswerStatus returns the value that was added to the "answer_status" field in this mutation.
func (m *UserAskAnswerMutation) AddedAnswerStatus() (r uint8, exists bool) {
	v := m.addanswer_status
	if v == nil {
		return
	}
	return *v, true
}

// ResetAnswerStatus resets all changes to the "answer_status" field.
func (m *UserAskAnswerMutation) ResetAnswerStatus() {
	m.answer_status = nil
	m.addanswer_status = nil
}

// SetUserID sets the "user_id" field.
func (m *UserAskAnswerMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserAskAnswerMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserAskAnswer entity.
// If the UserAskAnswer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAskAnswerMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *UserAskAnswerMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[useraskanswer.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *UserAskAnswerMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[useraskanswer.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserAskAnswerMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, useraskanswer.FieldUserID)
}

// SetTeacherID sets the "teacher_id" field.
func (m *UserAskAnswerMutation) SetTeacherID(i int) {
	m.teacher = &i
}

// TeacherID returns the value of the "teacher_id" field in the mutation.
func (m *UserAskAnswerMutation) TeacherID() (r int, exists bool) {
	v := m.teacher
	if v == nil {
		return
	}
	return *v, true
}

// OldTeacherID returns the old "teacher_id" field's value of the UserAskAnswer entity.
// If the UserAskAnswer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAskAnswerMutation) OldTeacherID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTeacherID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTeacherID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeacherID: %w", err)
	}
	return oldValue.TeacherID, nil
}

// ClearTeacherID clears the value of the "teacher_id" field.
func (m *UserAskAnswerMutation) ClearTeacherID() {
	m.teacher = nil
	m.clearedFields[useraskanswer.FieldTeacherID] = struct{}{}
}

// TeacherIDCleared returns if the "teacher_id" field was cleared in this mutation.
func (m *UserAskAnswerMutation) TeacherIDCleared() bool {
	_, ok := m.clearedFields[useraskanswer.FieldTeacherID]
	return ok
}

// ResetTeacherID resets all changes to the "teacher_id" field.
func (m *UserAskAnswerMutation) ResetTeacherID() {
	m.teacher = nil
	delete(m.clearedFields, useraskanswer.FieldTeacherID)
}

// SetShowStatus sets the "show_status" field.
func (m *UserAskAnswerMutation) SetShowStatus(u uint8) {
	m.show_status = &u
	m.addshow_status = nil
}

// ShowStatus returns the value of the "show_status" field in the mutation.
func (m *UserAskAnswerMutation) ShowStatus() (r uint8, exists bool) {
	v := m.show_status
	if v == nil {
		return
	}
	return *v, true
}

// OldShowStatus returns the old "show_status" field's value of the UserAskAnswer entity.
// If the UserAskAnswer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAskAnswerMutation) OldShowStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShowStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShowStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShowStatus: %w", err)
	}
	return oldValue.ShowStatus, nil
}

// AddShowStatus adds u to the "show_status" field.
func (m *UserAskAnswerMutation) AddShowStatus(u uint8) {
	if m.addshow_status != nil {
		*m.addshow_status += u
	} else {
		m.addshow_status = &u
	}
}

// AddedShowStatus returns the value that was added to the "show_status" field in this mutation.
func (m *UserAskAnswerMutation) AddedShowStatus() (r uint8, exists bool) {
	v := m.addshow_status
	if v == nil {
		return
	}
	return *v, true
}

// ResetShowStatus resets all changes to the "show_status" field.
func (m *UserAskAnswerMutation) ResetShowStatus() {
	m.show_status = nil
	m.addshow_status = nil
}

// SetReplyShowStatus sets the "reply_show_status" field.
func (m *UserAskAnswerMutation) SetReplyShowStatus(u uint8) {
	m.reply_show_status = &u
	m.addreply_show_status = nil
}

// ReplyShowStatus returns the value of the "reply_show_status" field in the mutation.
func (m *UserAskAnswerMutation) ReplyShowStatus() (r uint8, exists bool) {
	v := m.reply_show_status
	if v == nil {
		return
	}
	return *v, true
}

// OldReplyShowStatus returns the old "reply_show_status" field's value of the UserAskAnswer entity.
// If the UserAskAnswer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAskAnswerMutation) OldReplyShowStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReplyShowStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReplyShowStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReplyShowStatus: %w", err)
	}
	return oldValue.ReplyShowStatus, nil
}

// AddReplyShowStatus adds u to the "reply_show_status" field.
func (m *UserAskAnswerMutation) AddReplyShowStatus(u uint8) {
	if m.addreply_show_status != nil {
		*m.addreply_show_status += u
	} else {
		m.addreply_show_status = &u
	}
}

// AddedReplyShowStatus returns the value that was added to the "reply_show_status" field in this mutation.
func (m *UserAskAnswerMutation) AddedReplyShowStatus() (r uint8, exists bool) {
	v := m.addreply_show_status
	if v == nil {
		return
	}
	return *v, true
}

// ResetReplyShowStatus resets all changes to the "reply_show_status" field.
func (m *UserAskAnswerMutation) ResetReplyShowStatus() {
	m.reply_show_status = nil
	m.addreply_show_status = nil
}

// SetAnswerDesc sets the "answer_desc" field.
func (m *UserAskAnswerMutation) SetAnswerDesc(s string) {
	m.answer_desc = &s
}

// AnswerDesc returns the value of the "answer_desc" field in the mutation.
func (m *UserAskAnswerMutation) AnswerDesc() (r string, exists bool) {
	v := m.answer_desc
	if v == nil {
		return
	}
	return *v, true
}

// OldAnswerDesc returns the old "answer_desc" field's value of the UserAskAnswer entity.
// If the UserAskAnswer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAskAnswerMutation) OldAnswerDesc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAnswerDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAnswerDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnswerDesc: %w", err)
	}
	return oldValue.AnswerDesc, nil
}

// ResetAnswerDesc resets all changes to the "answer_desc" field.
func (m *UserAskAnswerMutation) ResetAnswerDesc() {
	m.answer_desc = nil
}

// SetAnswerAt sets the "answer_at" field.
func (m *UserAskAnswerMutation) SetAnswerAt(t time.Time) {
	m.answer_at = &t
}

// AnswerAt returns the value of the "answer_at" field in the mutation.
func (m *UserAskAnswerMutation) AnswerAt() (r time.Time, exists bool) {
	v := m.answer_at
	if v == nil {
		return
	}
	return *v, true
}

// OldAnswerAt returns the old "answer_at" field's value of the UserAskAnswer entity.
// If the UserAskAnswer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAskAnswerMutation) OldAnswerAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAnswerAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAnswerAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnswerAt: %w", err)
	}
	return oldValue.AnswerAt, nil
}

// ClearAnswerAt clears the value of the "answer_at" field.
func (m *UserAskAnswerMutation) ClearAnswerAt() {
	m.answer_at = nil
	m.clearedFields[useraskanswer.FieldAnswerAt] = struct{}{}
}

// AnswerAtCleared returns if the "answer_at" field was cleared in this mutation.
func (m *UserAskAnswerMutation) AnswerAtCleared() bool {
	_, ok := m.clearedFields[useraskanswer.FieldAnswerAt]
	return ok
}

// ResetAnswerAt resets all changes to the "answer_at" field.
func (m *UserAskAnswerMutation) ResetAnswerAt() {
	m.answer_at = nil
	delete(m.clearedFields, useraskanswer.FieldAnswerAt)
}

// ClearTeacher clears the "teacher" edge to the Teacher entity.
func (m *UserAskAnswerMutation) ClearTeacher() {
	m.clearedteacher = true
}

// TeacherCleared reports if the "teacher" edge to the Teacher entity was cleared.
func (m *UserAskAnswerMutation) TeacherCleared() bool {
	return m.TeacherIDCleared() || m.clearedteacher
}

// TeacherIDs returns the "teacher" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeacherID instead. It exists only for internal usage by the builders.
func (m *UserAskAnswerMutation) TeacherIDs() (ids []int) {
	if id := m.teacher; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeacher resets all changes to the "teacher" edge.
func (m *UserAskAnswerMutation) ResetTeacher() {
	m.teacher = nil
	m.clearedteacher = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserAskAnswerMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserAskAnswerMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserAskAnswerMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserAskAnswerMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddAskAnswersAttachmentIDs adds the "ask_answers_attachments" edge to the UserAskAnswerAttachment entity by ids.
func (m *UserAskAnswerMutation) AddAskAnswersAttachmentIDs(ids ...int) {
	if m.ask_answers_attachments == nil {
		m.ask_answers_attachments = make(map[int]struct{})
	}
	for i := range ids {
		m.ask_answers_attachments[ids[i]] = struct{}{}
	}
}

// ClearAskAnswersAttachments clears the "ask_answers_attachments" edge to the UserAskAnswerAttachment entity.
func (m *UserAskAnswerMutation) ClearAskAnswersAttachments() {
	m.clearedask_answers_attachments = true
}

// AskAnswersAttachmentsCleared reports if the "ask_answers_attachments" edge to the UserAskAnswerAttachment entity was cleared.
func (m *UserAskAnswerMutation) AskAnswersAttachmentsCleared() bool {
	return m.clearedask_answers_attachments
}

// RemoveAskAnswersAttachmentIDs removes the "ask_answers_attachments" edge to the UserAskAnswerAttachment entity by IDs.
func (m *UserAskAnswerMutation) RemoveAskAnswersAttachmentIDs(ids ...int) {
	if m.removedask_answers_attachments == nil {
		m.removedask_answers_attachments = make(map[int]struct{})
	}
	for i := range ids {
		m.removedask_answers_attachments[ids[i]] = struct{}{}
	}
}

// RemovedAskAnswersAttachments returns the removed IDs of the "ask_answers_attachments" edge to the UserAskAnswerAttachment entity.
func (m *UserAskAnswerMutation) RemovedAskAnswersAttachmentsIDs() (ids []int) {
	for id := range m.removedask_answers_attachments {
		ids = append(ids, id)
	}
	return
}

// AskAnswersAttachmentsIDs returns the "ask_answers_attachments" edge IDs in the mutation.
func (m *UserAskAnswerMutation) AskAnswersAttachmentsIDs() (ids []int) {
	for id := range m.ask_answers_attachments {
		ids = append(ids, id)
	}
	return
}

// ResetAskAnswersAttachments resets all changes to the "ask_answers_attachments" edge.
func (m *UserAskAnswerMutation) ResetAskAnswersAttachments() {
	m.ask_answers_attachments = nil
	m.clearedask_answers_attachments = false
	m.removedask_answers_attachments = nil
}

// Op returns the operation name.
func (m *UserAskAnswerMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (UserAskAnswer).
func (m *UserAskAnswerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserAskAnswerMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.uuid != nil {
		fields = append(fields, useraskanswer.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, useraskanswer.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, useraskanswer.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, useraskanswer.FieldDeletedAt)
	}
	if m.ask_desc != nil {
		fields = append(fields, useraskanswer.FieldAskDesc)
	}
	if m.answer_status != nil {
		fields = append(fields, useraskanswer.FieldAnswerStatus)
	}
	if m.user != nil {
		fields = append(fields, useraskanswer.FieldUserID)
	}
	if m.teacher != nil {
		fields = append(fields, useraskanswer.FieldTeacherID)
	}
	if m.show_status != nil {
		fields = append(fields, useraskanswer.FieldShowStatus)
	}
	if m.reply_show_status != nil {
		fields = append(fields, useraskanswer.FieldReplyShowStatus)
	}
	if m.answer_desc != nil {
		fields = append(fields, useraskanswer.FieldAnswerDesc)
	}
	if m.answer_at != nil {
		fields = append(fields, useraskanswer.FieldAnswerAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserAskAnswerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case useraskanswer.FieldUUID:
		return m.UUID()
	case useraskanswer.FieldCreatedAt:
		return m.CreatedAt()
	case useraskanswer.FieldUpdatedAt:
		return m.UpdatedAt()
	case useraskanswer.FieldDeletedAt:
		return m.DeletedAt()
	case useraskanswer.FieldAskDesc:
		return m.AskDesc()
	case useraskanswer.FieldAnswerStatus:
		return m.AnswerStatus()
	case useraskanswer.FieldUserID:
		return m.UserID()
	case useraskanswer.FieldTeacherID:
		return m.TeacherID()
	case useraskanswer.FieldShowStatus:
		return m.ShowStatus()
	case useraskanswer.FieldReplyShowStatus:
		return m.ReplyShowStatus()
	case useraskanswer.FieldAnswerDesc:
		return m.AnswerDesc()
	case useraskanswer.FieldAnswerAt:
		return m.AnswerAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserAskAnswerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case useraskanswer.FieldUUID:
		return m.OldUUID(ctx)
	case useraskanswer.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case useraskanswer.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case useraskanswer.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case useraskanswer.FieldAskDesc:
		return m.OldAskDesc(ctx)
	case useraskanswer.FieldAnswerStatus:
		return m.OldAnswerStatus(ctx)
	case useraskanswer.FieldUserID:
		return m.OldUserID(ctx)
	case useraskanswer.FieldTeacherID:
		return m.OldTeacherID(ctx)
	case useraskanswer.FieldShowStatus:
		return m.OldShowStatus(ctx)
	case useraskanswer.FieldReplyShowStatus:
		return m.OldReplyShowStatus(ctx)
	case useraskanswer.FieldAnswerDesc:
		return m.OldAnswerDesc(ctx)
	case useraskanswer.FieldAnswerAt:
		return m.OldAnswerAt(ctx)
	}
	return nil, fmt.Errorf("unknown UserAskAnswer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserAskAnswerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case useraskanswer.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case useraskanswer.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case useraskanswer.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case useraskanswer.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case useraskanswer.FieldAskDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAskDesc(v)
		return nil
	case useraskanswer.FieldAnswerStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnswerStatus(v)
		return nil
	case useraskanswer.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case useraskanswer.FieldTeacherID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeacherID(v)
		return nil
	case useraskanswer.FieldShowStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShowStatus(v)
		return nil
	case useraskanswer.FieldReplyShowStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReplyShowStatus(v)
		return nil
	case useraskanswer.FieldAnswerDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnswerDesc(v)
		return nil
	case useraskanswer.FieldAnswerAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnswerAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserAskAnswer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserAskAnswerMutation) AddedFields() []string {
	var fields []string
	if m.addanswer_status != nil {
		fields = append(fields, useraskanswer.FieldAnswerStatus)
	}
	if m.addshow_status != nil {
		fields = append(fields, useraskanswer.FieldShowStatus)
	}
	if m.addreply_show_status != nil {
		fields = append(fields, useraskanswer.FieldReplyShowStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserAskAnswerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case useraskanswer.FieldAnswerStatus:
		return m.AddedAnswerStatus()
	case useraskanswer.FieldShowStatus:
		return m.AddedShowStatus()
	case useraskanswer.FieldReplyShowStatus:
		return m.AddedReplyShowStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserAskAnswerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case useraskanswer.FieldAnswerStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAnswerStatus(v)
		return nil
	case useraskanswer.FieldShowStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShowStatus(v)
		return nil
	case useraskanswer.FieldReplyShowStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReplyShowStatus(v)
		return nil
	}
	return fmt.Errorf("unknown UserAskAnswer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserAskAnswerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(useraskanswer.FieldCreatedAt) {
		fields = append(fields, useraskanswer.FieldCreatedAt)
	}
	if m.FieldCleared(useraskanswer.FieldUpdatedAt) {
		fields = append(fields, useraskanswer.FieldUpdatedAt)
	}
	if m.FieldCleared(useraskanswer.FieldDeletedAt) {
		fields = append(fields, useraskanswer.FieldDeletedAt)
	}
	if m.FieldCleared(useraskanswer.FieldUserID) {
		fields = append(fields, useraskanswer.FieldUserID)
	}
	if m.FieldCleared(useraskanswer.FieldTeacherID) {
		fields = append(fields, useraskanswer.FieldTeacherID)
	}
	if m.FieldCleared(useraskanswer.FieldAnswerAt) {
		fields = append(fields, useraskanswer.FieldAnswerAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserAskAnswerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserAskAnswerMutation) ClearField(name string) error {
	switch name {
	case useraskanswer.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case useraskanswer.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case useraskanswer.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case useraskanswer.FieldUserID:
		m.ClearUserID()
		return nil
	case useraskanswer.FieldTeacherID:
		m.ClearTeacherID()
		return nil
	case useraskanswer.FieldAnswerAt:
		m.ClearAnswerAt()
		return nil
	}
	return fmt.Errorf("unknown UserAskAnswer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserAskAnswerMutation) ResetField(name string) error {
	switch name {
	case useraskanswer.FieldUUID:
		m.ResetUUID()
		return nil
	case useraskanswer.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case useraskanswer.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case useraskanswer.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case useraskanswer.FieldAskDesc:
		m.ResetAskDesc()
		return nil
	case useraskanswer.FieldAnswerStatus:
		m.ResetAnswerStatus()
		return nil
	case useraskanswer.FieldUserID:
		m.ResetUserID()
		return nil
	case useraskanswer.FieldTeacherID:
		m.ResetTeacherID()
		return nil
	case useraskanswer.FieldShowStatus:
		m.ResetShowStatus()
		return nil
	case useraskanswer.FieldReplyShowStatus:
		m.ResetReplyShowStatus()
		return nil
	case useraskanswer.FieldAnswerDesc:
		m.ResetAnswerDesc()
		return nil
	case useraskanswer.FieldAnswerAt:
		m.ResetAnswerAt()
		return nil
	}
	return fmt.Errorf("unknown UserAskAnswer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserAskAnswerMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.teacher != nil {
		edges = append(edges, useraskanswer.EdgeTeacher)
	}
	if m.user != nil {
		edges = append(edges, useraskanswer.EdgeUser)
	}
	if m.ask_answers_attachments != nil {
		edges = append(edges, useraskanswer.EdgeAskAnswersAttachments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserAskAnswerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case useraskanswer.EdgeTeacher:
		if id := m.teacher; id != nil {
			return []ent.Value{*id}
		}
	case useraskanswer.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case useraskanswer.EdgeAskAnswersAttachments:
		ids := make([]ent.Value, 0, len(m.ask_answers_attachments))
		for id := range m.ask_answers_attachments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserAskAnswerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedask_answers_attachments != nil {
		edges = append(edges, useraskanswer.EdgeAskAnswersAttachments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserAskAnswerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case useraskanswer.EdgeAskAnswersAttachments:
		ids := make([]ent.Value, 0, len(m.removedask_answers_attachments))
		for id := range m.removedask_answers_attachments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserAskAnswerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedteacher {
		edges = append(edges, useraskanswer.EdgeTeacher)
	}
	if m.cleareduser {
		edges = append(edges, useraskanswer.EdgeUser)
	}
	if m.clearedask_answers_attachments {
		edges = append(edges, useraskanswer.EdgeAskAnswersAttachments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserAskAnswerMutation) EdgeCleared(name string) bool {
	switch name {
	case useraskanswer.EdgeTeacher:
		return m.clearedteacher
	case useraskanswer.EdgeUser:
		return m.cleareduser
	case useraskanswer.EdgeAskAnswersAttachments:
		return m.clearedask_answers_attachments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserAskAnswerMutation) ClearEdge(name string) error {
	switch name {
	case useraskanswer.EdgeTeacher:
		m.ClearTeacher()
		return nil
	case useraskanswer.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserAskAnswer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserAskAnswerMutation) ResetEdge(name string) error {
	switch name {
	case useraskanswer.EdgeTeacher:
		m.ResetTeacher()
		return nil
	case useraskanswer.EdgeUser:
		m.ResetUser()
		return nil
	case useraskanswer.EdgeAskAnswersAttachments:
		m.ResetAskAnswersAttachments()
		return nil
	}
	return fmt.Errorf("unknown UserAskAnswer edge %s", name)
}

// UserAskAnswerAttachmentMutation represents an operation that mutates the UserAskAnswerAttachment nodes in the graph.
type UserAskAnswerAttachmentMutation struct {
	config
	op                Op
	typ               string
	id                *int
	_type             *uint8
	add_type          *uint8
	clearedFields     map[string]struct{}
	attachment        *int
	clearedattachment bool
	ask               *int
	clearedask        bool
	done              bool
	oldValue          func(context.Context) (*UserAskAnswerAttachment, error)
	predicates        []predicate.UserAskAnswerAttachment
}

var _ ent.Mutation = (*UserAskAnswerAttachmentMutation)(nil)

// useraskanswerattachmentOption allows management of the mutation configuration using functional options.
type useraskanswerattachmentOption func(*UserAskAnswerAttachmentMutation)

// newUserAskAnswerAttachmentMutation creates new mutation for the UserAskAnswerAttachment entity.
func newUserAskAnswerAttachmentMutation(c config, op Op, opts ...useraskanswerattachmentOption) *UserAskAnswerAttachmentMutation {
	m := &UserAskAnswerAttachmentMutation{
		config:        c,
		op:            op,
		typ:           TypeUserAskAnswerAttachment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserAskAnswerAttachmentID sets the ID field of the mutation.
func withUserAskAnswerAttachmentID(id int) useraskanswerattachmentOption {
	return func(m *UserAskAnswerAttachmentMutation) {
		var (
			err   error
			once  sync.Once
			value *UserAskAnswerAttachment
		)
		m.oldValue = func(ctx context.Context) (*UserAskAnswerAttachment, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserAskAnswerAttachment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserAskAnswerAttachment sets the old UserAskAnswerAttachment of the mutation.
func withUserAskAnswerAttachment(node *UserAskAnswerAttachment) useraskanswerattachmentOption {
	return func(m *UserAskAnswerAttachmentMutation) {
		m.oldValue = func(context.Context) (*UserAskAnswerAttachment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserAskAnswerAttachmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserAskAnswerAttachmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *UserAskAnswerAttachmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetAttachmentID sets the "attachment_id" field.
func (m *UserAskAnswerAttachmentMutation) SetAttachmentID(i int) {
	m.attachment = &i
}

// AttachmentID returns the value of the "attachment_id" field in the mutation.
func (m *UserAskAnswerAttachmentMutation) AttachmentID() (r int, exists bool) {
	v := m.attachment
	if v == nil {
		return
	}
	return *v, true
}

// OldAttachmentID returns the old "attachment_id" field's value of the UserAskAnswerAttachment entity.
// If the UserAskAnswerAttachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAskAnswerAttachmentMutation) OldAttachmentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAttachmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAttachmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttachmentID: %w", err)
	}
	return oldValue.AttachmentID, nil
}

// ClearAttachmentID clears the value of the "attachment_id" field.
func (m *UserAskAnswerAttachmentMutation) ClearAttachmentID() {
	m.attachment = nil
	m.clearedFields[useraskanswerattachment.FieldAttachmentID] = struct{}{}
}

// AttachmentIDCleared returns if the "attachment_id" field was cleared in this mutation.
func (m *UserAskAnswerAttachmentMutation) AttachmentIDCleared() bool {
	_, ok := m.clearedFields[useraskanswerattachment.FieldAttachmentID]
	return ok
}

// ResetAttachmentID resets all changes to the "attachment_id" field.
func (m *UserAskAnswerAttachmentMutation) ResetAttachmentID() {
	m.attachment = nil
	delete(m.clearedFields, useraskanswerattachment.FieldAttachmentID)
}

// SetAskID sets the "ask_id" field.
func (m *UserAskAnswerAttachmentMutation) SetAskID(i int) {
	m.ask = &i
}

// AskID returns the value of the "ask_id" field in the mutation.
func (m *UserAskAnswerAttachmentMutation) AskID() (r int, exists bool) {
	v := m.ask
	if v == nil {
		return
	}
	return *v, true
}

// OldAskID returns the old "ask_id" field's value of the UserAskAnswerAttachment entity.
// If the UserAskAnswerAttachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAskAnswerAttachmentMutation) OldAskID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAskID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAskID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAskID: %w", err)
	}
	return oldValue.AskID, nil
}

// ClearAskID clears the value of the "ask_id" field.
func (m *UserAskAnswerAttachmentMutation) ClearAskID() {
	m.ask = nil
	m.clearedFields[useraskanswerattachment.FieldAskID] = struct{}{}
}

// AskIDCleared returns if the "ask_id" field was cleared in this mutation.
func (m *UserAskAnswerAttachmentMutation) AskIDCleared() bool {
	_, ok := m.clearedFields[useraskanswerattachment.FieldAskID]
	return ok
}

// ResetAskID resets all changes to the "ask_id" field.
func (m *UserAskAnswerAttachmentMutation) ResetAskID() {
	m.ask = nil
	delete(m.clearedFields, useraskanswerattachment.FieldAskID)
}

// SetType sets the "type" field.
func (m *UserAskAnswerAttachmentMutation) SetType(u uint8) {
	m._type = &u
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *UserAskAnswerAttachmentMutation) GetType() (r uint8, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the UserAskAnswerAttachment entity.
// If the UserAskAnswerAttachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAskAnswerAttachmentMutation) OldType(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds u to the "type" field.
func (m *UserAskAnswerAttachmentMutation) AddType(u uint8) {
	if m.add_type != nil {
		*m.add_type += u
	} else {
		m.add_type = &u
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *UserAskAnswerAttachmentMutation) AddedType() (r uint8, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *UserAskAnswerAttachmentMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// ClearAttachment clears the "attachment" edge to the Attachment entity.
func (m *UserAskAnswerAttachmentMutation) ClearAttachment() {
	m.clearedattachment = true
}

// AttachmentCleared reports if the "attachment" edge to the Attachment entity was cleared.
func (m *UserAskAnswerAttachmentMutation) AttachmentCleared() bool {
	return m.AttachmentIDCleared() || m.clearedattachment
}

// AttachmentIDs returns the "attachment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AttachmentID instead. It exists only for internal usage by the builders.
func (m *UserAskAnswerAttachmentMutation) AttachmentIDs() (ids []int) {
	if id := m.attachment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAttachment resets all changes to the "attachment" edge.
func (m *UserAskAnswerAttachmentMutation) ResetAttachment() {
	m.attachment = nil
	m.clearedattachment = false
}

// ClearAsk clears the "ask" edge to the UserAskAnswer entity.
func (m *UserAskAnswerAttachmentMutation) ClearAsk() {
	m.clearedask = true
}

// AskCleared reports if the "ask" edge to the UserAskAnswer entity was cleared.
func (m *UserAskAnswerAttachmentMutation) AskCleared() bool {
	return m.AskIDCleared() || m.clearedask
}

// AskIDs returns the "ask" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AskID instead. It exists only for internal usage by the builders.
func (m *UserAskAnswerAttachmentMutation) AskIDs() (ids []int) {
	if id := m.ask; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAsk resets all changes to the "ask" edge.
func (m *UserAskAnswerAttachmentMutation) ResetAsk() {
	m.ask = nil
	m.clearedask = false
}

// Op returns the operation name.
func (m *UserAskAnswerAttachmentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (UserAskAnswerAttachment).
func (m *UserAskAnswerAttachmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserAskAnswerAttachmentMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.attachment != nil {
		fields = append(fields, useraskanswerattachment.FieldAttachmentID)
	}
	if m.ask != nil {
		fields = append(fields, useraskanswerattachment.FieldAskID)
	}
	if m._type != nil {
		fields = append(fields, useraskanswerattachment.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserAskAnswerAttachmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case useraskanswerattachment.FieldAttachmentID:
		return m.AttachmentID()
	case useraskanswerattachment.FieldAskID:
		return m.AskID()
	case useraskanswerattachment.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserAskAnswerAttachmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case useraskanswerattachment.FieldAttachmentID:
		return m.OldAttachmentID(ctx)
	case useraskanswerattachment.FieldAskID:
		return m.OldAskID(ctx)
	case useraskanswerattachment.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown UserAskAnswerAttachment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserAskAnswerAttachmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case useraskanswerattachment.FieldAttachmentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttachmentID(v)
		return nil
	case useraskanswerattachment.FieldAskID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAskID(v)
		return nil
	case useraskanswerattachment.FieldType:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown UserAskAnswerAttachment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserAskAnswerAttachmentMutation) AddedFields() []string {
	var fields []string
	if m.add_type != nil {
		fields = append(fields, useraskanswerattachment.FieldType)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserAskAnswerAttachmentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case useraskanswerattachment.FieldType:
		return m.AddedType()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserAskAnswerAttachmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case useraskanswerattachment.FieldType:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	}
	return fmt.Errorf("unknown UserAskAnswerAttachment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserAskAnswerAttachmentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(useraskanswerattachment.FieldAttachmentID) {
		fields = append(fields, useraskanswerattachment.FieldAttachmentID)
	}
	if m.FieldCleared(useraskanswerattachment.FieldAskID) {
		fields = append(fields, useraskanswerattachment.FieldAskID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserAskAnswerAttachmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserAskAnswerAttachmentMutation) ClearField(name string) error {
	switch name {
	case useraskanswerattachment.FieldAttachmentID:
		m.ClearAttachmentID()
		return nil
	case useraskanswerattachment.FieldAskID:
		m.ClearAskID()
		return nil
	}
	return fmt.Errorf("unknown UserAskAnswerAttachment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserAskAnswerAttachmentMutation) ResetField(name string) error {
	switch name {
	case useraskanswerattachment.FieldAttachmentID:
		m.ResetAttachmentID()
		return nil
	case useraskanswerattachment.FieldAskID:
		m.ResetAskID()
		return nil
	case useraskanswerattachment.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown UserAskAnswerAttachment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserAskAnswerAttachmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.attachment != nil {
		edges = append(edges, useraskanswerattachment.EdgeAttachment)
	}
	if m.ask != nil {
		edges = append(edges, useraskanswerattachment.EdgeAsk)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserAskAnswerAttachmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case useraskanswerattachment.EdgeAttachment:
		if id := m.attachment; id != nil {
			return []ent.Value{*id}
		}
	case useraskanswerattachment.EdgeAsk:
		if id := m.ask; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserAskAnswerAttachmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserAskAnswerAttachmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserAskAnswerAttachmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedattachment {
		edges = append(edges, useraskanswerattachment.EdgeAttachment)
	}
	if m.clearedask {
		edges = append(edges, useraskanswerattachment.EdgeAsk)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserAskAnswerAttachmentMutation) EdgeCleared(name string) bool {
	switch name {
	case useraskanswerattachment.EdgeAttachment:
		return m.clearedattachment
	case useraskanswerattachment.EdgeAsk:
		return m.clearedask
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserAskAnswerAttachmentMutation) ClearEdge(name string) error {
	switch name {
	case useraskanswerattachment.EdgeAttachment:
		m.ClearAttachment()
		return nil
	case useraskanswerattachment.EdgeAsk:
		m.ClearAsk()
		return nil
	}
	return fmt.Errorf("unknown UserAskAnswerAttachment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserAskAnswerAttachmentMutation) ResetEdge(name string) error {
	switch name {
	case useraskanswerattachment.EdgeAttachment:
		m.ResetAttachment()
		return nil
	case useraskanswerattachment.EdgeAsk:
		m.ResetAsk()
		return nil
	}
	return fmt.Errorf("unknown UserAskAnswerAttachment edge %s", name)
}

// UserCourseAppraiseMutation represents an operation that mutates the UserCourseAppraise nodes in the graph.
type UserCourseAppraiseMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	uuid                      *string
	created_at                *time.Time
	updated_at                *time.Time
	deleted_at                *time.Time
	teach_attitude_score      *float64
	addteach_attitude_score   *float64
	teach_content_score       *float64
	addteach_content_score    *float64
	teach_atmosphere_score    *float64
	addteach_atmosphere_score *float64
	composite_score           *float64
	addcomposite_score        *float64
	_type                     *uint8
	add_type                  *uint8
	show_status               *uint8
	addshow_status            *uint8
	teacher_impression        *string
	desc                      *string
	teacher_reply             *string
	clearedFields             map[string]struct{}
	small_cate                *int
	clearedsmall_cate         bool
	course                    *int
	clearedcourse             bool
	user                      *int
	cleareduser               bool
	done                      bool
	oldValue                  func(context.Context) (*UserCourseAppraise, error)
	predicates                []predicate.UserCourseAppraise
}

var _ ent.Mutation = (*UserCourseAppraiseMutation)(nil)

// usercourseappraiseOption allows management of the mutation configuration using functional options.
type usercourseappraiseOption func(*UserCourseAppraiseMutation)

// newUserCourseAppraiseMutation creates new mutation for the UserCourseAppraise entity.
func newUserCourseAppraiseMutation(c config, op Op, opts ...usercourseappraiseOption) *UserCourseAppraiseMutation {
	m := &UserCourseAppraiseMutation{
		config:        c,
		op:            op,
		typ:           TypeUserCourseAppraise,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserCourseAppraiseID sets the ID field of the mutation.
func withUserCourseAppraiseID(id int) usercourseappraiseOption {
	return func(m *UserCourseAppraiseMutation) {
		var (
			err   error
			once  sync.Once
			value *UserCourseAppraise
		)
		m.oldValue = func(ctx context.Context) (*UserCourseAppraise, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserCourseAppraise.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserCourseAppraise sets the old UserCourseAppraise of the mutation.
func withUserCourseAppraise(node *UserCourseAppraise) usercourseappraiseOption {
	return func(m *UserCourseAppraiseMutation) {
		m.oldValue = func(context.Context) (*UserCourseAppraise, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserCourseAppraiseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserCourseAppraiseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *UserCourseAppraiseMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *UserCourseAppraiseMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *UserCourseAppraiseMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the UserCourseAppraise entity.
// If the UserCourseAppraise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCourseAppraiseMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *UserCourseAppraiseMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserCourseAppraiseMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserCourseAppraiseMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserCourseAppraise entity.
// If the UserCourseAppraise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCourseAppraiseMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *UserCourseAppraiseMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[usercourseappraise.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *UserCourseAppraiseMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[usercourseappraise.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserCourseAppraiseMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, usercourseappraise.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserCourseAppraiseMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserCourseAppraiseMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserCourseAppraise entity.
// If the UserCourseAppraise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCourseAppraiseMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *UserCourseAppraiseMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[usercourseappraise.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *UserCourseAppraiseMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[usercourseappraise.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserCourseAppraiseMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, usercourseappraise.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserCourseAppraiseMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserCourseAppraiseMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the UserCourseAppraise entity.
// If the UserCourseAppraise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCourseAppraiseMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserCourseAppraiseMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[usercourseappraise.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserCourseAppraiseMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[usercourseappraise.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserCourseAppraiseMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, usercourseappraise.FieldDeletedAt)
}

// SetTeachAttitudeScore sets the "teach_attitude_score" field.
func (m *UserCourseAppraiseMutation) SetTeachAttitudeScore(f float64) {
	m.teach_attitude_score = &f
	m.addteach_attitude_score = nil
}

// TeachAttitudeScore returns the value of the "teach_attitude_score" field in the mutation.
func (m *UserCourseAppraiseMutation) TeachAttitudeScore() (r float64, exists bool) {
	v := m.teach_attitude_score
	if v == nil {
		return
	}
	return *v, true
}

// OldTeachAttitudeScore returns the old "teach_attitude_score" field's value of the UserCourseAppraise entity.
// If the UserCourseAppraise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCourseAppraiseMutation) OldTeachAttitudeScore(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTeachAttitudeScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTeachAttitudeScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeachAttitudeScore: %w", err)
	}
	return oldValue.TeachAttitudeScore, nil
}

// AddTeachAttitudeScore adds f to the "teach_attitude_score" field.
func (m *UserCourseAppraiseMutation) AddTeachAttitudeScore(f float64) {
	if m.addteach_attitude_score != nil {
		*m.addteach_attitude_score += f
	} else {
		m.addteach_attitude_score = &f
	}
}

// AddedTeachAttitudeScore returns the value that was added to the "teach_attitude_score" field in this mutation.
func (m *UserCourseAppraiseMutation) AddedTeachAttitudeScore() (r float64, exists bool) {
	v := m.addteach_attitude_score
	if v == nil {
		return
	}
	return *v, true
}

// ResetTeachAttitudeScore resets all changes to the "teach_attitude_score" field.
func (m *UserCourseAppraiseMutation) ResetTeachAttitudeScore() {
	m.teach_attitude_score = nil
	m.addteach_attitude_score = nil
}

// SetTeachContentScore sets the "teach_content_score" field.
func (m *UserCourseAppraiseMutation) SetTeachContentScore(f float64) {
	m.teach_content_score = &f
	m.addteach_content_score = nil
}

// TeachContentScore returns the value of the "teach_content_score" field in the mutation.
func (m *UserCourseAppraiseMutation) TeachContentScore() (r float64, exists bool) {
	v := m.teach_content_score
	if v == nil {
		return
	}
	return *v, true
}

// OldTeachContentScore returns the old "teach_content_score" field's value of the UserCourseAppraise entity.
// If the UserCourseAppraise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCourseAppraiseMutation) OldTeachContentScore(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTeachContentScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTeachContentScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeachContentScore: %w", err)
	}
	return oldValue.TeachContentScore, nil
}

// AddTeachContentScore adds f to the "teach_content_score" field.
func (m *UserCourseAppraiseMutation) AddTeachContentScore(f float64) {
	if m.addteach_content_score != nil {
		*m.addteach_content_score += f
	} else {
		m.addteach_content_score = &f
	}
}

// AddedTeachContentScore returns the value that was added to the "teach_content_score" field in this mutation.
func (m *UserCourseAppraiseMutation) AddedTeachContentScore() (r float64, exists bool) {
	v := m.addteach_content_score
	if v == nil {
		return
	}
	return *v, true
}

// ResetTeachContentScore resets all changes to the "teach_content_score" field.
func (m *UserCourseAppraiseMutation) ResetTeachContentScore() {
	m.teach_content_score = nil
	m.addteach_content_score = nil
}

// SetTeachAtmosphereScore sets the "teach_atmosphere_score" field.
func (m *UserCourseAppraiseMutation) SetTeachAtmosphereScore(f float64) {
	m.teach_atmosphere_score = &f
	m.addteach_atmosphere_score = nil
}

// TeachAtmosphereScore returns the value of the "teach_atmosphere_score" field in the mutation.
func (m *UserCourseAppraiseMutation) TeachAtmosphereScore() (r float64, exists bool) {
	v := m.teach_atmosphere_score
	if v == nil {
		return
	}
	return *v, true
}

// OldTeachAtmosphereScore returns the old "teach_atmosphere_score" field's value of the UserCourseAppraise entity.
// If the UserCourseAppraise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCourseAppraiseMutation) OldTeachAtmosphereScore(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTeachAtmosphereScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTeachAtmosphereScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeachAtmosphereScore: %w", err)
	}
	return oldValue.TeachAtmosphereScore, nil
}

// AddTeachAtmosphereScore adds f to the "teach_atmosphere_score" field.
func (m *UserCourseAppraiseMutation) AddTeachAtmosphereScore(f float64) {
	if m.addteach_atmosphere_score != nil {
		*m.addteach_atmosphere_score += f
	} else {
		m.addteach_atmosphere_score = &f
	}
}

// AddedTeachAtmosphereScore returns the value that was added to the "teach_atmosphere_score" field in this mutation.
func (m *UserCourseAppraiseMutation) AddedTeachAtmosphereScore() (r float64, exists bool) {
	v := m.addteach_atmosphere_score
	if v == nil {
		return
	}
	return *v, true
}

// ResetTeachAtmosphereScore resets all changes to the "teach_atmosphere_score" field.
func (m *UserCourseAppraiseMutation) ResetTeachAtmosphereScore() {
	m.teach_atmosphere_score = nil
	m.addteach_atmosphere_score = nil
}

// SetCompositeScore sets the "composite_score" field.
func (m *UserCourseAppraiseMutation) SetCompositeScore(f float64) {
	m.composite_score = &f
	m.addcomposite_score = nil
}

// CompositeScore returns the value of the "composite_score" field in the mutation.
func (m *UserCourseAppraiseMutation) CompositeScore() (r float64, exists bool) {
	v := m.composite_score
	if v == nil {
		return
	}
	return *v, true
}

// OldCompositeScore returns the old "composite_score" field's value of the UserCourseAppraise entity.
// If the UserCourseAppraise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCourseAppraiseMutation) OldCompositeScore(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCompositeScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCompositeScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompositeScore: %w", err)
	}
	return oldValue.CompositeScore, nil
}

// AddCompositeScore adds f to the "composite_score" field.
func (m *UserCourseAppraiseMutation) AddCompositeScore(f float64) {
	if m.addcomposite_score != nil {
		*m.addcomposite_score += f
	} else {
		m.addcomposite_score = &f
	}
}

// AddedCompositeScore returns the value that was added to the "composite_score" field in this mutation.
func (m *UserCourseAppraiseMutation) AddedCompositeScore() (r float64, exists bool) {
	v := m.addcomposite_score
	if v == nil {
		return
	}
	return *v, true
}

// ResetCompositeScore resets all changes to the "composite_score" field.
func (m *UserCourseAppraiseMutation) ResetCompositeScore() {
	m.composite_score = nil
	m.addcomposite_score = nil
}

// SetUserID sets the "user_id" field.
func (m *UserCourseAppraiseMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserCourseAppraiseMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserCourseAppraise entity.
// If the UserCourseAppraise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCourseAppraiseMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *UserCourseAppraiseMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[usercourseappraise.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *UserCourseAppraiseMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[usercourseappraise.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserCourseAppraiseMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, usercourseappraise.FieldUserID)
}

// SetSmallCateID sets the "small_cate_id" field.
func (m *UserCourseAppraiseMutation) SetSmallCateID(i int) {
	m.small_cate = &i
}

// SmallCateID returns the value of the "small_cate_id" field in the mutation.
func (m *UserCourseAppraiseMutation) SmallCateID() (r int, exists bool) {
	v := m.small_cate
	if v == nil {
		return
	}
	return *v, true
}

// OldSmallCateID returns the old "small_cate_id" field's value of the UserCourseAppraise entity.
// If the UserCourseAppraise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCourseAppraiseMutation) OldSmallCateID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSmallCateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSmallCateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSmallCateID: %w", err)
	}
	return oldValue.SmallCateID, nil
}

// ClearSmallCateID clears the value of the "small_cate_id" field.
func (m *UserCourseAppraiseMutation) ClearSmallCateID() {
	m.small_cate = nil
	m.clearedFields[usercourseappraise.FieldSmallCateID] = struct{}{}
}

// SmallCateIDCleared returns if the "small_cate_id" field was cleared in this mutation.
func (m *UserCourseAppraiseMutation) SmallCateIDCleared() bool {
	_, ok := m.clearedFields[usercourseappraise.FieldSmallCateID]
	return ok
}

// ResetSmallCateID resets all changes to the "small_cate_id" field.
func (m *UserCourseAppraiseMutation) ResetSmallCateID() {
	m.small_cate = nil
	delete(m.clearedFields, usercourseappraise.FieldSmallCateID)
}

// SetCourseID sets the "course_id" field.
func (m *UserCourseAppraiseMutation) SetCourseID(i int) {
	m.course = &i
}

// CourseID returns the value of the "course_id" field in the mutation.
func (m *UserCourseAppraiseMutation) CourseID() (r int, exists bool) {
	v := m.course
	if v == nil {
		return
	}
	return *v, true
}

// OldCourseID returns the old "course_id" field's value of the UserCourseAppraise entity.
// If the UserCourseAppraise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCourseAppraiseMutation) OldCourseID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCourseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCourseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCourseID: %w", err)
	}
	return oldValue.CourseID, nil
}

// ClearCourseID clears the value of the "course_id" field.
func (m *UserCourseAppraiseMutation) ClearCourseID() {
	m.course = nil
	m.clearedFields[usercourseappraise.FieldCourseID] = struct{}{}
}

// CourseIDCleared returns if the "course_id" field was cleared in this mutation.
func (m *UserCourseAppraiseMutation) CourseIDCleared() bool {
	_, ok := m.clearedFields[usercourseappraise.FieldCourseID]
	return ok
}

// ResetCourseID resets all changes to the "course_id" field.
func (m *UserCourseAppraiseMutation) ResetCourseID() {
	m.course = nil
	delete(m.clearedFields, usercourseappraise.FieldCourseID)
}

// SetType sets the "type" field.
func (m *UserCourseAppraiseMutation) SetType(u uint8) {
	m._type = &u
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *UserCourseAppraiseMutation) GetType() (r uint8, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the UserCourseAppraise entity.
// If the UserCourseAppraise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCourseAppraiseMutation) OldType(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds u to the "type" field.
func (m *UserCourseAppraiseMutation) AddType(u uint8) {
	if m.add_type != nil {
		*m.add_type += u
	} else {
		m.add_type = &u
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *UserCourseAppraiseMutation) AddedType() (r uint8, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *UserCourseAppraiseMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetShowStatus sets the "show_status" field.
func (m *UserCourseAppraiseMutation) SetShowStatus(u uint8) {
	m.show_status = &u
	m.addshow_status = nil
}

// ShowStatus returns the value of the "show_status" field in the mutation.
func (m *UserCourseAppraiseMutation) ShowStatus() (r uint8, exists bool) {
	v := m.show_status
	if v == nil {
		return
	}
	return *v, true
}

// OldShowStatus returns the old "show_status" field's value of the UserCourseAppraise entity.
// If the UserCourseAppraise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCourseAppraiseMutation) OldShowStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShowStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShowStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShowStatus: %w", err)
	}
	return oldValue.ShowStatus, nil
}

// AddShowStatus adds u to the "show_status" field.
func (m *UserCourseAppraiseMutation) AddShowStatus(u uint8) {
	if m.addshow_status != nil {
		*m.addshow_status += u
	} else {
		m.addshow_status = &u
	}
}

// AddedShowStatus returns the value that was added to the "show_status" field in this mutation.
func (m *UserCourseAppraiseMutation) AddedShowStatus() (r uint8, exists bool) {
	v := m.addshow_status
	if v == nil {
		return
	}
	return *v, true
}

// ResetShowStatus resets all changes to the "show_status" field.
func (m *UserCourseAppraiseMutation) ResetShowStatus() {
	m.show_status = nil
	m.addshow_status = nil
}

// SetTeacherImpression sets the "teacher_impression" field.
func (m *UserCourseAppraiseMutation) SetTeacherImpression(s string) {
	m.teacher_impression = &s
}

// TeacherImpression returns the value of the "teacher_impression" field in the mutation.
func (m *UserCourseAppraiseMutation) TeacherImpression() (r string, exists bool) {
	v := m.teacher_impression
	if v == nil {
		return
	}
	return *v, true
}

// OldTeacherImpression returns the old "teacher_impression" field's value of the UserCourseAppraise entity.
// If the UserCourseAppraise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCourseAppraiseMutation) OldTeacherImpression(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTeacherImpression is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTeacherImpression requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeacherImpression: %w", err)
	}
	return oldValue.TeacherImpression, nil
}

// ResetTeacherImpression resets all changes to the "teacher_impression" field.
func (m *UserCourseAppraiseMutation) ResetTeacherImpression() {
	m.teacher_impression = nil
}

// SetDesc sets the "desc" field.
func (m *UserCourseAppraiseMutation) SetDesc(s string) {
	m.desc = &s
}

// Desc returns the value of the "desc" field in the mutation.
func (m *UserCourseAppraiseMutation) Desc() (r string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the UserCourseAppraise entity.
// If the UserCourseAppraise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCourseAppraiseMutation) OldDesc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// ResetDesc resets all changes to the "desc" field.
func (m *UserCourseAppraiseMutation) ResetDesc() {
	m.desc = nil
}

// SetTeacherReply sets the "teacher_reply" field.
func (m *UserCourseAppraiseMutation) SetTeacherReply(s string) {
	m.teacher_reply = &s
}

// TeacherReply returns the value of the "teacher_reply" field in the mutation.
func (m *UserCourseAppraiseMutation) TeacherReply() (r string, exists bool) {
	v := m.teacher_reply
	if v == nil {
		return
	}
	return *v, true
}

// OldTeacherReply returns the old "teacher_reply" field's value of the UserCourseAppraise entity.
// If the UserCourseAppraise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCourseAppraiseMutation) OldTeacherReply(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTeacherReply is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTeacherReply requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeacherReply: %w", err)
	}
	return oldValue.TeacherReply, nil
}

// ResetTeacherReply resets all changes to the "teacher_reply" field.
func (m *UserCourseAppraiseMutation) ResetTeacherReply() {
	m.teacher_reply = nil
}

// ClearSmallCate clears the "small_cate" edge to the KcCourseSmallCategory entity.
func (m *UserCourseAppraiseMutation) ClearSmallCate() {
	m.clearedsmall_cate = true
}

// SmallCateCleared reports if the "small_cate" edge to the KcCourseSmallCategory entity was cleared.
func (m *UserCourseAppraiseMutation) SmallCateCleared() bool {
	return m.SmallCateIDCleared() || m.clearedsmall_cate
}

// SmallCateIDs returns the "small_cate" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SmallCateID instead. It exists only for internal usage by the builders.
func (m *UserCourseAppraiseMutation) SmallCateIDs() (ids []int) {
	if id := m.small_cate; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSmallCate resets all changes to the "small_cate" edge.
func (m *UserCourseAppraiseMutation) ResetSmallCate() {
	m.small_cate = nil
	m.clearedsmall_cate = false
}

// ClearCourse clears the "course" edge to the KcCourse entity.
func (m *UserCourseAppraiseMutation) ClearCourse() {
	m.clearedcourse = true
}

// CourseCleared reports if the "course" edge to the KcCourse entity was cleared.
func (m *UserCourseAppraiseMutation) CourseCleared() bool {
	return m.CourseIDCleared() || m.clearedcourse
}

// CourseIDs returns the "course" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CourseID instead. It exists only for internal usage by the builders.
func (m *UserCourseAppraiseMutation) CourseIDs() (ids []int) {
	if id := m.course; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCourse resets all changes to the "course" edge.
func (m *UserCourseAppraiseMutation) ResetCourse() {
	m.course = nil
	m.clearedcourse = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserCourseAppraiseMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserCourseAppraiseMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserCourseAppraiseMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserCourseAppraiseMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Op returns the operation name.
func (m *UserCourseAppraiseMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (UserCourseAppraise).
func (m *UserCourseAppraiseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserCourseAppraiseMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.uuid != nil {
		fields = append(fields, usercourseappraise.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, usercourseappraise.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, usercourseappraise.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, usercourseappraise.FieldDeletedAt)
	}
	if m.teach_attitude_score != nil {
		fields = append(fields, usercourseappraise.FieldTeachAttitudeScore)
	}
	if m.teach_content_score != nil {
		fields = append(fields, usercourseappraise.FieldTeachContentScore)
	}
	if m.teach_atmosphere_score != nil {
		fields = append(fields, usercourseappraise.FieldTeachAtmosphereScore)
	}
	if m.composite_score != nil {
		fields = append(fields, usercourseappraise.FieldCompositeScore)
	}
	if m.user != nil {
		fields = append(fields, usercourseappraise.FieldUserID)
	}
	if m.small_cate != nil {
		fields = append(fields, usercourseappraise.FieldSmallCateID)
	}
	if m.course != nil {
		fields = append(fields, usercourseappraise.FieldCourseID)
	}
	if m._type != nil {
		fields = append(fields, usercourseappraise.FieldType)
	}
	if m.show_status != nil {
		fields = append(fields, usercourseappraise.FieldShowStatus)
	}
	if m.teacher_impression != nil {
		fields = append(fields, usercourseappraise.FieldTeacherImpression)
	}
	if m.desc != nil {
		fields = append(fields, usercourseappraise.FieldDesc)
	}
	if m.teacher_reply != nil {
		fields = append(fields, usercourseappraise.FieldTeacherReply)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserCourseAppraiseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usercourseappraise.FieldUUID:
		return m.UUID()
	case usercourseappraise.FieldCreatedAt:
		return m.CreatedAt()
	case usercourseappraise.FieldUpdatedAt:
		return m.UpdatedAt()
	case usercourseappraise.FieldDeletedAt:
		return m.DeletedAt()
	case usercourseappraise.FieldTeachAttitudeScore:
		return m.TeachAttitudeScore()
	case usercourseappraise.FieldTeachContentScore:
		return m.TeachContentScore()
	case usercourseappraise.FieldTeachAtmosphereScore:
		return m.TeachAtmosphereScore()
	case usercourseappraise.FieldCompositeScore:
		return m.CompositeScore()
	case usercourseappraise.FieldUserID:
		return m.UserID()
	case usercourseappraise.FieldSmallCateID:
		return m.SmallCateID()
	case usercourseappraise.FieldCourseID:
		return m.CourseID()
	case usercourseappraise.FieldType:
		return m.GetType()
	case usercourseappraise.FieldShowStatus:
		return m.ShowStatus()
	case usercourseappraise.FieldTeacherImpression:
		return m.TeacherImpression()
	case usercourseappraise.FieldDesc:
		return m.Desc()
	case usercourseappraise.FieldTeacherReply:
		return m.TeacherReply()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserCourseAppraiseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usercourseappraise.FieldUUID:
		return m.OldUUID(ctx)
	case usercourseappraise.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case usercourseappraise.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case usercourseappraise.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case usercourseappraise.FieldTeachAttitudeScore:
		return m.OldTeachAttitudeScore(ctx)
	case usercourseappraise.FieldTeachContentScore:
		return m.OldTeachContentScore(ctx)
	case usercourseappraise.FieldTeachAtmosphereScore:
		return m.OldTeachAtmosphereScore(ctx)
	case usercourseappraise.FieldCompositeScore:
		return m.OldCompositeScore(ctx)
	case usercourseappraise.FieldUserID:
		return m.OldUserID(ctx)
	case usercourseappraise.FieldSmallCateID:
		return m.OldSmallCateID(ctx)
	case usercourseappraise.FieldCourseID:
		return m.OldCourseID(ctx)
	case usercourseappraise.FieldType:
		return m.OldType(ctx)
	case usercourseappraise.FieldShowStatus:
		return m.OldShowStatus(ctx)
	case usercourseappraise.FieldTeacherImpression:
		return m.OldTeacherImpression(ctx)
	case usercourseappraise.FieldDesc:
		return m.OldDesc(ctx)
	case usercourseappraise.FieldTeacherReply:
		return m.OldTeacherReply(ctx)
	}
	return nil, fmt.Errorf("unknown UserCourseAppraise field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserCourseAppraiseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usercourseappraise.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case usercourseappraise.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case usercourseappraise.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case usercourseappraise.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case usercourseappraise.FieldTeachAttitudeScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeachAttitudeScore(v)
		return nil
	case usercourseappraise.FieldTeachContentScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeachContentScore(v)
		return nil
	case usercourseappraise.FieldTeachAtmosphereScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeachAtmosphereScore(v)
		return nil
	case usercourseappraise.FieldCompositeScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompositeScore(v)
		return nil
	case usercourseappraise.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case usercourseappraise.FieldSmallCateID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSmallCateID(v)
		return nil
	case usercourseappraise.FieldCourseID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCourseID(v)
		return nil
	case usercourseappraise.FieldType:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case usercourseappraise.FieldShowStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShowStatus(v)
		return nil
	case usercourseappraise.FieldTeacherImpression:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeacherImpression(v)
		return nil
	case usercourseappraise.FieldDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	case usercourseappraise.FieldTeacherReply:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeacherReply(v)
		return nil
	}
	return fmt.Errorf("unknown UserCourseAppraise field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserCourseAppraiseMutation) AddedFields() []string {
	var fields []string
	if m.addteach_attitude_score != nil {
		fields = append(fields, usercourseappraise.FieldTeachAttitudeScore)
	}
	if m.addteach_content_score != nil {
		fields = append(fields, usercourseappraise.FieldTeachContentScore)
	}
	if m.addteach_atmosphere_score != nil {
		fields = append(fields, usercourseappraise.FieldTeachAtmosphereScore)
	}
	if m.addcomposite_score != nil {
		fields = append(fields, usercourseappraise.FieldCompositeScore)
	}
	if m.add_type != nil {
		fields = append(fields, usercourseappraise.FieldType)
	}
	if m.addshow_status != nil {
		fields = append(fields, usercourseappraise.FieldShowStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserCourseAppraiseMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case usercourseappraise.FieldTeachAttitudeScore:
		return m.AddedTeachAttitudeScore()
	case usercourseappraise.FieldTeachContentScore:
		return m.AddedTeachContentScore()
	case usercourseappraise.FieldTeachAtmosphereScore:
		return m.AddedTeachAtmosphereScore()
	case usercourseappraise.FieldCompositeScore:
		return m.AddedCompositeScore()
	case usercourseappraise.FieldType:
		return m.AddedType()
	case usercourseappraise.FieldShowStatus:
		return m.AddedShowStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserCourseAppraiseMutation) AddField(name string, value ent.Value) error {
	switch name {
	case usercourseappraise.FieldTeachAttitudeScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTeachAttitudeScore(v)
		return nil
	case usercourseappraise.FieldTeachContentScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTeachContentScore(v)
		return nil
	case usercourseappraise.FieldTeachAtmosphereScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTeachAtmosphereScore(v)
		return nil
	case usercourseappraise.FieldCompositeScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCompositeScore(v)
		return nil
	case usercourseappraise.FieldType:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case usercourseappraise.FieldShowStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShowStatus(v)
		return nil
	}
	return fmt.Errorf("unknown UserCourseAppraise numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserCourseAppraiseMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(usercourseappraise.FieldCreatedAt) {
		fields = append(fields, usercourseappraise.FieldCreatedAt)
	}
	if m.FieldCleared(usercourseappraise.FieldUpdatedAt) {
		fields = append(fields, usercourseappraise.FieldUpdatedAt)
	}
	if m.FieldCleared(usercourseappraise.FieldDeletedAt) {
		fields = append(fields, usercourseappraise.FieldDeletedAt)
	}
	if m.FieldCleared(usercourseappraise.FieldUserID) {
		fields = append(fields, usercourseappraise.FieldUserID)
	}
	if m.FieldCleared(usercourseappraise.FieldSmallCateID) {
		fields = append(fields, usercourseappraise.FieldSmallCateID)
	}
	if m.FieldCleared(usercourseappraise.FieldCourseID) {
		fields = append(fields, usercourseappraise.FieldCourseID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserCourseAppraiseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserCourseAppraiseMutation) ClearField(name string) error {
	switch name {
	case usercourseappraise.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case usercourseappraise.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case usercourseappraise.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case usercourseappraise.FieldUserID:
		m.ClearUserID()
		return nil
	case usercourseappraise.FieldSmallCateID:
		m.ClearSmallCateID()
		return nil
	case usercourseappraise.FieldCourseID:
		m.ClearCourseID()
		return nil
	}
	return fmt.Errorf("unknown UserCourseAppraise nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserCourseAppraiseMutation) ResetField(name string) error {
	switch name {
	case usercourseappraise.FieldUUID:
		m.ResetUUID()
		return nil
	case usercourseappraise.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case usercourseappraise.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case usercourseappraise.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case usercourseappraise.FieldTeachAttitudeScore:
		m.ResetTeachAttitudeScore()
		return nil
	case usercourseappraise.FieldTeachContentScore:
		m.ResetTeachContentScore()
		return nil
	case usercourseappraise.FieldTeachAtmosphereScore:
		m.ResetTeachAtmosphereScore()
		return nil
	case usercourseappraise.FieldCompositeScore:
		m.ResetCompositeScore()
		return nil
	case usercourseappraise.FieldUserID:
		m.ResetUserID()
		return nil
	case usercourseappraise.FieldSmallCateID:
		m.ResetSmallCateID()
		return nil
	case usercourseappraise.FieldCourseID:
		m.ResetCourseID()
		return nil
	case usercourseappraise.FieldType:
		m.ResetType()
		return nil
	case usercourseappraise.FieldShowStatus:
		m.ResetShowStatus()
		return nil
	case usercourseappraise.FieldTeacherImpression:
		m.ResetTeacherImpression()
		return nil
	case usercourseappraise.FieldDesc:
		m.ResetDesc()
		return nil
	case usercourseappraise.FieldTeacherReply:
		m.ResetTeacherReply()
		return nil
	}
	return fmt.Errorf("unknown UserCourseAppraise field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserCourseAppraiseMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.small_cate != nil {
		edges = append(edges, usercourseappraise.EdgeSmallCate)
	}
	if m.course != nil {
		edges = append(edges, usercourseappraise.EdgeCourse)
	}
	if m.user != nil {
		edges = append(edges, usercourseappraise.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserCourseAppraiseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usercourseappraise.EdgeSmallCate:
		if id := m.small_cate; id != nil {
			return []ent.Value{*id}
		}
	case usercourseappraise.EdgeCourse:
		if id := m.course; id != nil {
			return []ent.Value{*id}
		}
	case usercourseappraise.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserCourseAppraiseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserCourseAppraiseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserCourseAppraiseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedsmall_cate {
		edges = append(edges, usercourseappraise.EdgeSmallCate)
	}
	if m.clearedcourse {
		edges = append(edges, usercourseappraise.EdgeCourse)
	}
	if m.cleareduser {
		edges = append(edges, usercourseappraise.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserCourseAppraiseMutation) EdgeCleared(name string) bool {
	switch name {
	case usercourseappraise.EdgeSmallCate:
		return m.clearedsmall_cate
	case usercourseappraise.EdgeCourse:
		return m.clearedcourse
	case usercourseappraise.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserCourseAppraiseMutation) ClearEdge(name string) error {
	switch name {
	case usercourseappraise.EdgeSmallCate:
		m.ClearSmallCate()
		return nil
	case usercourseappraise.EdgeCourse:
		m.ClearCourse()
		return nil
	case usercourseappraise.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserCourseAppraise unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserCourseAppraiseMutation) ResetEdge(name string) error {
	switch name {
	case usercourseappraise.EdgeSmallCate:
		m.ResetSmallCate()
		return nil
	case usercourseappraise.EdgeCourse:
		m.ResetCourse()
		return nil
	case usercourseappraise.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserCourseAppraise edge %s", name)
}

// UserLoginLogMutation represents an operation that mutates the UserLoginLog nodes in the graph.
type UserLoginLogMutation struct {
	config
	op              Op
	typ             string
	id              *int
	uuid            *string
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *time.Time
	cid             *string
	platform        *string
	device          *string
	version         *string
	ip              *string
	province        *string
	city            *string
	latest_login_at *time.Time
	clearedFields   map[string]struct{}
	user            *int
	cleareduser     bool
	done            bool
	oldValue        func(context.Context) (*UserLoginLog, error)
	predicates      []predicate.UserLoginLog
}

var _ ent.Mutation = (*UserLoginLogMutation)(nil)

// userloginlogOption allows management of the mutation configuration using functional options.
type userloginlogOption func(*UserLoginLogMutation)

// newUserLoginLogMutation creates new mutation for the UserLoginLog entity.
func newUserLoginLogMutation(c config, op Op, opts ...userloginlogOption) *UserLoginLogMutation {
	m := &UserLoginLogMutation{
		config:        c,
		op:            op,
		typ:           TypeUserLoginLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserLoginLogID sets the ID field of the mutation.
func withUserLoginLogID(id int) userloginlogOption {
	return func(m *UserLoginLogMutation) {
		var (
			err   error
			once  sync.Once
			value *UserLoginLog
		)
		m.oldValue = func(ctx context.Context) (*UserLoginLog, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserLoginLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserLoginLog sets the old UserLoginLog of the mutation.
func withUserLoginLog(node *UserLoginLog) userloginlogOption {
	return func(m *UserLoginLogMutation) {
		m.oldValue = func(context.Context) (*UserLoginLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserLoginLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserLoginLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *UserLoginLogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *UserLoginLogMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *UserLoginLogMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the UserLoginLog entity.
// If the UserLoginLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginLogMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *UserLoginLogMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserLoginLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserLoginLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserLoginLog entity.
// If the UserLoginLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginLogMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *UserLoginLogMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[userloginlog.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *UserLoginLogMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[userloginlog.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserLoginLogMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, userloginlog.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserLoginLogMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserLoginLogMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserLoginLog entity.
// If the UserLoginLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginLogMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *UserLoginLogMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[userloginlog.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *UserLoginLogMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[userloginlog.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserLoginLogMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, userloginlog.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserLoginLogMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserLoginLogMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the UserLoginLog entity.
// If the UserLoginLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginLogMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserLoginLogMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[userloginlog.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserLoginLogMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[userloginlog.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserLoginLogMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, userloginlog.FieldDeletedAt)
}

// SetCid sets the "cid" field.
func (m *UserLoginLogMutation) SetCid(s string) {
	m.cid = &s
}

// Cid returns the value of the "cid" field in the mutation.
func (m *UserLoginLogMutation) Cid() (r string, exists bool) {
	v := m.cid
	if v == nil {
		return
	}
	return *v, true
}

// OldCid returns the old "cid" field's value of the UserLoginLog entity.
// If the UserLoginLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginLogMutation) OldCid(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCid: %w", err)
	}
	return oldValue.Cid, nil
}

// ResetCid resets all changes to the "cid" field.
func (m *UserLoginLogMutation) ResetCid() {
	m.cid = nil
}

// SetPlatform sets the "platform" field.
func (m *UserLoginLogMutation) SetPlatform(s string) {
	m.platform = &s
}

// Platform returns the value of the "platform" field in the mutation.
func (m *UserLoginLogMutation) Platform() (r string, exists bool) {
	v := m.platform
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatform returns the old "platform" field's value of the UserLoginLog entity.
// If the UserLoginLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginLogMutation) OldPlatform(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPlatform is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatform: %w", err)
	}
	return oldValue.Platform, nil
}

// ResetPlatform resets all changes to the "platform" field.
func (m *UserLoginLogMutation) ResetPlatform() {
	m.platform = nil
}

// SetDevice sets the "device" field.
func (m *UserLoginLogMutation) SetDevice(s string) {
	m.device = &s
}

// Device returns the value of the "device" field in the mutation.
func (m *UserLoginLogMutation) Device() (r string, exists bool) {
	v := m.device
	if v == nil {
		return
	}
	return *v, true
}

// OldDevice returns the old "device" field's value of the UserLoginLog entity.
// If the UserLoginLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginLogMutation) OldDevice(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDevice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDevice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDevice: %w", err)
	}
	return oldValue.Device, nil
}

// ResetDevice resets all changes to the "device" field.
func (m *UserLoginLogMutation) ResetDevice() {
	m.device = nil
}

// SetVersion sets the "version" field.
func (m *UserLoginLogMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *UserLoginLogMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the UserLoginLog entity.
// If the UserLoginLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginLogMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *UserLoginLogMutation) ResetVersion() {
	m.version = nil
}

// SetIP sets the "ip" field.
func (m *UserLoginLogMutation) SetIP(s string) {
	m.ip = &s
}

// IP returns the value of the "ip" field in the mutation.
func (m *UserLoginLogMutation) IP() (r string, exists bool) {
	v := m.ip
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old "ip" field's value of the UserLoginLog entity.
// If the UserLoginLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginLogMutation) OldIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// ResetIP resets all changes to the "ip" field.
func (m *UserLoginLogMutation) ResetIP() {
	m.ip = nil
}

// SetProvince sets the "province" field.
func (m *UserLoginLogMutation) SetProvince(s string) {
	m.province = &s
}

// Province returns the value of the "province" field in the mutation.
func (m *UserLoginLogMutation) Province() (r string, exists bool) {
	v := m.province
	if v == nil {
		return
	}
	return *v, true
}

// OldProvince returns the old "province" field's value of the UserLoginLog entity.
// If the UserLoginLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginLogMutation) OldProvince(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProvince is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProvince requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvince: %w", err)
	}
	return oldValue.Province, nil
}

// ResetProvince resets all changes to the "province" field.
func (m *UserLoginLogMutation) ResetProvince() {
	m.province = nil
}

// SetCity sets the "city" field.
func (m *UserLoginLogMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *UserLoginLogMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the UserLoginLog entity.
// If the UserLoginLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginLogMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ResetCity resets all changes to the "city" field.
func (m *UserLoginLogMutation) ResetCity() {
	m.city = nil
}

// SetLatestLoginAt sets the "latest_login_at" field.
func (m *UserLoginLogMutation) SetLatestLoginAt(t time.Time) {
	m.latest_login_at = &t
}

// LatestLoginAt returns the value of the "latest_login_at" field in the mutation.
func (m *UserLoginLogMutation) LatestLoginAt() (r time.Time, exists bool) {
	v := m.latest_login_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLatestLoginAt returns the old "latest_login_at" field's value of the UserLoginLog entity.
// If the UserLoginLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginLogMutation) OldLatestLoginAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLatestLoginAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLatestLoginAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatestLoginAt: %w", err)
	}
	return oldValue.LatestLoginAt, nil
}

// ClearLatestLoginAt clears the value of the "latest_login_at" field.
func (m *UserLoginLogMutation) ClearLatestLoginAt() {
	m.latest_login_at = nil
	m.clearedFields[userloginlog.FieldLatestLoginAt] = struct{}{}
}

// LatestLoginAtCleared returns if the "latest_login_at" field was cleared in this mutation.
func (m *UserLoginLogMutation) LatestLoginAtCleared() bool {
	_, ok := m.clearedFields[userloginlog.FieldLatestLoginAt]
	return ok
}

// ResetLatestLoginAt resets all changes to the "latest_login_at" field.
func (m *UserLoginLogMutation) ResetLatestLoginAt() {
	m.latest_login_at = nil
	delete(m.clearedFields, userloginlog.FieldLatestLoginAt)
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *UserLoginLogMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserLoginLogMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserLoginLogMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *UserLoginLogMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserLoginLogMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserLoginLogMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Op returns the operation name.
func (m *UserLoginLogMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (UserLoginLog).
func (m *UserLoginLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserLoginLogMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.uuid != nil {
		fields = append(fields, userloginlog.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, userloginlog.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, userloginlog.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, userloginlog.FieldDeletedAt)
	}
	if m.cid != nil {
		fields = append(fields, userloginlog.FieldCid)
	}
	if m.platform != nil {
		fields = append(fields, userloginlog.FieldPlatform)
	}
	if m.device != nil {
		fields = append(fields, userloginlog.FieldDevice)
	}
	if m.version != nil {
		fields = append(fields, userloginlog.FieldVersion)
	}
	if m.ip != nil {
		fields = append(fields, userloginlog.FieldIP)
	}
	if m.province != nil {
		fields = append(fields, userloginlog.FieldProvince)
	}
	if m.city != nil {
		fields = append(fields, userloginlog.FieldCity)
	}
	if m.latest_login_at != nil {
		fields = append(fields, userloginlog.FieldLatestLoginAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserLoginLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userloginlog.FieldUUID:
		return m.UUID()
	case userloginlog.FieldCreatedAt:
		return m.CreatedAt()
	case userloginlog.FieldUpdatedAt:
		return m.UpdatedAt()
	case userloginlog.FieldDeletedAt:
		return m.DeletedAt()
	case userloginlog.FieldCid:
		return m.Cid()
	case userloginlog.FieldPlatform:
		return m.Platform()
	case userloginlog.FieldDevice:
		return m.Device()
	case userloginlog.FieldVersion:
		return m.Version()
	case userloginlog.FieldIP:
		return m.IP()
	case userloginlog.FieldProvince:
		return m.Province()
	case userloginlog.FieldCity:
		return m.City()
	case userloginlog.FieldLatestLoginAt:
		return m.LatestLoginAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserLoginLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userloginlog.FieldUUID:
		return m.OldUUID(ctx)
	case userloginlog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userloginlog.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userloginlog.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case userloginlog.FieldCid:
		return m.OldCid(ctx)
	case userloginlog.FieldPlatform:
		return m.OldPlatform(ctx)
	case userloginlog.FieldDevice:
		return m.OldDevice(ctx)
	case userloginlog.FieldVersion:
		return m.OldVersion(ctx)
	case userloginlog.FieldIP:
		return m.OldIP(ctx)
	case userloginlog.FieldProvince:
		return m.OldProvince(ctx)
	case userloginlog.FieldCity:
		return m.OldCity(ctx)
	case userloginlog.FieldLatestLoginAt:
		return m.OldLatestLoginAt(ctx)
	}
	return nil, fmt.Errorf("unknown UserLoginLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserLoginLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userloginlog.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case userloginlog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userloginlog.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userloginlog.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case userloginlog.FieldCid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCid(v)
		return nil
	case userloginlog.FieldPlatform:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatform(v)
		return nil
	case userloginlog.FieldDevice:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDevice(v)
		return nil
	case userloginlog.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case userloginlog.FieldIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	case userloginlog.FieldProvince:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvince(v)
		return nil
	case userloginlog.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case userloginlog.FieldLatestLoginAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatestLoginAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserLoginLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserLoginLogMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserLoginLogMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserLoginLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserLoginLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserLoginLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userloginlog.FieldCreatedAt) {
		fields = append(fields, userloginlog.FieldCreatedAt)
	}
	if m.FieldCleared(userloginlog.FieldUpdatedAt) {
		fields = append(fields, userloginlog.FieldUpdatedAt)
	}
	if m.FieldCleared(userloginlog.FieldDeletedAt) {
		fields = append(fields, userloginlog.FieldDeletedAt)
	}
	if m.FieldCleared(userloginlog.FieldLatestLoginAt) {
		fields = append(fields, userloginlog.FieldLatestLoginAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserLoginLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserLoginLogMutation) ClearField(name string) error {
	switch name {
	case userloginlog.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case userloginlog.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case userloginlog.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case userloginlog.FieldLatestLoginAt:
		m.ClearLatestLoginAt()
		return nil
	}
	return fmt.Errorf("unknown UserLoginLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserLoginLogMutation) ResetField(name string) error {
	switch name {
	case userloginlog.FieldUUID:
		m.ResetUUID()
		return nil
	case userloginlog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userloginlog.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userloginlog.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case userloginlog.FieldCid:
		m.ResetCid()
		return nil
	case userloginlog.FieldPlatform:
		m.ResetPlatform()
		return nil
	case userloginlog.FieldDevice:
		m.ResetDevice()
		return nil
	case userloginlog.FieldVersion:
		m.ResetVersion()
		return nil
	case userloginlog.FieldIP:
		m.ResetIP()
		return nil
	case userloginlog.FieldProvince:
		m.ResetProvince()
		return nil
	case userloginlog.FieldCity:
		m.ResetCity()
		return nil
	case userloginlog.FieldLatestLoginAt:
		m.ResetLatestLoginAt()
		return nil
	}
	return fmt.Errorf("unknown UserLoginLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserLoginLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, userloginlog.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserLoginLogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userloginlog.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserLoginLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserLoginLogMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserLoginLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, userloginlog.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserLoginLogMutation) EdgeCleared(name string) bool {
	switch name {
	case userloginlog.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserLoginLogMutation) ClearEdge(name string) error {
	switch name {
	case userloginlog.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserLoginLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserLoginLogMutation) ResetEdge(name string) error {
	switch name {
	case userloginlog.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserLoginLog edge %s", name)
}

// VideoRecordMutation represents an operation that mutates the VideoRecord nodes in the graph.
type VideoRecordMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	uuid                *string
	created_at          *time.Time
	updated_at          *time.Time
	deleted_at          *time.Time
	video_name          *string
	view_time           *uint8
	addview_time        *uint8
	video_time          *int
	addvideo_time       *int
	view_at             *time.Time
	clearedFields       map[string]struct{}
	user                *int
	cleareduser         bool
	small_course        *int
	clearedsmall_course bool
	done                bool
	oldValue            func(context.Context) (*VideoRecord, error)
	predicates          []predicate.VideoRecord
}

var _ ent.Mutation = (*VideoRecordMutation)(nil)

// videorecordOption allows management of the mutation configuration using functional options.
type videorecordOption func(*VideoRecordMutation)

// newVideoRecordMutation creates new mutation for the VideoRecord entity.
func newVideoRecordMutation(c config, op Op, opts ...videorecordOption) *VideoRecordMutation {
	m := &VideoRecordMutation{
		config:        c,
		op:            op,
		typ:           TypeVideoRecord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVideoRecordID sets the ID field of the mutation.
func withVideoRecordID(id int) videorecordOption {
	return func(m *VideoRecordMutation) {
		var (
			err   error
			once  sync.Once
			value *VideoRecord
		)
		m.oldValue = func(ctx context.Context) (*VideoRecord, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VideoRecord.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVideoRecord sets the old VideoRecord of the mutation.
func withVideoRecord(node *VideoRecord) videorecordOption {
	return func(m *VideoRecordMutation) {
		m.oldValue = func(context.Context) (*VideoRecord, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VideoRecordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VideoRecordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *VideoRecordMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *VideoRecordMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *VideoRecordMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the VideoRecord entity.
// If the VideoRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoRecordMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *VideoRecordMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *VideoRecordMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VideoRecordMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the VideoRecord entity.
// If the VideoRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoRecordMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *VideoRecordMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[videorecord.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *VideoRecordMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[videorecord.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VideoRecordMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, videorecord.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VideoRecordMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VideoRecordMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the VideoRecord entity.
// If the VideoRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoRecordMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *VideoRecordMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[videorecord.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *VideoRecordMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[videorecord.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VideoRecordMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, videorecord.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *VideoRecordMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *VideoRecordMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the VideoRecord entity.
// If the VideoRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoRecordMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *VideoRecordMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[videorecord.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *VideoRecordMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[videorecord.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *VideoRecordMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, videorecord.FieldDeletedAt)
}

// SetVideoName sets the "video_name" field.
func (m *VideoRecordMutation) SetVideoName(s string) {
	m.video_name = &s
}

// VideoName returns the value of the "video_name" field in the mutation.
func (m *VideoRecordMutation) VideoName() (r string, exists bool) {
	v := m.video_name
	if v == nil {
		return
	}
	return *v, true
}

// OldVideoName returns the old "video_name" field's value of the VideoRecord entity.
// If the VideoRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoRecordMutation) OldVideoName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVideoName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVideoName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVideoName: %w", err)
	}
	return oldValue.VideoName, nil
}

// ResetVideoName resets all changes to the "video_name" field.
func (m *VideoRecordMutation) ResetVideoName() {
	m.video_name = nil
}

// SetViewTime sets the "view_time" field.
func (m *VideoRecordMutation) SetViewTime(u uint8) {
	m.view_time = &u
	m.addview_time = nil
}

// ViewTime returns the value of the "view_time" field in the mutation.
func (m *VideoRecordMutation) ViewTime() (r uint8, exists bool) {
	v := m.view_time
	if v == nil {
		return
	}
	return *v, true
}

// OldViewTime returns the old "view_time" field's value of the VideoRecord entity.
// If the VideoRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoRecordMutation) OldViewTime(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldViewTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldViewTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldViewTime: %w", err)
	}
	return oldValue.ViewTime, nil
}

// AddViewTime adds u to the "view_time" field.
func (m *VideoRecordMutation) AddViewTime(u uint8) {
	if m.addview_time != nil {
		*m.addview_time += u
	} else {
		m.addview_time = &u
	}
}

// AddedViewTime returns the value that was added to the "view_time" field in this mutation.
func (m *VideoRecordMutation) AddedViewTime() (r uint8, exists bool) {
	v := m.addview_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearViewTime clears the value of the "view_time" field.
func (m *VideoRecordMutation) ClearViewTime() {
	m.view_time = nil
	m.addview_time = nil
	m.clearedFields[videorecord.FieldViewTime] = struct{}{}
}

// ViewTimeCleared returns if the "view_time" field was cleared in this mutation.
func (m *VideoRecordMutation) ViewTimeCleared() bool {
	_, ok := m.clearedFields[videorecord.FieldViewTime]
	return ok
}

// ResetViewTime resets all changes to the "view_time" field.
func (m *VideoRecordMutation) ResetViewTime() {
	m.view_time = nil
	m.addview_time = nil
	delete(m.clearedFields, videorecord.FieldViewTime)
}

// SetUserID sets the "user_id" field.
func (m *VideoRecordMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *VideoRecordMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the VideoRecord entity.
// If the VideoRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoRecordMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *VideoRecordMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[videorecord.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *VideoRecordMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[videorecord.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *VideoRecordMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, videorecord.FieldUserID)
}

// SetSmallID sets the "small_id" field.
func (m *VideoRecordMutation) SetSmallID(i int) {
	m.small_course = &i
}

// SmallID returns the value of the "small_id" field in the mutation.
func (m *VideoRecordMutation) SmallID() (r int, exists bool) {
	v := m.small_course
	if v == nil {
		return
	}
	return *v, true
}

// OldSmallID returns the old "small_id" field's value of the VideoRecord entity.
// If the VideoRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoRecordMutation) OldSmallID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSmallID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSmallID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSmallID: %w", err)
	}
	return oldValue.SmallID, nil
}

// ClearSmallID clears the value of the "small_id" field.
func (m *VideoRecordMutation) ClearSmallID() {
	m.small_course = nil
	m.clearedFields[videorecord.FieldSmallID] = struct{}{}
}

// SmallIDCleared returns if the "small_id" field was cleared in this mutation.
func (m *VideoRecordMutation) SmallIDCleared() bool {
	_, ok := m.clearedFields[videorecord.FieldSmallID]
	return ok
}

// ResetSmallID resets all changes to the "small_id" field.
func (m *VideoRecordMutation) ResetSmallID() {
	m.small_course = nil
	delete(m.clearedFields, videorecord.FieldSmallID)
}

// SetVideoTime sets the "video_time" field.
func (m *VideoRecordMutation) SetVideoTime(i int) {
	m.video_time = &i
	m.addvideo_time = nil
}

// VideoTime returns the value of the "video_time" field in the mutation.
func (m *VideoRecordMutation) VideoTime() (r int, exists bool) {
	v := m.video_time
	if v == nil {
		return
	}
	return *v, true
}

// OldVideoTime returns the old "video_time" field's value of the VideoRecord entity.
// If the VideoRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoRecordMutation) OldVideoTime(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVideoTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVideoTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVideoTime: %w", err)
	}
	return oldValue.VideoTime, nil
}

// AddVideoTime adds i to the "video_time" field.
func (m *VideoRecordMutation) AddVideoTime(i int) {
	if m.addvideo_time != nil {
		*m.addvideo_time += i
	} else {
		m.addvideo_time = &i
	}
}

// AddedVideoTime returns the value that was added to the "video_time" field in this mutation.
func (m *VideoRecordMutation) AddedVideoTime() (r int, exists bool) {
	v := m.addvideo_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearVideoTime clears the value of the "video_time" field.
func (m *VideoRecordMutation) ClearVideoTime() {
	m.video_time = nil
	m.addvideo_time = nil
	m.clearedFields[videorecord.FieldVideoTime] = struct{}{}
}

// VideoTimeCleared returns if the "video_time" field was cleared in this mutation.
func (m *VideoRecordMutation) VideoTimeCleared() bool {
	_, ok := m.clearedFields[videorecord.FieldVideoTime]
	return ok
}

// ResetVideoTime resets all changes to the "video_time" field.
func (m *VideoRecordMutation) ResetVideoTime() {
	m.video_time = nil
	m.addvideo_time = nil
	delete(m.clearedFields, videorecord.FieldVideoTime)
}

// SetViewAt sets the "view_at" field.
func (m *VideoRecordMutation) SetViewAt(t time.Time) {
	m.view_at = &t
}

// ViewAt returns the value of the "view_at" field in the mutation.
func (m *VideoRecordMutation) ViewAt() (r time.Time, exists bool) {
	v := m.view_at
	if v == nil {
		return
	}
	return *v, true
}

// OldViewAt returns the old "view_at" field's value of the VideoRecord entity.
// If the VideoRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoRecordMutation) OldViewAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldViewAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldViewAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldViewAt: %w", err)
	}
	return oldValue.ViewAt, nil
}

// ClearViewAt clears the value of the "view_at" field.
func (m *VideoRecordMutation) ClearViewAt() {
	m.view_at = nil
	m.clearedFields[videorecord.FieldViewAt] = struct{}{}
}

// ViewAtCleared returns if the "view_at" field was cleared in this mutation.
func (m *VideoRecordMutation) ViewAtCleared() bool {
	_, ok := m.clearedFields[videorecord.FieldViewAt]
	return ok
}

// ResetViewAt resets all changes to the "view_at" field.
func (m *VideoRecordMutation) ResetViewAt() {
	m.view_at = nil
	delete(m.clearedFields, videorecord.FieldViewAt)
}

// ClearUser clears the "user" edge to the User entity.
func (m *VideoRecordMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *VideoRecordMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *VideoRecordMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *VideoRecordMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetSmallCourseID sets the "small_course" edge to the KcCourseSmallCategory entity by id.
func (m *VideoRecordMutation) SetSmallCourseID(id int) {
	m.small_course = &id
}

// ClearSmallCourse clears the "small_course" edge to the KcCourseSmallCategory entity.
func (m *VideoRecordMutation) ClearSmallCourse() {
	m.clearedsmall_course = true
}

// SmallCourseCleared reports if the "small_course" edge to the KcCourseSmallCategory entity was cleared.
func (m *VideoRecordMutation) SmallCourseCleared() bool {
	return m.SmallIDCleared() || m.clearedsmall_course
}

// SmallCourseID returns the "small_course" edge ID in the mutation.
func (m *VideoRecordMutation) SmallCourseID() (id int, exists bool) {
	if m.small_course != nil {
		return *m.small_course, true
	}
	return
}

// SmallCourseIDs returns the "small_course" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SmallCourseID instead. It exists only for internal usage by the builders.
func (m *VideoRecordMutation) SmallCourseIDs() (ids []int) {
	if id := m.small_course; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSmallCourse resets all changes to the "small_course" edge.
func (m *VideoRecordMutation) ResetSmallCourse() {
	m.small_course = nil
	m.clearedsmall_course = false
}

// Op returns the operation name.
func (m *VideoRecordMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (VideoRecord).
func (m *VideoRecordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VideoRecordMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.uuid != nil {
		fields = append(fields, videorecord.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, videorecord.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, videorecord.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, videorecord.FieldDeletedAt)
	}
	if m.video_name != nil {
		fields = append(fields, videorecord.FieldVideoName)
	}
	if m.view_time != nil {
		fields = append(fields, videorecord.FieldViewTime)
	}
	if m.user != nil {
		fields = append(fields, videorecord.FieldUserID)
	}
	if m.small_course != nil {
		fields = append(fields, videorecord.FieldSmallID)
	}
	if m.video_time != nil {
		fields = append(fields, videorecord.FieldVideoTime)
	}
	if m.view_at != nil {
		fields = append(fields, videorecord.FieldViewAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VideoRecordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case videorecord.FieldUUID:
		return m.UUID()
	case videorecord.FieldCreatedAt:
		return m.CreatedAt()
	case videorecord.FieldUpdatedAt:
		return m.UpdatedAt()
	case videorecord.FieldDeletedAt:
		return m.DeletedAt()
	case videorecord.FieldVideoName:
		return m.VideoName()
	case videorecord.FieldViewTime:
		return m.ViewTime()
	case videorecord.FieldUserID:
		return m.UserID()
	case videorecord.FieldSmallID:
		return m.SmallID()
	case videorecord.FieldVideoTime:
		return m.VideoTime()
	case videorecord.FieldViewAt:
		return m.ViewAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VideoRecordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case videorecord.FieldUUID:
		return m.OldUUID(ctx)
	case videorecord.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case videorecord.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case videorecord.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case videorecord.FieldVideoName:
		return m.OldVideoName(ctx)
	case videorecord.FieldViewTime:
		return m.OldViewTime(ctx)
	case videorecord.FieldUserID:
		return m.OldUserID(ctx)
	case videorecord.FieldSmallID:
		return m.OldSmallID(ctx)
	case videorecord.FieldVideoTime:
		return m.OldVideoTime(ctx)
	case videorecord.FieldViewAt:
		return m.OldViewAt(ctx)
	}
	return nil, fmt.Errorf("unknown VideoRecord field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VideoRecordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case videorecord.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case videorecord.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case videorecord.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case videorecord.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case videorecord.FieldVideoName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVideoName(v)
		return nil
	case videorecord.FieldViewTime:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetViewTime(v)
		return nil
	case videorecord.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case videorecord.FieldSmallID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSmallID(v)
		return nil
	case videorecord.FieldVideoTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVideoTime(v)
		return nil
	case videorecord.FieldViewAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetViewAt(v)
		return nil
	}
	return fmt.Errorf("unknown VideoRecord field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VideoRecordMutation) AddedFields() []string {
	var fields []string
	if m.addview_time != nil {
		fields = append(fields, videorecord.FieldViewTime)
	}
	if m.addvideo_time != nil {
		fields = append(fields, videorecord.FieldVideoTime)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VideoRecordMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case videorecord.FieldViewTime:
		return m.AddedViewTime()
	case videorecord.FieldVideoTime:
		return m.AddedVideoTime()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VideoRecordMutation) AddField(name string, value ent.Value) error {
	switch name {
	case videorecord.FieldViewTime:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddViewTime(v)
		return nil
	case videorecord.FieldVideoTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVideoTime(v)
		return nil
	}
	return fmt.Errorf("unknown VideoRecord numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VideoRecordMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(videorecord.FieldCreatedAt) {
		fields = append(fields, videorecord.FieldCreatedAt)
	}
	if m.FieldCleared(videorecord.FieldUpdatedAt) {
		fields = append(fields, videorecord.FieldUpdatedAt)
	}
	if m.FieldCleared(videorecord.FieldDeletedAt) {
		fields = append(fields, videorecord.FieldDeletedAt)
	}
	if m.FieldCleared(videorecord.FieldViewTime) {
		fields = append(fields, videorecord.FieldViewTime)
	}
	if m.FieldCleared(videorecord.FieldUserID) {
		fields = append(fields, videorecord.FieldUserID)
	}
	if m.FieldCleared(videorecord.FieldSmallID) {
		fields = append(fields, videorecord.FieldSmallID)
	}
	if m.FieldCleared(videorecord.FieldVideoTime) {
		fields = append(fields, videorecord.FieldVideoTime)
	}
	if m.FieldCleared(videorecord.FieldViewAt) {
		fields = append(fields, videorecord.FieldViewAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VideoRecordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VideoRecordMutation) ClearField(name string) error {
	switch name {
	case videorecord.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case videorecord.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case videorecord.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case videorecord.FieldViewTime:
		m.ClearViewTime()
		return nil
	case videorecord.FieldUserID:
		m.ClearUserID()
		return nil
	case videorecord.FieldSmallID:
		m.ClearSmallID()
		return nil
	case videorecord.FieldVideoTime:
		m.ClearVideoTime()
		return nil
	case videorecord.FieldViewAt:
		m.ClearViewAt()
		return nil
	}
	return fmt.Errorf("unknown VideoRecord nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VideoRecordMutation) ResetField(name string) error {
	switch name {
	case videorecord.FieldUUID:
		m.ResetUUID()
		return nil
	case videorecord.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case videorecord.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case videorecord.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case videorecord.FieldVideoName:
		m.ResetVideoName()
		return nil
	case videorecord.FieldViewTime:
		m.ResetViewTime()
		return nil
	case videorecord.FieldUserID:
		m.ResetUserID()
		return nil
	case videorecord.FieldSmallID:
		m.ResetSmallID()
		return nil
	case videorecord.FieldVideoTime:
		m.ResetVideoTime()
		return nil
	case videorecord.FieldViewAt:
		m.ResetViewAt()
		return nil
	}
	return fmt.Errorf("unknown VideoRecord field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VideoRecordMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, videorecord.EdgeUser)
	}
	if m.small_course != nil {
		edges = append(edges, videorecord.EdgeSmallCourse)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VideoRecordMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case videorecord.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case videorecord.EdgeSmallCourse:
		if id := m.small_course; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VideoRecordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VideoRecordMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VideoRecordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, videorecord.EdgeUser)
	}
	if m.clearedsmall_course {
		edges = append(edges, videorecord.EdgeSmallCourse)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VideoRecordMutation) EdgeCleared(name string) bool {
	switch name {
	case videorecord.EdgeUser:
		return m.cleareduser
	case videorecord.EdgeSmallCourse:
		return m.clearedsmall_course
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VideoRecordMutation) ClearEdge(name string) error {
	switch name {
	case videorecord.EdgeUser:
		m.ClearUser()
		return nil
	case videorecord.EdgeSmallCourse:
		m.ClearSmallCourse()
		return nil
	}
	return fmt.Errorf("unknown VideoRecord unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VideoRecordMutation) ResetEdge(name string) error {
	switch name {
	case videorecord.EdgeUser:
		m.ResetUser()
		return nil
	case videorecord.EdgeSmallCourse:
		m.ResetSmallCourse()
		return nil
	}
	return fmt.Errorf("unknown VideoRecord edge %s", name)
}
