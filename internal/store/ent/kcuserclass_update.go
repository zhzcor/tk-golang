// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"gserver/internal/store/ent/kcclass"
	"gserver/internal/store/ent/kcuserclass"
	"gserver/internal/store/ent/predicate"
	"gserver/internal/store/ent/user"
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
)

// KcUserClassUpdate is the builder for updating KcUserClass entities.
type KcUserClassUpdate struct {
	config
	hooks    []Hook
	mutation *KcUserClassMutation
}

// Where adds a new predicate for the KcUserClassUpdate builder.
func (kucu *KcUserClassUpdate) Where(ps ...predicate.KcUserClass) *KcUserClassUpdate {
	kucu.mutation.predicates = append(kucu.mutation.predicates, ps...)
	return kucu
}

// SetUUID sets the "uuid" field.
func (kucu *KcUserClassUpdate) SetUUID(s string) *KcUserClassUpdate {
	kucu.mutation.SetUUID(s)
	return kucu
}

// SetUpdatedAt sets the "updated_at" field.
func (kucu *KcUserClassUpdate) SetUpdatedAt(t time.Time) *KcUserClassUpdate {
	kucu.mutation.SetUpdatedAt(t)
	return kucu
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (kucu *KcUserClassUpdate) ClearUpdatedAt() *KcUserClassUpdate {
	kucu.mutation.ClearUpdatedAt()
	return kucu
}

// SetDeletedAt sets the "deleted_at" field.
func (kucu *KcUserClassUpdate) SetDeletedAt(t time.Time) *KcUserClassUpdate {
	kucu.mutation.SetDeletedAt(t)
	return kucu
}

// SetNillableDeletedAt sets the "deleted_at" field if the given value is not nil.
func (kucu *KcUserClassUpdate) SetNillableDeletedAt(t *time.Time) *KcUserClassUpdate {
	if t != nil {
		kucu.SetDeletedAt(*t)
	}
	return kucu
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (kucu *KcUserClassUpdate) ClearDeletedAt() *KcUserClassUpdate {
	kucu.mutation.ClearDeletedAt()
	return kucu
}

// SetPeriodType sets the "period_type" field.
func (kucu *KcUserClassUpdate) SetPeriodType(u uint8) *KcUserClassUpdate {
	kucu.mutation.ResetPeriodType()
	kucu.mutation.SetPeriodType(u)
	return kucu
}

// SetNillablePeriodType sets the "period_type" field if the given value is not nil.
func (kucu *KcUserClassUpdate) SetNillablePeriodType(u *uint8) *KcUserClassUpdate {
	if u != nil {
		kucu.SetPeriodType(*u)
	}
	return kucu
}

// AddPeriodType adds u to the "period_type" field.
func (kucu *KcUserClassUpdate) AddPeriodType(u uint8) *KcUserClassUpdate {
	kucu.mutation.AddPeriodType(u)
	return kucu
}

// SetClosingDate sets the "closing_date" field.
func (kucu *KcUserClassUpdate) SetClosingDate(t time.Time) *KcUserClassUpdate {
	kucu.mutation.SetClosingDate(t)
	return kucu
}

// SetNillableClosingDate sets the "closing_date" field if the given value is not nil.
func (kucu *KcUserClassUpdate) SetNillableClosingDate(t *time.Time) *KcUserClassUpdate {
	if t != nil {
		kucu.SetClosingDate(*t)
	}
	return kucu
}

// ClearClosingDate clears the value of the "closing_date" field.
func (kucu *KcUserClassUpdate) ClearClosingDate() *KcUserClassUpdate {
	kucu.mutation.ClearClosingDate()
	return kucu
}

// SetStudyRate sets the "study_rate" field.
func (kucu *KcUserClassUpdate) SetStudyRate(f float64) *KcUserClassUpdate {
	kucu.mutation.ResetStudyRate()
	kucu.mutation.SetStudyRate(f)
	return kucu
}

// SetNillableStudyRate sets the "study_rate" field if the given value is not nil.
func (kucu *KcUserClassUpdate) SetNillableStudyRate(f *float64) *KcUserClassUpdate {
	if f != nil {
		kucu.SetStudyRate(*f)
	}
	return kucu
}

// AddStudyRate adds f to the "study_rate" field.
func (kucu *KcUserClassUpdate) AddStudyRate(f float64) *KcUserClassUpdate {
	kucu.mutation.AddStudyRate(f)
	return kucu
}

// SetRemark sets the "remark" field.
func (kucu *KcUserClassUpdate) SetRemark(s string) *KcUserClassUpdate {
	kucu.mutation.SetRemark(s)
	return kucu
}

// SetNillableRemark sets the "remark" field if the given value is not nil.
func (kucu *KcUserClassUpdate) SetNillableRemark(s *string) *KcUserClassUpdate {
	if s != nil {
		kucu.SetRemark(*s)
	}
	return kucu
}

// SetPrice sets the "price" field.
func (kucu *KcUserClassUpdate) SetPrice(f float64) *KcUserClassUpdate {
	kucu.mutation.ResetPrice()
	kucu.mutation.SetPrice(f)
	return kucu
}

// SetNillablePrice sets the "price" field if the given value is not nil.
func (kucu *KcUserClassUpdate) SetNillablePrice(f *float64) *KcUserClassUpdate {
	if f != nil {
		kucu.SetPrice(*f)
	}
	return kucu
}

// AddPrice adds f to the "price" field.
func (kucu *KcUserClassUpdate) AddPrice(f float64) *KcUserClassUpdate {
	kucu.mutation.AddPrice(f)
	return kucu
}

// SetUserID sets the "user_id" field.
func (kucu *KcUserClassUpdate) SetUserID(i int) *KcUserClassUpdate {
	kucu.mutation.ResetUserID()
	kucu.mutation.SetUserID(i)
	return kucu
}

// SetNillableUserID sets the "user_id" field if the given value is not nil.
func (kucu *KcUserClassUpdate) SetNillableUserID(i *int) *KcUserClassUpdate {
	if i != nil {
		kucu.SetUserID(*i)
	}
	return kucu
}

// ClearUserID clears the value of the "user_id" field.
func (kucu *KcUserClassUpdate) ClearUserID() *KcUserClassUpdate {
	kucu.mutation.ClearUserID()
	return kucu
}

// SetClassID sets the "class_id" field.
func (kucu *KcUserClassUpdate) SetClassID(i int) *KcUserClassUpdate {
	kucu.mutation.ResetClassID()
	kucu.mutation.SetClassID(i)
	return kucu
}

// SetNillableClassID sets the "class_id" field if the given value is not nil.
func (kucu *KcUserClassUpdate) SetNillableClassID(i *int) *KcUserClassUpdate {
	if i != nil {
		kucu.SetClassID(*i)
	}
	return kucu
}

// ClearClassID clears the value of the "class_id" field.
func (kucu *KcUserClassUpdate) ClearClassID() *KcUserClassUpdate {
	kucu.mutation.ClearClassID()
	return kucu
}

// SetUser sets the "user" edge to the User entity.
func (kucu *KcUserClassUpdate) SetUser(u *User) *KcUserClassUpdate {
	return kucu.SetUserID(u.ID)
}

// SetClass sets the "class" edge to the KcClass entity.
func (kucu *KcUserClassUpdate) SetClass(k *KcClass) *KcUserClassUpdate {
	return kucu.SetClassID(k.ID)
}

// Mutation returns the KcUserClassMutation object of the builder.
func (kucu *KcUserClassUpdate) Mutation() *KcUserClassMutation {
	return kucu.mutation
}

// ClearUser clears the "user" edge to the User entity.
func (kucu *KcUserClassUpdate) ClearUser() *KcUserClassUpdate {
	kucu.mutation.ClearUser()
	return kucu
}

// ClearClass clears the "class" edge to the KcClass entity.
func (kucu *KcUserClassUpdate) ClearClass() *KcUserClassUpdate {
	kucu.mutation.ClearClass()
	return kucu
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (kucu *KcUserClassUpdate) Save(ctx context.Context) (int, error) {
	var (
		err      error
		affected int
	)
	kucu.defaults()
	if len(kucu.hooks) == 0 {
		affected, err = kucu.sqlSave(ctx)
	} else {
		var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
			mutation, ok := m.(*KcUserClassMutation)
			if !ok {
				return nil, fmt.Errorf("unexpected mutation type %T", m)
			}
			kucu.mutation = mutation
			affected, err = kucu.sqlSave(ctx)
			mutation.done = true
			return affected, err
		})
		for i := len(kucu.hooks) - 1; i >= 0; i-- {
			mut = kucu.hooks[i](mut)
		}
		if _, err := mut.Mutate(ctx, kucu.mutation); err != nil {
			return 0, err
		}
	}
	return affected, err
}

// SaveX is like Save, but panics if an error occurs.
func (kucu *KcUserClassUpdate) SaveX(ctx context.Context) int {
	affected, err := kucu.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (kucu *KcUserClassUpdate) Exec(ctx context.Context) error {
	_, err := kucu.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (kucu *KcUserClassUpdate) ExecX(ctx context.Context) {
	if err := kucu.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (kucu *KcUserClassUpdate) defaults() {
	if _, ok := kucu.mutation.UpdatedAt(); !ok && !kucu.mutation.UpdatedAtCleared() {
		v := kcuserclass.UpdateDefaultUpdatedAt()
		kucu.mutation.SetUpdatedAt(v)
	}
}

func (kucu *KcUserClassUpdate) sqlSave(ctx context.Context) (n int, err error) {
	_spec := &sqlgraph.UpdateSpec{
		Node: &sqlgraph.NodeSpec{
			Table:   kcuserclass.Table,
			Columns: kcuserclass.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeInt,
				Column: kcuserclass.FieldID,
			},
		},
	}
	if ps := kucu.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := kucu.mutation.UUID(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: kcuserclass.FieldUUID,
		})
	}
	if kucu.mutation.CreatedAtCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Column: kcuserclass.FieldCreatedAt,
		})
	}
	if value, ok := kucu.mutation.UpdatedAt(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: kcuserclass.FieldUpdatedAt,
		})
	}
	if kucu.mutation.UpdatedAtCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Column: kcuserclass.FieldUpdatedAt,
		})
	}
	if value, ok := kucu.mutation.DeletedAt(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: kcuserclass.FieldDeletedAt,
		})
	}
	if kucu.mutation.DeletedAtCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Column: kcuserclass.FieldDeletedAt,
		})
	}
	if value, ok := kucu.mutation.PeriodType(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeUint8,
			Value:  value,
			Column: kcuserclass.FieldPeriodType,
		})
	}
	if value, ok := kucu.mutation.AddedPeriodType(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeUint8,
			Value:  value,
			Column: kcuserclass.FieldPeriodType,
		})
	}
	if value, ok := kucu.mutation.ClosingDate(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: kcuserclass.FieldClosingDate,
		})
	}
	if kucu.mutation.ClosingDateCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Column: kcuserclass.FieldClosingDate,
		})
	}
	if value, ok := kucu.mutation.StudyRate(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeFloat64,
			Value:  value,
			Column: kcuserclass.FieldStudyRate,
		})
	}
	if value, ok := kucu.mutation.AddedStudyRate(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeFloat64,
			Value:  value,
			Column: kcuserclass.FieldStudyRate,
		})
	}
	if value, ok := kucu.mutation.Remark(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: kcuserclass.FieldRemark,
		})
	}
	if value, ok := kucu.mutation.Price(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeFloat64,
			Value:  value,
			Column: kcuserclass.FieldPrice,
		})
	}
	if value, ok := kucu.mutation.AddedPrice(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeFloat64,
			Value:  value,
			Column: kcuserclass.FieldPrice,
		})
	}
	if kucu.mutation.UserCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   kcuserclass.UserTable,
			Columns: []string{kcuserclass.UserColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: user.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := kucu.mutation.UserIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   kcuserclass.UserTable,
			Columns: []string{kcuserclass.UserColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: user.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if kucu.mutation.ClassCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   kcuserclass.ClassTable,
			Columns: []string{kcuserclass.ClassColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: kcclass.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := kucu.mutation.ClassIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   kcuserclass.ClassTable,
			Columns: []string{kcuserclass.ClassColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: kcclass.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if n, err = sqlgraph.UpdateNodes(ctx, kucu.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{kcuserclass.Label}
		} else if cerr, ok := isSQLConstraintError(err); ok {
			err = cerr
		}
		return 0, err
	}
	return n, nil
}

// KcUserClassUpdateOne is the builder for updating a single KcUserClass entity.
type KcUserClassUpdateOne struct {
	config
	fields   []string
	hooks    []Hook
	mutation *KcUserClassMutation
}

// SetUUID sets the "uuid" field.
func (kucuo *KcUserClassUpdateOne) SetUUID(s string) *KcUserClassUpdateOne {
	kucuo.mutation.SetUUID(s)
	return kucuo
}

// SetUpdatedAt sets the "updated_at" field.
func (kucuo *KcUserClassUpdateOne) SetUpdatedAt(t time.Time) *KcUserClassUpdateOne {
	kucuo.mutation.SetUpdatedAt(t)
	return kucuo
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (kucuo *KcUserClassUpdateOne) ClearUpdatedAt() *KcUserClassUpdateOne {
	kucuo.mutation.ClearUpdatedAt()
	return kucuo
}

// SetDeletedAt sets the "deleted_at" field.
func (kucuo *KcUserClassUpdateOne) SetDeletedAt(t time.Time) *KcUserClassUpdateOne {
	kucuo.mutation.SetDeletedAt(t)
	return kucuo
}

// SetNillableDeletedAt sets the "deleted_at" field if the given value is not nil.
func (kucuo *KcUserClassUpdateOne) SetNillableDeletedAt(t *time.Time) *KcUserClassUpdateOne {
	if t != nil {
		kucuo.SetDeletedAt(*t)
	}
	return kucuo
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (kucuo *KcUserClassUpdateOne) ClearDeletedAt() *KcUserClassUpdateOne {
	kucuo.mutation.ClearDeletedAt()
	return kucuo
}

// SetPeriodType sets the "period_type" field.
func (kucuo *KcUserClassUpdateOne) SetPeriodType(u uint8) *KcUserClassUpdateOne {
	kucuo.mutation.ResetPeriodType()
	kucuo.mutation.SetPeriodType(u)
	return kucuo
}

// SetNillablePeriodType sets the "period_type" field if the given value is not nil.
func (kucuo *KcUserClassUpdateOne) SetNillablePeriodType(u *uint8) *KcUserClassUpdateOne {
	if u != nil {
		kucuo.SetPeriodType(*u)
	}
	return kucuo
}

// AddPeriodType adds u to the "period_type" field.
func (kucuo *KcUserClassUpdateOne) AddPeriodType(u uint8) *KcUserClassUpdateOne {
	kucuo.mutation.AddPeriodType(u)
	return kucuo
}

// SetClosingDate sets the "closing_date" field.
func (kucuo *KcUserClassUpdateOne) SetClosingDate(t time.Time) *KcUserClassUpdateOne {
	kucuo.mutation.SetClosingDate(t)
	return kucuo
}

// SetNillableClosingDate sets the "closing_date" field if the given value is not nil.
func (kucuo *KcUserClassUpdateOne) SetNillableClosingDate(t *time.Time) *KcUserClassUpdateOne {
	if t != nil {
		kucuo.SetClosingDate(*t)
	}
	return kucuo
}

// ClearClosingDate clears the value of the "closing_date" field.
func (kucuo *KcUserClassUpdateOne) ClearClosingDate() *KcUserClassUpdateOne {
	kucuo.mutation.ClearClosingDate()
	return kucuo
}

// SetStudyRate sets the "study_rate" field.
func (kucuo *KcUserClassUpdateOne) SetStudyRate(f float64) *KcUserClassUpdateOne {
	kucuo.mutation.ResetStudyRate()
	kucuo.mutation.SetStudyRate(f)
	return kucuo
}

// SetNillableStudyRate sets the "study_rate" field if the given value is not nil.
func (kucuo *KcUserClassUpdateOne) SetNillableStudyRate(f *float64) *KcUserClassUpdateOne {
	if f != nil {
		kucuo.SetStudyRate(*f)
	}
	return kucuo
}

// AddStudyRate adds f to the "study_rate" field.
func (kucuo *KcUserClassUpdateOne) AddStudyRate(f float64) *KcUserClassUpdateOne {
	kucuo.mutation.AddStudyRate(f)
	return kucuo
}

// SetRemark sets the "remark" field.
func (kucuo *KcUserClassUpdateOne) SetRemark(s string) *KcUserClassUpdateOne {
	kucuo.mutation.SetRemark(s)
	return kucuo
}

// SetNillableRemark sets the "remark" field if the given value is not nil.
func (kucuo *KcUserClassUpdateOne) SetNillableRemark(s *string) *KcUserClassUpdateOne {
	if s != nil {
		kucuo.SetRemark(*s)
	}
	return kucuo
}

// SetPrice sets the "price" field.
func (kucuo *KcUserClassUpdateOne) SetPrice(f float64) *KcUserClassUpdateOne {
	kucuo.mutation.ResetPrice()
	kucuo.mutation.SetPrice(f)
	return kucuo
}

// SetNillablePrice sets the "price" field if the given value is not nil.
func (kucuo *KcUserClassUpdateOne) SetNillablePrice(f *float64) *KcUserClassUpdateOne {
	if f != nil {
		kucuo.SetPrice(*f)
	}
	return kucuo
}

// AddPrice adds f to the "price" field.
func (kucuo *KcUserClassUpdateOne) AddPrice(f float64) *KcUserClassUpdateOne {
	kucuo.mutation.AddPrice(f)
	return kucuo
}

// SetUserID sets the "user_id" field.
func (kucuo *KcUserClassUpdateOne) SetUserID(i int) *KcUserClassUpdateOne {
	kucuo.mutation.ResetUserID()
	kucuo.mutation.SetUserID(i)
	return kucuo
}

// SetNillableUserID sets the "user_id" field if the given value is not nil.
func (kucuo *KcUserClassUpdateOne) SetNillableUserID(i *int) *KcUserClassUpdateOne {
	if i != nil {
		kucuo.SetUserID(*i)
	}
	return kucuo
}

// ClearUserID clears the value of the "user_id" field.
func (kucuo *KcUserClassUpdateOne) ClearUserID() *KcUserClassUpdateOne {
	kucuo.mutation.ClearUserID()
	return kucuo
}

// SetClassID sets the "class_id" field.
func (kucuo *KcUserClassUpdateOne) SetClassID(i int) *KcUserClassUpdateOne {
	kucuo.mutation.ResetClassID()
	kucuo.mutation.SetClassID(i)
	return kucuo
}

// SetNillableClassID sets the "class_id" field if the given value is not nil.
func (kucuo *KcUserClassUpdateOne) SetNillableClassID(i *int) *KcUserClassUpdateOne {
	if i != nil {
		kucuo.SetClassID(*i)
	}
	return kucuo
}

// ClearClassID clears the value of the "class_id" field.
func (kucuo *KcUserClassUpdateOne) ClearClassID() *KcUserClassUpdateOne {
	kucuo.mutation.ClearClassID()
	return kucuo
}

// SetUser sets the "user" edge to the User entity.
func (kucuo *KcUserClassUpdateOne) SetUser(u *User) *KcUserClassUpdateOne {
	return kucuo.SetUserID(u.ID)
}

// SetClass sets the "class" edge to the KcClass entity.
func (kucuo *KcUserClassUpdateOne) SetClass(k *KcClass) *KcUserClassUpdateOne {
	return kucuo.SetClassID(k.ID)
}

// Mutation returns the KcUserClassMutation object of the builder.
func (kucuo *KcUserClassUpdateOne) Mutation() *KcUserClassMutation {
	return kucuo.mutation
}

// ClearUser clears the "user" edge to the User entity.
func (kucuo *KcUserClassUpdateOne) ClearUser() *KcUserClassUpdateOne {
	kucuo.mutation.ClearUser()
	return kucuo
}

// ClearClass clears the "class" edge to the KcClass entity.
func (kucuo *KcUserClassUpdateOne) ClearClass() *KcUserClassUpdateOne {
	kucuo.mutation.ClearClass()
	return kucuo
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (kucuo *KcUserClassUpdateOne) Select(field string, fields ...string) *KcUserClassUpdateOne {
	kucuo.fields = append([]string{field}, fields...)
	return kucuo
}

// Save executes the query and returns the updated KcUserClass entity.
func (kucuo *KcUserClassUpdateOne) Save(ctx context.Context) (*KcUserClass, error) {
	var (
		err  error
		node *KcUserClass
	)
	kucuo.defaults()
	if len(kucuo.hooks) == 0 {
		node, err = kucuo.sqlSave(ctx)
	} else {
		var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
			mutation, ok := m.(*KcUserClassMutation)
			if !ok {
				return nil, fmt.Errorf("unexpected mutation type %T", m)
			}
			kucuo.mutation = mutation
			node, err = kucuo.sqlSave(ctx)
			mutation.done = true
			return node, err
		})
		for i := len(kucuo.hooks) - 1; i >= 0; i-- {
			mut = kucuo.hooks[i](mut)
		}
		if _, err := mut.Mutate(ctx, kucuo.mutation); err != nil {
			return nil, err
		}
	}
	return node, err
}

// SaveX is like Save, but panics if an error occurs.
func (kucuo *KcUserClassUpdateOne) SaveX(ctx context.Context) *KcUserClass {
	node, err := kucuo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (kucuo *KcUserClassUpdateOne) Exec(ctx context.Context) error {
	_, err := kucuo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (kucuo *KcUserClassUpdateOne) ExecX(ctx context.Context) {
	if err := kucuo.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (kucuo *KcUserClassUpdateOne) defaults() {
	if _, ok := kucuo.mutation.UpdatedAt(); !ok && !kucuo.mutation.UpdatedAtCleared() {
		v := kcuserclass.UpdateDefaultUpdatedAt()
		kucuo.mutation.SetUpdatedAt(v)
	}
}

func (kucuo *KcUserClassUpdateOne) sqlSave(ctx context.Context) (_node *KcUserClass, err error) {
	_spec := &sqlgraph.UpdateSpec{
		Node: &sqlgraph.NodeSpec{
			Table:   kcuserclass.Table,
			Columns: kcuserclass.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeInt,
				Column: kcuserclass.FieldID,
			},
		},
	}
	id, ok := kucuo.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "ID", err: fmt.Errorf("missing KcUserClass.ID for update")}
	}
	_spec.Node.ID.Value = id
	if fields := kucuo.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, kcuserclass.FieldID)
		for _, f := range fields {
			if !kcuserclass.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
			}
			if f != kcuserclass.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := kucuo.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := kucuo.mutation.UUID(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: kcuserclass.FieldUUID,
		})
	}
	if kucuo.mutation.CreatedAtCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Column: kcuserclass.FieldCreatedAt,
		})
	}
	if value, ok := kucuo.mutation.UpdatedAt(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: kcuserclass.FieldUpdatedAt,
		})
	}
	if kucuo.mutation.UpdatedAtCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Column: kcuserclass.FieldUpdatedAt,
		})
	}
	if value, ok := kucuo.mutation.DeletedAt(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: kcuserclass.FieldDeletedAt,
		})
	}
	if kucuo.mutation.DeletedAtCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Column: kcuserclass.FieldDeletedAt,
		})
	}
	if value, ok := kucuo.mutation.PeriodType(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeUint8,
			Value:  value,
			Column: kcuserclass.FieldPeriodType,
		})
	}
	if value, ok := kucuo.mutation.AddedPeriodType(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeUint8,
			Value:  value,
			Column: kcuserclass.FieldPeriodType,
		})
	}
	if value, ok := kucuo.mutation.ClosingDate(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: kcuserclass.FieldClosingDate,
		})
	}
	if kucuo.mutation.ClosingDateCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Column: kcuserclass.FieldClosingDate,
		})
	}
	if value, ok := kucuo.mutation.StudyRate(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeFloat64,
			Value:  value,
			Column: kcuserclass.FieldStudyRate,
		})
	}
	if value, ok := kucuo.mutation.AddedStudyRate(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeFloat64,
			Value:  value,
			Column: kcuserclass.FieldStudyRate,
		})
	}
	if value, ok := kucuo.mutation.Remark(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: kcuserclass.FieldRemark,
		})
	}
	if value, ok := kucuo.mutation.Price(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeFloat64,
			Value:  value,
			Column: kcuserclass.FieldPrice,
		})
	}
	if value, ok := kucuo.mutation.AddedPrice(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeFloat64,
			Value:  value,
			Column: kcuserclass.FieldPrice,
		})
	}
	if kucuo.mutation.UserCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   kcuserclass.UserTable,
			Columns: []string{kcuserclass.UserColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: user.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := kucuo.mutation.UserIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   kcuserclass.UserTable,
			Columns: []string{kcuserclass.UserColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: user.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if kucuo.mutation.ClassCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   kcuserclass.ClassTable,
			Columns: []string{kcuserclass.ClassColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: kcclass.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := kucuo.mutation.ClassIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   kcuserclass.ClassTable,
			Columns: []string{kcuserclass.ClassColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: kcclass.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_node = &KcUserClass{config: kucuo.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, kucuo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{kcuserclass.Label}
		} else if cerr, ok := isSQLConstraintError(err); ok {
			err = cerr
		}
		return nil, err
	}
	return _node, nil
}
