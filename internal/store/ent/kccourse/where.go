// Code generated by entc, DO NOT EDIT.

package kccourse

import (
	"gserver/internal/store/ent/predicate"
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

// ID filters vertices based on their ID field.
func ID(id int) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id int) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id int) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldID), id))
	})
}

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...int) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.In(s.C(FieldID), v...))
	})
}

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...int) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.NotIn(s.C(FieldID), v...))
	})
}

// IDGT applies the GT predicate on the ID field.
func IDGT(id int) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldID), id))
	})
}

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id int) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldID), id))
	})
}

// IDLT applies the LT predicate on the ID field.
func IDLT(id int) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldID), id))
	})
}

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id int) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldID), id))
	})
}

// UUID applies equality check predicate on the "uuid" field. It's identical to UUIDEQ.
func UUID(v string) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUUID), v))
	})
}

// CreatedAt applies equality check predicate on the "created_at" field. It's identical to CreatedAtEQ.
func CreatedAt(v time.Time) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCreatedAt), v))
	})
}

// UpdatedAt applies equality check predicate on the "updated_at" field. It's identical to UpdatedAtEQ.
func UpdatedAt(v time.Time) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUpdatedAt), v))
	})
}

// DeletedAt applies equality check predicate on the "deleted_at" field. It's identical to DeletedAtEQ.
func DeletedAt(v time.Time) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDeletedAt), v))
	})
}

// CourseName applies equality check predicate on the "course_name" field. It's identical to CourseNameEQ.
func CourseName(v string) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCourseName), v))
	})
}

// CourseType applies equality check predicate on the "course_type" field. It's identical to CourseTypeEQ.
func CourseType(v uint8) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCourseType), v))
	})
}

// PeopleNum applies equality check predicate on the "people_num" field. It's identical to PeopleNumEQ.
func PeopleNum(v int) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPeopleNum), v))
	})
}

// CoursePrice applies equality check predicate on the "course_price" field. It's identical to CoursePriceEQ.
func CoursePrice(v float64) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCoursePrice), v))
	})
}

// CourseDesc applies equality check predicate on the "course_desc" field. It's identical to CourseDescEQ.
func CourseDesc(v string) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCourseDesc), v))
	})
}

// PushStatus applies equality check predicate on the "push_status" field. It's identical to PushStatusEQ.
func PushStatus(v uint8) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPushStatus), v))
	})
}

// CateID applies equality check predicate on the "cate_id" field. It's identical to CateIDEQ.
func CateID(v int) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCateID), v))
	})
}

// CityID applies equality check predicate on the "city_id" field. It's identical to CityIDEQ.
func CityID(v int) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCityID), v))
	})
}

// QuestionBankID applies equality check predicate on the "question_bank_id" field. It's identical to QuestionBankIDEQ.
func QuestionBankID(v int) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldQuestionBankID), v))
	})
}

// CourseCoverImgID applies equality check predicate on the "course_cover_img_id" field. It's identical to CourseCoverImgIDEQ.
func CourseCoverImgID(v int) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCourseCoverImgID), v))
	})
}

// CreatedAdminID applies equality check predicate on the "created_admin_id" field. It's identical to CreatedAdminIDEQ.
func CreatedAdminID(v int) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCreatedAdminID), v))
	})
}

// UUIDEQ applies the EQ predicate on the "uuid" field.
func UUIDEQ(v string) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUUID), v))
	})
}

// UUIDNEQ applies the NEQ predicate on the "uuid" field.
func UUIDNEQ(v string) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldUUID), v))
	})
}

// UUIDIn applies the In predicate on the "uuid" field.
func UUIDIn(vs ...string) predicate.KcCourse {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.KcCourse(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldUUID), v...))
	})
}

// UUIDNotIn applies the NotIn predicate on the "uuid" field.
func UUIDNotIn(vs ...string) predicate.KcCourse {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.KcCourse(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldUUID), v...))
	})
}

// UUIDGT applies the GT predicate on the "uuid" field.
func UUIDGT(v string) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldUUID), v))
	})
}

// UUIDGTE applies the GTE predicate on the "uuid" field.
func UUIDGTE(v string) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldUUID), v))
	})
}

// UUIDLT applies the LT predicate on the "uuid" field.
func UUIDLT(v string) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldUUID), v))
	})
}

// UUIDLTE applies the LTE predicate on the "uuid" field.
func UUIDLTE(v string) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldUUID), v))
	})
}

// UUIDContains applies the Contains predicate on the "uuid" field.
func UUIDContains(v string) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldUUID), v))
	})
}

// UUIDHasPrefix applies the HasPrefix predicate on the "uuid" field.
func UUIDHasPrefix(v string) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldUUID), v))
	})
}

// UUIDHasSuffix applies the HasSuffix predicate on the "uuid" field.
func UUIDHasSuffix(v string) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldUUID), v))
	})
}

// UUIDEqualFold applies the EqualFold predicate on the "uuid" field.
func UUIDEqualFold(v string) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldUUID), v))
	})
}

// UUIDContainsFold applies the ContainsFold predicate on the "uuid" field.
func UUIDContainsFold(v string) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldUUID), v))
	})
}

// CreatedAtEQ applies the EQ predicate on the "created_at" field.
func CreatedAtEQ(v time.Time) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCreatedAt), v))
	})
}

// CreatedAtNEQ applies the NEQ predicate on the "created_at" field.
func CreatedAtNEQ(v time.Time) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldCreatedAt), v))
	})
}

// CreatedAtIn applies the In predicate on the "created_at" field.
func CreatedAtIn(vs ...time.Time) predicate.KcCourse {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.KcCourse(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldCreatedAt), v...))
	})
}

// CreatedAtNotIn applies the NotIn predicate on the "created_at" field.
func CreatedAtNotIn(vs ...time.Time) predicate.KcCourse {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.KcCourse(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldCreatedAt), v...))
	})
}

// CreatedAtGT applies the GT predicate on the "created_at" field.
func CreatedAtGT(v time.Time) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldCreatedAt), v))
	})
}

// CreatedAtGTE applies the GTE predicate on the "created_at" field.
func CreatedAtGTE(v time.Time) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldCreatedAt), v))
	})
}

// CreatedAtLT applies the LT predicate on the "created_at" field.
func CreatedAtLT(v time.Time) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldCreatedAt), v))
	})
}

// CreatedAtLTE applies the LTE predicate on the "created_at" field.
func CreatedAtLTE(v time.Time) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldCreatedAt), v))
	})
}

// CreatedAtIsNil applies the IsNil predicate on the "created_at" field.
func CreatedAtIsNil() predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldCreatedAt)))
	})
}

// CreatedAtNotNil applies the NotNil predicate on the "created_at" field.
func CreatedAtNotNil() predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldCreatedAt)))
	})
}

// UpdatedAtEQ applies the EQ predicate on the "updated_at" field.
func UpdatedAtEQ(v time.Time) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUpdatedAt), v))
	})
}

// UpdatedAtNEQ applies the NEQ predicate on the "updated_at" field.
func UpdatedAtNEQ(v time.Time) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldUpdatedAt), v))
	})
}

// UpdatedAtIn applies the In predicate on the "updated_at" field.
func UpdatedAtIn(vs ...time.Time) predicate.KcCourse {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.KcCourse(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldUpdatedAt), v...))
	})
}

// UpdatedAtNotIn applies the NotIn predicate on the "updated_at" field.
func UpdatedAtNotIn(vs ...time.Time) predicate.KcCourse {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.KcCourse(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldUpdatedAt), v...))
	})
}

// UpdatedAtGT applies the GT predicate on the "updated_at" field.
func UpdatedAtGT(v time.Time) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldUpdatedAt), v))
	})
}

// UpdatedAtGTE applies the GTE predicate on the "updated_at" field.
func UpdatedAtGTE(v time.Time) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldUpdatedAt), v))
	})
}

// UpdatedAtLT applies the LT predicate on the "updated_at" field.
func UpdatedAtLT(v time.Time) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldUpdatedAt), v))
	})
}

// UpdatedAtLTE applies the LTE predicate on the "updated_at" field.
func UpdatedAtLTE(v time.Time) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldUpdatedAt), v))
	})
}

// UpdatedAtIsNil applies the IsNil predicate on the "updated_at" field.
func UpdatedAtIsNil() predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldUpdatedAt)))
	})
}

// UpdatedAtNotNil applies the NotNil predicate on the "updated_at" field.
func UpdatedAtNotNil() predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldUpdatedAt)))
	})
}

// DeletedAtEQ applies the EQ predicate on the "deleted_at" field.
func DeletedAtEQ(v time.Time) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDeletedAt), v))
	})
}

// DeletedAtNEQ applies the NEQ predicate on the "deleted_at" field.
func DeletedAtNEQ(v time.Time) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldDeletedAt), v))
	})
}

// DeletedAtIn applies the In predicate on the "deleted_at" field.
func DeletedAtIn(vs ...time.Time) predicate.KcCourse {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.KcCourse(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldDeletedAt), v...))
	})
}

// DeletedAtNotIn applies the NotIn predicate on the "deleted_at" field.
func DeletedAtNotIn(vs ...time.Time) predicate.KcCourse {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.KcCourse(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldDeletedAt), v...))
	})
}

// DeletedAtGT applies the GT predicate on the "deleted_at" field.
func DeletedAtGT(v time.Time) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldDeletedAt), v))
	})
}

// DeletedAtGTE applies the GTE predicate on the "deleted_at" field.
func DeletedAtGTE(v time.Time) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldDeletedAt), v))
	})
}

// DeletedAtLT applies the LT predicate on the "deleted_at" field.
func DeletedAtLT(v time.Time) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldDeletedAt), v))
	})
}

// DeletedAtLTE applies the LTE predicate on the "deleted_at" field.
func DeletedAtLTE(v time.Time) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldDeletedAt), v))
	})
}

// DeletedAtIsNil applies the IsNil predicate on the "deleted_at" field.
func DeletedAtIsNil() predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldDeletedAt)))
	})
}

// DeletedAtNotNil applies the NotNil predicate on the "deleted_at" field.
func DeletedAtNotNil() predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldDeletedAt)))
	})
}

// CourseNameEQ applies the EQ predicate on the "course_name" field.
func CourseNameEQ(v string) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCourseName), v))
	})
}

// CourseNameNEQ applies the NEQ predicate on the "course_name" field.
func CourseNameNEQ(v string) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldCourseName), v))
	})
}

// CourseNameIn applies the In predicate on the "course_name" field.
func CourseNameIn(vs ...string) predicate.KcCourse {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.KcCourse(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldCourseName), v...))
	})
}

// CourseNameNotIn applies the NotIn predicate on the "course_name" field.
func CourseNameNotIn(vs ...string) predicate.KcCourse {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.KcCourse(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldCourseName), v...))
	})
}

// CourseNameGT applies the GT predicate on the "course_name" field.
func CourseNameGT(v string) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldCourseName), v))
	})
}

// CourseNameGTE applies the GTE predicate on the "course_name" field.
func CourseNameGTE(v string) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldCourseName), v))
	})
}

// CourseNameLT applies the LT predicate on the "course_name" field.
func CourseNameLT(v string) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldCourseName), v))
	})
}

// CourseNameLTE applies the LTE predicate on the "course_name" field.
func CourseNameLTE(v string) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldCourseName), v))
	})
}

// CourseNameContains applies the Contains predicate on the "course_name" field.
func CourseNameContains(v string) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldCourseName), v))
	})
}

// CourseNameHasPrefix applies the HasPrefix predicate on the "course_name" field.
func CourseNameHasPrefix(v string) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldCourseName), v))
	})
}

// CourseNameHasSuffix applies the HasSuffix predicate on the "course_name" field.
func CourseNameHasSuffix(v string) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldCourseName), v))
	})
}

// CourseNameEqualFold applies the EqualFold predicate on the "course_name" field.
func CourseNameEqualFold(v string) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldCourseName), v))
	})
}

// CourseNameContainsFold applies the ContainsFold predicate on the "course_name" field.
func CourseNameContainsFold(v string) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldCourseName), v))
	})
}

// CourseTypeEQ applies the EQ predicate on the "course_type" field.
func CourseTypeEQ(v uint8) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCourseType), v))
	})
}

// CourseTypeNEQ applies the NEQ predicate on the "course_type" field.
func CourseTypeNEQ(v uint8) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldCourseType), v))
	})
}

// CourseTypeIn applies the In predicate on the "course_type" field.
func CourseTypeIn(vs ...uint8) predicate.KcCourse {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.KcCourse(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldCourseType), v...))
	})
}

// CourseTypeNotIn applies the NotIn predicate on the "course_type" field.
func CourseTypeNotIn(vs ...uint8) predicate.KcCourse {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.KcCourse(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldCourseType), v...))
	})
}

// CourseTypeGT applies the GT predicate on the "course_type" field.
func CourseTypeGT(v uint8) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldCourseType), v))
	})
}

// CourseTypeGTE applies the GTE predicate on the "course_type" field.
func CourseTypeGTE(v uint8) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldCourseType), v))
	})
}

// CourseTypeLT applies the LT predicate on the "course_type" field.
func CourseTypeLT(v uint8) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldCourseType), v))
	})
}

// CourseTypeLTE applies the LTE predicate on the "course_type" field.
func CourseTypeLTE(v uint8) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldCourseType), v))
	})
}

// PeopleNumEQ applies the EQ predicate on the "people_num" field.
func PeopleNumEQ(v int) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPeopleNum), v))
	})
}

// PeopleNumNEQ applies the NEQ predicate on the "people_num" field.
func PeopleNumNEQ(v int) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldPeopleNum), v))
	})
}

// PeopleNumIn applies the In predicate on the "people_num" field.
func PeopleNumIn(vs ...int) predicate.KcCourse {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.KcCourse(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldPeopleNum), v...))
	})
}

// PeopleNumNotIn applies the NotIn predicate on the "people_num" field.
func PeopleNumNotIn(vs ...int) predicate.KcCourse {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.KcCourse(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldPeopleNum), v...))
	})
}

// PeopleNumGT applies the GT predicate on the "people_num" field.
func PeopleNumGT(v int) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldPeopleNum), v))
	})
}

// PeopleNumGTE applies the GTE predicate on the "people_num" field.
func PeopleNumGTE(v int) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldPeopleNum), v))
	})
}

// PeopleNumLT applies the LT predicate on the "people_num" field.
func PeopleNumLT(v int) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldPeopleNum), v))
	})
}

// PeopleNumLTE applies the LTE predicate on the "people_num" field.
func PeopleNumLTE(v int) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldPeopleNum), v))
	})
}

// CoursePriceEQ applies the EQ predicate on the "course_price" field.
func CoursePriceEQ(v float64) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCoursePrice), v))
	})
}

// CoursePriceNEQ applies the NEQ predicate on the "course_price" field.
func CoursePriceNEQ(v float64) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldCoursePrice), v))
	})
}

// CoursePriceIn applies the In predicate on the "course_price" field.
func CoursePriceIn(vs ...float64) predicate.KcCourse {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.KcCourse(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldCoursePrice), v...))
	})
}

// CoursePriceNotIn applies the NotIn predicate on the "course_price" field.
func CoursePriceNotIn(vs ...float64) predicate.KcCourse {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.KcCourse(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldCoursePrice), v...))
	})
}

// CoursePriceGT applies the GT predicate on the "course_price" field.
func CoursePriceGT(v float64) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldCoursePrice), v))
	})
}

// CoursePriceGTE applies the GTE predicate on the "course_price" field.
func CoursePriceGTE(v float64) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldCoursePrice), v))
	})
}

// CoursePriceLT applies the LT predicate on the "course_price" field.
func CoursePriceLT(v float64) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldCoursePrice), v))
	})
}

// CoursePriceLTE applies the LTE predicate on the "course_price" field.
func CoursePriceLTE(v float64) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldCoursePrice), v))
	})
}

// CourseDescEQ applies the EQ predicate on the "course_desc" field.
func CourseDescEQ(v string) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCourseDesc), v))
	})
}

// CourseDescNEQ applies the NEQ predicate on the "course_desc" field.
func CourseDescNEQ(v string) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldCourseDesc), v))
	})
}

// CourseDescIn applies the In predicate on the "course_desc" field.
func CourseDescIn(vs ...string) predicate.KcCourse {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.KcCourse(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldCourseDesc), v...))
	})
}

// CourseDescNotIn applies the NotIn predicate on the "course_desc" field.
func CourseDescNotIn(vs ...string) predicate.KcCourse {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.KcCourse(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldCourseDesc), v...))
	})
}

// CourseDescGT applies the GT predicate on the "course_desc" field.
func CourseDescGT(v string) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldCourseDesc), v))
	})
}

// CourseDescGTE applies the GTE predicate on the "course_desc" field.
func CourseDescGTE(v string) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldCourseDesc), v))
	})
}

// CourseDescLT applies the LT predicate on the "course_desc" field.
func CourseDescLT(v string) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldCourseDesc), v))
	})
}

// CourseDescLTE applies the LTE predicate on the "course_desc" field.
func CourseDescLTE(v string) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldCourseDesc), v))
	})
}

// CourseDescContains applies the Contains predicate on the "course_desc" field.
func CourseDescContains(v string) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldCourseDesc), v))
	})
}

// CourseDescHasPrefix applies the HasPrefix predicate on the "course_desc" field.
func CourseDescHasPrefix(v string) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldCourseDesc), v))
	})
}

// CourseDescHasSuffix applies the HasSuffix predicate on the "course_desc" field.
func CourseDescHasSuffix(v string) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldCourseDesc), v))
	})
}

// CourseDescEqualFold applies the EqualFold predicate on the "course_desc" field.
func CourseDescEqualFold(v string) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldCourseDesc), v))
	})
}

// CourseDescContainsFold applies the ContainsFold predicate on the "course_desc" field.
func CourseDescContainsFold(v string) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldCourseDesc), v))
	})
}

// PushStatusEQ applies the EQ predicate on the "push_status" field.
func PushStatusEQ(v uint8) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPushStatus), v))
	})
}

// PushStatusNEQ applies the NEQ predicate on the "push_status" field.
func PushStatusNEQ(v uint8) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldPushStatus), v))
	})
}

// PushStatusIn applies the In predicate on the "push_status" field.
func PushStatusIn(vs ...uint8) predicate.KcCourse {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.KcCourse(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldPushStatus), v...))
	})
}

// PushStatusNotIn applies the NotIn predicate on the "push_status" field.
func PushStatusNotIn(vs ...uint8) predicate.KcCourse {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.KcCourse(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldPushStatus), v...))
	})
}

// PushStatusGT applies the GT predicate on the "push_status" field.
func PushStatusGT(v uint8) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldPushStatus), v))
	})
}

// PushStatusGTE applies the GTE predicate on the "push_status" field.
func PushStatusGTE(v uint8) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldPushStatus), v))
	})
}

// PushStatusLT applies the LT predicate on the "push_status" field.
func PushStatusLT(v uint8) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldPushStatus), v))
	})
}

// PushStatusLTE applies the LTE predicate on the "push_status" field.
func PushStatusLTE(v uint8) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldPushStatus), v))
	})
}

// CateIDEQ applies the EQ predicate on the "cate_id" field.
func CateIDEQ(v int) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCateID), v))
	})
}

// CateIDNEQ applies the NEQ predicate on the "cate_id" field.
func CateIDNEQ(v int) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldCateID), v))
	})
}

// CateIDIn applies the In predicate on the "cate_id" field.
func CateIDIn(vs ...int) predicate.KcCourse {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.KcCourse(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldCateID), v...))
	})
}

// CateIDNotIn applies the NotIn predicate on the "cate_id" field.
func CateIDNotIn(vs ...int) predicate.KcCourse {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.KcCourse(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldCateID), v...))
	})
}

// CateIDIsNil applies the IsNil predicate on the "cate_id" field.
func CateIDIsNil() predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldCateID)))
	})
}

// CateIDNotNil applies the NotNil predicate on the "cate_id" field.
func CateIDNotNil() predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldCateID)))
	})
}

// CityIDEQ applies the EQ predicate on the "city_id" field.
func CityIDEQ(v int) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCityID), v))
	})
}

// CityIDNEQ applies the NEQ predicate on the "city_id" field.
func CityIDNEQ(v int) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldCityID), v))
	})
}

// CityIDIn applies the In predicate on the "city_id" field.
func CityIDIn(vs ...int) predicate.KcCourse {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.KcCourse(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldCityID), v...))
	})
}

// CityIDNotIn applies the NotIn predicate on the "city_id" field.
func CityIDNotIn(vs ...int) predicate.KcCourse {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.KcCourse(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldCityID), v...))
	})
}

// CityIDIsNil applies the IsNil predicate on the "city_id" field.
func CityIDIsNil() predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldCityID)))
	})
}

// CityIDNotNil applies the NotNil predicate on the "city_id" field.
func CityIDNotNil() predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldCityID)))
	})
}

// QuestionBankIDEQ applies the EQ predicate on the "question_bank_id" field.
func QuestionBankIDEQ(v int) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldQuestionBankID), v))
	})
}

// QuestionBankIDNEQ applies the NEQ predicate on the "question_bank_id" field.
func QuestionBankIDNEQ(v int) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldQuestionBankID), v))
	})
}

// QuestionBankIDIn applies the In predicate on the "question_bank_id" field.
func QuestionBankIDIn(vs ...int) predicate.KcCourse {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.KcCourse(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldQuestionBankID), v...))
	})
}

// QuestionBankIDNotIn applies the NotIn predicate on the "question_bank_id" field.
func QuestionBankIDNotIn(vs ...int) predicate.KcCourse {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.KcCourse(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldQuestionBankID), v...))
	})
}

// QuestionBankIDIsNil applies the IsNil predicate on the "question_bank_id" field.
func QuestionBankIDIsNil() predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldQuestionBankID)))
	})
}

// QuestionBankIDNotNil applies the NotNil predicate on the "question_bank_id" field.
func QuestionBankIDNotNil() predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldQuestionBankID)))
	})
}

// CourseCoverImgIDEQ applies the EQ predicate on the "course_cover_img_id" field.
func CourseCoverImgIDEQ(v int) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCourseCoverImgID), v))
	})
}

// CourseCoverImgIDNEQ applies the NEQ predicate on the "course_cover_img_id" field.
func CourseCoverImgIDNEQ(v int) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldCourseCoverImgID), v))
	})
}

// CourseCoverImgIDIn applies the In predicate on the "course_cover_img_id" field.
func CourseCoverImgIDIn(vs ...int) predicate.KcCourse {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.KcCourse(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldCourseCoverImgID), v...))
	})
}

// CourseCoverImgIDNotIn applies the NotIn predicate on the "course_cover_img_id" field.
func CourseCoverImgIDNotIn(vs ...int) predicate.KcCourse {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.KcCourse(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldCourseCoverImgID), v...))
	})
}

// CourseCoverImgIDIsNil applies the IsNil predicate on the "course_cover_img_id" field.
func CourseCoverImgIDIsNil() predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldCourseCoverImgID)))
	})
}

// CourseCoverImgIDNotNil applies the NotNil predicate on the "course_cover_img_id" field.
func CourseCoverImgIDNotNil() predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldCourseCoverImgID)))
	})
}

// CreatedAdminIDEQ applies the EQ predicate on the "created_admin_id" field.
func CreatedAdminIDEQ(v int) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCreatedAdminID), v))
	})
}

// CreatedAdminIDNEQ applies the NEQ predicate on the "created_admin_id" field.
func CreatedAdminIDNEQ(v int) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldCreatedAdminID), v))
	})
}

// CreatedAdminIDIn applies the In predicate on the "created_admin_id" field.
func CreatedAdminIDIn(vs ...int) predicate.KcCourse {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.KcCourse(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldCreatedAdminID), v...))
	})
}

// CreatedAdminIDNotIn applies the NotIn predicate on the "created_admin_id" field.
func CreatedAdminIDNotIn(vs ...int) predicate.KcCourse {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.KcCourse(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldCreatedAdminID), v...))
	})
}

// CreatedAdminIDIsNil applies the IsNil predicate on the "created_admin_id" field.
func CreatedAdminIDIsNil() predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldCreatedAdminID)))
	})
}

// CreatedAdminIDNotNil applies the NotNil predicate on the "created_admin_id" field.
func CreatedAdminIDNotNil() predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldCreatedAdminID)))
	})
}

// HasMajor applies the HasEdge predicate on the "major" edge.
func HasMajor() predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(MajorTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, MajorTable, MajorPrimaryKey...),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasMajorWith applies the HasEdge predicate on the "major" edge with a given conditions (other predicates).
func HasMajorWith(preds ...predicate.Major) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(MajorInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, MajorTable, MajorPrimaryKey...),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasItem applies the HasEdge predicate on the "item" edge.
func HasItem() predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(ItemTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, ItemTable, ItemColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasItemWith applies the HasEdge predicate on the "item" edge with a given conditions (other predicates).
func HasItemWith(preds ...predicate.ItemCategory) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(ItemInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, ItemTable, ItemColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasCity applies the HasEdge predicate on the "city" edge.
func HasCity() predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(CityTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, CityTable, CityColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasCityWith applies the HasEdge predicate on the "city" edge with a given conditions (other predicates).
func HasCityWith(preds ...predicate.City) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(CityInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, CityTable, CityColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasAdmin applies the HasEdge predicate on the "admin" edge.
func HasAdmin() predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(AdminTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, AdminTable, AdminColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasAdminWith applies the HasEdge predicate on the "admin" edge with a given conditions (other predicates).
func HasAdminWith(preds ...predicate.Admin) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(AdminInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, AdminTable, AdminColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasQuestionBank applies the HasEdge predicate on the "question_bank" edge.
func HasQuestionBank() predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(QuestionBankTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, QuestionBankTable, QuestionBankColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasQuestionBankWith applies the HasEdge predicate on the "question_bank" edge with a given conditions (other predicates).
func HasQuestionBankWith(preds ...predicate.TkQuestionBank) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(QuestionBankInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, QuestionBankTable, QuestionBankColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasAttachment applies the HasEdge predicate on the "attachment" edge.
func HasAttachment() predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(AttachmentTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, AttachmentTable, AttachmentColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasAttachmentWith applies the HasEdge predicate on the "attachment" edge with a given conditions (other predicates).
func HasAttachmentWith(preds ...predicate.Attachment) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(AttachmentInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, AttachmentTable, AttachmentColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasCourseTeachers applies the HasEdge predicate on the "course_teachers" edge.
func HasCourseTeachers() predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(CourseTeachersTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, CourseTeachersTable, CourseTeachersColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasCourseTeachersWith applies the HasEdge predicate on the "course_teachers" edge with a given conditions (other predicates).
func HasCourseTeachersWith(preds ...predicate.KcCourseTeacher) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(CourseTeachersInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, CourseTeachersTable, CourseTeachersColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasClasses applies the HasEdge predicate on the "classes" edge.
func HasClasses() predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(ClassesTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, ClassesTable, ClassesPrimaryKey...),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasClassesWith applies the HasEdge predicate on the "classes" edge with a given conditions (other predicates).
func HasClassesWith(preds ...predicate.KcClass) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(ClassesInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, ClassesTable, ClassesPrimaryKey...),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasCourseSmallCategorys applies the HasEdge predicate on the "course_small_categorys" edge.
func HasCourseSmallCategorys() predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(CourseSmallCategorysTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, CourseSmallCategorysTable, CourseSmallCategorysColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasCourseSmallCategorysWith applies the HasEdge predicate on the "course_small_categorys" edge with a given conditions (other predicates).
func HasCourseSmallCategorysWith(preds ...predicate.KcCourseSmallCategory) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(CourseSmallCategorysInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, CourseSmallCategorysTable, CourseSmallCategorysColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasCourseAppraise applies the HasEdge predicate on the "course_appraise" edge.
func HasCourseAppraise() predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(CourseAppraiseTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, CourseAppraiseTable, CourseAppraiseColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasCourseAppraiseWith applies the HasEdge predicate on the "course_appraise" edge with a given conditions (other predicates).
func HasCourseAppraiseWith(preds ...predicate.UserCourseAppraise) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(CourseAppraiseInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, CourseAppraiseTable, CourseAppraiseColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasCourseChapters applies the HasEdge predicate on the "course_chapters" edge.
func HasCourseChapters() predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(CourseChaptersTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, CourseChaptersTable, CourseChaptersColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasCourseChaptersWith applies the HasEdge predicate on the "course_chapters" edge with a given conditions (other predicates).
func HasCourseChaptersWith(preds ...predicate.KcCourseChapter) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(CourseChaptersInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, CourseChaptersTable, CourseChaptersColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasKcUserCourses applies the HasEdge predicate on the "kc_user_courses" edge.
func HasKcUserCourses() predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(KcUserCoursesTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, KcUserCoursesTable, KcUserCoursesColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasKcUserCoursesWith applies the HasEdge predicate on the "kc_user_courses" edge with a given conditions (other predicates).
func HasKcUserCoursesWith(preds ...predicate.KcUserCourse) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(KcUserCoursesInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, KcUserCoursesTable, KcUserCoursesColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasMessageCourses applies the HasEdge predicate on the "message_courses" edge.
func HasMessageCourses() predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(MessageCoursesTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, MessageCoursesTable, MessageCoursesColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasMessageCoursesWith applies the HasEdge predicate on the "message_courses" edge with a given conditions (other predicates).
func HasMessageCoursesWith(preds ...predicate.Message) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(MessageCoursesInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, MessageCoursesTable, MessageCoursesColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.KcCourse) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for _, p := range predicates {
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.KcCourse) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for i, p := range predicates {
			if i > 0 {
				s1.Or()
			}
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Not applies the not operator on the given predicate.
func Not(p predicate.KcCourse) predicate.KcCourse {
	return predicate.KcCourse(func(s *sql.Selector) {
		p(s.Not())
	})
}
