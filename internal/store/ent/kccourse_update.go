// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"time"
	"tkserver/internal/store/ent/admin"
	"tkserver/internal/store/ent/attachment"
	"tkserver/internal/store/ent/city"
	"tkserver/internal/store/ent/itemcategory"
	"tkserver/internal/store/ent/kcclass"
	"tkserver/internal/store/ent/kccourse"
	"tkserver/internal/store/ent/kccoursechapter"
	"tkserver/internal/store/ent/kccoursesmallcategory"
	"tkserver/internal/store/ent/kccourseteacher"
	"tkserver/internal/store/ent/kcusercourse"
	"tkserver/internal/store/ent/major"
	"tkserver/internal/store/ent/message"
	"tkserver/internal/store/ent/predicate"
	"tkserver/internal/store/ent/tkquestionbank"
	"tkserver/internal/store/ent/usercourseappraise"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
)

// KcCourseUpdate is the builder for updating KcCourse entities.
type KcCourseUpdate struct {
	config
	hooks    []Hook
	mutation *KcCourseMutation
}

// Where adds a new predicate for the KcCourseUpdate builder.
func (kcu *KcCourseUpdate) Where(ps ...predicate.KcCourse) *KcCourseUpdate {
	kcu.mutation.predicates = append(kcu.mutation.predicates, ps...)
	return kcu
}

// SetUUID sets the "uuid" field.
func (kcu *KcCourseUpdate) SetUUID(s string) *KcCourseUpdate {
	kcu.mutation.SetUUID(s)
	return kcu
}

// SetUpdatedAt sets the "updated_at" field.
func (kcu *KcCourseUpdate) SetUpdatedAt(t time.Time) *KcCourseUpdate {
	kcu.mutation.SetUpdatedAt(t)
	return kcu
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (kcu *KcCourseUpdate) ClearUpdatedAt() *KcCourseUpdate {
	kcu.mutation.ClearUpdatedAt()
	return kcu
}

// SetDeletedAt sets the "deleted_at" field.
func (kcu *KcCourseUpdate) SetDeletedAt(t time.Time) *KcCourseUpdate {
	kcu.mutation.SetDeletedAt(t)
	return kcu
}

// SetNillableDeletedAt sets the "deleted_at" field if the given value is not nil.
func (kcu *KcCourseUpdate) SetNillableDeletedAt(t *time.Time) *KcCourseUpdate {
	if t != nil {
		kcu.SetDeletedAt(*t)
	}
	return kcu
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (kcu *KcCourseUpdate) ClearDeletedAt() *KcCourseUpdate {
	kcu.mutation.ClearDeletedAt()
	return kcu
}

// SetCourseName sets the "course_name" field.
func (kcu *KcCourseUpdate) SetCourseName(s string) *KcCourseUpdate {
	kcu.mutation.SetCourseName(s)
	return kcu
}

// SetNillableCourseName sets the "course_name" field if the given value is not nil.
func (kcu *KcCourseUpdate) SetNillableCourseName(s *string) *KcCourseUpdate {
	if s != nil {
		kcu.SetCourseName(*s)
	}
	return kcu
}

// SetCourseType sets the "course_type" field.
func (kcu *KcCourseUpdate) SetCourseType(u uint8) *KcCourseUpdate {
	kcu.mutation.ResetCourseType()
	kcu.mutation.SetCourseType(u)
	return kcu
}

// SetNillableCourseType sets the "course_type" field if the given value is not nil.
func (kcu *KcCourseUpdate) SetNillableCourseType(u *uint8) *KcCourseUpdate {
	if u != nil {
		kcu.SetCourseType(*u)
	}
	return kcu
}

// AddCourseType adds u to the "course_type" field.
func (kcu *KcCourseUpdate) AddCourseType(u uint8) *KcCourseUpdate {
	kcu.mutation.AddCourseType(u)
	return kcu
}

// SetPeopleNum sets the "people_num" field.
func (kcu *KcCourseUpdate) SetPeopleNum(i int) *KcCourseUpdate {
	kcu.mutation.ResetPeopleNum()
	kcu.mutation.SetPeopleNum(i)
	return kcu
}

// SetNillablePeopleNum sets the "people_num" field if the given value is not nil.
func (kcu *KcCourseUpdate) SetNillablePeopleNum(i *int) *KcCourseUpdate {
	if i != nil {
		kcu.SetPeopleNum(*i)
	}
	return kcu
}

// AddPeopleNum adds i to the "people_num" field.
func (kcu *KcCourseUpdate) AddPeopleNum(i int) *KcCourseUpdate {
	kcu.mutation.AddPeopleNum(i)
	return kcu
}

// SetCoursePrice sets the "course_price" field.
func (kcu *KcCourseUpdate) SetCoursePrice(f float64) *KcCourseUpdate {
	kcu.mutation.ResetCoursePrice()
	kcu.mutation.SetCoursePrice(f)
	return kcu
}

// SetNillableCoursePrice sets the "course_price" field if the given value is not nil.
func (kcu *KcCourseUpdate) SetNillableCoursePrice(f *float64) *KcCourseUpdate {
	if f != nil {
		kcu.SetCoursePrice(*f)
	}
	return kcu
}

// AddCoursePrice adds f to the "course_price" field.
func (kcu *KcCourseUpdate) AddCoursePrice(f float64) *KcCourseUpdate {
	kcu.mutation.AddCoursePrice(f)
	return kcu
}

// SetCourseDesc sets the "course_desc" field.
func (kcu *KcCourseUpdate) SetCourseDesc(s string) *KcCourseUpdate {
	kcu.mutation.SetCourseDesc(s)
	return kcu
}

// SetNillableCourseDesc sets the "course_desc" field if the given value is not nil.
func (kcu *KcCourseUpdate) SetNillableCourseDesc(s *string) *KcCourseUpdate {
	if s != nil {
		kcu.SetCourseDesc(*s)
	}
	return kcu
}

// SetPushStatus sets the "push_status" field.
func (kcu *KcCourseUpdate) SetPushStatus(u uint8) *KcCourseUpdate {
	kcu.mutation.ResetPushStatus()
	kcu.mutation.SetPushStatus(u)
	return kcu
}

// SetNillablePushStatus sets the "push_status" field if the given value is not nil.
func (kcu *KcCourseUpdate) SetNillablePushStatus(u *uint8) *KcCourseUpdate {
	if u != nil {
		kcu.SetPushStatus(*u)
	}
	return kcu
}

// AddPushStatus adds u to the "push_status" field.
func (kcu *KcCourseUpdate) AddPushStatus(u uint8) *KcCourseUpdate {
	kcu.mutation.AddPushStatus(u)
	return kcu
}

// SetCateID sets the "cate_id" field.
func (kcu *KcCourseUpdate) SetCateID(i int) *KcCourseUpdate {
	kcu.mutation.ResetCateID()
	kcu.mutation.SetCateID(i)
	return kcu
}

// SetNillableCateID sets the "cate_id" field if the given value is not nil.
func (kcu *KcCourseUpdate) SetNillableCateID(i *int) *KcCourseUpdate {
	if i != nil {
		kcu.SetCateID(*i)
	}
	return kcu
}

// ClearCateID clears the value of the "cate_id" field.
func (kcu *KcCourseUpdate) ClearCateID() *KcCourseUpdate {
	kcu.mutation.ClearCateID()
	return kcu
}

// SetCityID sets the "city_id" field.
func (kcu *KcCourseUpdate) SetCityID(i int) *KcCourseUpdate {
	kcu.mutation.ResetCityID()
	kcu.mutation.SetCityID(i)
	return kcu
}

// SetNillableCityID sets the "city_id" field if the given value is not nil.
func (kcu *KcCourseUpdate) SetNillableCityID(i *int) *KcCourseUpdate {
	if i != nil {
		kcu.SetCityID(*i)
	}
	return kcu
}

// ClearCityID clears the value of the "city_id" field.
func (kcu *KcCourseUpdate) ClearCityID() *KcCourseUpdate {
	kcu.mutation.ClearCityID()
	return kcu
}

// SetQuestionBankID sets the "question_bank_id" field.
func (kcu *KcCourseUpdate) SetQuestionBankID(i int) *KcCourseUpdate {
	kcu.mutation.ResetQuestionBankID()
	kcu.mutation.SetQuestionBankID(i)
	return kcu
}

// SetNillableQuestionBankID sets the "question_bank_id" field if the given value is not nil.
func (kcu *KcCourseUpdate) SetNillableQuestionBankID(i *int) *KcCourseUpdate {
	if i != nil {
		kcu.SetQuestionBankID(*i)
	}
	return kcu
}

// ClearQuestionBankID clears the value of the "question_bank_id" field.
func (kcu *KcCourseUpdate) ClearQuestionBankID() *KcCourseUpdate {
	kcu.mutation.ClearQuestionBankID()
	return kcu
}

// SetCourseCoverImgID sets the "course_cover_img_id" field.
func (kcu *KcCourseUpdate) SetCourseCoverImgID(i int) *KcCourseUpdate {
	kcu.mutation.ResetCourseCoverImgID()
	kcu.mutation.SetCourseCoverImgID(i)
	return kcu
}

// SetNillableCourseCoverImgID sets the "course_cover_img_id" field if the given value is not nil.
func (kcu *KcCourseUpdate) SetNillableCourseCoverImgID(i *int) *KcCourseUpdate {
	if i != nil {
		kcu.SetCourseCoverImgID(*i)
	}
	return kcu
}

// ClearCourseCoverImgID clears the value of the "course_cover_img_id" field.
func (kcu *KcCourseUpdate) ClearCourseCoverImgID() *KcCourseUpdate {
	kcu.mutation.ClearCourseCoverImgID()
	return kcu
}

// SetCreatedAdminID sets the "created_admin_id" field.
func (kcu *KcCourseUpdate) SetCreatedAdminID(i int) *KcCourseUpdate {
	kcu.mutation.ResetCreatedAdminID()
	kcu.mutation.SetCreatedAdminID(i)
	return kcu
}

// SetNillableCreatedAdminID sets the "created_admin_id" field if the given value is not nil.
func (kcu *KcCourseUpdate) SetNillableCreatedAdminID(i *int) *KcCourseUpdate {
	if i != nil {
		kcu.SetCreatedAdminID(*i)
	}
	return kcu
}

// ClearCreatedAdminID clears the value of the "created_admin_id" field.
func (kcu *KcCourseUpdate) ClearCreatedAdminID() *KcCourseUpdate {
	kcu.mutation.ClearCreatedAdminID()
	return kcu
}

// AddMajorIDs adds the "major" edge to the Major entity by IDs.
func (kcu *KcCourseUpdate) AddMajorIDs(ids ...int) *KcCourseUpdate {
	kcu.mutation.AddMajorIDs(ids...)
	return kcu
}

// AddMajor adds the "major" edges to the Major entity.
func (kcu *KcCourseUpdate) AddMajor(m ...*Major) *KcCourseUpdate {
	ids := make([]int, len(m))
	for i := range m {
		ids[i] = m[i].ID
	}
	return kcu.AddMajorIDs(ids...)
}

// SetItemID sets the "item" edge to the ItemCategory entity by ID.
func (kcu *KcCourseUpdate) SetItemID(id int) *KcCourseUpdate {
	kcu.mutation.SetItemID(id)
	return kcu
}

// SetNillableItemID sets the "item" edge to the ItemCategory entity by ID if the given value is not nil.
func (kcu *KcCourseUpdate) SetNillableItemID(id *int) *KcCourseUpdate {
	if id != nil {
		kcu = kcu.SetItemID(*id)
	}
	return kcu
}

// SetItem sets the "item" edge to the ItemCategory entity.
func (kcu *KcCourseUpdate) SetItem(i *ItemCategory) *KcCourseUpdate {
	return kcu.SetItemID(i.ID)
}

// SetCity sets the "city" edge to the City entity.
func (kcu *KcCourseUpdate) SetCity(c *City) *KcCourseUpdate {
	return kcu.SetCityID(c.ID)
}

// SetAdminID sets the "admin" edge to the Admin entity by ID.
func (kcu *KcCourseUpdate) SetAdminID(id int) *KcCourseUpdate {
	kcu.mutation.SetAdminID(id)
	return kcu
}

// SetNillableAdminID sets the "admin" edge to the Admin entity by ID if the given value is not nil.
func (kcu *KcCourseUpdate) SetNillableAdminID(id *int) *KcCourseUpdate {
	if id != nil {
		kcu = kcu.SetAdminID(*id)
	}
	return kcu
}

// SetAdmin sets the "admin" edge to the Admin entity.
func (kcu *KcCourseUpdate) SetAdmin(a *Admin) *KcCourseUpdate {
	return kcu.SetAdminID(a.ID)
}

// SetQuestionBank sets the "question_bank" edge to the TkQuestionBank entity.
func (kcu *KcCourseUpdate) SetQuestionBank(t *TkQuestionBank) *KcCourseUpdate {
	return kcu.SetQuestionBankID(t.ID)
}

// SetAttachmentID sets the "attachment" edge to the Attachment entity by ID.
func (kcu *KcCourseUpdate) SetAttachmentID(id int) *KcCourseUpdate {
	kcu.mutation.SetAttachmentID(id)
	return kcu
}

// SetNillableAttachmentID sets the "attachment" edge to the Attachment entity by ID if the given value is not nil.
func (kcu *KcCourseUpdate) SetNillableAttachmentID(id *int) *KcCourseUpdate {
	if id != nil {
		kcu = kcu.SetAttachmentID(*id)
	}
	return kcu
}

// SetAttachment sets the "attachment" edge to the Attachment entity.
func (kcu *KcCourseUpdate) SetAttachment(a *Attachment) *KcCourseUpdate {
	return kcu.SetAttachmentID(a.ID)
}

// AddCourseTeacherIDs adds the "course_teachers" edge to the KcCourseTeacher entity by IDs.
func (kcu *KcCourseUpdate) AddCourseTeacherIDs(ids ...int) *KcCourseUpdate {
	kcu.mutation.AddCourseTeacherIDs(ids...)
	return kcu
}

// AddCourseTeachers adds the "course_teachers" edges to the KcCourseTeacher entity.
func (kcu *KcCourseUpdate) AddCourseTeachers(k ...*KcCourseTeacher) *KcCourseUpdate {
	ids := make([]int, len(k))
	for i := range k {
		ids[i] = k[i].ID
	}
	return kcu.AddCourseTeacherIDs(ids...)
}

// AddClassIDs adds the "classes" edge to the KcClass entity by IDs.
func (kcu *KcCourseUpdate) AddClassIDs(ids ...int) *KcCourseUpdate {
	kcu.mutation.AddClassIDs(ids...)
	return kcu
}

// AddClasses adds the "classes" edges to the KcClass entity.
func (kcu *KcCourseUpdate) AddClasses(k ...*KcClass) *KcCourseUpdate {
	ids := make([]int, len(k))
	for i := range k {
		ids[i] = k[i].ID
	}
	return kcu.AddClassIDs(ids...)
}

// AddCourseSmallCategoryIDs adds the "course_small_categorys" edge to the KcCourseSmallCategory entity by IDs.
func (kcu *KcCourseUpdate) AddCourseSmallCategoryIDs(ids ...int) *KcCourseUpdate {
	kcu.mutation.AddCourseSmallCategoryIDs(ids...)
	return kcu
}

// AddCourseSmallCategorys adds the "course_small_categorys" edges to the KcCourseSmallCategory entity.
func (kcu *KcCourseUpdate) AddCourseSmallCategorys(k ...*KcCourseSmallCategory) *KcCourseUpdate {
	ids := make([]int, len(k))
	for i := range k {
		ids[i] = k[i].ID
	}
	return kcu.AddCourseSmallCategoryIDs(ids...)
}

// AddCourseAppraiseIDs adds the "course_appraise" edge to the UserCourseAppraise entity by IDs.
func (kcu *KcCourseUpdate) AddCourseAppraiseIDs(ids ...int) *KcCourseUpdate {
	kcu.mutation.AddCourseAppraiseIDs(ids...)
	return kcu
}

// AddCourseAppraise adds the "course_appraise" edges to the UserCourseAppraise entity.
func (kcu *KcCourseUpdate) AddCourseAppraise(u ...*UserCourseAppraise) *KcCourseUpdate {
	ids := make([]int, len(u))
	for i := range u {
		ids[i] = u[i].ID
	}
	return kcu.AddCourseAppraiseIDs(ids...)
}

// AddCourseChapterIDs adds the "course_chapters" edge to the KcCourseChapter entity by IDs.
func (kcu *KcCourseUpdate) AddCourseChapterIDs(ids ...int) *KcCourseUpdate {
	kcu.mutation.AddCourseChapterIDs(ids...)
	return kcu
}

// AddCourseChapters adds the "course_chapters" edges to the KcCourseChapter entity.
func (kcu *KcCourseUpdate) AddCourseChapters(k ...*KcCourseChapter) *KcCourseUpdate {
	ids := make([]int, len(k))
	for i := range k {
		ids[i] = k[i].ID
	}
	return kcu.AddCourseChapterIDs(ids...)
}

// AddKcUserCourseIDs adds the "kc_user_courses" edge to the KcUserCourse entity by IDs.
func (kcu *KcCourseUpdate) AddKcUserCourseIDs(ids ...int) *KcCourseUpdate {
	kcu.mutation.AddKcUserCourseIDs(ids...)
	return kcu
}

// AddKcUserCourses adds the "kc_user_courses" edges to the KcUserCourse entity.
func (kcu *KcCourseUpdate) AddKcUserCourses(k ...*KcUserCourse) *KcCourseUpdate {
	ids := make([]int, len(k))
	for i := range k {
		ids[i] = k[i].ID
	}
	return kcu.AddKcUserCourseIDs(ids...)
}

// AddMessageCourseIDs adds the "message_courses" edge to the Message entity by IDs.
func (kcu *KcCourseUpdate) AddMessageCourseIDs(ids ...int) *KcCourseUpdate {
	kcu.mutation.AddMessageCourseIDs(ids...)
	return kcu
}

// AddMessageCourses adds the "message_courses" edges to the Message entity.
func (kcu *KcCourseUpdate) AddMessageCourses(m ...*Message) *KcCourseUpdate {
	ids := make([]int, len(m))
	for i := range m {
		ids[i] = m[i].ID
	}
	return kcu.AddMessageCourseIDs(ids...)
}

// Mutation returns the KcCourseMutation object of the builder.
func (kcu *KcCourseUpdate) Mutation() *KcCourseMutation {
	return kcu.mutation
}

// ClearMajor clears all "major" edges to the Major entity.
func (kcu *KcCourseUpdate) ClearMajor() *KcCourseUpdate {
	kcu.mutation.ClearMajor()
	return kcu
}

// RemoveMajorIDs removes the "major" edge to Major entities by IDs.
func (kcu *KcCourseUpdate) RemoveMajorIDs(ids ...int) *KcCourseUpdate {
	kcu.mutation.RemoveMajorIDs(ids...)
	return kcu
}

// RemoveMajor removes "major" edges to Major entities.
func (kcu *KcCourseUpdate) RemoveMajor(m ...*Major) *KcCourseUpdate {
	ids := make([]int, len(m))
	for i := range m {
		ids[i] = m[i].ID
	}
	return kcu.RemoveMajorIDs(ids...)
}

// ClearItem clears the "item" edge to the ItemCategory entity.
func (kcu *KcCourseUpdate) ClearItem() *KcCourseUpdate {
	kcu.mutation.ClearItem()
	return kcu
}

// ClearCity clears the "city" edge to the City entity.
func (kcu *KcCourseUpdate) ClearCity() *KcCourseUpdate {
	kcu.mutation.ClearCity()
	return kcu
}

// ClearAdmin clears the "admin" edge to the Admin entity.
func (kcu *KcCourseUpdate) ClearAdmin() *KcCourseUpdate {
	kcu.mutation.ClearAdmin()
	return kcu
}

// ClearQuestionBank clears the "question_bank" edge to the TkQuestionBank entity.
func (kcu *KcCourseUpdate) ClearQuestionBank() *KcCourseUpdate {
	kcu.mutation.ClearQuestionBank()
	return kcu
}

// ClearAttachment clears the "attachment" edge to the Attachment entity.
func (kcu *KcCourseUpdate) ClearAttachment() *KcCourseUpdate {
	kcu.mutation.ClearAttachment()
	return kcu
}

// ClearCourseTeachers clears all "course_teachers" edges to the KcCourseTeacher entity.
func (kcu *KcCourseUpdate) ClearCourseTeachers() *KcCourseUpdate {
	kcu.mutation.ClearCourseTeachers()
	return kcu
}

// RemoveCourseTeacherIDs removes the "course_teachers" edge to KcCourseTeacher entities by IDs.
func (kcu *KcCourseUpdate) RemoveCourseTeacherIDs(ids ...int) *KcCourseUpdate {
	kcu.mutation.RemoveCourseTeacherIDs(ids...)
	return kcu
}

// RemoveCourseTeachers removes "course_teachers" edges to KcCourseTeacher entities.
func (kcu *KcCourseUpdate) RemoveCourseTeachers(k ...*KcCourseTeacher) *KcCourseUpdate {
	ids := make([]int, len(k))
	for i := range k {
		ids[i] = k[i].ID
	}
	return kcu.RemoveCourseTeacherIDs(ids...)
}

// ClearClasses clears all "classes" edges to the KcClass entity.
func (kcu *KcCourseUpdate) ClearClasses() *KcCourseUpdate {
	kcu.mutation.ClearClasses()
	return kcu
}

// RemoveClassIDs removes the "classes" edge to KcClass entities by IDs.
func (kcu *KcCourseUpdate) RemoveClassIDs(ids ...int) *KcCourseUpdate {
	kcu.mutation.RemoveClassIDs(ids...)
	return kcu
}

// RemoveClasses removes "classes" edges to KcClass entities.
func (kcu *KcCourseUpdate) RemoveClasses(k ...*KcClass) *KcCourseUpdate {
	ids := make([]int, len(k))
	for i := range k {
		ids[i] = k[i].ID
	}
	return kcu.RemoveClassIDs(ids...)
}

// ClearCourseSmallCategorys clears all "course_small_categorys" edges to the KcCourseSmallCategory entity.
func (kcu *KcCourseUpdate) ClearCourseSmallCategorys() *KcCourseUpdate {
	kcu.mutation.ClearCourseSmallCategorys()
	return kcu
}

// RemoveCourseSmallCategoryIDs removes the "course_small_categorys" edge to KcCourseSmallCategory entities by IDs.
func (kcu *KcCourseUpdate) RemoveCourseSmallCategoryIDs(ids ...int) *KcCourseUpdate {
	kcu.mutation.RemoveCourseSmallCategoryIDs(ids...)
	return kcu
}

// RemoveCourseSmallCategorys removes "course_small_categorys" edges to KcCourseSmallCategory entities.
func (kcu *KcCourseUpdate) RemoveCourseSmallCategorys(k ...*KcCourseSmallCategory) *KcCourseUpdate {
	ids := make([]int, len(k))
	for i := range k {
		ids[i] = k[i].ID
	}
	return kcu.RemoveCourseSmallCategoryIDs(ids...)
}

// ClearCourseAppraise clears all "course_appraise" edges to the UserCourseAppraise entity.
func (kcu *KcCourseUpdate) ClearCourseAppraise() *KcCourseUpdate {
	kcu.mutation.ClearCourseAppraise()
	return kcu
}

// RemoveCourseAppraiseIDs removes the "course_appraise" edge to UserCourseAppraise entities by IDs.
func (kcu *KcCourseUpdate) RemoveCourseAppraiseIDs(ids ...int) *KcCourseUpdate {
	kcu.mutation.RemoveCourseAppraiseIDs(ids...)
	return kcu
}

// RemoveCourseAppraise removes "course_appraise" edges to UserCourseAppraise entities.
func (kcu *KcCourseUpdate) RemoveCourseAppraise(u ...*UserCourseAppraise) *KcCourseUpdate {
	ids := make([]int, len(u))
	for i := range u {
		ids[i] = u[i].ID
	}
	return kcu.RemoveCourseAppraiseIDs(ids...)
}

// ClearCourseChapters clears all "course_chapters" edges to the KcCourseChapter entity.
func (kcu *KcCourseUpdate) ClearCourseChapters() *KcCourseUpdate {
	kcu.mutation.ClearCourseChapters()
	return kcu
}

// RemoveCourseChapterIDs removes the "course_chapters" edge to KcCourseChapter entities by IDs.
func (kcu *KcCourseUpdate) RemoveCourseChapterIDs(ids ...int) *KcCourseUpdate {
	kcu.mutation.RemoveCourseChapterIDs(ids...)
	return kcu
}

// RemoveCourseChapters removes "course_chapters" edges to KcCourseChapter entities.
func (kcu *KcCourseUpdate) RemoveCourseChapters(k ...*KcCourseChapter) *KcCourseUpdate {
	ids := make([]int, len(k))
	for i := range k {
		ids[i] = k[i].ID
	}
	return kcu.RemoveCourseChapterIDs(ids...)
}

// ClearKcUserCourses clears all "kc_user_courses" edges to the KcUserCourse entity.
func (kcu *KcCourseUpdate) ClearKcUserCourses() *KcCourseUpdate {
	kcu.mutation.ClearKcUserCourses()
	return kcu
}

// RemoveKcUserCourseIDs removes the "kc_user_courses" edge to KcUserCourse entities by IDs.
func (kcu *KcCourseUpdate) RemoveKcUserCourseIDs(ids ...int) *KcCourseUpdate {
	kcu.mutation.RemoveKcUserCourseIDs(ids...)
	return kcu
}

// RemoveKcUserCourses removes "kc_user_courses" edges to KcUserCourse entities.
func (kcu *KcCourseUpdate) RemoveKcUserCourses(k ...*KcUserCourse) *KcCourseUpdate {
	ids := make([]int, len(k))
	for i := range k {
		ids[i] = k[i].ID
	}
	return kcu.RemoveKcUserCourseIDs(ids...)
}

// ClearMessageCourses clears all "message_courses" edges to the Message entity.
func (kcu *KcCourseUpdate) ClearMessageCourses() *KcCourseUpdate {
	kcu.mutation.ClearMessageCourses()
	return kcu
}

// RemoveMessageCourseIDs removes the "message_courses" edge to Message entities by IDs.
func (kcu *KcCourseUpdate) RemoveMessageCourseIDs(ids ...int) *KcCourseUpdate {
	kcu.mutation.RemoveMessageCourseIDs(ids...)
	return kcu
}

// RemoveMessageCourses removes "message_courses" edges to Message entities.
func (kcu *KcCourseUpdate) RemoveMessageCourses(m ...*Message) *KcCourseUpdate {
	ids := make([]int, len(m))
	for i := range m {
		ids[i] = m[i].ID
	}
	return kcu.RemoveMessageCourseIDs(ids...)
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (kcu *KcCourseUpdate) Save(ctx context.Context) (int, error) {
	var (
		err      error
		affected int
	)
	kcu.defaults()
	if len(kcu.hooks) == 0 {
		affected, err = kcu.sqlSave(ctx)
	} else {
		var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
			mutation, ok := m.(*KcCourseMutation)
			if !ok {
				return nil, fmt.Errorf("unexpected mutation type %T", m)
			}
			kcu.mutation = mutation
			affected, err = kcu.sqlSave(ctx)
			mutation.done = true
			return affected, err
		})
		for i := len(kcu.hooks) - 1; i >= 0; i-- {
			mut = kcu.hooks[i](mut)
		}
		if _, err := mut.Mutate(ctx, kcu.mutation); err != nil {
			return 0, err
		}
	}
	return affected, err
}

// SaveX is like Save, but panics if an error occurs.
func (kcu *KcCourseUpdate) SaveX(ctx context.Context) int {
	affected, err := kcu.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (kcu *KcCourseUpdate) Exec(ctx context.Context) error {
	_, err := kcu.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (kcu *KcCourseUpdate) ExecX(ctx context.Context) {
	if err := kcu.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (kcu *KcCourseUpdate) defaults() {
	if _, ok := kcu.mutation.UpdatedAt(); !ok && !kcu.mutation.UpdatedAtCleared() {
		v := kccourse.UpdateDefaultUpdatedAt()
		kcu.mutation.SetUpdatedAt(v)
	}
}

func (kcu *KcCourseUpdate) sqlSave(ctx context.Context) (n int, err error) {
	_spec := &sqlgraph.UpdateSpec{
		Node: &sqlgraph.NodeSpec{
			Table:   kccourse.Table,
			Columns: kccourse.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeInt,
				Column: kccourse.FieldID,
			},
		},
	}
	if ps := kcu.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := kcu.mutation.UUID(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: kccourse.FieldUUID,
		})
	}
	if kcu.mutation.CreatedAtCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Column: kccourse.FieldCreatedAt,
		})
	}
	if value, ok := kcu.mutation.UpdatedAt(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: kccourse.FieldUpdatedAt,
		})
	}
	if kcu.mutation.UpdatedAtCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Column: kccourse.FieldUpdatedAt,
		})
	}
	if value, ok := kcu.mutation.DeletedAt(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: kccourse.FieldDeletedAt,
		})
	}
	if kcu.mutation.DeletedAtCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Column: kccourse.FieldDeletedAt,
		})
	}
	if value, ok := kcu.mutation.CourseName(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: kccourse.FieldCourseName,
		})
	}
	if value, ok := kcu.mutation.CourseType(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeUint8,
			Value:  value,
			Column: kccourse.FieldCourseType,
		})
	}
	if value, ok := kcu.mutation.AddedCourseType(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeUint8,
			Value:  value,
			Column: kccourse.FieldCourseType,
		})
	}
	if value, ok := kcu.mutation.PeopleNum(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Value:  value,
			Column: kccourse.FieldPeopleNum,
		})
	}
	if value, ok := kcu.mutation.AddedPeopleNum(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Value:  value,
			Column: kccourse.FieldPeopleNum,
		})
	}
	if value, ok := kcu.mutation.CoursePrice(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeFloat64,
			Value:  value,
			Column: kccourse.FieldCoursePrice,
		})
	}
	if value, ok := kcu.mutation.AddedCoursePrice(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeFloat64,
			Value:  value,
			Column: kccourse.FieldCoursePrice,
		})
	}
	if value, ok := kcu.mutation.CourseDesc(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: kccourse.FieldCourseDesc,
		})
	}
	if value, ok := kcu.mutation.PushStatus(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeUint8,
			Value:  value,
			Column: kccourse.FieldPushStatus,
		})
	}
	if value, ok := kcu.mutation.AddedPushStatus(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeUint8,
			Value:  value,
			Column: kccourse.FieldPushStatus,
		})
	}
	if kcu.mutation.MajorCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   kccourse.MajorTable,
			Columns: kccourse.MajorPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: major.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := kcu.mutation.RemovedMajorIDs(); len(nodes) > 0 && !kcu.mutation.MajorCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   kccourse.MajorTable,
			Columns: kccourse.MajorPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: major.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := kcu.mutation.MajorIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   kccourse.MajorTable,
			Columns: kccourse.MajorPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: major.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if kcu.mutation.ItemCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   kccourse.ItemTable,
			Columns: []string{kccourse.ItemColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: itemcategory.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := kcu.mutation.ItemIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   kccourse.ItemTable,
			Columns: []string{kccourse.ItemColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: itemcategory.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if kcu.mutation.CityCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   kccourse.CityTable,
			Columns: []string{kccourse.CityColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: city.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := kcu.mutation.CityIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   kccourse.CityTable,
			Columns: []string{kccourse.CityColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: city.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if kcu.mutation.AdminCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   kccourse.AdminTable,
			Columns: []string{kccourse.AdminColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: admin.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := kcu.mutation.AdminIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   kccourse.AdminTable,
			Columns: []string{kccourse.AdminColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: admin.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if kcu.mutation.QuestionBankCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   kccourse.QuestionBankTable,
			Columns: []string{kccourse.QuestionBankColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkquestionbank.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := kcu.mutation.QuestionBankIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   kccourse.QuestionBankTable,
			Columns: []string{kccourse.QuestionBankColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkquestionbank.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if kcu.mutation.AttachmentCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   kccourse.AttachmentTable,
			Columns: []string{kccourse.AttachmentColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: attachment.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := kcu.mutation.AttachmentIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   kccourse.AttachmentTable,
			Columns: []string{kccourse.AttachmentColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: attachment.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if kcu.mutation.CourseTeachersCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   kccourse.CourseTeachersTable,
			Columns: []string{kccourse.CourseTeachersColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: kccourseteacher.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := kcu.mutation.RemovedCourseTeachersIDs(); len(nodes) > 0 && !kcu.mutation.CourseTeachersCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   kccourse.CourseTeachersTable,
			Columns: []string{kccourse.CourseTeachersColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: kccourseteacher.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := kcu.mutation.CourseTeachersIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   kccourse.CourseTeachersTable,
			Columns: []string{kccourse.CourseTeachersColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: kccourseteacher.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if kcu.mutation.ClassesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   kccourse.ClassesTable,
			Columns: kccourse.ClassesPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: kcclass.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := kcu.mutation.RemovedClassesIDs(); len(nodes) > 0 && !kcu.mutation.ClassesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   kccourse.ClassesTable,
			Columns: kccourse.ClassesPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: kcclass.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := kcu.mutation.ClassesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   kccourse.ClassesTable,
			Columns: kccourse.ClassesPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: kcclass.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if kcu.mutation.CourseSmallCategorysCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   kccourse.CourseSmallCategorysTable,
			Columns: []string{kccourse.CourseSmallCategorysColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: kccoursesmallcategory.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := kcu.mutation.RemovedCourseSmallCategorysIDs(); len(nodes) > 0 && !kcu.mutation.CourseSmallCategorysCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   kccourse.CourseSmallCategorysTable,
			Columns: []string{kccourse.CourseSmallCategorysColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: kccoursesmallcategory.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := kcu.mutation.CourseSmallCategorysIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   kccourse.CourseSmallCategorysTable,
			Columns: []string{kccourse.CourseSmallCategorysColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: kccoursesmallcategory.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if kcu.mutation.CourseAppraiseCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   kccourse.CourseAppraiseTable,
			Columns: []string{kccourse.CourseAppraiseColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: usercourseappraise.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := kcu.mutation.RemovedCourseAppraiseIDs(); len(nodes) > 0 && !kcu.mutation.CourseAppraiseCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   kccourse.CourseAppraiseTable,
			Columns: []string{kccourse.CourseAppraiseColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: usercourseappraise.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := kcu.mutation.CourseAppraiseIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   kccourse.CourseAppraiseTable,
			Columns: []string{kccourse.CourseAppraiseColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: usercourseappraise.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if kcu.mutation.CourseChaptersCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   kccourse.CourseChaptersTable,
			Columns: []string{kccourse.CourseChaptersColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: kccoursechapter.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := kcu.mutation.RemovedCourseChaptersIDs(); len(nodes) > 0 && !kcu.mutation.CourseChaptersCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   kccourse.CourseChaptersTable,
			Columns: []string{kccourse.CourseChaptersColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: kccoursechapter.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := kcu.mutation.CourseChaptersIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   kccourse.CourseChaptersTable,
			Columns: []string{kccourse.CourseChaptersColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: kccoursechapter.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if kcu.mutation.KcUserCoursesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   kccourse.KcUserCoursesTable,
			Columns: []string{kccourse.KcUserCoursesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: kcusercourse.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := kcu.mutation.RemovedKcUserCoursesIDs(); len(nodes) > 0 && !kcu.mutation.KcUserCoursesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   kccourse.KcUserCoursesTable,
			Columns: []string{kccourse.KcUserCoursesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: kcusercourse.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := kcu.mutation.KcUserCoursesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   kccourse.KcUserCoursesTable,
			Columns: []string{kccourse.KcUserCoursesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: kcusercourse.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if kcu.mutation.MessageCoursesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   kccourse.MessageCoursesTable,
			Columns: []string{kccourse.MessageCoursesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: message.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := kcu.mutation.RemovedMessageCoursesIDs(); len(nodes) > 0 && !kcu.mutation.MessageCoursesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   kccourse.MessageCoursesTable,
			Columns: []string{kccourse.MessageCoursesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: message.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := kcu.mutation.MessageCoursesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   kccourse.MessageCoursesTable,
			Columns: []string{kccourse.MessageCoursesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: message.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if n, err = sqlgraph.UpdateNodes(ctx, kcu.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{kccourse.Label}
		} else if cerr, ok := isSQLConstraintError(err); ok {
			err = cerr
		}
		return 0, err
	}
	return n, nil
}

// KcCourseUpdateOne is the builder for updating a single KcCourse entity.
type KcCourseUpdateOne struct {
	config
	fields   []string
	hooks    []Hook
	mutation *KcCourseMutation
}

// SetUUID sets the "uuid" field.
func (kcuo *KcCourseUpdateOne) SetUUID(s string) *KcCourseUpdateOne {
	kcuo.mutation.SetUUID(s)
	return kcuo
}

// SetUpdatedAt sets the "updated_at" field.
func (kcuo *KcCourseUpdateOne) SetUpdatedAt(t time.Time) *KcCourseUpdateOne {
	kcuo.mutation.SetUpdatedAt(t)
	return kcuo
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (kcuo *KcCourseUpdateOne) ClearUpdatedAt() *KcCourseUpdateOne {
	kcuo.mutation.ClearUpdatedAt()
	return kcuo
}

// SetDeletedAt sets the "deleted_at" field.
func (kcuo *KcCourseUpdateOne) SetDeletedAt(t time.Time) *KcCourseUpdateOne {
	kcuo.mutation.SetDeletedAt(t)
	return kcuo
}

// SetNillableDeletedAt sets the "deleted_at" field if the given value is not nil.
func (kcuo *KcCourseUpdateOne) SetNillableDeletedAt(t *time.Time) *KcCourseUpdateOne {
	if t != nil {
		kcuo.SetDeletedAt(*t)
	}
	return kcuo
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (kcuo *KcCourseUpdateOne) ClearDeletedAt() *KcCourseUpdateOne {
	kcuo.mutation.ClearDeletedAt()
	return kcuo
}

// SetCourseName sets the "course_name" field.
func (kcuo *KcCourseUpdateOne) SetCourseName(s string) *KcCourseUpdateOne {
	kcuo.mutation.SetCourseName(s)
	return kcuo
}

// SetNillableCourseName sets the "course_name" field if the given value is not nil.
func (kcuo *KcCourseUpdateOne) SetNillableCourseName(s *string) *KcCourseUpdateOne {
	if s != nil {
		kcuo.SetCourseName(*s)
	}
	return kcuo
}

// SetCourseType sets the "course_type" field.
func (kcuo *KcCourseUpdateOne) SetCourseType(u uint8) *KcCourseUpdateOne {
	kcuo.mutation.ResetCourseType()
	kcuo.mutation.SetCourseType(u)
	return kcuo
}

// SetNillableCourseType sets the "course_type" field if the given value is not nil.
func (kcuo *KcCourseUpdateOne) SetNillableCourseType(u *uint8) *KcCourseUpdateOne {
	if u != nil {
		kcuo.SetCourseType(*u)
	}
	return kcuo
}

// AddCourseType adds u to the "course_type" field.
func (kcuo *KcCourseUpdateOne) AddCourseType(u uint8) *KcCourseUpdateOne {
	kcuo.mutation.AddCourseType(u)
	return kcuo
}

// SetPeopleNum sets the "people_num" field.
func (kcuo *KcCourseUpdateOne) SetPeopleNum(i int) *KcCourseUpdateOne {
	kcuo.mutation.ResetPeopleNum()
	kcuo.mutation.SetPeopleNum(i)
	return kcuo
}

// SetNillablePeopleNum sets the "people_num" field if the given value is not nil.
func (kcuo *KcCourseUpdateOne) SetNillablePeopleNum(i *int) *KcCourseUpdateOne {
	if i != nil {
		kcuo.SetPeopleNum(*i)
	}
	return kcuo
}

// AddPeopleNum adds i to the "people_num" field.
func (kcuo *KcCourseUpdateOne) AddPeopleNum(i int) *KcCourseUpdateOne {
	kcuo.mutation.AddPeopleNum(i)
	return kcuo
}

// SetCoursePrice sets the "course_price" field.
func (kcuo *KcCourseUpdateOne) SetCoursePrice(f float64) *KcCourseUpdateOne {
	kcuo.mutation.ResetCoursePrice()
	kcuo.mutation.SetCoursePrice(f)
	return kcuo
}

// SetNillableCoursePrice sets the "course_price" field if the given value is not nil.
func (kcuo *KcCourseUpdateOne) SetNillableCoursePrice(f *float64) *KcCourseUpdateOne {
	if f != nil {
		kcuo.SetCoursePrice(*f)
	}
	return kcuo
}

// AddCoursePrice adds f to the "course_price" field.
func (kcuo *KcCourseUpdateOne) AddCoursePrice(f float64) *KcCourseUpdateOne {
	kcuo.mutation.AddCoursePrice(f)
	return kcuo
}

// SetCourseDesc sets the "course_desc" field.
func (kcuo *KcCourseUpdateOne) SetCourseDesc(s string) *KcCourseUpdateOne {
	kcuo.mutation.SetCourseDesc(s)
	return kcuo
}

// SetNillableCourseDesc sets the "course_desc" field if the given value is not nil.
func (kcuo *KcCourseUpdateOne) SetNillableCourseDesc(s *string) *KcCourseUpdateOne {
	if s != nil {
		kcuo.SetCourseDesc(*s)
	}
	return kcuo
}

// SetPushStatus sets the "push_status" field.
func (kcuo *KcCourseUpdateOne) SetPushStatus(u uint8) *KcCourseUpdateOne {
	kcuo.mutation.ResetPushStatus()
	kcuo.mutation.SetPushStatus(u)
	return kcuo
}

// SetNillablePushStatus sets the "push_status" field if the given value is not nil.
func (kcuo *KcCourseUpdateOne) SetNillablePushStatus(u *uint8) *KcCourseUpdateOne {
	if u != nil {
		kcuo.SetPushStatus(*u)
	}
	return kcuo
}

// AddPushStatus adds u to the "push_status" field.
func (kcuo *KcCourseUpdateOne) AddPushStatus(u uint8) *KcCourseUpdateOne {
	kcuo.mutation.AddPushStatus(u)
	return kcuo
}

// SetCateID sets the "cate_id" field.
func (kcuo *KcCourseUpdateOne) SetCateID(i int) *KcCourseUpdateOne {
	kcuo.mutation.ResetCateID()
	kcuo.mutation.SetCateID(i)
	return kcuo
}

// SetNillableCateID sets the "cate_id" field if the given value is not nil.
func (kcuo *KcCourseUpdateOne) SetNillableCateID(i *int) *KcCourseUpdateOne {
	if i != nil {
		kcuo.SetCateID(*i)
	}
	return kcuo
}

// ClearCateID clears the value of the "cate_id" field.
func (kcuo *KcCourseUpdateOne) ClearCateID() *KcCourseUpdateOne {
	kcuo.mutation.ClearCateID()
	return kcuo
}

// SetCityID sets the "city_id" field.
func (kcuo *KcCourseUpdateOne) SetCityID(i int) *KcCourseUpdateOne {
	kcuo.mutation.ResetCityID()
	kcuo.mutation.SetCityID(i)
	return kcuo
}

// SetNillableCityID sets the "city_id" field if the given value is not nil.
func (kcuo *KcCourseUpdateOne) SetNillableCityID(i *int) *KcCourseUpdateOne {
	if i != nil {
		kcuo.SetCityID(*i)
	}
	return kcuo
}

// ClearCityID clears the value of the "city_id" field.
func (kcuo *KcCourseUpdateOne) ClearCityID() *KcCourseUpdateOne {
	kcuo.mutation.ClearCityID()
	return kcuo
}

// SetQuestionBankID sets the "question_bank_id" field.
func (kcuo *KcCourseUpdateOne) SetQuestionBankID(i int) *KcCourseUpdateOne {
	kcuo.mutation.ResetQuestionBankID()
	kcuo.mutation.SetQuestionBankID(i)
	return kcuo
}

// SetNillableQuestionBankID sets the "question_bank_id" field if the given value is not nil.
func (kcuo *KcCourseUpdateOne) SetNillableQuestionBankID(i *int) *KcCourseUpdateOne {
	if i != nil {
		kcuo.SetQuestionBankID(*i)
	}
	return kcuo
}

// ClearQuestionBankID clears the value of the "question_bank_id" field.
func (kcuo *KcCourseUpdateOne) ClearQuestionBankID() *KcCourseUpdateOne {
	kcuo.mutation.ClearQuestionBankID()
	return kcuo
}

// SetCourseCoverImgID sets the "course_cover_img_id" field.
func (kcuo *KcCourseUpdateOne) SetCourseCoverImgID(i int) *KcCourseUpdateOne {
	kcuo.mutation.ResetCourseCoverImgID()
	kcuo.mutation.SetCourseCoverImgID(i)
	return kcuo
}

// SetNillableCourseCoverImgID sets the "course_cover_img_id" field if the given value is not nil.
func (kcuo *KcCourseUpdateOne) SetNillableCourseCoverImgID(i *int) *KcCourseUpdateOne {
	if i != nil {
		kcuo.SetCourseCoverImgID(*i)
	}
	return kcuo
}

// ClearCourseCoverImgID clears the value of the "course_cover_img_id" field.
func (kcuo *KcCourseUpdateOne) ClearCourseCoverImgID() *KcCourseUpdateOne {
	kcuo.mutation.ClearCourseCoverImgID()
	return kcuo
}

// SetCreatedAdminID sets the "created_admin_id" field.
func (kcuo *KcCourseUpdateOne) SetCreatedAdminID(i int) *KcCourseUpdateOne {
	kcuo.mutation.ResetCreatedAdminID()
	kcuo.mutation.SetCreatedAdminID(i)
	return kcuo
}

// SetNillableCreatedAdminID sets the "created_admin_id" field if the given value is not nil.
func (kcuo *KcCourseUpdateOne) SetNillableCreatedAdminID(i *int) *KcCourseUpdateOne {
	if i != nil {
		kcuo.SetCreatedAdminID(*i)
	}
	return kcuo
}

// ClearCreatedAdminID clears the value of the "created_admin_id" field.
func (kcuo *KcCourseUpdateOne) ClearCreatedAdminID() *KcCourseUpdateOne {
	kcuo.mutation.ClearCreatedAdminID()
	return kcuo
}

// AddMajorIDs adds the "major" edge to the Major entity by IDs.
func (kcuo *KcCourseUpdateOne) AddMajorIDs(ids ...int) *KcCourseUpdateOne {
	kcuo.mutation.AddMajorIDs(ids...)
	return kcuo
}

// AddMajor adds the "major" edges to the Major entity.
func (kcuo *KcCourseUpdateOne) AddMajor(m ...*Major) *KcCourseUpdateOne {
	ids := make([]int, len(m))
	for i := range m {
		ids[i] = m[i].ID
	}
	return kcuo.AddMajorIDs(ids...)
}

// SetItemID sets the "item" edge to the ItemCategory entity by ID.
func (kcuo *KcCourseUpdateOne) SetItemID(id int) *KcCourseUpdateOne {
	kcuo.mutation.SetItemID(id)
	return kcuo
}

// SetNillableItemID sets the "item" edge to the ItemCategory entity by ID if the given value is not nil.
func (kcuo *KcCourseUpdateOne) SetNillableItemID(id *int) *KcCourseUpdateOne {
	if id != nil {
		kcuo = kcuo.SetItemID(*id)
	}
	return kcuo
}

// SetItem sets the "item" edge to the ItemCategory entity.
func (kcuo *KcCourseUpdateOne) SetItem(i *ItemCategory) *KcCourseUpdateOne {
	return kcuo.SetItemID(i.ID)
}

// SetCity sets the "city" edge to the City entity.
func (kcuo *KcCourseUpdateOne) SetCity(c *City) *KcCourseUpdateOne {
	return kcuo.SetCityID(c.ID)
}

// SetAdminID sets the "admin" edge to the Admin entity by ID.
func (kcuo *KcCourseUpdateOne) SetAdminID(id int) *KcCourseUpdateOne {
	kcuo.mutation.SetAdminID(id)
	return kcuo
}

// SetNillableAdminID sets the "admin" edge to the Admin entity by ID if the given value is not nil.
func (kcuo *KcCourseUpdateOne) SetNillableAdminID(id *int) *KcCourseUpdateOne {
	if id != nil {
		kcuo = kcuo.SetAdminID(*id)
	}
	return kcuo
}

// SetAdmin sets the "admin" edge to the Admin entity.
func (kcuo *KcCourseUpdateOne) SetAdmin(a *Admin) *KcCourseUpdateOne {
	return kcuo.SetAdminID(a.ID)
}

// SetQuestionBank sets the "question_bank" edge to the TkQuestionBank entity.
func (kcuo *KcCourseUpdateOne) SetQuestionBank(t *TkQuestionBank) *KcCourseUpdateOne {
	return kcuo.SetQuestionBankID(t.ID)
}

// SetAttachmentID sets the "attachment" edge to the Attachment entity by ID.
func (kcuo *KcCourseUpdateOne) SetAttachmentID(id int) *KcCourseUpdateOne {
	kcuo.mutation.SetAttachmentID(id)
	return kcuo
}

// SetNillableAttachmentID sets the "attachment" edge to the Attachment entity by ID if the given value is not nil.
func (kcuo *KcCourseUpdateOne) SetNillableAttachmentID(id *int) *KcCourseUpdateOne {
	if id != nil {
		kcuo = kcuo.SetAttachmentID(*id)
	}
	return kcuo
}

// SetAttachment sets the "attachment" edge to the Attachment entity.
func (kcuo *KcCourseUpdateOne) SetAttachment(a *Attachment) *KcCourseUpdateOne {
	return kcuo.SetAttachmentID(a.ID)
}

// AddCourseTeacherIDs adds the "course_teachers" edge to the KcCourseTeacher entity by IDs.
func (kcuo *KcCourseUpdateOne) AddCourseTeacherIDs(ids ...int) *KcCourseUpdateOne {
	kcuo.mutation.AddCourseTeacherIDs(ids...)
	return kcuo
}

// AddCourseTeachers adds the "course_teachers" edges to the KcCourseTeacher entity.
func (kcuo *KcCourseUpdateOne) AddCourseTeachers(k ...*KcCourseTeacher) *KcCourseUpdateOne {
	ids := make([]int, len(k))
	for i := range k {
		ids[i] = k[i].ID
	}
	return kcuo.AddCourseTeacherIDs(ids...)
}

// AddClassIDs adds the "classes" edge to the KcClass entity by IDs.
func (kcuo *KcCourseUpdateOne) AddClassIDs(ids ...int) *KcCourseUpdateOne {
	kcuo.mutation.AddClassIDs(ids...)
	return kcuo
}

// AddClasses adds the "classes" edges to the KcClass entity.
func (kcuo *KcCourseUpdateOne) AddClasses(k ...*KcClass) *KcCourseUpdateOne {
	ids := make([]int, len(k))
	for i := range k {
		ids[i] = k[i].ID
	}
	return kcuo.AddClassIDs(ids...)
}

// AddCourseSmallCategoryIDs adds the "course_small_categorys" edge to the KcCourseSmallCategory entity by IDs.
func (kcuo *KcCourseUpdateOne) AddCourseSmallCategoryIDs(ids ...int) *KcCourseUpdateOne {
	kcuo.mutation.AddCourseSmallCategoryIDs(ids...)
	return kcuo
}

// AddCourseSmallCategorys adds the "course_small_categorys" edges to the KcCourseSmallCategory entity.
func (kcuo *KcCourseUpdateOne) AddCourseSmallCategorys(k ...*KcCourseSmallCategory) *KcCourseUpdateOne {
	ids := make([]int, len(k))
	for i := range k {
		ids[i] = k[i].ID
	}
	return kcuo.AddCourseSmallCategoryIDs(ids...)
}

// AddCourseAppraiseIDs adds the "course_appraise" edge to the UserCourseAppraise entity by IDs.
func (kcuo *KcCourseUpdateOne) AddCourseAppraiseIDs(ids ...int) *KcCourseUpdateOne {
	kcuo.mutation.AddCourseAppraiseIDs(ids...)
	return kcuo
}

// AddCourseAppraise adds the "course_appraise" edges to the UserCourseAppraise entity.
func (kcuo *KcCourseUpdateOne) AddCourseAppraise(u ...*UserCourseAppraise) *KcCourseUpdateOne {
	ids := make([]int, len(u))
	for i := range u {
		ids[i] = u[i].ID
	}
	return kcuo.AddCourseAppraiseIDs(ids...)
}

// AddCourseChapterIDs adds the "course_chapters" edge to the KcCourseChapter entity by IDs.
func (kcuo *KcCourseUpdateOne) AddCourseChapterIDs(ids ...int) *KcCourseUpdateOne {
	kcuo.mutation.AddCourseChapterIDs(ids...)
	return kcuo
}

// AddCourseChapters adds the "course_chapters" edges to the KcCourseChapter entity.
func (kcuo *KcCourseUpdateOne) AddCourseChapters(k ...*KcCourseChapter) *KcCourseUpdateOne {
	ids := make([]int, len(k))
	for i := range k {
		ids[i] = k[i].ID
	}
	return kcuo.AddCourseChapterIDs(ids...)
}

// AddKcUserCourseIDs adds the "kc_user_courses" edge to the KcUserCourse entity by IDs.
func (kcuo *KcCourseUpdateOne) AddKcUserCourseIDs(ids ...int) *KcCourseUpdateOne {
	kcuo.mutation.AddKcUserCourseIDs(ids...)
	return kcuo
}

// AddKcUserCourses adds the "kc_user_courses" edges to the KcUserCourse entity.
func (kcuo *KcCourseUpdateOne) AddKcUserCourses(k ...*KcUserCourse) *KcCourseUpdateOne {
	ids := make([]int, len(k))
	for i := range k {
		ids[i] = k[i].ID
	}
	return kcuo.AddKcUserCourseIDs(ids...)
}

// AddMessageCourseIDs adds the "message_courses" edge to the Message entity by IDs.
func (kcuo *KcCourseUpdateOne) AddMessageCourseIDs(ids ...int) *KcCourseUpdateOne {
	kcuo.mutation.AddMessageCourseIDs(ids...)
	return kcuo
}

// AddMessageCourses adds the "message_courses" edges to the Message entity.
func (kcuo *KcCourseUpdateOne) AddMessageCourses(m ...*Message) *KcCourseUpdateOne {
	ids := make([]int, len(m))
	for i := range m {
		ids[i] = m[i].ID
	}
	return kcuo.AddMessageCourseIDs(ids...)
}

// Mutation returns the KcCourseMutation object of the builder.
func (kcuo *KcCourseUpdateOne) Mutation() *KcCourseMutation {
	return kcuo.mutation
}

// ClearMajor clears all "major" edges to the Major entity.
func (kcuo *KcCourseUpdateOne) ClearMajor() *KcCourseUpdateOne {
	kcuo.mutation.ClearMajor()
	return kcuo
}

// RemoveMajorIDs removes the "major" edge to Major entities by IDs.
func (kcuo *KcCourseUpdateOne) RemoveMajorIDs(ids ...int) *KcCourseUpdateOne {
	kcuo.mutation.RemoveMajorIDs(ids...)
	return kcuo
}

// RemoveMajor removes "major" edges to Major entities.
func (kcuo *KcCourseUpdateOne) RemoveMajor(m ...*Major) *KcCourseUpdateOne {
	ids := make([]int, len(m))
	for i := range m {
		ids[i] = m[i].ID
	}
	return kcuo.RemoveMajorIDs(ids...)
}

// ClearItem clears the "item" edge to the ItemCategory entity.
func (kcuo *KcCourseUpdateOne) ClearItem() *KcCourseUpdateOne {
	kcuo.mutation.ClearItem()
	return kcuo
}

// ClearCity clears the "city" edge to the City entity.
func (kcuo *KcCourseUpdateOne) ClearCity() *KcCourseUpdateOne {
	kcuo.mutation.ClearCity()
	return kcuo
}

// ClearAdmin clears the "admin" edge to the Admin entity.
func (kcuo *KcCourseUpdateOne) ClearAdmin() *KcCourseUpdateOne {
	kcuo.mutation.ClearAdmin()
	return kcuo
}

// ClearQuestionBank clears the "question_bank" edge to the TkQuestionBank entity.
func (kcuo *KcCourseUpdateOne) ClearQuestionBank() *KcCourseUpdateOne {
	kcuo.mutation.ClearQuestionBank()
	return kcuo
}

// ClearAttachment clears the "attachment" edge to the Attachment entity.
func (kcuo *KcCourseUpdateOne) ClearAttachment() *KcCourseUpdateOne {
	kcuo.mutation.ClearAttachment()
	return kcuo
}

// ClearCourseTeachers clears all "course_teachers" edges to the KcCourseTeacher entity.
func (kcuo *KcCourseUpdateOne) ClearCourseTeachers() *KcCourseUpdateOne {
	kcuo.mutation.ClearCourseTeachers()
	return kcuo
}

// RemoveCourseTeacherIDs removes the "course_teachers" edge to KcCourseTeacher entities by IDs.
func (kcuo *KcCourseUpdateOne) RemoveCourseTeacherIDs(ids ...int) *KcCourseUpdateOne {
	kcuo.mutation.RemoveCourseTeacherIDs(ids...)
	return kcuo
}

// RemoveCourseTeachers removes "course_teachers" edges to KcCourseTeacher entities.
func (kcuo *KcCourseUpdateOne) RemoveCourseTeachers(k ...*KcCourseTeacher) *KcCourseUpdateOne {
	ids := make([]int, len(k))
	for i := range k {
		ids[i] = k[i].ID
	}
	return kcuo.RemoveCourseTeacherIDs(ids...)
}

// ClearClasses clears all "classes" edges to the KcClass entity.
func (kcuo *KcCourseUpdateOne) ClearClasses() *KcCourseUpdateOne {
	kcuo.mutation.ClearClasses()
	return kcuo
}

// RemoveClassIDs removes the "classes" edge to KcClass entities by IDs.
func (kcuo *KcCourseUpdateOne) RemoveClassIDs(ids ...int) *KcCourseUpdateOne {
	kcuo.mutation.RemoveClassIDs(ids...)
	return kcuo
}

// RemoveClasses removes "classes" edges to KcClass entities.
func (kcuo *KcCourseUpdateOne) RemoveClasses(k ...*KcClass) *KcCourseUpdateOne {
	ids := make([]int, len(k))
	for i := range k {
		ids[i] = k[i].ID
	}
	return kcuo.RemoveClassIDs(ids...)
}

// ClearCourseSmallCategorys clears all "course_small_categorys" edges to the KcCourseSmallCategory entity.
func (kcuo *KcCourseUpdateOne) ClearCourseSmallCategorys() *KcCourseUpdateOne {
	kcuo.mutation.ClearCourseSmallCategorys()
	return kcuo
}

// RemoveCourseSmallCategoryIDs removes the "course_small_categorys" edge to KcCourseSmallCategory entities by IDs.
func (kcuo *KcCourseUpdateOne) RemoveCourseSmallCategoryIDs(ids ...int) *KcCourseUpdateOne {
	kcuo.mutation.RemoveCourseSmallCategoryIDs(ids...)
	return kcuo
}

// RemoveCourseSmallCategorys removes "course_small_categorys" edges to KcCourseSmallCategory entities.
func (kcuo *KcCourseUpdateOne) RemoveCourseSmallCategorys(k ...*KcCourseSmallCategory) *KcCourseUpdateOne {
	ids := make([]int, len(k))
	for i := range k {
		ids[i] = k[i].ID
	}
	return kcuo.RemoveCourseSmallCategoryIDs(ids...)
}

// ClearCourseAppraise clears all "course_appraise" edges to the UserCourseAppraise entity.
func (kcuo *KcCourseUpdateOne) ClearCourseAppraise() *KcCourseUpdateOne {
	kcuo.mutation.ClearCourseAppraise()
	return kcuo
}

// RemoveCourseAppraiseIDs removes the "course_appraise" edge to UserCourseAppraise entities by IDs.
func (kcuo *KcCourseUpdateOne) RemoveCourseAppraiseIDs(ids ...int) *KcCourseUpdateOne {
	kcuo.mutation.RemoveCourseAppraiseIDs(ids...)
	return kcuo
}

// RemoveCourseAppraise removes "course_appraise" edges to UserCourseAppraise entities.
func (kcuo *KcCourseUpdateOne) RemoveCourseAppraise(u ...*UserCourseAppraise) *KcCourseUpdateOne {
	ids := make([]int, len(u))
	for i := range u {
		ids[i] = u[i].ID
	}
	return kcuo.RemoveCourseAppraiseIDs(ids...)
}

// ClearCourseChapters clears all "course_chapters" edges to the KcCourseChapter entity.
func (kcuo *KcCourseUpdateOne) ClearCourseChapters() *KcCourseUpdateOne {
	kcuo.mutation.ClearCourseChapters()
	return kcuo
}

// RemoveCourseChapterIDs removes the "course_chapters" edge to KcCourseChapter entities by IDs.
func (kcuo *KcCourseUpdateOne) RemoveCourseChapterIDs(ids ...int) *KcCourseUpdateOne {
	kcuo.mutation.RemoveCourseChapterIDs(ids...)
	return kcuo
}

// RemoveCourseChapters removes "course_chapters" edges to KcCourseChapter entities.
func (kcuo *KcCourseUpdateOne) RemoveCourseChapters(k ...*KcCourseChapter) *KcCourseUpdateOne {
	ids := make([]int, len(k))
	for i := range k {
		ids[i] = k[i].ID
	}
	return kcuo.RemoveCourseChapterIDs(ids...)
}

// ClearKcUserCourses clears all "kc_user_courses" edges to the KcUserCourse entity.
func (kcuo *KcCourseUpdateOne) ClearKcUserCourses() *KcCourseUpdateOne {
	kcuo.mutation.ClearKcUserCourses()
	return kcuo
}

// RemoveKcUserCourseIDs removes the "kc_user_courses" edge to KcUserCourse entities by IDs.
func (kcuo *KcCourseUpdateOne) RemoveKcUserCourseIDs(ids ...int) *KcCourseUpdateOne {
	kcuo.mutation.RemoveKcUserCourseIDs(ids...)
	return kcuo
}

// RemoveKcUserCourses removes "kc_user_courses" edges to KcUserCourse entities.
func (kcuo *KcCourseUpdateOne) RemoveKcUserCourses(k ...*KcUserCourse) *KcCourseUpdateOne {
	ids := make([]int, len(k))
	for i := range k {
		ids[i] = k[i].ID
	}
	return kcuo.RemoveKcUserCourseIDs(ids...)
}

// ClearMessageCourses clears all "message_courses" edges to the Message entity.
func (kcuo *KcCourseUpdateOne) ClearMessageCourses() *KcCourseUpdateOne {
	kcuo.mutation.ClearMessageCourses()
	return kcuo
}

// RemoveMessageCourseIDs removes the "message_courses" edge to Message entities by IDs.
func (kcuo *KcCourseUpdateOne) RemoveMessageCourseIDs(ids ...int) *KcCourseUpdateOne {
	kcuo.mutation.RemoveMessageCourseIDs(ids...)
	return kcuo
}

// RemoveMessageCourses removes "message_courses" edges to Message entities.
func (kcuo *KcCourseUpdateOne) RemoveMessageCourses(m ...*Message) *KcCourseUpdateOne {
	ids := make([]int, len(m))
	for i := range m {
		ids[i] = m[i].ID
	}
	return kcuo.RemoveMessageCourseIDs(ids...)
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (kcuo *KcCourseUpdateOne) Select(field string, fields ...string) *KcCourseUpdateOne {
	kcuo.fields = append([]string{field}, fields...)
	return kcuo
}

// Save executes the query and returns the updated KcCourse entity.
func (kcuo *KcCourseUpdateOne) Save(ctx context.Context) (*KcCourse, error) {
	var (
		err  error
		node *KcCourse
	)
	kcuo.defaults()
	if len(kcuo.hooks) == 0 {
		node, err = kcuo.sqlSave(ctx)
	} else {
		var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
			mutation, ok := m.(*KcCourseMutation)
			if !ok {
				return nil, fmt.Errorf("unexpected mutation type %T", m)
			}
			kcuo.mutation = mutation
			node, err = kcuo.sqlSave(ctx)
			mutation.done = true
			return node, err
		})
		for i := len(kcuo.hooks) - 1; i >= 0; i-- {
			mut = kcuo.hooks[i](mut)
		}
		if _, err := mut.Mutate(ctx, kcuo.mutation); err != nil {
			return nil, err
		}
	}
	return node, err
}

// SaveX is like Save, but panics if an error occurs.
func (kcuo *KcCourseUpdateOne) SaveX(ctx context.Context) *KcCourse {
	node, err := kcuo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (kcuo *KcCourseUpdateOne) Exec(ctx context.Context) error {
	_, err := kcuo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (kcuo *KcCourseUpdateOne) ExecX(ctx context.Context) {
	if err := kcuo.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (kcuo *KcCourseUpdateOne) defaults() {
	if _, ok := kcuo.mutation.UpdatedAt(); !ok && !kcuo.mutation.UpdatedAtCleared() {
		v := kccourse.UpdateDefaultUpdatedAt()
		kcuo.mutation.SetUpdatedAt(v)
	}
}

func (kcuo *KcCourseUpdateOne) sqlSave(ctx context.Context) (_node *KcCourse, err error) {
	_spec := &sqlgraph.UpdateSpec{
		Node: &sqlgraph.NodeSpec{
			Table:   kccourse.Table,
			Columns: kccourse.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeInt,
				Column: kccourse.FieldID,
			},
		},
	}
	id, ok := kcuo.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "ID", err: fmt.Errorf("missing KcCourse.ID for update")}
	}
	_spec.Node.ID.Value = id
	if fields := kcuo.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, kccourse.FieldID)
		for _, f := range fields {
			if !kccourse.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
			}
			if f != kccourse.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := kcuo.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := kcuo.mutation.UUID(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: kccourse.FieldUUID,
		})
	}
	if kcuo.mutation.CreatedAtCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Column: kccourse.FieldCreatedAt,
		})
	}
	if value, ok := kcuo.mutation.UpdatedAt(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: kccourse.FieldUpdatedAt,
		})
	}
	if kcuo.mutation.UpdatedAtCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Column: kccourse.FieldUpdatedAt,
		})
	}
	if value, ok := kcuo.mutation.DeletedAt(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: kccourse.FieldDeletedAt,
		})
	}
	if kcuo.mutation.DeletedAtCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Column: kccourse.FieldDeletedAt,
		})
	}
	if value, ok := kcuo.mutation.CourseName(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: kccourse.FieldCourseName,
		})
	}
	if value, ok := kcuo.mutation.CourseType(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeUint8,
			Value:  value,
			Column: kccourse.FieldCourseType,
		})
	}
	if value, ok := kcuo.mutation.AddedCourseType(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeUint8,
			Value:  value,
			Column: kccourse.FieldCourseType,
		})
	}
	if value, ok := kcuo.mutation.PeopleNum(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Value:  value,
			Column: kccourse.FieldPeopleNum,
		})
	}
	if value, ok := kcuo.mutation.AddedPeopleNum(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Value:  value,
			Column: kccourse.FieldPeopleNum,
		})
	}
	if value, ok := kcuo.mutation.CoursePrice(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeFloat64,
			Value:  value,
			Column: kccourse.FieldCoursePrice,
		})
	}
	if value, ok := kcuo.mutation.AddedCoursePrice(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeFloat64,
			Value:  value,
			Column: kccourse.FieldCoursePrice,
		})
	}
	if value, ok := kcuo.mutation.CourseDesc(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: kccourse.FieldCourseDesc,
		})
	}
	if value, ok := kcuo.mutation.PushStatus(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeUint8,
			Value:  value,
			Column: kccourse.FieldPushStatus,
		})
	}
	if value, ok := kcuo.mutation.AddedPushStatus(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeUint8,
			Value:  value,
			Column: kccourse.FieldPushStatus,
		})
	}
	if kcuo.mutation.MajorCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   kccourse.MajorTable,
			Columns: kccourse.MajorPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: major.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := kcuo.mutation.RemovedMajorIDs(); len(nodes) > 0 && !kcuo.mutation.MajorCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   kccourse.MajorTable,
			Columns: kccourse.MajorPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: major.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := kcuo.mutation.MajorIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   kccourse.MajorTable,
			Columns: kccourse.MajorPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: major.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if kcuo.mutation.ItemCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   kccourse.ItemTable,
			Columns: []string{kccourse.ItemColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: itemcategory.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := kcuo.mutation.ItemIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   kccourse.ItemTable,
			Columns: []string{kccourse.ItemColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: itemcategory.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if kcuo.mutation.CityCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   kccourse.CityTable,
			Columns: []string{kccourse.CityColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: city.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := kcuo.mutation.CityIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   kccourse.CityTable,
			Columns: []string{kccourse.CityColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: city.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if kcuo.mutation.AdminCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   kccourse.AdminTable,
			Columns: []string{kccourse.AdminColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: admin.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := kcuo.mutation.AdminIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   kccourse.AdminTable,
			Columns: []string{kccourse.AdminColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: admin.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if kcuo.mutation.QuestionBankCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   kccourse.QuestionBankTable,
			Columns: []string{kccourse.QuestionBankColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkquestionbank.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := kcuo.mutation.QuestionBankIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   kccourse.QuestionBankTable,
			Columns: []string{kccourse.QuestionBankColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: tkquestionbank.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if kcuo.mutation.AttachmentCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   kccourse.AttachmentTable,
			Columns: []string{kccourse.AttachmentColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: attachment.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := kcuo.mutation.AttachmentIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   kccourse.AttachmentTable,
			Columns: []string{kccourse.AttachmentColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: attachment.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if kcuo.mutation.CourseTeachersCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   kccourse.CourseTeachersTable,
			Columns: []string{kccourse.CourseTeachersColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: kccourseteacher.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := kcuo.mutation.RemovedCourseTeachersIDs(); len(nodes) > 0 && !kcuo.mutation.CourseTeachersCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   kccourse.CourseTeachersTable,
			Columns: []string{kccourse.CourseTeachersColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: kccourseteacher.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := kcuo.mutation.CourseTeachersIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   kccourse.CourseTeachersTable,
			Columns: []string{kccourse.CourseTeachersColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: kccourseteacher.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if kcuo.mutation.ClassesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   kccourse.ClassesTable,
			Columns: kccourse.ClassesPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: kcclass.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := kcuo.mutation.RemovedClassesIDs(); len(nodes) > 0 && !kcuo.mutation.ClassesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   kccourse.ClassesTable,
			Columns: kccourse.ClassesPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: kcclass.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := kcuo.mutation.ClassesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   kccourse.ClassesTable,
			Columns: kccourse.ClassesPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: kcclass.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if kcuo.mutation.CourseSmallCategorysCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   kccourse.CourseSmallCategorysTable,
			Columns: []string{kccourse.CourseSmallCategorysColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: kccoursesmallcategory.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := kcuo.mutation.RemovedCourseSmallCategorysIDs(); len(nodes) > 0 && !kcuo.mutation.CourseSmallCategorysCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   kccourse.CourseSmallCategorysTable,
			Columns: []string{kccourse.CourseSmallCategorysColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: kccoursesmallcategory.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := kcuo.mutation.CourseSmallCategorysIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   kccourse.CourseSmallCategorysTable,
			Columns: []string{kccourse.CourseSmallCategorysColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: kccoursesmallcategory.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if kcuo.mutation.CourseAppraiseCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   kccourse.CourseAppraiseTable,
			Columns: []string{kccourse.CourseAppraiseColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: usercourseappraise.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := kcuo.mutation.RemovedCourseAppraiseIDs(); len(nodes) > 0 && !kcuo.mutation.CourseAppraiseCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   kccourse.CourseAppraiseTable,
			Columns: []string{kccourse.CourseAppraiseColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: usercourseappraise.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := kcuo.mutation.CourseAppraiseIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   kccourse.CourseAppraiseTable,
			Columns: []string{kccourse.CourseAppraiseColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: usercourseappraise.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if kcuo.mutation.CourseChaptersCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   kccourse.CourseChaptersTable,
			Columns: []string{kccourse.CourseChaptersColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: kccoursechapter.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := kcuo.mutation.RemovedCourseChaptersIDs(); len(nodes) > 0 && !kcuo.mutation.CourseChaptersCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   kccourse.CourseChaptersTable,
			Columns: []string{kccourse.CourseChaptersColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: kccoursechapter.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := kcuo.mutation.CourseChaptersIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   kccourse.CourseChaptersTable,
			Columns: []string{kccourse.CourseChaptersColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: kccoursechapter.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if kcuo.mutation.KcUserCoursesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   kccourse.KcUserCoursesTable,
			Columns: []string{kccourse.KcUserCoursesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: kcusercourse.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := kcuo.mutation.RemovedKcUserCoursesIDs(); len(nodes) > 0 && !kcuo.mutation.KcUserCoursesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   kccourse.KcUserCoursesTable,
			Columns: []string{kccourse.KcUserCoursesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: kcusercourse.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := kcuo.mutation.KcUserCoursesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   kccourse.KcUserCoursesTable,
			Columns: []string{kccourse.KcUserCoursesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: kcusercourse.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if kcuo.mutation.MessageCoursesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   kccourse.MessageCoursesTable,
			Columns: []string{kccourse.MessageCoursesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: message.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := kcuo.mutation.RemovedMessageCoursesIDs(); len(nodes) > 0 && !kcuo.mutation.MessageCoursesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   kccourse.MessageCoursesTable,
			Columns: []string{kccourse.MessageCoursesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: message.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := kcuo.mutation.MessageCoursesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   kccourse.MessageCoursesTable,
			Columns: []string{kccourse.MessageCoursesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: message.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_node = &KcCourse{config: kcuo.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, kcuo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{kccourse.Label}
		} else if cerr, ok := isSQLConstraintError(err); ok {
			err = cerr
		}
		return nil, err
	}
	return _node, nil
}
