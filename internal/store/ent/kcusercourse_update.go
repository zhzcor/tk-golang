// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"gserver/internal/store/ent/kccourse"
	"gserver/internal/store/ent/kcusercourse"
	"gserver/internal/store/ent/predicate"
	"gserver/internal/store/ent/user"
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
)

// KcUserCourseUpdate is the builder for updating KcUserCourse entities.
type KcUserCourseUpdate struct {
	config
	hooks    []Hook
	mutation *KcUserCourseMutation
}

// Where adds a new predicate for the KcUserCourseUpdate builder.
func (kucu *KcUserCourseUpdate) Where(ps ...predicate.KcUserCourse) *KcUserCourseUpdate {
	kucu.mutation.predicates = append(kucu.mutation.predicates, ps...)
	return kucu
}

// SetUUID sets the "uuid" field.
func (kucu *KcUserCourseUpdate) SetUUID(s string) *KcUserCourseUpdate {
	kucu.mutation.SetUUID(s)
	return kucu
}

// SetUpdatedAt sets the "updated_at" field.
func (kucu *KcUserCourseUpdate) SetUpdatedAt(t time.Time) *KcUserCourseUpdate {
	kucu.mutation.SetUpdatedAt(t)
	return kucu
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (kucu *KcUserCourseUpdate) ClearUpdatedAt() *KcUserCourseUpdate {
	kucu.mutation.ClearUpdatedAt()
	return kucu
}

// SetDeletedAt sets the "deleted_at" field.
func (kucu *KcUserCourseUpdate) SetDeletedAt(t time.Time) *KcUserCourseUpdate {
	kucu.mutation.SetDeletedAt(t)
	return kucu
}

// SetNillableDeletedAt sets the "deleted_at" field if the given value is not nil.
func (kucu *KcUserCourseUpdate) SetNillableDeletedAt(t *time.Time) *KcUserCourseUpdate {
	if t != nil {
		kucu.SetDeletedAt(*t)
	}
	return kucu
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (kucu *KcUserCourseUpdate) ClearDeletedAt() *KcUserCourseUpdate {
	kucu.mutation.ClearDeletedAt()
	return kucu
}

// SetPeriodType sets the "period_type" field.
func (kucu *KcUserCourseUpdate) SetPeriodType(u uint8) *KcUserCourseUpdate {
	kucu.mutation.ResetPeriodType()
	kucu.mutation.SetPeriodType(u)
	return kucu
}

// SetNillablePeriodType sets the "period_type" field if the given value is not nil.
func (kucu *KcUserCourseUpdate) SetNillablePeriodType(u *uint8) *KcUserCourseUpdate {
	if u != nil {
		kucu.SetPeriodType(*u)
	}
	return kucu
}

// AddPeriodType adds u to the "period_type" field.
func (kucu *KcUserCourseUpdate) AddPeriodType(u uint8) *KcUserCourseUpdate {
	kucu.mutation.AddPeriodType(u)
	return kucu
}

// SetClosingDate sets the "closing_date" field.
func (kucu *KcUserCourseUpdate) SetClosingDate(t time.Time) *KcUserCourseUpdate {
	kucu.mutation.SetClosingDate(t)
	return kucu
}

// SetNillableClosingDate sets the "closing_date" field if the given value is not nil.
func (kucu *KcUserCourseUpdate) SetNillableClosingDate(t *time.Time) *KcUserCourseUpdate {
	if t != nil {
		kucu.SetClosingDate(*t)
	}
	return kucu
}

// ClearClosingDate clears the value of the "closing_date" field.
func (kucu *KcUserCourseUpdate) ClearClosingDate() *KcUserCourseUpdate {
	kucu.mutation.ClearClosingDate()
	return kucu
}

// SetStudyRate sets the "study_rate" field.
func (kucu *KcUserCourseUpdate) SetStudyRate(f float64) *KcUserCourseUpdate {
	kucu.mutation.ResetStudyRate()
	kucu.mutation.SetStudyRate(f)
	return kucu
}

// SetNillableStudyRate sets the "study_rate" field if the given value is not nil.
func (kucu *KcUserCourseUpdate) SetNillableStudyRate(f *float64) *KcUserCourseUpdate {
	if f != nil {
		kucu.SetStudyRate(*f)
	}
	return kucu
}

// AddStudyRate adds f to the "study_rate" field.
func (kucu *KcUserCourseUpdate) AddStudyRate(f float64) *KcUserCourseUpdate {
	kucu.mutation.AddStudyRate(f)
	return kucu
}

// SetRemark sets the "remark" field.
func (kucu *KcUserCourseUpdate) SetRemark(s string) *KcUserCourseUpdate {
	kucu.mutation.SetRemark(s)
	return kucu
}

// SetNillableRemark sets the "remark" field if the given value is not nil.
func (kucu *KcUserCourseUpdate) SetNillableRemark(s *string) *KcUserCourseUpdate {
	if s != nil {
		kucu.SetRemark(*s)
	}
	return kucu
}

// SetPrice sets the "price" field.
func (kucu *KcUserCourseUpdate) SetPrice(f float64) *KcUserCourseUpdate {
	kucu.mutation.ResetPrice()
	kucu.mutation.SetPrice(f)
	return kucu
}

// SetNillablePrice sets the "price" field if the given value is not nil.
func (kucu *KcUserCourseUpdate) SetNillablePrice(f *float64) *KcUserCourseUpdate {
	if f != nil {
		kucu.SetPrice(*f)
	}
	return kucu
}

// AddPrice adds f to the "price" field.
func (kucu *KcUserCourseUpdate) AddPrice(f float64) *KcUserCourseUpdate {
	kucu.mutation.AddPrice(f)
	return kucu
}

// SetUserID sets the "user_id" field.
func (kucu *KcUserCourseUpdate) SetUserID(i int) *KcUserCourseUpdate {
	kucu.mutation.ResetUserID()
	kucu.mutation.SetUserID(i)
	return kucu
}

// SetNillableUserID sets the "user_id" field if the given value is not nil.
func (kucu *KcUserCourseUpdate) SetNillableUserID(i *int) *KcUserCourseUpdate {
	if i != nil {
		kucu.SetUserID(*i)
	}
	return kucu
}

// ClearUserID clears the value of the "user_id" field.
func (kucu *KcUserCourseUpdate) ClearUserID() *KcUserCourseUpdate {
	kucu.mutation.ClearUserID()
	return kucu
}

// SetCourseID sets the "course_id" field.
func (kucu *KcUserCourseUpdate) SetCourseID(i int) *KcUserCourseUpdate {
	kucu.mutation.ResetCourseID()
	kucu.mutation.SetCourseID(i)
	return kucu
}

// SetNillableCourseID sets the "course_id" field if the given value is not nil.
func (kucu *KcUserCourseUpdate) SetNillableCourseID(i *int) *KcUserCourseUpdate {
	if i != nil {
		kucu.SetCourseID(*i)
	}
	return kucu
}

// ClearCourseID clears the value of the "course_id" field.
func (kucu *KcUserCourseUpdate) ClearCourseID() *KcUserCourseUpdate {
	kucu.mutation.ClearCourseID()
	return kucu
}

// SetUser sets the "user" edge to the User entity.
func (kucu *KcUserCourseUpdate) SetUser(u *User) *KcUserCourseUpdate {
	return kucu.SetUserID(u.ID)
}

// SetCourse sets the "course" edge to the KcCourse entity.
func (kucu *KcUserCourseUpdate) SetCourse(k *KcCourse) *KcUserCourseUpdate {
	return kucu.SetCourseID(k.ID)
}

// Mutation returns the KcUserCourseMutation object of the builder.
func (kucu *KcUserCourseUpdate) Mutation() *KcUserCourseMutation {
	return kucu.mutation
}

// ClearUser clears the "user" edge to the User entity.
func (kucu *KcUserCourseUpdate) ClearUser() *KcUserCourseUpdate {
	kucu.mutation.ClearUser()
	return kucu
}

// ClearCourse clears the "course" edge to the KcCourse entity.
func (kucu *KcUserCourseUpdate) ClearCourse() *KcUserCourseUpdate {
	kucu.mutation.ClearCourse()
	return kucu
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (kucu *KcUserCourseUpdate) Save(ctx context.Context) (int, error) {
	var (
		err      error
		affected int
	)
	kucu.defaults()
	if len(kucu.hooks) == 0 {
		affected, err = kucu.sqlSave(ctx)
	} else {
		var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
			mutation, ok := m.(*KcUserCourseMutation)
			if !ok {
				return nil, fmt.Errorf("unexpected mutation type %T", m)
			}
			kucu.mutation = mutation
			affected, err = kucu.sqlSave(ctx)
			mutation.done = true
			return affected, err
		})
		for i := len(kucu.hooks) - 1; i >= 0; i-- {
			mut = kucu.hooks[i](mut)
		}
		if _, err := mut.Mutate(ctx, kucu.mutation); err != nil {
			return 0, err
		}
	}
	return affected, err
}

// SaveX is like Save, but panics if an error occurs.
func (kucu *KcUserCourseUpdate) SaveX(ctx context.Context) int {
	affected, err := kucu.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (kucu *KcUserCourseUpdate) Exec(ctx context.Context) error {
	_, err := kucu.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (kucu *KcUserCourseUpdate) ExecX(ctx context.Context) {
	if err := kucu.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (kucu *KcUserCourseUpdate) defaults() {
	if _, ok := kucu.mutation.UpdatedAt(); !ok && !kucu.mutation.UpdatedAtCleared() {
		v := kcusercourse.UpdateDefaultUpdatedAt()
		kucu.mutation.SetUpdatedAt(v)
	}
}

func (kucu *KcUserCourseUpdate) sqlSave(ctx context.Context) (n int, err error) {
	_spec := &sqlgraph.UpdateSpec{
		Node: &sqlgraph.NodeSpec{
			Table:   kcusercourse.Table,
			Columns: kcusercourse.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeInt,
				Column: kcusercourse.FieldID,
			},
		},
	}
	if ps := kucu.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := kucu.mutation.UUID(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: kcusercourse.FieldUUID,
		})
	}
	if kucu.mutation.CreatedAtCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Column: kcusercourse.FieldCreatedAt,
		})
	}
	if value, ok := kucu.mutation.UpdatedAt(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: kcusercourse.FieldUpdatedAt,
		})
	}
	if kucu.mutation.UpdatedAtCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Column: kcusercourse.FieldUpdatedAt,
		})
	}
	if value, ok := kucu.mutation.DeletedAt(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: kcusercourse.FieldDeletedAt,
		})
	}
	if kucu.mutation.DeletedAtCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Column: kcusercourse.FieldDeletedAt,
		})
	}
	if value, ok := kucu.mutation.PeriodType(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeUint8,
			Value:  value,
			Column: kcusercourse.FieldPeriodType,
		})
	}
	if value, ok := kucu.mutation.AddedPeriodType(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeUint8,
			Value:  value,
			Column: kcusercourse.FieldPeriodType,
		})
	}
	if value, ok := kucu.mutation.ClosingDate(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: kcusercourse.FieldClosingDate,
		})
	}
	if kucu.mutation.ClosingDateCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Column: kcusercourse.FieldClosingDate,
		})
	}
	if value, ok := kucu.mutation.StudyRate(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeFloat64,
			Value:  value,
			Column: kcusercourse.FieldStudyRate,
		})
	}
	if value, ok := kucu.mutation.AddedStudyRate(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeFloat64,
			Value:  value,
			Column: kcusercourse.FieldStudyRate,
		})
	}
	if value, ok := kucu.mutation.Remark(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: kcusercourse.FieldRemark,
		})
	}
	if value, ok := kucu.mutation.Price(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeFloat64,
			Value:  value,
			Column: kcusercourse.FieldPrice,
		})
	}
	if value, ok := kucu.mutation.AddedPrice(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeFloat64,
			Value:  value,
			Column: kcusercourse.FieldPrice,
		})
	}
	if kucu.mutation.UserCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   kcusercourse.UserTable,
			Columns: []string{kcusercourse.UserColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: user.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := kucu.mutation.UserIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   kcusercourse.UserTable,
			Columns: []string{kcusercourse.UserColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: user.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if kucu.mutation.CourseCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   kcusercourse.CourseTable,
			Columns: []string{kcusercourse.CourseColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: kccourse.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := kucu.mutation.CourseIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   kcusercourse.CourseTable,
			Columns: []string{kcusercourse.CourseColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: kccourse.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if n, err = sqlgraph.UpdateNodes(ctx, kucu.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{kcusercourse.Label}
		} else if cerr, ok := isSQLConstraintError(err); ok {
			err = cerr
		}
		return 0, err
	}
	return n, nil
}

// KcUserCourseUpdateOne is the builder for updating a single KcUserCourse entity.
type KcUserCourseUpdateOne struct {
	config
	fields   []string
	hooks    []Hook
	mutation *KcUserCourseMutation
}

// SetUUID sets the "uuid" field.
func (kucuo *KcUserCourseUpdateOne) SetUUID(s string) *KcUserCourseUpdateOne {
	kucuo.mutation.SetUUID(s)
	return kucuo
}

// SetUpdatedAt sets the "updated_at" field.
func (kucuo *KcUserCourseUpdateOne) SetUpdatedAt(t time.Time) *KcUserCourseUpdateOne {
	kucuo.mutation.SetUpdatedAt(t)
	return kucuo
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (kucuo *KcUserCourseUpdateOne) ClearUpdatedAt() *KcUserCourseUpdateOne {
	kucuo.mutation.ClearUpdatedAt()
	return kucuo
}

// SetDeletedAt sets the "deleted_at" field.
func (kucuo *KcUserCourseUpdateOne) SetDeletedAt(t time.Time) *KcUserCourseUpdateOne {
	kucuo.mutation.SetDeletedAt(t)
	return kucuo
}

// SetNillableDeletedAt sets the "deleted_at" field if the given value is not nil.
func (kucuo *KcUserCourseUpdateOne) SetNillableDeletedAt(t *time.Time) *KcUserCourseUpdateOne {
	if t != nil {
		kucuo.SetDeletedAt(*t)
	}
	return kucuo
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (kucuo *KcUserCourseUpdateOne) ClearDeletedAt() *KcUserCourseUpdateOne {
	kucuo.mutation.ClearDeletedAt()
	return kucuo
}

// SetPeriodType sets the "period_type" field.
func (kucuo *KcUserCourseUpdateOne) SetPeriodType(u uint8) *KcUserCourseUpdateOne {
	kucuo.mutation.ResetPeriodType()
	kucuo.mutation.SetPeriodType(u)
	return kucuo
}

// SetNillablePeriodType sets the "period_type" field if the given value is not nil.
func (kucuo *KcUserCourseUpdateOne) SetNillablePeriodType(u *uint8) *KcUserCourseUpdateOne {
	if u != nil {
		kucuo.SetPeriodType(*u)
	}
	return kucuo
}

// AddPeriodType adds u to the "period_type" field.
func (kucuo *KcUserCourseUpdateOne) AddPeriodType(u uint8) *KcUserCourseUpdateOne {
	kucuo.mutation.AddPeriodType(u)
	return kucuo
}

// SetClosingDate sets the "closing_date" field.
func (kucuo *KcUserCourseUpdateOne) SetClosingDate(t time.Time) *KcUserCourseUpdateOne {
	kucuo.mutation.SetClosingDate(t)
	return kucuo
}

// SetNillableClosingDate sets the "closing_date" field if the given value is not nil.
func (kucuo *KcUserCourseUpdateOne) SetNillableClosingDate(t *time.Time) *KcUserCourseUpdateOne {
	if t != nil {
		kucuo.SetClosingDate(*t)
	}
	return kucuo
}

// ClearClosingDate clears the value of the "closing_date" field.
func (kucuo *KcUserCourseUpdateOne) ClearClosingDate() *KcUserCourseUpdateOne {
	kucuo.mutation.ClearClosingDate()
	return kucuo
}

// SetStudyRate sets the "study_rate" field.
func (kucuo *KcUserCourseUpdateOne) SetStudyRate(f float64) *KcUserCourseUpdateOne {
	kucuo.mutation.ResetStudyRate()
	kucuo.mutation.SetStudyRate(f)
	return kucuo
}

// SetNillableStudyRate sets the "study_rate" field if the given value is not nil.
func (kucuo *KcUserCourseUpdateOne) SetNillableStudyRate(f *float64) *KcUserCourseUpdateOne {
	if f != nil {
		kucuo.SetStudyRate(*f)
	}
	return kucuo
}

// AddStudyRate adds f to the "study_rate" field.
func (kucuo *KcUserCourseUpdateOne) AddStudyRate(f float64) *KcUserCourseUpdateOne {
	kucuo.mutation.AddStudyRate(f)
	return kucuo
}

// SetRemark sets the "remark" field.
func (kucuo *KcUserCourseUpdateOne) SetRemark(s string) *KcUserCourseUpdateOne {
	kucuo.mutation.SetRemark(s)
	return kucuo
}

// SetNillableRemark sets the "remark" field if the given value is not nil.
func (kucuo *KcUserCourseUpdateOne) SetNillableRemark(s *string) *KcUserCourseUpdateOne {
	if s != nil {
		kucuo.SetRemark(*s)
	}
	return kucuo
}

// SetPrice sets the "price" field.
func (kucuo *KcUserCourseUpdateOne) SetPrice(f float64) *KcUserCourseUpdateOne {
	kucuo.mutation.ResetPrice()
	kucuo.mutation.SetPrice(f)
	return kucuo
}

// SetNillablePrice sets the "price" field if the given value is not nil.
func (kucuo *KcUserCourseUpdateOne) SetNillablePrice(f *float64) *KcUserCourseUpdateOne {
	if f != nil {
		kucuo.SetPrice(*f)
	}
	return kucuo
}

// AddPrice adds f to the "price" field.
func (kucuo *KcUserCourseUpdateOne) AddPrice(f float64) *KcUserCourseUpdateOne {
	kucuo.mutation.AddPrice(f)
	return kucuo
}

// SetUserID sets the "user_id" field.
func (kucuo *KcUserCourseUpdateOne) SetUserID(i int) *KcUserCourseUpdateOne {
	kucuo.mutation.ResetUserID()
	kucuo.mutation.SetUserID(i)
	return kucuo
}

// SetNillableUserID sets the "user_id" field if the given value is not nil.
func (kucuo *KcUserCourseUpdateOne) SetNillableUserID(i *int) *KcUserCourseUpdateOne {
	if i != nil {
		kucuo.SetUserID(*i)
	}
	return kucuo
}

// ClearUserID clears the value of the "user_id" field.
func (kucuo *KcUserCourseUpdateOne) ClearUserID() *KcUserCourseUpdateOne {
	kucuo.mutation.ClearUserID()
	return kucuo
}

// SetCourseID sets the "course_id" field.
func (kucuo *KcUserCourseUpdateOne) SetCourseID(i int) *KcUserCourseUpdateOne {
	kucuo.mutation.ResetCourseID()
	kucuo.mutation.SetCourseID(i)
	return kucuo
}

// SetNillableCourseID sets the "course_id" field if the given value is not nil.
func (kucuo *KcUserCourseUpdateOne) SetNillableCourseID(i *int) *KcUserCourseUpdateOne {
	if i != nil {
		kucuo.SetCourseID(*i)
	}
	return kucuo
}

// ClearCourseID clears the value of the "course_id" field.
func (kucuo *KcUserCourseUpdateOne) ClearCourseID() *KcUserCourseUpdateOne {
	kucuo.mutation.ClearCourseID()
	return kucuo
}

// SetUser sets the "user" edge to the User entity.
func (kucuo *KcUserCourseUpdateOne) SetUser(u *User) *KcUserCourseUpdateOne {
	return kucuo.SetUserID(u.ID)
}

// SetCourse sets the "course" edge to the KcCourse entity.
func (kucuo *KcUserCourseUpdateOne) SetCourse(k *KcCourse) *KcUserCourseUpdateOne {
	return kucuo.SetCourseID(k.ID)
}

// Mutation returns the KcUserCourseMutation object of the builder.
func (kucuo *KcUserCourseUpdateOne) Mutation() *KcUserCourseMutation {
	return kucuo.mutation
}

// ClearUser clears the "user" edge to the User entity.
func (kucuo *KcUserCourseUpdateOne) ClearUser() *KcUserCourseUpdateOne {
	kucuo.mutation.ClearUser()
	return kucuo
}

// ClearCourse clears the "course" edge to the KcCourse entity.
func (kucuo *KcUserCourseUpdateOne) ClearCourse() *KcUserCourseUpdateOne {
	kucuo.mutation.ClearCourse()
	return kucuo
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (kucuo *KcUserCourseUpdateOne) Select(field string, fields ...string) *KcUserCourseUpdateOne {
	kucuo.fields = append([]string{field}, fields...)
	return kucuo
}

// Save executes the query and returns the updated KcUserCourse entity.
func (kucuo *KcUserCourseUpdateOne) Save(ctx context.Context) (*KcUserCourse, error) {
	var (
		err  error
		node *KcUserCourse
	)
	kucuo.defaults()
	if len(kucuo.hooks) == 0 {
		node, err = kucuo.sqlSave(ctx)
	} else {
		var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
			mutation, ok := m.(*KcUserCourseMutation)
			if !ok {
				return nil, fmt.Errorf("unexpected mutation type %T", m)
			}
			kucuo.mutation = mutation
			node, err = kucuo.sqlSave(ctx)
			mutation.done = true
			return node, err
		})
		for i := len(kucuo.hooks) - 1; i >= 0; i-- {
			mut = kucuo.hooks[i](mut)
		}
		if _, err := mut.Mutate(ctx, kucuo.mutation); err != nil {
			return nil, err
		}
	}
	return node, err
}

// SaveX is like Save, but panics if an error occurs.
func (kucuo *KcUserCourseUpdateOne) SaveX(ctx context.Context) *KcUserCourse {
	node, err := kucuo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (kucuo *KcUserCourseUpdateOne) Exec(ctx context.Context) error {
	_, err := kucuo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (kucuo *KcUserCourseUpdateOne) ExecX(ctx context.Context) {
	if err := kucuo.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (kucuo *KcUserCourseUpdateOne) defaults() {
	if _, ok := kucuo.mutation.UpdatedAt(); !ok && !kucuo.mutation.UpdatedAtCleared() {
		v := kcusercourse.UpdateDefaultUpdatedAt()
		kucuo.mutation.SetUpdatedAt(v)
	}
}

func (kucuo *KcUserCourseUpdateOne) sqlSave(ctx context.Context) (_node *KcUserCourse, err error) {
	_spec := &sqlgraph.UpdateSpec{
		Node: &sqlgraph.NodeSpec{
			Table:   kcusercourse.Table,
			Columns: kcusercourse.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeInt,
				Column: kcusercourse.FieldID,
			},
		},
	}
	id, ok := kucuo.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "ID", err: fmt.Errorf("missing KcUserCourse.ID for update")}
	}
	_spec.Node.ID.Value = id
	if fields := kucuo.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, kcusercourse.FieldID)
		for _, f := range fields {
			if !kcusercourse.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
			}
			if f != kcusercourse.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := kucuo.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := kucuo.mutation.UUID(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: kcusercourse.FieldUUID,
		})
	}
	if kucuo.mutation.CreatedAtCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Column: kcusercourse.FieldCreatedAt,
		})
	}
	if value, ok := kucuo.mutation.UpdatedAt(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: kcusercourse.FieldUpdatedAt,
		})
	}
	if kucuo.mutation.UpdatedAtCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Column: kcusercourse.FieldUpdatedAt,
		})
	}
	if value, ok := kucuo.mutation.DeletedAt(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: kcusercourse.FieldDeletedAt,
		})
	}
	if kucuo.mutation.DeletedAtCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Column: kcusercourse.FieldDeletedAt,
		})
	}
	if value, ok := kucuo.mutation.PeriodType(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeUint8,
			Value:  value,
			Column: kcusercourse.FieldPeriodType,
		})
	}
	if value, ok := kucuo.mutation.AddedPeriodType(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeUint8,
			Value:  value,
			Column: kcusercourse.FieldPeriodType,
		})
	}
	if value, ok := kucuo.mutation.ClosingDate(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: kcusercourse.FieldClosingDate,
		})
	}
	if kucuo.mutation.ClosingDateCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Column: kcusercourse.FieldClosingDate,
		})
	}
	if value, ok := kucuo.mutation.StudyRate(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeFloat64,
			Value:  value,
			Column: kcusercourse.FieldStudyRate,
		})
	}
	if value, ok := kucuo.mutation.AddedStudyRate(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeFloat64,
			Value:  value,
			Column: kcusercourse.FieldStudyRate,
		})
	}
	if value, ok := kucuo.mutation.Remark(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: kcusercourse.FieldRemark,
		})
	}
	if value, ok := kucuo.mutation.Price(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeFloat64,
			Value:  value,
			Column: kcusercourse.FieldPrice,
		})
	}
	if value, ok := kucuo.mutation.AddedPrice(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeFloat64,
			Value:  value,
			Column: kcusercourse.FieldPrice,
		})
	}
	if kucuo.mutation.UserCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   kcusercourse.UserTable,
			Columns: []string{kcusercourse.UserColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: user.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := kucuo.mutation.UserIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   kcusercourse.UserTable,
			Columns: []string{kcusercourse.UserColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: user.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if kucuo.mutation.CourseCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   kcusercourse.CourseTable,
			Columns: []string{kcusercourse.CourseColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: kccourse.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := kucuo.mutation.CourseIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   kcusercourse.CourseTable,
			Columns: []string{kcusercourse.CourseColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: kccourse.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_node = &KcUserCourse{config: kucuo.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, kucuo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{kcusercourse.Label}
		} else if cerr, ok := isSQLConstraintError(err); ok {
			err = cerr
		}
		return nil, err
	}
	return _node, nil
}
